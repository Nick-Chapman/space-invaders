
0000:

    #0000
    #instruction: NOP
    advance (4)
    jump (0001);

0001:

    #0001
    #instruction: NOP
    advance (4)
    jump (0002);

0002:

    #0002
    #instruction: NOP
    advance (4)
    jump (0003);

0003:

    #0003
    #instruction: JP   18D4
    advance (10)
    jump (18D4);

0004:

    #0004
    #instruction: CALL NC,0018
    if (!FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 00;
      let:16 a2 = (-1 + a1) in
      M[a2] := 07;
      #return-to: 0007
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0018);
    } else {
      advance (11)
      jump (0007);
    }

0005:

    #0005
    #instruction: *NOP
    advance (4)
    jump (0006);

0006:

    #0006
    #instruction: NOP
    advance (4)
    jump (0007);

0007:

    #0007
    #instruction: NOP
    advance (4)
    jump (0008);

0008:

    #0008
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0009);

0009:

    #0009
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (000A);

000A:

    #000A
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (000B);

000B:

    #000B
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (000C);

000C:

    #000C
    #instruction: JP   008C
    advance (10)
    jump (008C);

000D:

    #000D
    #instruction: ADC  H
    let:16 a1 = addWithCarry(FlagCY,H,A) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (000E);

000E:

    #000E
    #instruction: NOP
    advance (4)
    jump (000F);

000F:

    #000F
    #instruction: NOP
    advance (4)
    jump (0010);

0010:

    #0010
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0011);

0011:

    #0011
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0012);

0012:

    #0012
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0013);

0013:

    #0013
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0014);

0014:

    #0014
    #instruction: LD   A,80
    advance (7)
    A := 80;
    jump (0016);

0015:

    #0015
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0016);

0016:

    #0016
    #instruction: LD   (2072),A
    M[2072] := A;
    advance (13)
    jump (0019);

0017:

    #0017
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (0018);

0018:

    #0018
    #instruction: *NOP
    advance (4)
    jump (0019);

0019:

    #0019
    #instruction: LD   HL,20C0
    advance (10)
    H := 20;
    L := C0;
    jump (001C);

001A:

    #001A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (001B);
    }

001B:

    #001B
    #instruction: *NOP
    advance (4)
    jump (001C);

001C:

    #001C
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (001D);

001D:

    #001D
    #instruction: CALL 17CD
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 20;
    #return-to: 0020
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (17CD);

001E:

    #001E
    #instruction: CALL DB17
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 21;
    #return-to: 0021
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (DB17);

001F:

    #001F
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0020);

0020:

    #0020
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (0022);

0021:

    #0021
    #instruction: LD   BC,DA0F
    advance (10)
    B := DA;
    C := 0F;
    jump (0024);

0022:

    #0022
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0023);

0023:

    #0023
    #instruction: JP   CY,0067
    if (FlagCY) {
      advance (10)
      jump (0067);
    } else {
      advance (10)
      jump (0026);
    }

0024:

    #0024
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0025);

0025:

    #0025
    #instruction: NOP
    advance (4)
    jump (0026);

0026:

    #0026
    #instruction: LD   A,(20EA)
    advance (13)
    A := M[20EA];
    jump (0029);

0027:

    #0027
    #instruction: JP   PE,A720
    if (FlagP) {
      advance (10)
      jump (A720);
    } else {
      advance (10)
      jump (002A);
    }

0028:

    #0028
    #instruction: *NOP
    advance (4)
    jump (0029);

0029:

    #0029
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (002A);

002A:

    #002A
    #instruction: JP   Z,0042
    if (FlagZ) {
      advance (10)
      jump (0042);
    } else {
      advance (10)
      jump (002D);
    }

002B:

    #002B
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (002C);

002C:

    #002C
    #instruction: NOP
    advance (4)
    jump (002D);

002D:

    #002D
    #instruction: LD   A,(20EB)
    advance (13)
    A := M[20EB];
    jump (0030);

002E:

    #002E
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (002F);

002F:

    #002F
    #instruction: *NOP
    advance (4)
    jump (0030);

0030:

    #0030
    #instruction: CP   99
    let:16 a1 = addWithCarry(!false,A,~99) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~99 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0032);

0031:

    #0031
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0032);

0032:

    #0032
    #instruction: JP   Z,003E
    if (FlagZ) {
      advance (10)
      jump (003E);
    } else {
      advance (10)
      jump (0035);
    }

0033:

    #0033
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (0035);

0034:

    #0034
    #instruction: NOP
    advance (4)
    jump (0035);

0035:

    #0035
    #instruction: ADD  01
    let:16 a1 = addWithCarry(false,01,A) in
    let:8 a2 = (01 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0037);

0036:

    #0036
    #instruction: LD   BC,3227
    advance (10)
    B := 32;
    C := 27;
    jump (0039);

0037:

    #0037
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (0038);

0038:

    #0038
    #instruction: LD   (20EB),A
    M[20EB] := A;
    advance (13)
    jump (003B);

0039:

    #0039
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (003A);

003A:

    #003A
    #instruction: *NOP
    advance (4)
    jump (003B);

003B:

    #003B
    #instruction: CALL 1947
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3E;
    #return-to: 003E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1947);

003C:

    #003C
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (003D);

003D:

    #003D
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (003E);

003E:

    #003E
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (003F);

003F:

    #003F
    #instruction: LD   (20EA),A
    M[20EA] := A;
    advance (13)
    jump (0042);

0040:

    #0040
    #instruction: JP   PE,3A20
    if (FlagP) {
      advance (10)
      jump (3A20);
    } else {
      advance (10)
      jump (0043);
    }

0041:

    #0041
    #instruction: *NOP
    advance (4)
    jump (0042);

0042:

    #0042
    #instruction: LD   A,(20E9)
    advance (13)
    A := M[20E9];
    jump (0045);

0043:

    #0043
    #instruction: JP   (HL)
    advance (5)
    jump ((H,L));

0044:

    #0044
    #instruction: *NOP
    advance (4)
    jump (0045);

0045:

    #0045
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0046);

0046:

    #0046
    #instruction: JP   Z,0082
    if (FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0049);
    }

0047:

    #0047
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0048);

0048:

    #0048
    #instruction: NOP
    advance (4)
    jump (0049);

0049:

    #0049
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (004C);

004A:

    #004A
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4B;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

004B:

    #004B
    #instruction: *NOP
    advance (4)
    jump (004C);

004C:

    #004C
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (004D);

004D:

    #004D
    #instruction: JP   NZ,006F
    if (!FlagZ) {
      advance (10)
      jump (006F);
    } else {
      advance (10)
      jump (0050);
    }

004E:

    #004E
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (004F);

004F:

    #004F
    #instruction: NOP
    advance (4)
    jump (0050);

0050:

    #0050
    #instruction: LD   A,(20EB)
    advance (13)
    A := M[20EB];
    jump (0053);

0051:

    #0051
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0052);

0052:

    #0052
    #instruction: *NOP
    advance (4)
    jump (0053);

0053:

    #0053
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0054);

0054:

    #0054
    #instruction: JP   NZ,005D
    if (!FlagZ) {
      advance (10)
      jump (005D);
    } else {
      advance (10)
      jump (0057);
    }

0055:

    #0055
    #instruction: LD   E,L
    advance (5)
    E := L;
    jump (0056);

0056:

    #0056
    #instruction: NOP
    advance (4)
    jump (0057);

0057:

    #0057
    #instruction: CALL 0ABF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5A;
    #return-to: 005A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0ABF);

0058:

    #0058
    #instruction: CP   A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0059);

0059:

    #0059
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (005A);

005A:

    #005A
    #instruction: JP   0082
    advance (10)
    jump (0082);

005B:

    #005B
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (005C);

005C:

    #005C
    #instruction: NOP
    advance (4)
    jump (005D);

005D:

    #005D
    #instruction: LD   A,(2093)
    advance (13)
    A := M[2093];
    jump (0060);

005E:

    #005E
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (005F);

005F:

    #005F
    #instruction: *NOP
    advance (4)
    jump (0060);

0060:

    #0060
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0061);

0061:

    #0061
    #instruction: JP   NZ,0082
    if (!FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0064);
    }

0062:

    #0062
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0063);

0063:

    #0063
    #instruction: NOP
    advance (4)
    jump (0064);

0064:

    #0064
    #instruction: JP   0765
    advance (10)
    jump (0765);

0065:

    #0065
    #instruction: LD   H,L
    advance (5)
    H := L;
    jump (0066);

0066:

    #0066
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0067);

0067:

    #0067
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0069);

0068:

    #0068
    #instruction: LD   BC,EA32
    advance (10)
    B := EA;
    C := 32;
    jump (006B);

0069:

    #0069
    #instruction: LD   (20EA),A
    M[20EA] := A;
    advance (13)
    jump (006C);

006A:

    #006A
    #instruction: JP   PE,C320
    if (FlagP) {
      advance (10)
      jump (C320);
    } else {
      advance (10)
      jump (006D);
    }

006B:

    #006B
    #instruction: *NOP
    advance (4)
    jump (006C);

006C:

    #006C
    #instruction: JP   003F
    advance (10)
    jump (003F);

006D:

    #006D
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (006E);

006E:

    #006E
    #instruction: NOP
    advance (4)
    jump (006F);

006F:

    #006F
    #instruction: CALL 1740
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 72;
    #return-to: 0072
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1740);

0070:

    #0070
    #instruction: LD   B,B
    advance (5)
    jump (0071);

0071:

    #0071
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0072);

0072:

    #0072
    #instruction: LD   A,(2032)
    advance (13)
    A := M[2032];
    jump (0075);

0073:

    #0073
    #instruction: LD   (3220),A
    M[3220] := A;
    advance (13)
    jump (0076);

0074:

    #0074
    #instruction: *NOP
    advance (4)
    jump (0075);

0075:

    #0075
    #instruction: LD   (2080),A
    M[2080] := A;
    advance (13)
    jump (0078);

0076:

    #0076
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0077);

0077:

    #0077
    #instruction: *NOP
    advance (4)
    jump (0078);

0078:

    #0078
    #instruction: CALL 0100
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    #return-to: 007B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0100);

0079:

    #0079
    #instruction: NOP
    advance (4)
    jump (007A);

007A:

    #007A
    #instruction: LD   BC,48CD
    advance (10)
    B := 48;
    C := CD;
    jump (007D);

007B:

    #007B
    #instruction: CALL 0248
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7E;
    #return-to: 007E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0248);

007C:

    #007C
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (007D);

007D:

    #007D
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (007E);

007E:

    #007E
    #instruction: CALL 0913
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 81;
    #return-to: 0081
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0913);

007F:

    #007F
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0080);

0080:

    #0080
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0081);

0081:

    #0081
    #instruction: NOP
    advance (4)
    jump (0082);

0082:

    #0082
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0083);

0083:

    #0083
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0084);

0084:

    #0084
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0085);

0085:

    #0085
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0086);

0086:

    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (0087);

0087:

    #0087
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0088:

    #0088
    #instruction: NOP
    advance (4)
    jump (0089);

0089:

    #0089
    #instruction: NOP
    advance (4)
    jump (008A);

008A:

    #008A
    #instruction: NOP
    advance (4)
    jump (008B);

008B:

    #008B
    #instruction: NOP
    advance (4)
    jump (008C);

008C:

    #008C
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (008D);

008D:

    #008D
    #instruction: LD   (2072),A
    M[2072] := A;
    advance (13)
    jump (0090);

008E:

    #008E
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (008F);

008F:

    #008F
    #instruction: *NOP
    advance (4)
    jump (0090);

0090:

    #0090
    #instruction: LD   A,(20E9)
    advance (13)
    A := M[20E9];
    jump (0093);

0091:

    #0091
    #instruction: JP   (HL)
    advance (5)
    jump ((H,L));

0092:

    #0092
    #instruction: *NOP
    advance (4)
    jump (0093);

0093:

    #0093
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0094);

0094:

    #0094
    #instruction: JP   Z,0082
    if (FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0097);
    }

0095:

    #0095
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0096);

0096:

    #0096
    #instruction: NOP
    advance (4)
    jump (0097);

0097:

    #0097
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (009A);

0098:

    #0098
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 99;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0099:

    #0099
    #instruction: *NOP
    advance (4)
    jump (009A);

009A:

    #009A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (009B);

009B:

    #009B
    #instruction: JP   NZ,00A5
    if (!FlagZ) {
      advance (10)
      jump (00A5);
    } else {
      advance (10)
      jump (009E);
    }

009C:

    #009C
    #instruction: AND  L
    let:8 a1 = (L & A) in
    let:8 a2 = (L | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (009D);

009D:

    #009D
    #instruction: NOP
    advance (4)
    jump (009E);

009E:

    #009E
    #instruction: LD   A,(20C1)
    advance (13)
    A := M[20C1];
    jump (00A1);

009F:

    #009F
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (00A0);

00A0:

    #00A0
    #instruction: *NOP
    advance (4)
    jump (00A1);

00A1:

    #00A1
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (00A2);

00A2:

    #00A2
    #instruction: JP   NC,0082
    if (!FlagCY) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (00A5);
    }

00A3:

    #00A3
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (00A4);

00A4:

    #00A4
    #instruction: NOP
    advance (4)
    jump (00A5);

00A5:

    #00A5
    #instruction: LD   HL,2020
    advance (10)
    H := 20;
    L := 20;
    jump (00A8);

00A6:

    #00A6
    #instruction: *NOP
    advance (4)
    jump (00A7);

00A7:

    #00A7
    #instruction: *NOP
    advance (4)
    jump (00A8);

00A8:

    #00A8
    #instruction: CALL 024B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := AB;
    #return-to: 00AB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (024B);

00A9:

    #00A9
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (00AA);

00AA:

    #00AA
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (00AB);

00AB:

    #00AB
    #instruction: CALL 0141
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := AE;
    #return-to: 00AE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0141);

00AC:

    #00AC
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (00AD);

00AD:

    #00AD
    #instruction: LD   BC,82C3
    advance (10)
    B := 82;
    C := C3;
    jump (00B0);

00AE:

    #00AE
    #instruction: JP   0082
    advance (10)
    jump (0082);

00AF:

    #00AF
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (00B0);

00B0:

    #00B0
    #instruction: NOP
    advance (4)
    jump (00B1);

00B1:

    #00B1
    #instruction: CALL 0886
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := B4;
    #return-to: 00B4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0886);

00B2:

    #00B2
    #instruction: ADD  (HL)
    let:16 a1 = addWithCarry(false,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (00B3);

00B3:

    #00B3
    #instruction: *NOP
    advance (4)
    jump (00B4);

00B4:

    #00B4
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (00B5);

00B5:

    #00B5
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (00B6);

00B6:

    #00B6
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (00B7);

00B7:

    #00B7
    #instruction: LD   H,(HL)
    advance (7)
    H := M[(H,L)];
    jump (00B8);

00B8:

    #00B8
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (00B9);

00B9:

    #00B9
    #instruction: LD   (2009),HL
    M[2009] := L;
    M[200A] := H;
    advance (16)
    jump (00BC);

00BA:

    #00BA
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (00BB);

00BB:

    #00BB
    #instruction: *NOP
    advance (4)
    jump (00BC);

00BC:

    #00BC
    #instruction: LD   (200B),HL
    M[200B] := L;
    M[200C] := H;
    advance (16)
    jump (00BF);

00BD:

    #00BD
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (00BE);

00BE:

    #00BE
    #instruction: *NOP
    advance (4)
    jump (00BF);

00BF:

    #00BF
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (00C0);

00C0:

    #00C0
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (00C1);

00C1:

    #00C1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (00C2);

00C2:

    #00C2
    #instruction: CP   03
    let:16 a1 = addWithCarry(!false,A,~03) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~03 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (00C4);

00C3:

    #00C3
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (00C4);

00C4:

    #00C4
    #instruction: JP   NZ,00C8
    if (!FlagZ) {
      advance (10)
      jump (00C8);
    } else {
      advance (10)
      jump (00C7);
    }

00C5:

    #00C5
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (00C6);
    }

00C6:

    #00C6
    #instruction: NOP
    advance (4)
    jump (00C7);

00C7:

    #00C7
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (00C8);

00C8:

    #00C8
    #instruction: LD   (2008),A
    M[2008] := A;
    advance (13)
    jump (00CB);

00C9:

    #00C9
    #instruction: *NOP
    advance (4)
    jump (00CA);

00CA:

    #00CA
    #instruction: *NOP
    advance (4)
    jump (00CB);

00CB:

    #00CB
    #instruction: CP   FE
    let:16 a1 = addWithCarry(!false,A,~FE) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FE & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (00CD);

00CC:

    #00CC
    #instruction: CP   3E
    let:16 a1 = addWithCarry(!false,A,~3E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~3E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (00CE);

00CD:

    #00CD
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (00CF);

00CE:

    #00CE
    #instruction: NOP
    advance (4)
    jump (00CF);

00CF:

    #00CF
    #instruction: JP   NZ,00D3
    if (!FlagZ) {
      advance (10)
      jump (00D3);
    } else {
      advance (10)
      jump (00D2);
    }

00D0:

    #00D0
    #instruction: OUT  00
    advance (10)
    jump (00D2);

00D1:

    #00D1
    #instruction: NOP
    advance (4)
    jump (00D2);

00D2:

    #00D2
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (00D3);

00D3:

    #00D3
    #instruction: LD   (200D),A
    M[200D] := A;
    advance (13)
    jump (00D6);

00D4:

    #00D4
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (00D5);

00D5:

    #00D5
    #instruction: *NOP
    advance (4)
    jump (00D6);

00D6:

    #00D6
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

00D7:

    #00D7
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (00D9);

00D8:

    #00D8
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (00D9);

00D9:

    #00D9
    #instruction: LD   (21FB),A
    M[21FB] := A;
    advance (13)
    jump (00DC);

00DA:

    #00DA
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (00DB);

00DB:

    #00DB
    #instruction: LD   HL,FB32
    advance (10)
    H := FB;
    L := 32;
    jump (00DE);

00DC:

    #00DC
    #instruction: LD   (22FB),A
    M[22FB] := A;
    advance (13)
    jump (00DF);

00DD:

    #00DD
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (00DE);

00DE:

    #00DE
    #instruction: LD   (E4C3),HL
    M[E4C3] := L;
    M[E4C4] := H;
    advance (16)
    jump (00E1);

00DF:

    #00DF
    #instruction: JP   08E4
    advance (10)
    jump (08E4);

00E0:

    #00E0
    #instruction: CALL PO,0008
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 00;
      let:16 a2 = (-1 + a1) in
      M[a2] := E3;
      #return-to: 00E3
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0008);
    } else {
      advance (11)
      jump (00E3);
    }

00E1:

    #00E1
    #instruction: *NOP
    advance (4)
    jump (00E2);

00E2:

    #00E2
    #instruction: NOP
    advance (4)
    jump (00E3);

00E3:

    #00E3
    #instruction: NOP
    advance (4)
    jump (00E4);

00E4:

    #00E4
    #instruction: NOP
    advance (4)
    jump (00E5);

00E5:

    #00E5
    #instruction: NOP
    advance (4)
    jump (00E6);

00E6:

    #00E6
    #instruction: NOP
    advance (4)
    jump (00E7);

00E7:

    #00E7
    #instruction: NOP
    advance (4)
    jump (00E8);

00E8:

    #00E8
    #instruction: NOP
    advance (4)
    jump (00E9);

00E9:

    #00E9
    #instruction: NOP
    advance (4)
    jump (00EA);

00EA:

    #00EA
    #instruction: NOP
    advance (4)
    jump (00EB);

00EB:

    #00EB
    #instruction: NOP
    advance (4)
    jump (00EC);

00EC:

    #00EC
    #instruction: NOP
    advance (4)
    jump (00ED);

00ED:

    #00ED
    #instruction: NOP
    advance (4)
    jump (00EE);

00EE:

    #00EE
    #instruction: NOP
    advance (4)
    jump (00EF);

00EF:

    #00EF
    #instruction: NOP
    advance (4)
    jump (00F0);

00F0:

    #00F0
    #instruction: NOP
    advance (4)
    jump (00F1);

00F1:

    #00F1
    #instruction: NOP
    advance (4)
    jump (00F2);

00F2:

    #00F2
    #instruction: NOP
    advance (4)
    jump (00F3);

00F3:

    #00F3
    #instruction: NOP
    advance (4)
    jump (00F4);

00F4:

    #00F4
    #instruction: NOP
    advance (4)
    jump (00F5);

00F5:

    #00F5
    #instruction: NOP
    advance (4)
    jump (00F6);

00F6:

    #00F6
    #instruction: NOP
    advance (4)
    jump (00F7);

00F7:

    #00F7
    #instruction: NOP
    advance (4)
    jump (00F8);

00F8:

    #00F8
    #instruction: NOP
    advance (4)
    jump (00F9);

00F9:

    #00F9
    #instruction: NOP
    advance (4)
    jump (00FA);

00FA:

    #00FA
    #instruction: NOP
    advance (4)
    jump (00FB);

00FB:

    #00FB
    #instruction: NOP
    advance (4)
    jump (00FC);

00FC:

    #00FC
    #instruction: NOP
    advance (4)
    jump (00FD);

00FD:

    #00FD
    #instruction: NOP
    advance (4)
    jump (00FE);

00FE:

    #00FE
    #instruction: NOP
    advance (4)
    jump (00FF);

00FF:

    #00FF
    #instruction: NOP
    advance (4)
    jump (0100);

0100:

    #0100
    #instruction: LD   HL,2002
    advance (10)
    H := 20;
    L := 02;
    jump (0103);

0101:

    #0101
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0102);

0102:

    #0102
    #instruction: *NOP
    advance (4)
    jump (0103);

0103:

    #0103
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0104);

0104:

    #0104
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0105);

0105:

    #0105
    #instruction: JP   NZ,1538
    if (!FlagZ) {
      advance (10)
      jump (1538);
    } else {
      advance (10)
      jump (0108);
    }

0106:

    #0106
    #instruction: *NOP
    advance (4)
    jump (0107);

0107:

    #0107
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0108);

0108:

    #0108
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0109);

0109:

    #0109
    #instruction: LD   A,(2006)
    advance (13)
    A := M[2006];
    jump (010C);

010A:

    #010A
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (010C);

010B:

    #010B
    #instruction: *NOP
    advance (4)
    jump (010C);

010C:

    #010C
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (010D);

010D:

    #010D
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (0110);

010E:

    #010E
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (010F);

010F:

    #010F
    #instruction: *NOP
    advance (4)
    jump (0110);

0110:

    #0110
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0111);

0111:

    #0111
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0112);

0112:

    #0112
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0113);

0113:

    #0113
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0114);

0114:

    #0114
    #instruction: JP   Z,0136
    if (FlagZ) {
      advance (10)
      jump (0136);
    } else {
      advance (10)
      jump (0117);
    }

0115:

    #0115
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (0117);

0116:

    #0116
    #instruction: LD   BC,2323
    advance (10)
    B := 23;
    C := 23;
    jump (0119);

0117:

    #0117
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0118);

0118:

    #0118
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0119);

0119:

    #0119
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (011A);

011A:

    #011A
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (011B);

011B:

    #011B
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (011C);

011C:

    #011C
    #instruction: AND  FE
    let:8 a1 = (FE & A) in
    let:8 a2 = (FE | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (011E);

011D:

    #011D
    #instruction: CP   07
    let:16 a1 = addWithCarry(!false,A,~07) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~07 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (011F);

011E:

    #011E
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (011F);

011F:

    #011F
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0120);

0120:

    #0120
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0121);

0121:

    #0121
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (0122);

0122:

    #0122
    #instruction: LD   D,00
    advance (7)
    D := 00;
    jump (0124);

0123:

    #0123
    #instruction: NOP
    advance (4)
    jump (0124);

0124:

    #0124
    #instruction: LD   HL,1C00
    advance (10)
    H := 1C;
    L := 00;
    jump (0127);

0125:

    #0125
    #instruction: NOP
    advance (4)
    jump (0126);

0126:

    #0126
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0127);

0127:

    #0127
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0128);

0128:

    #0128
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0129);

0129:

    #0129
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (012A);

012A:

    #012A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (012B);

012B:

    #012B
    #instruction: CALL NZ,013B
    if (!FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 01;
      let:16 a2 = (-1 + a1) in
      M[a2] := 2E;
      #return-to: 012E
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (013B);
    } else {
      advance (11)
      jump (012E);
    }

012C:

    #012C
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (012D);

012D:

    #012D
    #instruction: LD   BC,0B2A
    advance (10)
    B := 0B;
    C := 2A;
    jump (0130);

012E:

    #012E
    #instruction: LD   HL,(200B)
    advance (16)
    H := M[200C];
    L := M[200B];
    jump (0131);

012F:

    #012F
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0130);

0130:

    #0130
    #instruction: *NOP
    advance (4)
    jump (0131);

0131:

    #0131
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0133);

0132:

    #0132
    #instruction: *NOP
    advance (4)
    jump (0133);

0133:

    #0133
    #instruction: CALL 15D3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 01;
    let:16 a2 = (-1 + a1) in
    M[a2] := 36;
    #return-to: 0136
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15D3);

0134:

    #0134
    #instruction: OUT  15
    unknown_output(21);
    advance (10)
    jump (0136);

0135:

    #0135
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0136);

0136:

    #0136
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0137);

0137:

    #0137
    #instruction: LD   (2000),A
    M[2000] := A;
    advance (13)
    jump (013A);

0138:

    #0138
    #instruction: NOP
    advance (4)
    jump (0139);

0139:

    #0139
    #instruction: *NOP
    advance (4)
    jump (013A);

013A:

    #013A
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

013B:

    #013B
    #instruction: LD   HL,0030
    advance (10)
    H := 00;
    L := 30;
    jump (013E);

013C:

    #013C
    #instruction: *NOP
    advance (4)
    jump (013D);

013D:

    #013D
    #instruction: NOP
    advance (4)
    jump (013E);

013E:

    #013E
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (013F);

013F:

    #013F
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0140);

0140:

    #0140
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0141:

    #0141
    #instruction: LD   A,(2068)
    advance (13)
    A := M[2068];
    jump (0144);

0142:

    #0142
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (0143);

0143:

    #0143
    #instruction: *NOP
    advance (4)
    jump (0144);

0144:

    #0144
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0145);

0145:

    #0145
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0146);
    }

0146:

    #0146
    #instruction: LD   A,(2000)
    advance (13)
    A := M[2000];
    jump (0149);

0147:

    #0147
    #instruction: NOP
    advance (4)
    jump (0148);

0148:

    #0148
    #instruction: *NOP
    advance (4)
    jump (0149);

0149:

    #0149
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (014A);

014A:

    #014A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (014B);
    }

014B:

    #014B
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (014E);

014C:

    #014C
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (014D);

014D:

    #014D
    #instruction: *NOP
    advance (4)
    jump (014E);

014E:

    #014E
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (014F);

014F:

    #014F
    #instruction: LD   A,(2006)
    advance (13)
    A := M[2006];
    jump (0152);

0150:

    #0150
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (0152);

0151:

    #0151
    #instruction: *NOP
    advance (4)
    jump (0152);

0152:

    #0152
    #instruction: LD   D,02
    advance (7)
    D := 02;
    jump (0154);

0153:

    #0153
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0154);

0154:

    #0154
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0155);

0155:

    #0155
    #instruction: CP   37
    let:16 a1 = addWithCarry(!false,A,~37) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~37 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0157);

0156:

    #0156
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (0157);

0157:

    #0157
    #instruction: CALL Z,01A1
    if (FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 01;
      let:16 a2 = (-1 + a1) in
      M[a2] := 5A;
      #return-to: 015A
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (01A1);
    } else {
      advance (11)
      jump (015A);
    }

0158:

    #0158
    #instruction: AND  C
    let:8 a1 = (C & A) in
    let:8 a2 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0159);

0159:

    #0159
    #instruction: LD   BC,466F
    advance (10)
    B := 46;
    C := 6F;
    jump (015C);

015A:

    #015A
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (015B);

015B:

    #015B
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (015C);

015C:

    #015C
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (015D);

015D:

    #015D
    #instruction: JP   NZ,0154
    if (!FlagZ) {
      advance (10)
      jump (0154);
    } else {
      advance (10)
      jump (0160);
    }

015E:

    #015E
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (015F);

015F:

    #015F
    #instruction: LD   BC,0632
    advance (10)
    B := 06;
    C := 32;
    jump (0162);

0160:

    #0160
    #instruction: LD   (2006),A
    M[2006] := A;
    advance (13)
    jump (0163);

0161:

    #0161
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (0163);

0162:

    #0162
    #instruction: *NOP
    advance (4)
    jump (0163);

0163:

    #0163
    #instruction: CALL 017A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 01;
    let:16 a2 = (-1 + a1) in
    M[a2] := 66;
    #return-to: 0166
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (017A);

0164:

    #0164
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (0165);

0165:

    #0165
    #instruction: LD   BC,2261
    advance (10)
    B := 22;
    C := 61;
    jump (0168);

0166:

    #0166
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (0167);

0167:

    #0167
    #instruction: LD   (200B),HL
    M[200B] := L;
    M[200C] := H;
    advance (16)
    jump (016A);

0168:

    #0168
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0169);

0169:

    #0169
    #instruction: *NOP
    advance (4)
    jump (016A);

016A:

    #016A
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (016B);

016B:

    #016B
    #instruction: CP   28
    let:16 a1 = addWithCarry(!false,A,~28) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~28 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (016D);

016C:

    #016C
    #instruction: *NOP
    advance (4)
    jump (016D);

016D:

    #016D
    #instruction: JP   CY,1971
    if (FlagCY) {
      advance (10)
      jump (1971);
    } else {
      advance (10)
      jump (0170);
    }

016E:

    #016E
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (016F);

016F:

    #016F
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0170);

0170:

    #0170
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (0171);

0171:

    #0171
    #instruction: LD   (2004),A
    M[2004] := A;
    advance (13)
    jump (0174);

0172:

    #0172
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0173);

0173:

    #0173
    #instruction: *NOP
    advance (4)
    jump (0174);

0174:

    #0174
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0176);

0175:

    #0175
    #instruction: LD   BC,0032
    advance (10)
    B := 00;
    C := 32;
    jump (0178);

0176:

    #0176
    #instruction: LD   (2000),A
    M[2000] := A;
    advance (13)
    jump (0179);

0177:

    #0177
    #instruction: NOP
    advance (4)
    jump (0178);

0178:

    #0178
    #instruction: *NOP
    advance (4)
    jump (0179);

0179:

    #0179
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

017A:

    #017A
    #instruction: LD   D,00
    advance (7)
    D := 00;
    jump (017C);

017B:

    #017B
    #instruction: NOP
    advance (4)
    jump (017C);

017C:

    #017C
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (017D);

017D:

    #017D
    #instruction: LD   HL,2009
    advance (10)
    H := 20;
    L := 09;
    jump (0180);

017E:

    #017E
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (017F);

017F:

    #017F
    #instruction: *NOP
    advance (4)
    jump (0180);

0180:

    #0180
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (0181);

0181:

    #0181
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0182);

0182:

    #0182
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (0183);

0183:

    #0183
    #instruction: CP   0B
    let:16 a1 = addWithCarry(!false,A,~0B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0185);

0184:

    #0184
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0185);

0185:

    #0185
    #instruction: JP   MI,0194
    if (FlagS) {
      advance (10)
      jump (0194);
    } else {
      advance (10)
      jump (0188);
    }

0186:

    #0186
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0187);

0187:

    #0187
    #instruction: LD   BC,0BDE
    advance (10)
    B := 0B;
    C := DE;
    jump (018A);

0188:

    #0188
    #instruction: SBC  0B
    let:16 a1 = addWithCarry(!FlagCY,A,~0B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (018A);

0189:

    #0189
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (018A);

018A:

    #018A
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (018B);

018B:

    #018B
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (018C);

018C:

    #018C
    #instruction: ADD  10
    let:16 a1 = addWithCarry(false,10,A) in
    let:8 a2 = (10 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (018E);

018D:

    #018D
    #instruction: *NOP
    advance (4)
    jump (018E);

018E:

    #018E
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (018F);

018F:

    #018F
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (0190);

0190:

    #0190
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0191);

0191:

    #0191
    #instruction: JP   0183
    advance (10)
    jump (0183);

0192:

    #0192
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0193);

0193:

    #0193
    #instruction: LD   BC,A768
    advance (10)
    B := A7;
    C := 68;
    jump (0196);

0194:

    #0194
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (0195);

0195:

    #0195
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0196);

0196:

    #0196
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0197);
    }

0197:

    #0197
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (0198);

0198:

    #0198
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0199);

0199:

    #0199
    #instruction: ADD  10
    let:16 a1 = addWithCarry(false,10,A) in
    let:8 a2 = (10 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (019B);

019A:

    #019A
    #instruction: *NOP
    advance (4)
    jump (019B);

019B:

    #019B
    #instruction: LD   C,A
    advance (5)
    C := A;
    jump (019C);

019C:

    #019C
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (019D);

019D:

    #019D
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (019E);

019E:

    #019E
    #instruction: JP   0195
    advance (10)
    jump (0195);

019F:

    #019F
    #instruction: SUB  L
    let:16 a1 = addWithCarry(!false,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (01A0);

01A0:

    #01A0
    #instruction: LD   BC,CA15
    advance (10)
    B := CA;
    C := 15;
    jump (01A3);

01A1:

    #01A1
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01A2);

01A2:

    #01A2
    #instruction: JP   Z,01CD
    if (FlagZ) {
      advance (10)
      jump (01CD);
    } else {
      advance (10)
      jump (01A5);
    }

01A3:

    #01A3
    #instruction: CALL 2101
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 01;
    let:16 a2 = (-1 + a1) in
    M[a2] := A6;
    #return-to: 01A6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (2101);

01A4:

    #01A4
    #instruction: LD   BC,0621
    advance (10)
    B := 06;
    C := 21;
    jump (01A7);

01A5:

    #01A5
    #instruction: LD   HL,2006
    advance (10)
    H := 20;
    L := 06;
    jump (01A8);

01A6:

    #01A6
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (01A8);

01A7:

    #01A7
    #instruction: *NOP
    advance (4)
    jump (01A8);

01A8:

    #01A8
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (01AA);

01A9:

    #01A9
    #instruction: NOP
    advance (4)
    jump (01AA);

01AA:

    #01AA
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (01AB);

01AB:

    #01AB
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (01AC);

01AC:

    #01AC
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (01AE);

01AD:

    #01AD
    #instruction: NOP
    advance (4)
    jump (01AE);

01AE:

    #01AE
    #instruction: CALL 01D9
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 01;
    let:16 a2 = (-1 + a1) in
    M[a2] := B1;
    #return-to: 01B1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01D9);

01AF:

    #01AF
    #instruction: *RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

01B0:

    #01B0
    #instruction: LD   BC,0521
    advance (10)
    B := 05;
    C := 21;
    jump (01B3);

01B1:

    #01B1
    #instruction: LD   HL,2005
    advance (10)
    H := 20;
    L := 05;
    jump (01B4);

01B2:

    #01B2
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01B3);

01B3:

    #01B3
    #instruction: *NOP
    advance (4)
    jump (01B4);

01B4:

    #01B4
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (01B5);

01B5:

    #01B5
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01B6);

01B6:

    #01B6
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (01B8);

01B7:

    #01B7
    #instruction: LD   BC,AF77
    advance (10)
    B := AF;
    C := 77;
    jump (01BA);

01B8:

    #01B8
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (01B9);

01B9:

    #01B9
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (01BA);

01BA:

    #01BA
    #instruction: LD   HL,2067
    advance (10)
    H := 20;
    L := 67;
    jump (01BD);

01BB:

    #01BB
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (01BC);

01BC:

    #01BC
    #instruction: *NOP
    advance (4)
    jump (01BD);

01BD:

    #01BD
    #instruction: LD   H,(HL)
    advance (7)
    H := M[(H,L)];
    jump (01BE);

01BE:

    #01BE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

01BF:

    #01BF
    #instruction: NOP
    advance (4)
    jump (01C0);

01C0:

    #01C0
    #instruction: LD   HL,2100
    advance (10)
    H := 21;
    L := 00;
    jump (01C3);

01C1:

    #01C1
    #instruction: NOP
    advance (4)
    jump (01C2);

01C2:

    #01C2
    #instruction: LD   HL,3706
    advance (10)
    H := 37;
    L := 06;
    jump (01C5);

01C3:

    #01C3
    #instruction: LD   B,37
    advance (7)
    B := 37;
    jump (01C5);

01C4:

    #01C4
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (01C5);

01C5:

    #01C5
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (01C7);

01C6:

    #01C6
    #instruction: LD   BC,0523
    advance (10)
    B := 05;
    C := 23;
    jump (01C9);

01C7:

    #01C7
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (01C8);

01C8:

    #01C8
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01C9);

01C9:

    #01C9
    #instruction: JP   NZ,01C5
    if (!FlagZ) {
      advance (10)
      jump (01C5);
    } else {
      advance (10)
      jump (01CC);
    }

01CA:

    #01CA
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01CB);

01CB:

    #01CB
    #instruction: LD   BC,E1C9
    advance (10)
    B := E1;
    C := C9;
    jump (01CE);

01CC:

    #01CC
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

01CD:

    #01CD
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01CE);

01CE:

    #01CE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

01CF:

    #01CF
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (01D1);

01D0:

    #01D0
    #instruction: LD   BC,E006
    advance (10)
    B := E0;
    C := 06;
    jump (01D3);

01D1:

    #01D1
    #instruction: LD   B,E0
    advance (7)
    B := E0;
    jump (01D3);

01D2:

    #01D2
    #instruction: RET  PO
    if (!FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (01D3);
    }

01D3:

    #01D3
    #instruction: LD   HL,2402
    advance (10)
    H := 24;
    L := 02;
    jump (01D6);

01D4:

    #01D4
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (01D5);

01D5:

    #01D5
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01D6);

01D6:

    #01D6
    #instruction: JP   14CC
    advance (10)
    jump (14CC);

01D7:

    #01D7
    #instruction: CALL Z,2314
    if (FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 01;
      let:16 a2 = (-1 + a1) in
      M[a2] := DA;
      #return-to: 01DA
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (2314);
    } else {
      advance (11)
      jump (01DA);
    }

01D8:

    #01D8
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01D9);

01D9:

    #01D9
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (01DA);

01DA:

    #01DA
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (01DB);

01DB:

    #01DB
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (01DC);

01DC:

    #01DC
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (01DD);

01DD:

    #01DD
    #instruction: ADD  (HL)
    let:16 a1 = addWithCarry(false,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (01DE);

01DE:

    #01DE
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (01DF);

01DF:

    #01DF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (01E0);

01E0:

    #01E0
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (01E1);

01E1:

    #01E1
    #instruction: ADD  (HL)
    let:16 a1 = addWithCarry(false,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (01E2);

01E2:

    #01E2
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (01E3);

01E3:

    #01E3
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

01E4:

    #01E4
    #instruction: LD   B,C0
    advance (7)
    B := C0;
    jump (01E6);

01E5:

    #01E5
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (01E6);
    }

01E6:

    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    D := 1B;
    E := 00;
    jump (01E9);

01E7:

    #01E7
    #instruction: NOP
    advance (4)
    jump (01E8);

01E8:

    #01E8
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (01E9);

01E9:

    #01E9
    #instruction: LD   HL,2000
    advance (10)
    H := 20;
    L := 00;
    jump (01EC);

01EA:

    #01EA
    #instruction: NOP
    advance (4)
    jump (01EB);

01EB:

    #01EB
    #instruction: *NOP
    advance (4)
    jump (01EC);

01EC:

    #01EC
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

01ED:

    #01ED
    #instruction: LD   (211A),A
    M[211A] := A;
    advance (13)
    jump (01F0);

01EE:

    #01EE
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (01EF);

01EF:

    #01EF
    #instruction: LD   HL,2142
    advance (10)
    H := 21;
    L := 42;
    jump (01F2);

01F0:

    #01F0
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (01F1);

01F1:

    #01F1
    #instruction: LD   HL,F8C3
    advance (10)
    H := F8;
    L := C3;
    jump (01F4);

01F2:

    #01F2
    #instruction: JP   01F8
    advance (10)
    jump (01F8);

01F3:

    #01F3
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (01F4);
    }

01F4:

    #01F4
    #instruction: LD   BC,4221
    advance (10)
    B := 42;
    C := 21;
    jump (01F7);

01F5:

    #01F5
    #instruction: LD   HL,2242
    advance (10)
    H := 22;
    L := 42;
    jump (01F8);

01F6:

    #01F6
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (01F7);

01F7:

    #01F7
    #instruction: LD   (040E),HL
    M[040E] := L;
    M[040F] := H;
    advance (16)
    jump (01FA);

01F8:

    #01F8
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (01FA);

01F9:

    #01F9
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01FA);

01FA:

    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    D := 1D;
    E := 20;
    jump (01FD);

01FB:

    #01FB
    #instruction: *NOP
    advance (4)
    jump (01FC);

01FC:

    #01FC
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (01FD);

01FD:

    #01FD
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01FE);

01FE:

    #01FE
    #instruction: LD   B,2C
    advance (7)
    B := 2C;
    jump (0200);

01FF:

    #01FF
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0200);

0200:

    #0200
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    #return-to: 0203
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

0201:

    #0201
    #instruction: LD   (D11A),A
    M[D11A] := A;
    advance (13)
    jump (0204);

0202:

    #0202
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0203);

0203:

    #0203
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0204);

0204:

    #0204
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0205);

0205:

    #0205
    #instruction: JP   NZ,01FD
    if (!FlagZ) {
      advance (10)
      jump (01FD);
    } else {
      advance (10)
      jump (0208);
    }

0206:

    #0206
    #instruction: *CAL C901
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    #return-to: 0209
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (C901);

0207:

    #0207
    #instruction: LD   BC,3EC9
    advance (10)
    B := 3E;
    C := C9;
    jump (020A);

0208:

    #0208
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0209:

    #0209
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (020B);

020A:

    #020A
    #instruction: LD   BC,1BC3
    advance (10)
    B := 1B;
    C := C3;
    jump (020D);

020B:

    #020B
    #instruction: JP   021B
    advance (10)
    jump (021B);

020C:

    #020C
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (020D);

020D:

    #020D
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (020E);

020E:

    #020E
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0210);

020F:

    #020F
    #instruction: LD   BC,14C3
    advance (10)
    B := 14;
    C := C3;
    jump (0212);

0210:

    #0210
    #instruction: JP   0214
    advance (10)
    jump (0214);

0211:

    #0211
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0212);

0212:

    #0212
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0213);

0213:

    #0213
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0214);

0214:

    #0214
    #instruction: LD   DE,2242
    advance (10)
    D := 22;
    E := 42;
    jump (0217);

0215:

    #0215
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (0216);

0216:

    #0216
    #instruction: LD   (1EC3),HL
    M[1EC3] := L;
    M[1EC4] := H;
    advance (16)
    jump (0219);

0217:

    #0217
    #instruction: JP   021E
    advance (10)
    jump (021E);

0218:

    #0218
    #instruction: LD   E,02
    advance (7)
    E := 02;
    jump (021A);

0219:

    #0219
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (021A);

021A:

    #021A
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (021B);

021B:

    #021B
    #instruction: LD   DE,2142
    advance (10)
    D := 21;
    E := 42;
    jump (021E);

021C:

    #021C
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (021D);

021D:

    #021D
    #instruction: LD   HL,8132
    advance (10)
    H := 81;
    L := 32;
    jump (0220);

021E:

    #021E
    #instruction: LD   (2081),A
    M[2081] := A;
    advance (13)
    jump (0221);

021F:

    #021F
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0220);

0220:

    #0220
    #instruction: *NOP
    advance (4)
    jump (0221);

0221:

    #0221
    #instruction: LD   BC,1602
    advance (10)
    B := 16;
    C := 02;
    jump (0224);

0222:

    #0222
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0223);

0223:

    #0223
    #instruction: LD   D,21
    advance (7)
    D := 21;
    jump (0225);

0224:

    #0224
    #instruction: LD   HL,2806
    advance (10)
    H := 28;
    L := 06;
    jump (0227);

0225:

    #0225
    #instruction: LD   B,28
    advance (7)
    B := 28;
    jump (0227);

0226:

    #0226
    #instruction: *NOP
    advance (4)
    jump (0227);

0227:

    #0227
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (0229);

0228:

    #0228
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0229);

0229:

    #0229
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (022A);

022A:

    #022A
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (022B);

022B:

    #022B
    #instruction: LD   A,(2081)
    advance (13)
    A := M[2081];
    jump (022E);

022C:

    #022C
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (022D);

022D:

    #022D
    #instruction: *NOP
    advance (4)
    jump (022E);

022E:

    #022E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (022F);

022F:

    #022F
    #instruction: JP   NZ,0242
    if (!FlagZ) {
      advance (10)
      jump (0242);
    } else {
      advance (10)
      jump (0232);
    }

0230:

    #0230
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (0231);

0231:

    #0231
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0232);

0232:

    #0232
    #instruction: CALL 1A69
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 35;
    #return-to: 0235
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A69);

0233:

    #0233
    #instruction: LD   L,C
    advance (5)
    L := C;
    jump (0234);

0234:

    #0234
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0235);

0235:

    #0235
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0236);

0236:

    #0236
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0237);

0237:

    #0237
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0238);

0238:

    #0238
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0239);
    }

0239:

    #0239
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (023A);

023A:

    #023A
    #instruction: LD   DE,02E0
    advance (10)
    D := 02;
    E := E0;
    jump (023D);

023B:

    #023B
    #instruction: RET  PO
    if (!FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (023C);
    }

023C:

    #023C
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (023D);

023D:

    #023D
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (023E);

023E:

    #023E
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (023F);

023F:

    #023F
    #instruction: JP   0229
    advance (10)
    jump (0229);

0240:

    #0240
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0241);

0241:

    #0241
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0242);

0242:

    #0242
    #instruction: CALL 147C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 45;
    #return-to: 0245
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (147C);

0243:

    #0243
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0244);

0244:

    #0244
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0245);

0245:

    #0245
    #instruction: JP   0235
    advance (10)
    jump (0235);

0246:

    #0246
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0247);

0247:

    #0247
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0248);

0248:

    #0248
    #instruction: LD   HL,2010
    advance (10)
    H := 20;
    L := 10;
    jump (024B);

0249:

    #0249
    #instruction: *NOP
    advance (4)
    jump (024A);

024A:

    #024A
    #instruction: *NOP
    advance (4)
    jump (024B);

024B:

    #024B
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (024C);

024C:

    #024C
    #instruction: CP   FF
    let:16 a1 = addWithCarry(!false,A,~FF) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FF & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (024E);

024D:

    #024D
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4E;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

024E:

    #024E
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (024F);
    }

024F:

    #024F
    #instruction: CP   FE
    let:16 a1 = addWithCarry(!false,A,~FE) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FE & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0251);

0250:

    #0250
    #instruction: CP   CA
    let:16 a1 = addWithCarry(!false,A,~CA) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~CA & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0252);

0251:

    #0251
    #instruction: JP   Z,0281
    if (FlagZ) {
      advance (10)
      jump (0281);
    } else {
      advance (10)
      jump (0254);
    }

0252:

    #0252
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0253);

0253:

    #0253
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0254);

0254:

    #0254
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0255);

0255:

    #0255
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (0256);

0256:

    #0256
    #instruction: LD   C,A
    advance (5)
    C := A;
    jump (0257);

0257:

    #0257
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0258);

0258:

    #0258
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0259);

0259:

    #0259
    #instruction: JP   NZ,0277
    if (!FlagZ) {
      advance (10)
      jump (0277);
    } else {
      advance (10)
      jump (025C);
    }

025A:

    #025A
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (025B);

025B:

    #025B
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (025C);

025C:

    #025C
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (025D);

025D:

    #025D
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (025E);

025E:

    #025E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (025F);

025F:

    #025F
    #instruction: JP   NZ,0288
    if (!FlagZ) {
      advance (10)
      jump (0288);
    } else {
      advance (10)
      jump (0262);
    }

0260:

    #0260
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0261);

0261:

    #0261
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0262);

0262:

    #0262
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0263);

0263:

    #0263
    #instruction: LD   E,(HL)
    advance (7)
    E := M[(H,L)];
    jump (0264);

0264:

    #0264
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0265);

0265:

    #0265
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (0266);

0266:

    #0266
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0267);

0267:

    #0267
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0268);

0268:

    #0268
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0269);

0269:

    #0269
    #instruction: LD   HL,026F
    advance (10)
    H := 02;
    L := 6F;
    jump (026C);

026A:

    #026A
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (026B);

026B:

    #026B
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (026C);

026C:

    #026C
    #instruction: EX   (SP),HL
    let:16 a1 = (1 + (SPH,SPL)) in
    M[(SPH,SPL)] := L;
    M[a1] := H;
    advance (18)
    H := M[a1];
    L := M[(SPH,SPL)];
    jump (026D);

026D:

    #026D
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (026E);

026E:

    #026E
    #instruction: JP   (HL)
    advance (5)
    jump ((H,L));

026F:

    #026F
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0270);

0270:

    #0270
    #instruction: LD   DE,000C
    advance (10)
    D := 00;
    E := 0C;
    jump (0273);

0271:

    #0271
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0272);

0272:

    #0272
    #instruction: NOP
    advance (4)
    jump (0273);

0273:

    #0273
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0274);

0274:

    #0274
    #instruction: JP   024B
    advance (10)
    jump (024B);

0275:

    #0275
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (0276);

0276:

    #0276
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0277);

0277:

    #0277
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0278);

0278:

    #0278
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0279);

0279:

    #0279
    #instruction: JP   NZ,027D
    if (!FlagZ) {
      advance (10)
      jump (027D);
    } else {
      advance (10)
      jump (027C);
    }

027A:

    #027A
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (027B);

027B:

    #027B
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (027C);

027C:

    #027C
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (027D);

027D:

    #027D
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (027E);

027E:

    #027E
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (027F);

027F:

    #027F
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0280);

0280:

    #0280
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0281);

0281:

    #0281
    #instruction: LD   DE,0010
    advance (10)
    D := 00;
    E := 10;
    jump (0284);

0282:

    #0282
    #instruction: *NOP
    advance (4)
    jump (0283);

0283:

    #0283
    #instruction: NOP
    advance (4)
    jump (0284);

0284:

    #0284
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0285);

0285:

    #0285
    #instruction: JP   024B
    advance (10)
    jump (024B);

0286:

    #0286
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (0287);

0287:

    #0287
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0288);

0288:

    #0288
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0289);

0289:

    #0289
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (028A);

028A:

    #028A
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (028B);

028B:

    #028B
    #instruction: JP   0281
    advance (10)
    jump (0281);

028C:

    #028C
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (028D);

028D:

    #028D
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (028E);

028E:

    #028E
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (028F);

028F:

    #028F
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0290);

0290:

    #0290
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0291);

0291:

    #0291
    #instruction: CP   FF
    let:16 a1 = addWithCarry(!false,A,~FF) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FF & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0293);

0292:

    #0292
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := 93;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0293:

    #0293
    #instruction: JP   Z,033B
    if (FlagZ) {
      advance (10)
      jump (033B);
    } else {
      advance (10)
      jump (0296);
    }

0294:

    #0294
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0295);

0295:

    #0295
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0296);

0296:

    #0296
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0297);

0297:

    #0297
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0298);

0298:

    #0298
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0299);
    }

0299:

    #0299
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (029A);

029A:

    #029A
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (029B);

029B:

    #029B
    #instruction: LD   (2068),A
    M[2068] := A;
    advance (13)
    jump (029E);

029C:

    #029C
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (029D);

029D:

    #029D
    #instruction: *NOP
    advance (4)
    jump (029E);

029E:

    #029E
    #instruction: LD   (2069),A
    M[2069] := A;
    advance (13)
    jump (02A1);

029F:

    #029F
    #instruction: LD   L,C
    advance (5)
    L := C;
    jump (02A0);

02A0:

    #02A0
    #instruction: *NOP
    advance (4)
    jump (02A1);

02A1:

    #02A1
    #instruction: LD   A,30
    advance (7)
    A := 30;
    jump (02A3);

02A2:

    #02A2
    #instruction: *NOP
    advance (4)
    jump (02A3);

02A3:

    #02A3
    #instruction: LD   (206A),A
    M[206A] := A;
    advance (13)
    jump (02A6);

02A4:

    #02A4
    #instruction: LD   L,D
    advance (5)
    L := D;
    jump (02A5);

02A5:

    #02A5
    #instruction: *NOP
    advance (4)
    jump (02A6);

02A6:

    #02A6
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (02A7);

02A7:

    #02A7
    #instruction: LD   (HL),05
    M[(H,L)] := 05;
    advance (10)
    jump (02A9);

02A8:

    #02A8
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02A9);

02A9:

    #02A9
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (02AA);

02AA:

    #02AA
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02AB);

02AB:

    #02AB
    #instruction: JP   NZ,039B
    if (!FlagZ) {
      advance (10)
      jump (039B);
    } else {
      advance (10)
      jump (02AE);
    }

02AC:

    #02AC
    #instruction: SBC  E
    let:16 a1 = addWithCarry(!FlagCY,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (02AD);

02AD:

    #02AD
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (02AE);

02AE:

    #02AE
    #instruction: LD   HL,(201A)
    advance (16)
    H := M[201B];
    L := M[201A];
    jump (02B1);

02AF:

    #02AF
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (02B0);

02B0:

    #02B0
    #instruction: *NOP
    advance (4)
    jump (02B1);

02B1:

    #02B1
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (02B3);

02B2:

    #02B2
    #instruction: *NOP
    advance (4)
    jump (02B3);

02B3:

    #02B3
    #instruction: CALL 1424
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := B6;
    #return-to: 02B6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1424);

02B4:

    #02B4
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02B5);

02B5:

    #02B5
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02B6);

02B6:

    #02B6
    #instruction: LD   HL,2010
    advance (10)
    H := 20;
    L := 10;
    jump (02B9);

02B7:

    #02B7
    #instruction: *NOP
    advance (4)
    jump (02B8);

02B8:

    #02B8
    #instruction: *NOP
    advance (4)
    jump (02B9);

02B9:

    #02B9
    #instruction: LD   DE,1B10
    advance (10)
    D := 1B;
    E := 10;
    jump (02BC);

02BA:

    #02BA
    #instruction: *NOP
    advance (4)
    jump (02BB);

02BB:

    #02BB
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (02BC);

02BC:

    #02BC
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (02BE);

02BD:

    #02BD
    #instruction: *NOP
    advance (4)
    jump (02BE);

02BE:

    #02BE
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 02C1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

02BF:

    #02BF
    #instruction: LD   (061A),A
    M[061A] := A;
    advance (13)
    jump (02C2);

02C0:

    #02C0
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (02C1);

02C1:

    #02C1
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (02C3);

02C2:

    #02C2
    #instruction: NOP
    advance (4)
    jump (02C3);

02C3:

    #02C3
    #instruction: CALL 19DC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := C6;
    #return-to: 02C6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19DC);

02C4:

    #02C4
    #instruction: CALL CY,3A19
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 02;
      let:16 a2 = (-1 + a1) in
      M[a2] := C7;
      #return-to: 02C7
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3A19);
    } else {
      advance (11)
      jump (02C7);
    }

02C5:

    #02C5
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (02C6);

02C6:

    #02C6
    #instruction: LD   A,(206D)
    advance (13)
    A := M[206D];
    jump (02C9);

02C7:

    #02C7
    #instruction: LD   L,L
    advance (5)
    jump (02C8);

02C8:

    #02C8
    #instruction: *NOP
    advance (4)
    jump (02C9);

02C9:

    #02C9
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (02CA);

02CA:

    #02CA
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (02CB);
    }

02CB:

    #02CB
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (02CE);

02CC:

    #02CC
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := CD;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

02CD:

    #02CD
    #instruction: *NOP
    advance (4)
    jump (02CE);

02CE:

    #02CE
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (02CF);

02CF:

    #02CF
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (02D0);
    }

02D0:

    #02D0
    #instruction: LD   SP,2400
    advance (10)
    SPH := 24;
    SPL := 00;
    jump (02D3);

02D1:

    #02D1
    #instruction: NOP
    advance (4)
    jump (02D2);

02D2:

    #02D2
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02D3);

02D3:

    #02D3
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (02D4);

02D4:

    #02D4
    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := D7;
    #return-to: 02D7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D7);

02D5:

    #02D5
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := D6;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

02D6:

    #02D6
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (02D7);

02D7:

    #02D7
    #instruction: CALL 092E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 02DA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (092E);

02D8:

    #02D8
    #instruction: LD   L,09
    advance (7)
    L := 09;
    jump (02DA);

02D9:

    #02D9
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (02DA);

02DA:

    #02DA
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (02DB);

02DB:

    #02DB
    #instruction: JP   Z,166D
    if (FlagZ) {
      advance (10)
      jump (166D);
    } else {
      advance (10)
      jump (02DE);
    }

02DC:

    #02DC
    #instruction: LD   L,L
    advance (5)
    jump (02DD);

02DD:

    #02DD
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (02DF);

02DE:

    #02DE
    #instruction: CALL 18E7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := E1;
    #return-to: 02E1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18E7);

02DF:

    #02DF
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := E0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

02E0:

    #02E0
    #instruction: *NOP
    advance (4)
    jump (02E1);

02E1:

    #02E1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (02E2);

02E2:

    #02E2
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (02E3);

02E3:

    #02E3
    #instruction: JP   Z,032C
    if (FlagZ) {
      advance (10)
      jump (032C);
    } else {
      advance (10)
      jump (02E6);
    }

02E4:

    #02E4
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02E5);

02E5:

    #02E5
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (02E6);

02E6:

    #02E6
    #instruction: LD   A,(20CE)
    advance (13)
    A := M[20CE];
    jump (02E9);

02E7:

    #02E7
    #instruction: ADC  20
    let:16 a1 = addWithCarry(FlagCY,20,A) in
    let:8 a2 = (20 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (02E9);

02E8:

    #02E8
    #instruction: *NOP
    advance (4)
    jump (02E9);

02E9:

    #02E9
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (02EA);

02EA:

    #02EA
    #instruction: JP   Z,032C
    if (FlagZ) {
      advance (10)
      jump (032C);
    } else {
      advance (10)
      jump (02ED);
    }

02EB:

    #02EB
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (02EC);

02EC:

    #02EC
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (02ED);

02ED:

    #02ED
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (02F0);

02EE:

    #02EE
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (02EF);

02EF:

    #02EF
    #instruction: *NOP
    advance (4)
    jump (02F0);

02F0:

    #02F0
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (02F1);

02F1:

    #02F1
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (02F2);

02F2:

    #02F2
    #instruction: JP   CY,0332
    if (FlagCY) {
      advance (10)
      jump (0332);
    } else {
      advance (10)
      jump (02F5);
    }

02F3:

    #02F3
    #instruction: LD   (CD03),A
    M[CD03] := A;
    advance (13)
    jump (02F6);

02F4:

    #02F4
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (02F5);

02F5:

    #02F5
    #instruction: CALL 020E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := F8;
    #return-to: 02F8
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (020E);

02F6:

    #02F6
    #instruction: LD   C,02
    advance (7)
    C := 02;
    jump (02F8);

02F7:

    #02F7
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (02F8);

02F8:

    #02F8
    #instruction: CALL 0878
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := FB;
    #return-to: 02FB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0878);

02F9:

    #02F9
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (02FA);

02FA:

    #02FA
    #instruction: *NOP
    advance (4)
    jump (02FB);

02FB:

    #02FB
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (02FC);

02FC:

    #02FC
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (02FD);

02FD:

    #02FD
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (02FE);

02FE:

    #02FE
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (02FF);

02FF:

    #02FF
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0300);

0300:

    #0300
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (0301);

0301:

    #0301
    #instruction: NOP
    advance (4)
    jump (0302);

0302:

    #0302
    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    #return-to: 0305
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01E4);

0303:

    #0303
    #instruction: CALL PO,F101
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 03;
      let:16 a2 = (-1 + a1) in
      M[a2] := 06;
      #return-to: 0306
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (F101);
    } else {
      advance (11)
      jump (0306);
    }

0304:

    #0304
    #instruction: LD   BC,0FF1
    advance (10)
    B := 0F;
    C := F1;
    jump (0307);

0305:

    #0305
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0306);

0306:

    #0306
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0307);

0307:

    #0307
    #instruction: LD   A,21
    advance (7)
    A := 21;
    jump (0309);

0308:

    #0308
    #instruction: LD   HL,0006
    advance (10)
    H := 00;
    L := 06;
    jump (030B);

0309:

    #0309
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (030B);

030A:

    #030A
    #instruction: NOP
    advance (4)
    jump (030B);

030B:

    #030B
    #instruction: JP   NC,0312
    if (!FlagCY) {
      advance (10)
      jump (0312);
    } else {
      advance (10)
      jump (030E);
    }

030C:

    #030C
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (030D);

030D:

    #030D
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (030E);

030E:

    #030E
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (0310);

030F:

    #030F
    #instruction: *NOP
    advance (4)
    jump (0310);

0310:

    #0310
    #instruction: LD   A,22
    advance (7)
    A := 22;
    jump (0312);

0311:

    #0311
    #instruction: LD   (6732),HL
    M[6732] := L;
    M[6733] := H;
    advance (16)
    jump (0314);

0312:

    #0312
    #instruction: LD   (2067),A
    M[2067] := A;
    advance (13)
    jump (0315);

0313:

    #0313
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0314);

0314:

    #0314
    #instruction: *NOP
    advance (4)
    jump (0315);

0315:

    #0315
    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    #return-to: 0318
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB6);

0316:

    #0316
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0317);

0317:

    #0317
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0318);

0318:

    #0318
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0319);

0319:

    #0319
    #instruction: LD   (2011),A
    M[2011] := A;
    advance (13)
    jump (031C);

031A:

    #031A
    #instruction: LD   DE,7820
    advance (10)
    D := 78;
    E := 20;
    jump (031D);

031B:

    #031B
    #instruction: *NOP
    advance (4)
    jump (031C);

031C:

    #031C
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (031D);

031D:

    #031D
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (031F);

031E:

    #031E
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (031F);

031F:

    #031F
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0320);

0320:

    #0320
    #instruction: LD   (2098),A
    M[2098] := A;
    advance (13)
    jump (0323);

0321:

    #0321
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0322);

0322:

    #0322
    #instruction: *NOP
    advance (4)
    jump (0323);

0323:

    #0323
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 26;
    #return-to: 0326
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

0324:

    #0324
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0326);

0325:

    #0325
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0326);

0326:

    #0326
    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 29;
    #return-to: 0329
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A7F);

0327:

    #0327
    #instruction: LD   A,A
    advance (5)
    jump (0328);

0328:

    #0328
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0329);

0329:

    #0329
    #instruction: JP   07F9
    advance (10)
    jump (07F9);

032A:

    #032A
    #instruction: LD   SP,HL
    advance (5)
    SPH := H;
    SPL := L;
    jump (032B);

032B:

    #032B
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (032C);

032C:

    #032C
    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2F;
    #return-to: 032F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A7F);

032D:

    #032D
    #instruction: LD   A,A
    advance (5)
    jump (032E);

032E:

    #032E
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (032F);

032F:

    #032F
    #instruction: JP   0817
    advance (10)
    jump (0817);

0330:

    #0330
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0331);

0331:

    #0331
    #instruction: *NOP
    advance (4)
    jump (0332);

0332:

    #0332
    #instruction: CALL 0209
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 35;
    #return-to: 0335
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0209);

0333:

    #0333
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0334);

0334:

    #0334
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0335);

0335:

    #0335
    #instruction: JP   02F8
    advance (10)
    jump (02F8);

0336:

    #0336
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0337);
    }

0337:

    #0337
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0338);

0338:

    #0338
    #instruction: NOP
    advance (4)
    jump (0339);

0339:

    #0339
    #instruction: NOP
    advance (4)
    jump (033A);

033A:

    #033A
    #instruction: NOP
    advance (4)
    jump (033B);

033B:

    #033B
    #instruction: LD   HL,2068
    advance (10)
    H := 20;
    L := 68;
    jump (033E);

033C:

    #033C
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (033D);

033D:

    #033D
    #instruction: *NOP
    advance (4)
    jump (033E);

033E:

    #033E
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (0340);

033F:

    #033F
    #instruction: LD   BC,7E23
    advance (10)
    B := 7E;
    C := 23;
    jump (0342);

0340:

    #0340
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0341);

0341:

    #0341
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0342);

0342:

    #0342
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0343);

0343:

    #0343
    #instruction: JP   03B0
    advance (10)
    jump (03B0);

0344:

    #0344
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0345);

0345:

    #0345
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0346);

0346:

    #0346
    #instruction: NOP
    advance (4)
    jump (0347);

0347:

    #0347
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0348);

0348:

    #0348
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (034A);

0349:

    #0349
    #instruction: LD   BC,1B3A
    advance (10)
    B := 1B;
    C := 3A;
    jump (034C);

034A:

    #034A
    #instruction: LD   A,(201B)
    advance (13)
    A := M[201B];
    jump (034D);

034B:

    #034B
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (034C);

034C:

    #034C
    #instruction: *NOP
    advance (4)
    jump (034D);

034D:

    #034D
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (034E);

034E:

    #034E
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (0351);

034F:

    #034F
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 50;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0350:

    #0350
    #instruction: *NOP
    advance (4)
    jump (0351);

0351:

    #0351
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0352);

0352:

    #0352
    #instruction: JP   NZ,0363
    if (!FlagZ) {
      advance (10)
      jump (0363);
    } else {
      advance (10)
      jump (0355);
    }

0353:

    #0353
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (0354);

0354:

    #0354
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0355);

0355:

    #0355
    #instruction: LD   A,(201D)
    advance (13)
    A := M[201D];
    jump (0358);

0356:

    #0356
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0357);

0357:

    #0357
    #instruction: *NOP
    advance (4)
    jump (0358);

0358:

    #0358
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0359);

0359:

    #0359
    #instruction: JP   CY,0381
    if (FlagCY) {
      advance (10)
      jump (0381);
    } else {
      advance (10)
      jump (035C);
    }

035A:

    #035A
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (035B);

035B:

    #035B
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (035C);

035C:

    #035C
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (035D);

035D:

    #035D
    #instruction: JP   CY,038E
    if (FlagCY) {
      advance (10)
      jump (038E);
    } else {
      advance (10)
      jump (0360);
    }

035E:

    #035E
    #instruction: ADC  (HL)
    let:16 a1 = addWithCarry(FlagCY,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (035F);

035F:

    #035F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0360);

0360:

    #0360
    #instruction: JP   036F
    advance (10)
    jump (036F);

0361:

    #0361
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (0362);

0362:

    #0362
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0363);

0363:

    #0363
    #instruction: CALL 17C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 66;
    #return-to: 0366
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (17C0);

0364:

    #0364
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0365);
    }

0365:

    #0365
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0366);

0366:

    #0366
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0367);

0367:

    #0367
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0368);

0368:

    #0368
    #instruction: JP   CY,0381
    if (FlagCY) {
      advance (10)
      jump (0381);
    } else {
      advance (10)
      jump (036B);
    }

0369:

    #0369
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (036A);

036A:

    #036A
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (036B);

036B:

    #036B
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (036C);

036C:

    #036C
    #instruction: JP   CY,038E
    if (FlagCY) {
      advance (10)
      jump (038E);
    } else {
      advance (10)
      jump (036F);
    }

036D:

    #036D
    #instruction: ADC  (HL)
    let:16 a1 = addWithCarry(FlagCY,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (036E);

036E:

    #036E
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (036F);

036F:

    #036F
    #instruction: LD   HL,2018
    advance (10)
    H := 20;
    L := 18;
    jump (0372);

0370:

    #0370
    #instruction: *NOP
    advance (4)
    jump (0371);

0371:

    #0371
    #instruction: *NOP
    advance (4)
    jump (0372);

0372:

    #0372
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 75;
    #return-to: 0375
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

0373:

    #0373
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0374);

0374:

    #0374
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0375);

0375:

    #0375
    #instruction: CALL 1A47
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 78;
    #return-to: 0378
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A47);

0376:

    #0376
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (0377);

0377:

    #0377
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0378);

0378:

    #0378
    #instruction: CALL 1439
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    #return-to: 037B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1439);

0379:

    #0379
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (037A);

037A:

    #037A
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (037B);

037B:

    #037B
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (037D);

037C:

    #037C
    #instruction: NOP
    advance (4)
    jump (037D);

037D:

    #037D
    #instruction: LD   (2012),A
    M[2012] := A;
    advance (13)
    jump (0380);

037E:

    #037E
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (037F);

037F:

    #037F
    #instruction: *NOP
    advance (4)
    jump (0380);

0380:

    #0380
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0381:

    #0381
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (0382);

0382:

    #0382
    #instruction: CP   D9
    let:16 a1 = addWithCarry(!false,A,~D9) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D9 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0384);

0383:

    #0383
    #instruction: *RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0384:

    #0384
    #instruction: JP   Z,036F
    if (FlagZ) {
      advance (10)
      jump (036F);
    } else {
      advance (10)
      jump (0387);
    }

0385:

    #0385
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (0386);

0386:

    #0386
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0387);

0387:

    #0387
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0388);

0388:

    #0388
    #instruction: LD   (201B),A
    M[201B] := A;
    advance (13)
    jump (038B);

0389:

    #0389
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (038A);

038A:

    #038A
    #instruction: *NOP
    advance (4)
    jump (038B);

038B:

    #038B
    #instruction: JP   036F
    advance (10)
    jump (036F);

038C:

    #038C
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (038D);

038D:

    #038D
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (038E);

038E:

    #038E
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (038F);

038F:

    #038F
    #instruction: CP   30
    let:16 a1 = addWithCarry(!false,A,~30) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~30 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0391);

0390:

    #0390
    #instruction: *NOP
    advance (4)
    jump (0391);

0391:

    #0391
    #instruction: JP   Z,036F
    if (FlagZ) {
      advance (10)
      jump (036F);
    } else {
      advance (10)
      jump (0394);
    }

0392:

    #0392
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (0393);

0393:

    #0393
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0394);

0394:

    #0394
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0395);

0395:

    #0395
    #instruction: LD   (201B),A
    M[201B] := A;
    advance (13)
    jump (0398);

0396:

    #0396
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0397);

0397:

    #0397
    #instruction: *NOP
    advance (4)
    jump (0398);

0398:

    #0398
    #instruction: JP   036F
    advance (10)
    jump (036F);

0399:

    #0399
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (039A);

039A:

    #039A
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (039B);

039B:

    #039B
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (039C);

039C:

    #039C
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (039E);

039D:

    #039D
    #instruction: LD   BC,1532
    advance (10)
    B := 15;
    C := 32;
    jump (03A0);

039E:

    #039E
    #instruction: LD   (2015),A
    M[2015] := A;
    advance (13)
    jump (03A1);

039F:

    #039F
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03A0);

03A0:

    #03A0
    #instruction: *NOP
    advance (4)
    jump (03A1);

03A1:

    #03A1
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (03A2);

03A2:

    #03A2
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (03A3);

03A3:

    #03A3
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (03A4);

03A4:

    #03A4
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (03A5);

03A5:

    #03A5
    #instruction: LD   HL,1C70
    advance (10)
    H := 1C;
    L := 70;
    jump (03A8);

03A6:

    #03A6
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (03A7);

03A7:

    #03A7
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03A8);

03A8:

    #03A8
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (03A9);

03A9:

    #03A9
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (03AA);

03AA:

    #03AA
    #instruction: LD   (2018),HL
    M[2018] := L;
    M[2019] := H;
    advance (16)
    jump (03AD);

03AB:

    #03AB
    #instruction: *NOP
    advance (4)
    jump (03AC);

03AC:

    #03AC
    #instruction: *NOP
    advance (4)
    jump (03AD);

03AD:

    #03AD
    #instruction: JP   036F
    advance (10)
    jump (036F);

03AE:

    #03AE
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (03AF);

03AF:

    #03AF
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03B0);

03B0:

    #03B0
    #instruction: JP   NZ,034A
    if (!FlagZ) {
      advance (10)
      jump (034A);
    } else {
      advance (10)
      jump (03B3);
    }

03B1:

    #03B1
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (03B2);

03B2:

    #03B2
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03B3);

03B3:

    #03B3
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03B4);

03B4:

    #03B4
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03B5);

03B5:

    #03B5
    #instruction: JP   NZ,034A
    if (!FlagZ) {
      advance (10)
      jump (034A);
    } else {
      advance (10)
      jump (03B8);
    }

03B6:

    #03B6
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (03B7);

03B7:

    #03B7
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03B8);

03B8:

    #03B8
    #instruction: JP   0346
    advance (10)
    jump (0346);

03B9:

    #03B9
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (03BA);

03BA:

    #03BA
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03BB);

03BB:

    #03BB
    #instruction: LD   DE,202A
    advance (10)
    D := 20;
    E := 2A;
    jump (03BE);

03BC:

    #03BC
    #instruction: LD   HL,(CD20)
    advance (16)
    H := M[CD21];
    L := M[CD20];
    jump (03BF);

03BD:

    #03BD
    #instruction: *NOP
    advance (4)
    jump (03BE);

03BE:

    #03BE
    #instruction: CALL 1A06
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 03C1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A06);

03BF:

    #03BF
    #instruction: LD   B,1A
    advance (7)
    B := 1A;
    jump (03C1);

03C0:

    #03C0
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (03C1);

03C1:

    #03C1
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (03C2);

03C2:

    #03C2
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (03C3);
    }

03C3:

    #03C3
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03C4);

03C4:

    #03C4
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (03C5);

03C5:

    #03C5
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (03C6);

03C6:

    #03C6
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (03C7);
    }

03C7:

    #03C7
    #instruction: CP   01
    let:16 a1 = addWithCarry(!false,A,~01) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~01 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (03C9);

03C8:

    #03C8
    #instruction: LD   BC,FACA
    advance (10)
    B := FA;
    C := CA;
    jump (03CB);

03C9:

    #03C9
    #instruction: JP   Z,03FA
    if (FlagZ) {
      advance (10)
      jump (03FA);
    } else {
      advance (10)
      jump (03CC);
    }

03CA:

    #03CA
    #instruction: JP   MI,FE03
    if (FlagS) {
      advance (10)
      jump (FE03);
    } else {
      advance (10)
      jump (03CD);
    }

03CB:

    #03CB
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03CC);

03CC:

    #03CC
    #instruction: CP   02
    let:16 a1 = addWithCarry(!false,A,~02) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~02 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (03CE);

03CD:

    #03CD
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (03CE);

03CE:

    #03CE
    #instruction: JP   Z,040A
    if (FlagZ) {
      advance (10)
      jump (040A);
    } else {
      advance (10)
      jump (03D1);
    }

03CF:

    #03CF
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (03D0);

03D0:

    #03D0
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03D1);

03D1:

    #03D1
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03D2);

03D2:

    #03D2
    #instruction: CP   03
    let:16 a1 = addWithCarry(!false,A,~03) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~03 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (03D4);

03D3:

    #03D3
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (03D4);

03D4:

    #03D4
    #instruction: JP   NZ,042A
    if (!FlagZ) {
      advance (10)
      jump (042A);
    } else {
      advance (10)
      jump (03D7);
    }

03D5:

    #03D5
    #instruction: LD   HL,(3504)
    advance (16)
    H := M[3505];
    L := M[3504];
    jump (03D8);

03D6:

    #03D6
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03D7);

03D7:

    #03D7
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03D8);

03D8:

    #03D8
    #instruction: JP   Z,0436
    if (FlagZ) {
      advance (10)
      jump (0436);
    } else {
      advance (10)
      jump (03DB);
    }

03D9:

    #03D9
    #instruction: LD   (HL),04
    M[(H,L)] := 04;
    advance (10)
    jump (03DB);

03DA:

    #03DA
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03DB);

03DB:

    #03DB
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (03DC);

03DC:

    #03DC
    #instruction: CP   0F
    let:16 a1 = addWithCarry(!false,A,~0F) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0F & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (03DE);

03DD:

    #03DD
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (03DE);

03DE:

    #03DE
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (03DF);
    }

03DF:

    #03DF
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (03E0);

03E0:

    #03E0
    #instruction: CALL 0430
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := E3;
    #return-to: 03E3
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0430);

03E1:

    #03E1
    #instruction: *NOP
    advance (4)
    jump (03E2);

03E2:

    #03E2
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03E3);

03E3:

    #03E3
    #instruction: CALL 1452
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := E6;
    #return-to: 03E6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1452);

03E4:

    #03E4
    #instruction: LD   D,D
    advance (5)
    jump (03E5);

03E5:

    #03E5
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03E6);

03E6:

    #03E6
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (03E7);

03E7:

    #03E7
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03E8);

03E8:

    #03E8
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03E9);

03E9:

    #03E9
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03EA);

03EA:

    #03EA
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03EB);

03EB:

    #03EB
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03EC);

03EC:

    #03EC
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03ED);

03ED:

    #03ED
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03EE);

03EE:

    #03EE
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03EF);

03EF:

    #03EF
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03F0);

03F0:

    #03F0
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03F1);

03F1:

    #03F1
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (03F2);

03F2:

    #03F2
    #instruction: LD   (HL),08
    M[(H,L)] := 08;
    advance (10)
    jump (03F4);

03F3:

    #03F3
    #instruction: *NOP
    advance (4)
    jump (03F4);

03F4:

    #03F4
    #instruction: CALL 0430
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := F7;
    #return-to: 03F7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0430);

03F5:

    #03F5
    #instruction: *NOP
    advance (4)
    jump (03F6);

03F6:

    #03F6
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03F7);

03F7:

    #03F7
    #instruction: JP   1400
    advance (10)
    jump (1400);

03F8:

    #03F8
    #instruction: NOP
    advance (4)
    jump (03F9);

03F9:

    #03F9
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03FA);

03FA:

    #03FA
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (03FB);

03FB:

    #03FB
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (03FC);

03FC:

    #03FC
    #instruction: LD   A,(201B)
    advance (13)
    A := M[201B];
    jump (03FF);

03FD:

    #03FD
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (03FE);

03FE:

    #03FE
    #instruction: *NOP
    advance (4)
    jump (03FF);

03FF:

    #03FF
    #instruction: ADD  08
    let:16 a1 = addWithCarry(false,08,A) in
    let:8 a2 = (08 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0401);

0400:

    #0400
    #instruction: *NOP
    advance (4)
    jump (0401);

0401:

    #0401
    #instruction: LD   (202A),A
    M[202A] := A;
    advance (13)
    jump (0404);

0402:

    #0402
    #instruction: LD   HL,(CD20)
    advance (16)
    H := M[CD21];
    L := M[CD20];
    jump (0405);

0403:

    #0403
    #instruction: *NOP
    advance (4)
    jump (0404);

0404:

    #0404
    #instruction: CALL 0430
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0407
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0430);

0405:

    #0405
    #instruction: *NOP
    advance (4)
    jump (0406);

0406:

    #0406
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0407);

0407:

    #0407
    #instruction: JP   1400
    advance (10)
    jump (1400);

0408:

    #0408
    #instruction: NOP
    advance (4)
    jump (0409);

0409:

    #0409
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (040A);

040A:

    #040A
    #instruction: CALL 0430
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0D;
    #return-to: 040D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0430);

040B:

    #040B
    #instruction: *NOP
    advance (4)
    jump (040C);

040C:

    #040C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (040D);

040D:

    #040D
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (040E);

040E:

    #040E
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (040F);

040F:

    #040F
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0410);

0410:

    #0410
    #instruction: CALL 1452
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 13;
    #return-to: 0413
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1452);

0411:

    #0411
    #instruction: LD   D,D
    advance (5)
    jump (0412);

0412:

    #0412
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0413);

0413:

    #0413
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0414);

0414:

    #0414
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0415);

0415:

    #0415
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0416);

0416:

    #0416
    #instruction: LD   A,(202C)
    advance (13)
    A := M[202C];
    jump (0419);

0417:

    #0417
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0418);

0418:

    #0418
    #instruction: *NOP
    advance (4)
    jump (0419);

0419:

    #0419
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (041A);

041A:

    #041A
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (041B);

041B:

    #041B
    #instruction: LD   (2029),A
    M[2029] := A;
    advance (13)
    jump (041E);

041C:

    #041C
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (041D);

041D:

    #041D
    #instruction: *NOP
    advance (4)
    jump (041E);

041E:

    #041E
    #instruction: CALL 1491
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 21;
    #return-to: 0421
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1491);

041F:

    #041F
    #instruction: SUB  C
    let:16 a1 = addWithCarry(!false,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0420);

0420:

    #0420
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0421);

0421:

    #0421
    #instruction: LD   A,(2061)
    advance (13)
    A := M[2061];
    jump (0424);

0422:

    #0422
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (0423);

0423:

    #0423
    #instruction: *NOP
    advance (4)
    jump (0424);

0424:

    #0424
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0425);

0425:

    #0425
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0426);
    }

0426:

    #0426
    #instruction: LD   (2002),A
    M[2002] := A;
    advance (13)
    jump (0429);

0427:

    #0427
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0428);

0428:

    #0428
    #instruction: *NOP
    advance (4)
    jump (0429);

0429:

    #0429
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

042A:

    #042A
    #instruction: CP   05
    let:16 a1 = addWithCarry(!false,A,~05) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~05 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (042C);

042B:

    #042B
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (042C);

042C:

    #042C
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (042D);
    }

042D:

    #042D
    #instruction: JP   0436
    advance (10)
    jump (0436);

042E:

    #042E
    #instruction: LD   (HL),04
    M[(H,L)] := 04;
    advance (10)
    jump (0430);

042F:

    #042F
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0430);

0430:

    #0430
    #instruction: LD   HL,2027
    advance (10)
    H := 20;
    L := 27;
    jump (0433);

0431:

    #0431
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (0432);

0432:

    #0432
    #instruction: *NOP
    advance (4)
    jump (0433);

0433:

    #0433
    #instruction: JP   1A3B
    advance (10)
    jump (1A3B);

0434:

    #0434
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0435);

0435:

    #0435
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0436);

0436:

    #0436
    #instruction: CALL 0430
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0439
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0430);

0437:

    #0437
    #instruction: *NOP
    advance (4)
    jump (0438);

0438:

    #0438
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0439);

0439:

    #0439
    #instruction: CALL 1452
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    #return-to: 043C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1452);

043A:

    #043A
    #instruction: LD   D,D
    advance (5)
    jump (043B);

043B:

    #043B
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (043C);

043C:

    #043C
    #instruction: LD   HL,2025
    advance (10)
    H := 20;
    L := 25;
    jump (043F);

043D:

    #043D
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (043E);

043E:

    #043E
    #instruction: *NOP
    advance (4)
    jump (043F);

043F:

    #043F
    #instruction: LD   DE,1B25
    advance (10)
    D := 1B;
    E := 25;
    jump (0442);

0440:

    #0440
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0441);

0441:

    #0441
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0442);

0442:

    #0442
    #instruction: LD   B,07
    advance (7)
    B := 07;
    jump (0444);

0443:

    #0443
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0444);

0444:

    #0444
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 47;
    #return-to: 0447
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

0445:

    #0445
    #instruction: LD   (2A1A),A
    M[2A1A] := A;
    advance (13)
    jump (0448);

0446:

    #0446
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0447);

0447:

    #0447
    #instruction: LD   HL,(208D)
    advance (16)
    H := M[208E];
    L := M[208D];
    jump (044A);

0448:

    #0448
    #instruction: ADC  L
    let:16 a1 = addWithCarry(FlagCY,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0449);

0449:

    #0449
    #instruction: *NOP
    advance (4)
    jump (044A);

044A:

    #044A
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (044B);

044B:

    #044B
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (044C);

044C:

    #044C
    #instruction: CP   63
    let:16 a1 = addWithCarry(!false,A,~63) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~63 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (044E);

044D:

    #044D
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (044E);

044E:

    #044E
    #instruction: JP   CY,0453
    if (FlagCY) {
      advance (10)
      jump (0453);
    } else {
      advance (10)
      jump (0451);
    }

044F:

    #044F
    #instruction: LD   D,E
    advance (5)
    D := E;
    jump (0450);

0450:

    #0450
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0451);

0451:

    #0451
    #instruction: LD   L,54
    advance (7)
    L := 54;
    jump (0453);

0452:

    #0452
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (0453);

0453:

    #0453
    #instruction: LD   (208D),HL
    M[208D] := L;
    M[208E] := H;
    advance (16)
    jump (0456);

0454:

    #0454
    #instruction: ADC  L
    let:16 a1 = addWithCarry(FlagCY,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0455);

0455:

    #0455
    #instruction: *NOP
    advance (4)
    jump (0456);

0456:

    #0456
    #instruction: LD   HL,(208F)
    advance (16)
    H := M[2090];
    L := M[208F];
    jump (0459);

0457:

    #0457
    #instruction: ADC  A
    let:16 a1 = addWithCarry(FlagCY,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0458);

0458:

    #0458
    #instruction: *NOP
    advance (4)
    jump (0459);

0459:

    #0459
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (045A);

045A:

    #045A
    #instruction: LD   (208F),HL
    M[208F] := L;
    M[2090] := H;
    advance (16)
    jump (045D);

045B:

    #045B
    #instruction: ADC  A
    let:16 a1 = addWithCarry(FlagCY,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (045C);

045C:

    #045C
    #instruction: *NOP
    advance (4)
    jump (045D);

045D:

    #045D
    #instruction: LD   A,(2084)
    advance (13)
    A := M[2084];
    jump (0460);

045E:

    #045E
    #instruction: ADD  H
    let:16 a1 = addWithCarry(false,H,A) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (045F);

045F:

    #045F
    #instruction: *NOP
    advance (4)
    jump (0460);

0460:

    #0460
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0461);

0461:

    #0461
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0462);
    }

0462:

    #0462
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0463);

0463:

    #0463
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0465);

0464:

    #0464
    #instruction: LD   BC,2901
    advance (10)
    B := 29;
    C := 01;
    jump (0467);

0465:

    #0465
    #instruction: LD   BC,0229
    advance (10)
    B := 02;
    C := 29;
    jump (0468);

0466:

    #0466
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0467);

0467:

    #0467
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0468);

0468:

    #0468
    #instruction: JP   NZ,046E
    if (!FlagZ) {
      advance (10)
      jump (046E);
    } else {
      advance (10)
      jump (046B);
    }

0469:

    #0469
    #instruction: LD   L,(HL)
    advance (7)
    L := M[(H,L)];
    jump (046A);

046A:

    #046A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (046B);

046B:

    #046B
    #instruction: LD   BC,FEE0
    advance (10)
    B := FE;
    C := E0;
    jump (046E);

046C:

    #046C
    #instruction: RET  PO
    if (!FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (046D);
    }

046D:

    #046D
    #instruction: CP   21
    let:16 a1 = addWithCarry(!false,A,~21) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~21 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (046F);

046E:

    #046E
    #instruction: LD   HL,208A
    advance (10)
    H := 20;
    L := 8A;
    jump (0471);

046F:

    #046F
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0470);

0470:

    #0470
    #instruction: *NOP
    advance (4)
    jump (0471);

0471:

    #0471
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (0472);

0472:

    #0472
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0473);

0473:

    #0473
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0474);

0474:

    #0474
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (0475);

0475:

    #0475
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0476:

    #0476
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0477);

0477:

    #0477
    #instruction: LD   A,(1B32)
    advance (13)
    A := 02;
    jump (047A);

0478:

    #0478
    #instruction: LD   (321B),A
    M[321B] := A;
    advance (13)
    jump (047B);

0479:

    #0479
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (047A);

047A:

    #047A
    #instruction: LD   (2032),A
    M[2032] := A;
    advance (13)
    jump (047D);

047B:

    #047B
    #instruction: LD   (2A20),A
    M[2A20] := A;
    advance (13)
    jump (047E);

047C:

    #047C
    #instruction: *NOP
    advance (4)
    jump (047D);

047D:

    #047D
    #instruction: LD   HL,(2038)
    advance (16)
    H := M[2039];
    L := M[2038];
    jump (0480);

047E:

    #047E
    #instruction: *NOP
    advance (4)
    jump (047F);

047F:

    #047F
    #instruction: *NOP
    advance (4)
    jump (0480);

0480:

    #0480
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (0481);

0481:

    #0481
    #instruction: OR   H
    let:8 a1 = (H | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0482);

0482:

    #0482
    #instruction: JP   NZ,048A
    if (!FlagZ) {
      advance (10)
      jump (048A);
    } else {
      advance (10)
      jump (0485);
    }

0483:

    #0483
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0484);

0484:

    #0484
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0485);

0485:

    #0485
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0486);

0486:

    #0486
    #instruction: LD   (2038),HL
    M[2038] := L;
    M[2039] := H;
    advance (16)
    jump (0489);

0487:

    #0487
    #instruction: *NOP
    advance (4)
    jump (0488);

0488:

    #0488
    #instruction: *NOP
    advance (4)
    jump (0489);

0489:

    #0489
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

048A:

    #048A
    #instruction: LD   DE,2035
    advance (10)
    D := 20;
    E := 35;
    jump (048D);

048B:

    #048B
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (048C);

048C:

    #048C
    #instruction: *NOP
    advance (4)
    jump (048D);

048D:

    #048D
    #instruction: LD   A,F9
    advance (7)
    A := F9;
    jump (048F);

048E:

    #048E
    #instruction: LD   SP,HL
    advance (5)
    SPH := H;
    SPL := L;
    jump (048F);

048F:

    #048F
    #instruction: CALL 0550
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 92;
    #return-to: 0492
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0550);

0490:

    #0490
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0491);

0491:

    #0491
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0492);

0492:

    #0492
    #instruction: LD   A,(2046)
    advance (13)
    A := M[2046];
    jump (0495);

0493:

    #0493
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (0494);

0494:

    #0494
    #instruction: *NOP
    advance (4)
    jump (0495);

0495:

    #0495
    #instruction: LD   (2070),A
    M[2070] := A;
    advance (13)
    jump (0498);

0496:

    #0496
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (0497);

0497:

    #0497
    #instruction: *NOP
    advance (4)
    jump (0498);

0498:

    #0498
    #instruction: LD   A,(2056)
    advance (13)
    A := M[2056];
    jump (049B);

0499:

    #0499
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (049A);

049A:

    #049A
    #instruction: *NOP
    advance (4)
    jump (049B);

049B:

    #049B
    #instruction: LD   (2071),A
    M[2071] := A;
    advance (13)
    jump (049E);

049C:

    #049C
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (049D);

049D:

    #049D
    #instruction: *NOP
    advance (4)
    jump (049E);

049E:

    #049E
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := A1;
    #return-to: 04A1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0563);

049F:

    #049F
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (04A0);

04A0:

    #04A0
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04A1);

04A1:

    #04A1
    #instruction: LD   A,(2078)
    advance (13)
    A := M[2078];
    jump (04A4);

04A2:

    #04A2
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (04A3);

04A3:

    #04A3
    #instruction: *NOP
    advance (4)
    jump (04A4);

04A4:

    #04A4
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (04A5);

04A5:

    #04A5
    #instruction: LD   HL,2035
    advance (10)
    H := 20;
    L := 35;
    jump (04A8);

04A6:

    #04A6
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04A7);

04A7:

    #04A7
    #instruction: *NOP
    advance (4)
    jump (04A8);

04A8:

    #04A8
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (04AB);
    }

04A9:

    #04A9
    #instruction: LD   E,E
    advance (5)
    jump (04AA);

04AA:

    #04AA
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04AB);

04AB:

    #04AB
    #instruction: LD   DE,1B30
    advance (10)
    D := 1B;
    E := 30;
    jump (04AE);

04AC:

    #04AC
    #instruction: *NOP
    advance (4)
    jump (04AD);

04AD:

    #04AD
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (04AE);

04AE:

    #04AE
    #instruction: LD   HL,2030
    advance (10)
    H := 20;
    L := 30;
    jump (04B1);

04AF:

    #04AF
    #instruction: *NOP
    advance (4)
    jump (04B0);

04B0:

    #04B0
    #instruction: *NOP
    advance (4)
    jump (04B1);

04B1:

    #04B1
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (04B3);

04B2:

    #04B2
    #instruction: *NOP
    advance (4)
    jump (04B3);

04B3:

    #04B3
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

04B4:

    #04B4
    #instruction: LD   (E11A),A
    M[E11A] := A;
    advance (13)
    jump (04B7);

04B5:

    #04B5
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (04B6);

04B6:

    #04B6
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (04B7);

04B7:

    #04B7
    #instruction: LD   A,(206E)
    advance (13)
    A := M[206E];
    jump (04BA);

04B8:

    #04B8
    #instruction: LD   L,(HL)
    advance (7)
    L := M[(H,L)];
    jump (04B9);

04B9:

    #04B9
    #instruction: *NOP
    advance (4)
    jump (04BA);

04BA:

    #04BA
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (04BB);

04BB:

    #04BB
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (04BC);
    }

04BC:

    #04BC
    #instruction: LD   A,(2080)
    advance (13)
    A := M[2080];
    jump (04BF);

04BD:

    #04BD
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (04BE);

04BE:

    #04BE
    #instruction: *NOP
    advance (4)
    jump (04BF);

04BF:

    #04BF
    #instruction: CP   01
    let:16 a1 = addWithCarry(!false,A,~01) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~01 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (04C1);

04C0:

    #04C0
    #instruction: LD   BC,11C0
    advance (10)
    B := 11;
    C := C0;
    jump (04C3);

04C1:

    #04C1
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (04C2);
    }

04C2:

    #04C2
    #instruction: LD   DE,2045
    advance (10)
    D := 20;
    E := 45;
    jump (04C5);

04C3:

    #04C3
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (04C4);

04C4:

    #04C4
    #instruction: *NOP
    advance (4)
    jump (04C5);

04C5:

    #04C5
    #instruction: LD   A,ED
    advance (7)
    A := ED;
    jump (04C7);

04C6:

    #04C6
    #instruction: *CAL 50CD
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := C9;
    #return-to: 04C9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (50CD);

04C7:

    #04C7
    #instruction: CALL 0550
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := CA;
    #return-to: 04CA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0550);

04C8:

    #04C8
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (04C9);

04C9:

    #04C9
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04CA);

04CA:

    #04CA
    #instruction: LD   A,(2036)
    advance (13)
    A := M[2036];
    jump (04CD);

04CB:

    #04CB
    #instruction: LD   (HL),20
    M[(H,L)] := 20;
    advance (10)
    jump (04CD);

04CC:

    #04CC
    #instruction: *NOP
    advance (4)
    jump (04CD);

04CD:

    #04CD
    #instruction: LD   (2070),A
    M[2070] := A;
    advance (13)
    jump (04D0);

04CE:

    #04CE
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (04CF);

04CF:

    #04CF
    #instruction: *NOP
    advance (4)
    jump (04D0);

04D0:

    #04D0
    #instruction: LD   A,(2056)
    advance (13)
    A := M[2056];
    jump (04D3);

04D1:

    #04D1
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (04D2);

04D2:

    #04D2
    #instruction: *NOP
    advance (4)
    jump (04D3);

04D3:

    #04D3
    #instruction: LD   (2071),A
    M[2071] := A;
    advance (13)
    jump (04D6);

04D4:

    #04D4
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (04D5);

04D5:

    #04D5
    #instruction: *NOP
    advance (4)
    jump (04D6);

04D6:

    #04D6
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := D9;
    #return-to: 04D9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0563);

04D7:

    #04D7
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (04D8);

04D8:

    #04D8
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04D9);

04D9:

    #04D9
    #instruction: LD   A,(2076)
    advance (13)
    A := M[2076];
    jump (04DC);

04DA:

    #04DA
    #instruction: HLT
    advance (7)
    jump (04DA);

04DB:

    #04DB
    #instruction: *NOP
    advance (4)
    jump (04DC);

04DC:

    #04DC
    #instruction: CP   10
    let:16 a1 = addWithCarry(!false,A,~10) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (04DE);

04DD:

    #04DD
    #instruction: *NOP
    advance (4)
    jump (04DE);

04DE:

    #04DE
    #instruction: JP   CY,04E7
    if (FlagCY) {
      advance (10)
      jump (04E7);
    } else {
      advance (10)
      jump (04E1);
    }

04DF:

    #04DF
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := E0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

04E0:

    #04E0
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04E1);

04E1:

    #04E1
    #instruction: LD   A,(1B48)
    advance (13)
    A := 00;
    jump (04E4);

04E2:

    #04E2
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (04E3);

04E3:

    #04E3
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (04E4);

04E4:

    #04E4
    #instruction: LD   (2076),A
    M[2076] := A;
    advance (13)
    jump (04E7);

04E5:

    #04E5
    #instruction: HLT
    advance (7)
    jump (04E5);

04E6:

    #04E6
    #instruction: *NOP
    advance (4)
    jump (04E7);

04E7:

    #04E7
    #instruction: LD   A,(2078)
    advance (13)
    A := M[2078];
    jump (04EA);

04E8:

    #04E8
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (04E9);

04E9:

    #04E9
    #instruction: *NOP
    advance (4)
    jump (04EA);

04EA:

    #04EA
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (04EB);

04EB:

    #04EB
    #instruction: LD   HL,2045
    advance (10)
    H := 20;
    L := 45;
    jump (04EE);

04EC:

    #04EC
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (04ED);

04ED:

    #04ED
    #instruction: *NOP
    advance (4)
    jump (04EE);

04EE:

    #04EE
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (04F1);
    }

04EF:

    #04EF
    #instruction: LD   E,E
    advance (5)
    jump (04F0);

04F0:

    #04F0
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (04F1);

04F1:

    #04F1
    #instruction: LD   DE,1B40
    advance (10)
    D := 1B;
    E := 40;
    jump (04F4);

04F2:

    #04F2
    #instruction: LD   B,B
    advance (5)
    jump (04F3);

04F3:

    #04F3
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (04F4);

04F4:

    #04F4
    #instruction: LD   HL,2040
    advance (10)
    H := 20;
    L := 40;
    jump (04F7);

04F5:

    #04F5
    #instruction: LD   B,B
    advance (5)
    jump (04F6);

04F6:

    #04F6
    #instruction: *NOP
    advance (4)
    jump (04F7);

04F7:

    #04F7
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (04F9);

04F8:

    #04F8
    #instruction: *NOP
    advance (4)
    jump (04F9);

04F9:

    #04F9
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := FC;
    #return-to: 04FC
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

04FA:

    #04FA
    #instruction: LD   (3A1A),A
    M[3A1A] := A;
    advance (13)
    jump (04FD);

04FB:

    #04FB
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (04FC);

04FC:

    #04FC
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (04FF);

04FD:

    #04FD
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (04FE);

04FE:

    #04FE
    #instruction: *NOP
    advance (4)
    jump (04FF);

04FF:

    #04FF
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0500);

0500:

    #0500
    #instruction: JP   NZ,0508
    if (!FlagZ) {
      advance (10)
      jump (0508);
    } else {
      advance (10)
      jump (0503);
    }

0501:

    #0501
    #instruction: *NOP
    advance (4)
    jump (0502);

0502:

    #0502
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0503);

0503:

    #0503
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0505);

0504:

    #0504
    #instruction: LD   BC,6E32
    advance (10)
    B := 6E;
    C := 32;
    jump (0507);

0505:

    #0505
    #instruction: LD   (206E),A
    M[206E] := A;
    advance (13)
    jump (0508);

0506:

    #0506
    #instruction: LD   L,(HL)
    advance (7)
    L := M[(H,L)];
    jump (0507);

0507:

    #0507
    #instruction: *NOP
    advance (4)
    jump (0508);

0508:

    #0508
    #instruction: LD   HL,(2076)
    advance (16)
    H := M[2077];
    L := M[2076];
    jump (050B);

0509:

    #0509
    #instruction: HLT
    advance (7)
    jump (0509);

050A:

    #050A
    #instruction: *NOP
    advance (4)
    jump (050B);

050B:

    #050B
    #instruction: JP   067E
    advance (10)
    jump (067E);

050C:

    #050C
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (050D);

050D:

    #050D
    #instruction: LD   B,E1
    advance (7)
    B := E1;
    jump (050F);

050E:

    #050E
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (050F);

050F:

    #050F
    #instruction: LD   DE,2055
    advance (10)
    D := 20;
    E := 55;
    jump (0512);

0510:

    #0510
    #instruction: LD   D,L
    advance (5)
    D := L;
    jump (0511);

0511:

    #0511
    #instruction: *NOP
    advance (4)
    jump (0512);

0512:

    #0512
    #instruction: LD   A,DB
    advance (7)
    A := DB;
    jump (0514);

0513:

    #0513
    #instruction: IN   CD
    advance (10)
    A := unknown_input(205);
    jump (0515);

0514:

    #0514
    #instruction: CALL 0550
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    #return-to: 0517
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0550);

0515:

    #0515
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0516);

0516:

    #0516
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0517);

0517:

    #0517
    #instruction: LD   A,(2046)
    advance (13)
    A := M[2046];
    jump (051A);

0518:

    #0518
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (0519);

0519:

    #0519
    #instruction: *NOP
    advance (4)
    jump (051A);

051A:

    #051A
    #instruction: LD   (2070),A
    M[2070] := A;
    advance (13)
    jump (051D);

051B:

    #051B
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (051C);

051C:

    #051C
    #instruction: *NOP
    advance (4)
    jump (051D);

051D:

    #051D
    #instruction: LD   A,(2036)
    advance (13)
    A := M[2036];
    jump (0520);

051E:

    #051E
    #instruction: LD   (HL),20
    M[(H,L)] := 20;
    advance (10)
    jump (0520);

051F:

    #051F
    #instruction: *NOP
    advance (4)
    jump (0520);

0520:

    #0520
    #instruction: LD   (2071),A
    M[2071] := A;
    advance (13)
    jump (0523);

0521:

    #0521
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (0522);

0522:

    #0522
    #instruction: *NOP
    advance (4)
    jump (0523);

0523:

    #0523
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 26;
    #return-to: 0526
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0563);

0524:

    #0524
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (0525);

0525:

    #0525
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0526);

0526:

    #0526
    #instruction: LD   A,(2076)
    advance (13)
    A := M[2076];
    jump (0529);

0527:

    #0527
    #instruction: HLT
    advance (7)
    jump (0527);

0528:

    #0528
    #instruction: *NOP
    advance (4)
    jump (0529);

0529:

    #0529
    #instruction: CP   15
    let:16 a1 = addWithCarry(!false,A,~15) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~15 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (052B);

052A:

    #052A
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (052B);

052B:

    #052B
    #instruction: JP   CY,0534
    if (FlagCY) {
      advance (10)
      jump (0534);
    } else {
      advance (10)
      jump (052E);
    }

052C:

    #052C
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (052D);

052D:

    #052D
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (052E);

052E:

    #052E
    #instruction: LD   A,(1B58)
    advance (13)
    A := 06;
    jump (0531);

052F:

    #052F
    #instruction: LD   E,B
    advance (5)
    E := B;
    jump (0530);

0530:

    #0530
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0531);

0531:

    #0531
    #instruction: LD   (2076),A
    M[2076] := A;
    advance (13)
    jump (0534);

0532:

    #0532
    #instruction: HLT
    advance (7)
    jump (0532);

0533:

    #0533
    #instruction: *NOP
    advance (4)
    jump (0534);

0534:

    #0534
    #instruction: LD   A,(2078)
    advance (13)
    A := M[2078];
    jump (0537);

0535:

    #0535
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (0536);

0536:

    #0536
    #instruction: *NOP
    advance (4)
    jump (0537);

0537:

    #0537
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0538);

0538:

    #0538
    #instruction: LD   HL,2055
    advance (10)
    H := 20;
    L := 55;
    jump (053B);

0539:

    #0539
    #instruction: LD   D,L
    advance (5)
    D := L;
    jump (053A);

053A:

    #053A
    #instruction: *NOP
    advance (4)
    jump (053B);

053B:

    #053B
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (053E);
    }

053C:

    #053C
    #instruction: LD   E,E
    advance (5)
    jump (053D);

053D:

    #053D
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (053E);

053E:

    #053E
    #instruction: LD   DE,1B50
    advance (10)
    D := 1B;
    E := 50;
    jump (0541);

053F:

    #053F
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0540);

0540:

    #0540
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0541);

0541:

    #0541
    #instruction: LD   HL,2050
    advance (10)
    H := 20;
    L := 50;
    jump (0544);

0542:

    #0542
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0543);

0543:

    #0543
    #instruction: *NOP
    advance (4)
    jump (0544);

0544:

    #0544
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0546);

0545:

    #0545
    #instruction: *NOP
    advance (4)
    jump (0546);

0546:

    #0546
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 49;
    #return-to: 0549
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

0547:

    #0547
    #instruction: LD   (2A1A),A
    M[2A1A] := A;
    advance (13)
    jump (054A);

0548:

    #0548
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0549);

0549:

    #0549
    #instruction: LD   HL,(2076)
    advance (16)
    H := M[2077];
    L := M[2076];
    jump (054C);

054A:

    #054A
    #instruction: HLT
    advance (7)
    jump (054A);

054B:

    #054B
    #instruction: *NOP
    advance (4)
    jump (054C);

054C:

    #054C
    #instruction: LD   (2058),HL
    M[2058] := L;
    M[2059] := H;
    advance (16)
    jump (054F);

054D:

    #054D
    #instruction: LD   E,B
    advance (5)
    E := B;
    jump (054E);

054E:

    #054E
    #instruction: *NOP
    advance (4)
    jump (054F);

054F:

    #054F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0550:

    #0550
    #instruction: LD   (207F),A
    M[207F] := A;
    advance (13)
    jump (0553);

0551:

    #0551
    #instruction: LD   A,A
    advance (5)
    jump (0552);

0552:

    #0552
    #instruction: *NOP
    advance (4)
    jump (0553);

0553:

    #0553
    #instruction: LD   HL,2073
    advance (10)
    H := 20;
    L := 73;
    jump (0556);

0554:

    #0554
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (0555);

0555:

    #0555
    #instruction: *NOP
    advance (4)
    jump (0556);

0556:

    #0556
    #instruction: LD   B,0B
    advance (7)
    B := 0B;
    jump (0558);

0557:

    #0557
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0558);

0558:

    #0558
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0559:

    #0559
    #instruction: LD   (111A),A
    M[111A] := A;
    advance (13)
    jump (055C);

055A:

    #055A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (055B);

055B:

    #055B
    #instruction: LD   DE,2073
    advance (10)
    D := 20;
    E := 73;
    jump (055E);

055C:

    #055C
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (055D);

055D:

    #055D
    #instruction: *NOP
    advance (4)
    jump (055E);

055E:

    #055E
    #instruction: LD   B,0B
    advance (7)
    B := 0B;
    jump (0560);

055F:

    #055F
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0560);

0560:

    #0560
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0561:

    #0561
    #instruction: LD   (211A),A
    M[211A] := A;
    advance (13)
    jump (0564);

0562:

    #0562
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0563);

0563:

    #0563
    #instruction: LD   HL,2073
    advance (10)
    H := 20;
    L := 73;
    jump (0566);

0564:

    #0564
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (0565);

0565:

    #0565
    #instruction: *NOP
    advance (4)
    jump (0566);

0566:

    #0566
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0567);

0567:

    #0567
    #instruction: AND  80
    let:8 a1 = (80 & A) in
    let:8 a2 = (80 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0569);

0568:

    #0568
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0569);

0569:

    #0569
    #instruction: JP   NZ,05C1
    if (!FlagZ) {
      advance (10)
      jump (05C1);
    } else {
      advance (10)
      jump (056C);
    }

056A:

    #056A
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (056B);

056B:

    #056B
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (056C);

056C:

    #056C
    #instruction: LD   A,(20C1)
    advance (13)
    A := M[20C1];
    jump (056F);

056D:

    #056D
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (056E);

056E:

    #056E
    #instruction: *NOP
    advance (4)
    jump (056F);

056F:

    #056F
    #instruction: CP   04
    let:16 a1 = addWithCarry(!false,A,~04) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~04 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0571);

0570:

    #0570
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0571);

0571:

    #0571
    #instruction: LD   A,(2069)
    advance (13)
    A := M[2069];
    jump (0574);

0572:

    #0572
    #instruction: LD   L,C
    advance (5)
    L := C;
    jump (0573);

0573:

    #0573
    #instruction: *NOP
    advance (4)
    jump (0574);

0574:

    #0574
    #instruction: JP   Z,05B7
    if (FlagZ) {
      advance (10)
      jump (05B7);
    } else {
      advance (10)
      jump (0577);
    }

0575:

    #0575
    #instruction: OR   A
    let:8 a1 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0576);

0576:

    #0576
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0577);

0577:

    #0577
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0578);

0578:

    #0578
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0579);
    }

0579:

    #0579
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (057A);

057A:

    #057A
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (057C);

057B:

    #057B
    #instruction: NOP
    advance (4)
    jump (057C);

057C:

    #057C
    #instruction: LD   A,(2070)
    advance (13)
    A := M[2070];
    jump (057F);

057D:

    #057D
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (057E);

057E:

    #057E
    #instruction: *NOP
    advance (4)
    jump (057F);

057F:

    #057F
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0580);

0580:

    #0580
    #instruction: JP   Z,0589
    if (FlagZ) {
      advance (10)
      jump (0589);
    } else {
      advance (10)
      jump (0583);
    }

0581:

    #0581
    #instruction: ADC  C
    let:16 a1 = addWithCarry(FlagCY,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0582);

0582:

    #0582
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0583);

0583:

    #0583
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (0584);

0584:

    #0584
    #instruction: LD   A,(20CF)
    advance (13)
    A := M[20CF];
    jump (0587);

0585:

    #0585
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 86;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0586:

    #0586
    #instruction: *NOP
    advance (4)
    jump (0587);

0587:

    #0587
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0588);

0588:

    #0588
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0589);
    }

0589:

    #0589
    #instruction: LD   A,(2071)
    advance (13)
    A := M[2071];
    jump (058C);

058A:

    #058A
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (058B);

058B:

    #058B
    #instruction: *NOP
    advance (4)
    jump (058C);

058C:

    #058C
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (058D);

058D:

    #058D
    #instruction: JP   Z,0596
    if (FlagZ) {
      advance (10)
      jump (0596);
    } else {
      advance (10)
      jump (0590);
    }

058E:

    #058E
    #instruction: SUB  (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (058F);

058F:

    #058F
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0590);

0590:

    #0590
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (0591);

0591:

    #0591
    #instruction: LD   A,(20CF)
    advance (13)
    A := M[20CF];
    jump (0594);

0592:

    #0592
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 93;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0593:

    #0593
    #instruction: *NOP
    advance (4)
    jump (0594);

0594:

    #0594
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0595);

0595:

    #0595
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0596);
    }

0596:

    #0596
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0597);

0597:

    #0597
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0598);

0598:

    #0598
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0599);

0599:

    #0599
    #instruction: JP   Z,061B
    if (FlagZ) {
      advance (10)
      jump (061B);
    } else {
      advance (10)
      jump (059C);
    }

059A:

    #059A
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (059B);

059B:

    #059B
    #instruction: LD   B,2A
    advance (7)
    B := 2A;
    jump (059D);

059C:

    #059C
    #instruction: LD   HL,(2076)
    advance (16)
    H := M[2077];
    L := M[2076];
    jump (059F);

059D:

    #059D
    #instruction: HLT
    advance (7)
    jump (059D);

059E:

    #059E
    #instruction: *NOP
    advance (4)
    jump (059F);

059F:

    #059F
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (05A0);

05A0:

    #05A0
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (05A1);

05A1:

    #05A1
    #instruction: NOP
    advance (4)
    jump (05A2);

05A2:

    #05A2
    #instruction: LD   (2076),HL
    M[2076] := L;
    M[2077] := H;
    advance (16)
    jump (05A5);

05A3:

    #05A3
    #instruction: HLT
    advance (7)
    jump (05A3);

05A4:

    #05A4
    #instruction: *NOP
    advance (4)
    jump (05A5);

05A5:

    #05A5
    #instruction: CALL 062F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := A8;
    #return-to: 05A8
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (062F);

05A6:

    #05A6
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (05A7);

05A7:

    #05A7
    #instruction: LD   B,D0
    advance (7)
    B := D0;
    jump (05A9);

05A8:

    #05A8
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (05A9);
    }

05A9:

    #05A9
    #instruction: CALL 017A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := AC;
    #return-to: 05AC
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (017A);

05AA:

    #05AA
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (05AB);

05AB:

    #05AB
    #instruction: LD   BC,C679
    advance (10)
    B := C6;
    C := 79;
    jump (05AE);

05AC:

    #05AC
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (05AD);

05AD:

    #05AD
    #instruction: ADD  07
    let:16 a1 = addWithCarry(false,07,A) in
    let:8 a2 = (07 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (05AF);

05AE:

    #05AE
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (05AF);

05AF:

    #05AF
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (05B0);

05B0:

    #05B0
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (05B1);

05B1:

    #05B1
    #instruction: SUB  0A
    let:16 a1 = addWithCarry(!false,A,~0A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (05B3);

05B2:

    #05B2
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (05B3);

05B3:

    #05B3
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (05B4);

05B4:

    #05B4
    #instruction: LD   (207B),HL
    M[207B] := L;
    M[207C] := H;
    advance (16)
    jump (05B7);

05B5:

    #05B5
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (05B6);

05B6:

    #05B6
    #instruction: *NOP
    advance (4)
    jump (05B7);

05B7:

    #05B7
    #instruction: LD   HL,2073
    advance (10)
    H := 20;
    L := 73;
    jump (05BA);

05B8:

    #05B8
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (05B9);

05B9:

    #05B9
    #instruction: *NOP
    advance (4)
    jump (05BA);

05BA:

    #05BA
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (05BB);

05BB:

    #05BB
    #instruction: OR   80
    let:8 a1 = (80 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (05BD);

05BC:

    #05BC
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (05BD);

05BD:

    #05BD
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (05BE);

05BE:

    #05BE
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (05BF);

05BF:

    #05BF
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (05C0);

05C0:

    #05C0
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

05C1:

    #05C1
    #instruction: LD   DE,207C
    advance (10)
    D := 20;
    E := 7C;
    jump (05C4);

05C2:

    #05C2
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (05C3);

05C3:

    #05C3
    #instruction: *NOP
    advance (4)
    jump (05C4);

05C4:

    #05C4
    #instruction: CALL 1A06
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := C7;
    #return-to: 05C7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A06);

05C5:

    #05C5
    #instruction: LD   B,1A
    advance (7)
    B := 1A;
    jump (05C7);

05C6:

    #05C6
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (05C7);

05C7:

    #05C7
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (05C8);
    }

05C8:

    #05C8
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (05C9);

05C9:

    #05C9
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (05CA);

05CA:

    #05CA
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (05CC);

05CB:

    #05CB
    #instruction: LD   BC,44C2
    advance (10)
    B := 44;
    C := C2;
    jump (05CE);

05CC:

    #05CC
    #instruction: JP   NZ,0644
    if (!FlagZ) {
      advance (10)
      jump (0644);
    } else {
      advance (10)
      jump (05CF);
    }

05CD:

    #05CD
    #instruction: LD   B,H
    advance (5)
    B := H;
    jump (05CE);

05CE:

    #05CE
    #instruction: LD   B,23
    advance (7)
    B := 23;
    jump (05D0);

05CF:

    #05CF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (05D0);

05D0:

    #05D0
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (05D1);

05D1:

    #05D1
    #instruction: CALL 0675
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := D4;
    #return-to: 05D4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0675);

05D2:

    #05D2
    #instruction: LD   (HL),L
    M[(H,L)] := L;
    advance (7)
    jump (05D3);

05D3:

    #05D3
    #instruction: LD   B,3A
    advance (7)
    B := 3A;
    jump (05D5);

05D4:

    #05D4
    #instruction: LD   A,(2079)
    advance (13)
    A := M[2079];
    jump (05D7);

05D5:

    #05D5
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (05D6);

05D6:

    #05D6
    #instruction: *NOP
    advance (4)
    jump (05D7);

05D7:

    #05D7
    #instruction: ADD  03
    let:16 a1 = addWithCarry(false,03,A) in
    let:8 a2 = (03 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (05D9);

05D8:

    #05D8
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (05D9);

05D9:

    #05D9
    #instruction: LD   HL,207F
    advance (10)
    H := 20;
    L := 7F;
    jump (05DC);

05DA:

    #05DA
    #instruction: LD   A,A
    advance (5)
    jump (05DB);

05DB:

    #05DB
    #instruction: *NOP
    advance (4)
    jump (05DC);

05DC:

    #05DC
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (05DD);

05DD:

    #05DD
    #instruction: JP   CY,05E2
    if (FlagCY) {
      advance (10)
      jump (05E2);
    } else {
      advance (10)
      jump (05E0);
    }

05DE:

    #05DE
    #instruction: JP   PO,D605
    if (!FlagP) {
      advance (10)
      jump (D605);
    } else {
      advance (10)
      jump (05E1);
    }

05DF:

    #05DF
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (05E0);

05E0:

    #05E0
    #instruction: SUB  0C
    let:16 a1 = addWithCarry(!false,A,~0C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (05E2);

05E1:

    #05E1
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (05E2);

05E2:

    #05E2
    #instruction: LD   (2079),A
    M[2079] := A;
    advance (13)
    jump (05E5);

05E3:

    #05E3
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (05E4);

05E4:

    #05E4
    #instruction: *NOP
    advance (4)
    jump (05E5);

05E5:

    #05E5
    #instruction: LD   A,(207B)
    advance (13)
    A := M[207B];
    jump (05E8);

05E6:

    #05E6
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (05E7);

05E7:

    #05E7
    #instruction: *NOP
    advance (4)
    jump (05E8);

05E8:

    #05E8
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (05E9);

05E9:

    #05E9
    #instruction: LD   A,(207E)
    advance (13)
    A := M[207E];
    jump (05EC);

05EA:

    #05EA
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (05EB);

05EB:

    #05EB
    #instruction: *NOP
    advance (4)
    jump (05EC);

05EC:

    #05EC
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (05ED);

05ED:

    #05ED
    #instruction: LD   (207B),A
    M[207B] := A;
    advance (13)
    jump (05F0);

05EE:

    #05EE
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (05EF);

05EF:

    #05EF
    #instruction: *NOP
    advance (4)
    jump (05F0);

05F0:

    #05F0
    #instruction: CALL 066C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := F3;
    #return-to: 05F3
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (066C);

05F1:

    #05F1
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (05F2);

05F2:

    #05F2
    #instruction: LD   B,3A
    advance (7)
    B := 3A;
    jump (05F4);

05F3:

    #05F3
    #instruction: LD   A,(207B)
    advance (13)
    A := M[207B];
    jump (05F6);

05F4:

    #05F4
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (05F5);

05F5:

    #05F5
    #instruction: *NOP
    advance (4)
    jump (05F6);

05F6:

    #05F6
    #instruction: CP   15
    let:16 a1 = addWithCarry(!false,A,~15) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~15 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (05F8);

05F7:

    #05F7
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (05F8);

05F8:

    #05F8
    #instruction: JP   CY,0612
    if (FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (05FB);
    }

05F9:

    #05F9
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (05FA);

05FA:

    #05FA
    #instruction: LD   B,3A
    advance (7)
    B := 3A;
    jump (05FC);

05FB:

    #05FB
    #instruction: LD   A,(2061)
    advance (13)
    A := M[2061];
    jump (05FE);

05FC:

    #05FC
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (05FD);

05FD:

    #05FD
    #instruction: *NOP
    advance (4)
    jump (05FE);

05FE:

    #05FE
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (05FF);

05FF:

    #05FF
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0600);
    }

0600:

    #0600
    #instruction: LD   A,(207B)
    advance (13)
    A := M[207B];
    jump (0603);

0601:

    #0601
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (0602);

0602:

    #0602
    #instruction: *NOP
    advance (4)
    jump (0603);

0603:

    #0603
    #instruction: CP   1E
    let:16 a1 = addWithCarry(!false,A,~1E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~1E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0605);

0604:

    #0604
    #instruction: LD   E,DA
    advance (7)
    E := DA;
    jump (0606);

0605:

    #0605
    #instruction: JP   CY,0612
    if (FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (0608);
    }

0606:

    #0606
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (0607);

0607:

    #0607
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (0609);

0608:

    #0608
    #instruction: CP   27
    let:16 a1 = addWithCarry(!false,A,~27) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~27 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (060A);

0609:

    #0609
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (060A);

060A:

    #060A
    #instruction: NOP
    advance (4)
    jump (060B);

060B:

    #060B
    #instruction: JP   NC,0612
    if (!FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (060E);
    }

060C:

    #060C
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (060D);

060D:

    #060D
    #instruction: LD   B,97
    advance (7)
    B := 97;
    jump (060F);

060E:

    #060E
    #instruction: SUB  A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (060F);

060F:

    #060F
    #instruction: LD   (2015),A
    M[2015] := A;
    advance (13)
    jump (0612);

0610:

    #0610
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0611);

0611:

    #0611
    #instruction: *NOP
    advance (4)
    jump (0612);

0612:

    #0612
    #instruction: LD   A,(2073)
    advance (13)
    A := M[2073];
    jump (0615);

0613:

    #0613
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (0614);

0614:

    #0614
    #instruction: *NOP
    advance (4)
    jump (0615);

0615:

    #0615
    #instruction: OR   01
    let:8 a1 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0617);

0616:

    #0616
    #instruction: LD   BC,7332
    advance (10)
    B := 73;
    C := 32;
    jump (0619);

0617:

    #0617
    #instruction: LD   (2073),A
    M[2073] := A;
    advance (13)
    jump (061A);

0618:

    #0618
    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    jump (0619);

0619:

    #0619
    #instruction: *NOP
    advance (4)
    jump (061A);

061A:

    #061A
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

061B:

    #061B
    #instruction: LD   A,(201B)
    advance (13)
    A := M[201B];
    jump (061E);

061C:

    #061C
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (061D);

061D:

    #061D
    #instruction: *NOP
    advance (4)
    jump (061E);

061E:

    #061E
    #instruction: ADD  08
    let:16 a1 = addWithCarry(false,08,A) in
    let:8 a2 = (08 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0620);

061F:

    #061F
    #instruction: *NOP
    advance (4)
    jump (0620);

0620:

    #0620
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0621);

0621:

    #0621
    #instruction: CALL 156F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := 24;
    #return-to: 0624
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (156F);

0622:

    #0622
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (0623);

0623:

    #0623
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0624);

0624:

    #0624
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0625);

0625:

    #0625
    #instruction: CP   0C
    let:16 a1 = addWithCarry(!false,A,~0C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~0C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0627);

0626:

    #0626
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0627);

0627:

    #0627
    #instruction: JP   CY,05A5
    if (FlagCY) {
      advance (10)
      jump (05A5);
    } else {
      advance (10)
      jump (062A);
    }

0628:

    #0628
    #instruction: AND  L
    let:8 a1 = (L & A) in
    let:8 a2 = (L | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0629);

0629:

    #0629
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (062A);

062A:

    #062A
    #instruction: LD   C,0B
    advance (7)
    C := 0B;
    jump (062C);

062B:

    #062B
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (062C);

062C:

    #062C
    #instruction: JP   05A5
    advance (10)
    jump (05A5);

062D:

    #062D
    #instruction: AND  L
    let:8 a1 = (L & A) in
    let:8 a2 = (L | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (062E);

062E:

    #062E
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (062F);

062F:

    #062F
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0630);

0630:

    #0630
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (0633);

0631:

    #0631
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0632);

0632:

    #0632
    #instruction: *NOP
    advance (4)
    jump (0633);

0633:

    #0633
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0634);

0634:

    #0634
    #instruction: LD   L,C
    advance (5)
    L := C;
    jump (0635);

0635:

    #0635
    #instruction: LD   D,05
    advance (7)
    D := 05;
    jump (0637);

0636:

    #0636
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0637);

0637:

    #0637
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0638);

0638:

    #0638
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0639);

0639:

    #0639
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (063A);

063A:

    #063A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (063B);
    }

063B:

    #063B
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (063C);

063C:

    #063C
    #instruction: ADD  0B
    let:16 a1 = addWithCarry(false,0B,A) in
    let:8 a2 = (0B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (063E);

063D:

    #063D
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (063E);

063E:

    #063E
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (063F);

063F:

    #063F
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0640);

0640:

    #0640
    #instruction: JP   NZ,0637
    if (!FlagZ) {
      advance (10)
      jump (0637);
    } else {
      advance (10)
      jump (0643);
    }

0641:

    #0641
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (0642);

0642:

    #0642
    #instruction: LD   B,C9
    advance (7)
    B := C9;
    jump (0644);

0643:

    #0643
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0644:

    #0644
    #instruction: LD   HL,2078
    advance (10)
    H := 20;
    L := 78;
    jump (0647);

0645:

    #0645
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (0646);

0646:

    #0646
    #instruction: *NOP
    advance (4)
    jump (0647);

0647:

    #0647
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0648);

0648:

    #0648
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0649);

0649:

    #0649
    #instruction: CP   03
    let:16 a1 = addWithCarry(!false,A,~03) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~03 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (064B);

064A:

    #064A
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (064B);

064B:

    #064B
    #instruction: JP   NZ,0667
    if (!FlagZ) {
      advance (10)
      jump (0667);
    } else {
      advance (10)
      jump (064E);
    }

064C:

    #064C
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (064D);

064D:

    #064D
    #instruction: LD   B,CD
    advance (7)
    B := CD;
    jump (064F);

064E:

    #064E
    #instruction: CALL 0675
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := 51;
    #return-to: 0651
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0675);

064F:

    #064F
    #instruction: LD   (HL),L
    M[(H,L)] := L;
    advance (7)
    jump (0650);

0650:

    #0650
    #instruction: LD   B,21
    advance (7)
    B := 21;
    jump (0652);

0651:

    #0651
    #instruction: LD   HL,1CDC
    advance (10)
    H := 1C;
    L := DC;
    jump (0654);

0652:

    #0652
    #instruction: CALL CY,221C
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 06;
      let:16 a2 = (-1 + a1) in
      M[a2] := 55;
      #return-to: 0655
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (221C);
    } else {
      advance (11)
      jump (0655);
    }

0653:

    #0653
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0654);

0654:

    #0654
    #instruction: LD   (2079),HL
    M[2079] := L;
    M[207A] := H;
    advance (16)
    jump (0657);

0655:

    #0655
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0656);

0656:

    #0656
    #instruction: *NOP
    advance (4)
    jump (0657);

0657:

    #0657
    #instruction: LD   HL,207C
    advance (10)
    H := 20;
    L := 7C;
    jump (065A);

0658:

    #0658
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0659);

0659:

    #0659
    #instruction: *NOP
    advance (4)
    jump (065A);

065A:

    #065A
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (065B);

065B:

    #065B
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (065C);

065C:

    #065C
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (065D);

065D:

    #065D
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (065E);

065E:

    #065E
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (065F);

065F:

    #065F
    #instruction: LD   A,06
    advance (7)
    A := 06;
    jump (0661);

0660:

    #0660
    #instruction: LD   B,32
    advance (7)
    B := 32;
    jump (0662);

0661:

    #0661
    #instruction: LD   (207D),A
    M[207D] := A;
    advance (13)
    jump (0664);

0662:

    #0662
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (0663);

0663:

    #0663
    #instruction: *NOP
    advance (4)
    jump (0664);

0664:

    #0664
    #instruction: JP   066C
    advance (10)
    jump (066C);

0665:

    #0665
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (0666);

0666:

    #0666
    #instruction: LD   B,A7
    advance (7)
    B := A7;
    jump (0668);

0667:

    #0667
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0668);

0668:

    #0668
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0669);
    }

0669:

    #0669
    #instruction: JP   0675
    advance (10)
    jump (0675);

066A:

    #066A
    #instruction: LD   (HL),L
    M[(H,L)] := L;
    advance (7)
    jump (066B);

066B:

    #066B
    #instruction: LD   B,21
    advance (7)
    B := 21;
    jump (066D);

066C:

    #066C
    #instruction: LD   HL,2079
    advance (10)
    H := 20;
    L := 79;
    jump (066F);

066D:

    #066D
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (066E);

066E:

    #066E
    #instruction: *NOP
    advance (4)
    jump (066F);

066F:

    #066F
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := 72;
    #return-to: 0672
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

0670:

    #0670
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0671);

0671:

    #0671
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0672);

0672:

    #0672
    #instruction: JP   1491
    advance (10)
    jump (1491);

0673:

    #0673
    #instruction: SUB  C
    let:16 a1 = addWithCarry(!false,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0674);

0674:

    #0674
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0675);

0675:

    #0675
    #instruction: LD   HL,2079
    advance (10)
    H := 20;
    L := 79;
    jump (0678);

0676:

    #0676
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0677);

0677:

    #0677
    #instruction: *NOP
    advance (4)
    jump (0678);

0678:

    #0678
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    #return-to: 067B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

0679:

    #0679
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (067A);

067A:

    #067A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (067B);

067B:

    #067B
    #instruction: JP   1452
    advance (10)
    jump (1452);

067C:

    #067C
    #instruction: LD   D,D
    advance (5)
    jump (067D);

067D:

    #067D
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (067E);

067E:

    #067E
    #instruction: LD   (2048),HL
    M[2048] := L;
    M[2049] := H;
    advance (16)
    jump (0681);

067F:

    #067F
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (0680);

0680:

    #0680
    #instruction: *NOP
    advance (4)
    jump (0681);

0681:

    #0681
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0682:

    #0682
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0683);

0683:

    #0683
    #instruction: LD   A,(2080)
    advance (13)
    A := M[2080];
    jump (0686);

0684:

    #0684
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0685);

0685:

    #0685
    #instruction: *NOP
    advance (4)
    jump (0686);

0686:

    #0686
    #instruction: CP   02
    let:16 a1 = addWithCarry(!false,A,~02) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~02 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0688);

0687:

    #0687
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0688);

0688:

    #0688
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0689);
    }

0689:

    #0689
    #instruction: LD   HL,2083
    advance (10)
    H := 20;
    L := 83;
    jump (068C);

068A:

    #068A
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (068B);

068B:

    #068B
    #instruction: *NOP
    advance (4)
    jump (068C);

068C:

    #068C
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (068D);

068D:

    #068D
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (068E);

068E:

    #068E
    #instruction: JP   Z,050F
    if (FlagZ) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (0691);
    }

068F:

    #068F
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0690);

0690:

    #0690
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0691);

0691:

    #0691
    #instruction: LD   A,(2056)
    advance (13)
    A := M[2056];
    jump (0694);

0692:

    #0692
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (0693);

0693:

    #0693
    #instruction: *NOP
    advance (4)
    jump (0694);

0694:

    #0694
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0695);

0695:

    #0695
    #instruction: JP   NZ,050F
    if (!FlagZ) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (0698);
    }

0696:

    #0696
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0697);

0697:

    #0697
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0698);

0698:

    #0698
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0699);

0699:

    #0699
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (069A);

069A:

    #069A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (069B);

069B:

    #069B
    #instruction: JP   NZ,06AB
    if (!FlagZ) {
      advance (10)
      jump (06AB);
    } else {
      advance (10)
      jump (069E);
    }

069C:

    #069C
    #instruction: XOR  E
    let:8 a1 = (E ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (069D);

069D:

    #069D
    #instruction: LD   B,3A
    advance (7)
    B := 3A;
    jump (069F);

069E:

    #069E
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (06A1);

069F:

    #069F
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06A0);

06A0:

    #06A0
    #instruction: *NOP
    advance (4)
    jump (06A1);

06A1:

    #06A1
    #instruction: CP   08
    let:16 a1 = addWithCarry(!false,A,~08) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~08 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06A3);

06A2:

    #06A2
    #instruction: *NOP
    advance (4)
    jump (06A3);

06A3:

    #06A3
    #instruction: JP   CY,050F
    if (FlagCY) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (06A6);
    }

06A4:

    #06A4
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (06A5);

06A5:

    #06A5
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06A6);

06A6:

    #06A6
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (06A8);

06A7:

    #06A7
    #instruction: LD   BC,3CCD
    advance (10)
    B := 3C;
    C := CD;
    jump (06AA);

06A8:

    #06A8
    #instruction: CALL 073C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := AB;
    #return-to: 06AB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (073C);

06A9:

    #06A9
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06AA);

06AA:

    #06AA
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (06AB);

06AB:

    #06AB
    #instruction: LD   DE,208A
    advance (10)
    D := 20;
    E := 8A;
    jump (06AE);

06AC:

    #06AC
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06AD);

06AD:

    #06AD
    #instruction: *NOP
    advance (4)
    jump (06AE);

06AE:

    #06AE
    #instruction: CALL 1A06
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := B1;
    #return-to: 06B1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A06);

06AF:

    #06AF
    #instruction: LD   B,1A
    advance (7)
    B := 1A;
    jump (06B1);

06B0:

    #06B0
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (06B1);

06B1:

    #06B1
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (06B2);
    }

06B2:

    #06B2
    #instruction: LD   HL,2085
    advance (10)
    H := 20;
    L := 85;
    jump (06B5);

06B3:

    #06B3
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06B4);

06B4:

    #06B4
    #instruction: *NOP
    advance (4)
    jump (06B5);

06B5:

    #06B5
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (06B6);

06B6:

    #06B6
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (06B7);

06B7:

    #06B7
    #instruction: JP   NZ,06D6
    if (!FlagZ) {
      advance (10)
      jump (06D6);
    } else {
      advance (10)
      jump (06BA);
    }

06B8:

    #06B8
    #instruction: SUB  06
    let:16 a1 = addWithCarry(!false,A,~06) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~06 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06BA);

06B9:

    #06B9
    #instruction: LD   B,21
    advance (7)
    B := 21;
    jump (06BB);

06BA:

    #06BA
    #instruction: LD   HL,208A
    advance (10)
    H := 20;
    L := 8A;
    jump (06BD);

06BB:

    #06BB
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06BC);

06BC:

    #06BC
    #instruction: *NOP
    advance (4)
    jump (06BD);

06BD:

    #06BD
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (06BE);

06BE:

    #06BE
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (06BF);

06BF:

    #06BF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (06C0);

06C0:

    #06C0
    #instruction: ADD  (HL)
    let:16 a1 = addWithCarry(false,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06C1);

06C1:

    #06C1
    #instruction: LD   (208A),A
    M[208A] := A;
    advance (13)
    jump (06C4);

06C2:

    #06C2
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06C3);

06C3:

    #06C3
    #instruction: *NOP
    advance (4)
    jump (06C4);

06C4:

    #06C4
    #instruction: CALL 073C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := C7;
    #return-to: 06C7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (073C);

06C5:

    #06C5
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06C6);

06C6:

    #06C6
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (06C7);

06C7:

    #06C7
    #instruction: LD   HL,208A
    advance (10)
    H := 20;
    L := 8A;
    jump (06CA);

06C8:

    #06C8
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (06C9);

06C9:

    #06C9
    #instruction: *NOP
    advance (4)
    jump (06CA);

06CA:

    #06CA
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (06CB);

06CB:

    #06CB
    #instruction: CP   28
    let:16 a1 = addWithCarry(!false,A,~28) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~28 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06CD);

06CC:

    #06CC
    #instruction: *NOP
    advance (4)
    jump (06CD);

06CD:

    #06CD
    #instruction: JP   CY,06F9
    if (FlagCY) {
      advance (10)
      jump (06F9);
    } else {
      advance (10)
      jump (06D0);
    }

06CE:

    #06CE
    #instruction: LD   SP,HL
    advance (5)
    SPH := H;
    SPL := L;
    jump (06CF);

06CF:

    #06CF
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (06D1);

06D0:

    #06D0
    #instruction: CP   E1
    let:16 a1 = addWithCarry(!false,A,~E1) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E1 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06D2);

06D1:

    #06D1
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (06D2);

06D2:

    #06D2
    #instruction: JP   NC,06F9
    if (!FlagCY) {
      advance (10)
      jump (06F9);
    } else {
      advance (10)
      jump (06D5);
    }

06D3:

    #06D3
    #instruction: LD   SP,HL
    advance (5)
    SPH := H;
    SPL := L;
    jump (06D4);

06D4:

    #06D4
    #instruction: LD   B,C9
    advance (7)
    B := C9;
    jump (06D6);

06D5:

    #06D5
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

06D6:

    #06D6
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (06D8);

06D7:

    #06D7
    #instruction: CP   CD
    let:16 a1 = addWithCarry(!false,A,~CD) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~CD & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06D9);

06D8:

    #06D8
    #instruction: CALL 19DC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := DB;
    #return-to: 06DB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19DC);

06D9:

    #06D9
    #instruction: CALL CY,2319
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 06;
      let:16 a2 = (-1 + a1) in
      M[a2] := DC;
      #return-to: 06DC
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (2319);
    } else {
      advance (11)
      jump (06DC);
    }

06DA:

    #06DA
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (06DB);

06DB:

    #06DB
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (06DC);

06DC:

    #06DC
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06DD);

06DD:

    #06DD
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (06DE);

06DE:

    #06DE
    #instruction: CP   1F
    let:16 a1 = addWithCarry(!false,A,~1F) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~1F & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06E0);

06DF:

    #06DF
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (06E0);

06E0:

    #06E0
    #instruction: JP   Z,074B
    if (FlagZ) {
      advance (10)
      jump (074B);
    } else {
      advance (10)
      jump (06E3);
    }

06E1:

    #06E1
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (06E2);

06E2:

    #06E2
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (06E3);

06E3:

    #06E3
    #instruction: CP   18
    let:16 a1 = addWithCarry(!false,A,~18) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~18 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06E5);

06E4:

    #06E4
    #instruction: *NOP
    advance (4)
    jump (06E5);

06E5:

    #06E5
    #instruction: JP   Z,070C
    if (FlagZ) {
      advance (10)
      jump (070C);
    } else {
      advance (10)
      jump (06E8);
    }

06E6:

    #06E6
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06E7);

06E7:

    #06E7
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (06E8);

06E8:

    #06E8
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (06E9);

06E9:

    #06E9
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (06EA);
    }

06EA:

    #06EA
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (06EC);

06EB:

    #06EB
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := EC;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

06EC:

    #06EC
    #instruction: LD   HL,2098
    advance (10)
    H := 20;
    L := 98;
    jump (06EF);

06ED:

    #06ED
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (06EE);

06EE:

    #06EE
    #instruction: *NOP
    advance (4)
    jump (06EF);

06EF:

    #06EF
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (06F0);

06F0:

    #06F0
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (06F1);

06F1:

    #06F1
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (06F2);

06F2:

    #06F2
    #instruction: AND  20
    let:8 a1 = (20 & A) in
    let:8 a2 = (20 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (06F4);

06F3:

    #06F3
    #instruction: *NOP
    advance (4)
    jump (06F4);

06F4:

    #06F4
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (06F6);

06F5:

    #06F5
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06F6);

06F6:

    #06F6
    #instruction: NOP
    advance (4)
    jump (06F7);

06F7:

    #06F7
    #instruction: NOP
    advance (4)
    jump (06F8);

06F8:

    #06F8
    #instruction: NOP
    advance (4)
    jump (06F9);

06F9:

    #06F9
    #instruction: CALL 0742
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := FC;
    #return-to: 06FC
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0742);

06FA:

    #06FA
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (06FB);

06FB:

    #06FB
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (06FC);

06FC:

    #06FC
    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 06FF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14CB);

06FD:

    #06FD
    #instruction: *JP  2114
    advance (10)
    jump (2114);

06FE:

    #06FE
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (06FF);

06FF:

    #06FF
    #instruction: LD   HL,2083
    advance (10)
    H := 20;
    L := 83;
    jump (0702);

0700:

    #0700
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0701);

0701:

    #0701
    #instruction: *NOP
    advance (4)
    jump (0702);

0702:

    #0702
    #instruction: LD   B,0A
    advance (7)
    B := 0A;
    jump (0704);

0703:

    #0703
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0704);

0704:

    #0704
    #instruction: CALL 075F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0707
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (075F);

0705:

    #0705
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (0706);

0706:

    #0706
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0707);

0707:

    #0707
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (0709);

0708:

    #0708
    #instruction: CP   C3
    let:16 a1 = addWithCarry(!false,A,~C3) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C3 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (070A);

0709:

    #0709
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

070A:

    #070A
    #instruction: CALL CY,3E19
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 07;
      let:16 a2 = (-1 + a1) in
      M[a2] := 0D;
      #return-to: 070D
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3E19);
    } else {
      advance (11)
      jump (070D);
    }

070B:

    #070B
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (070C);

070C:

    #070C
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (070E);

070D:

    #070D
    #instruction: LD   BC,F132
    advance (10)
    B := F1;
    C := 32;
    jump (0710);

070E:

    #070E
    #instruction: LD   (20F1),A
    M[20F1] := A;
    advance (13)
    jump (0711);

070F:

    #070F
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0710);

0710:

    #0710
    #instruction: *NOP
    advance (4)
    jump (0711);

0711:

    #0711
    #instruction: LD   HL,(208D)
    advance (16)
    H := M[208E];
    L := M[208D];
    jump (0714);

0712:

    #0712
    #instruction: ADC  L
    let:16 a1 = addWithCarry(FlagCY,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0713);

0713:

    #0713
    #instruction: *NOP
    advance (4)
    jump (0714);

0714:

    #0714
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (0715);

0715:

    #0715
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (0717);

0716:

    #0716
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0717);

0717:

    #0717
    #instruction: LD   HL,1D50
    advance (10)
    H := 1D;
    L := 50;
    jump (071A);

0718:

    #0718
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0719);

0719:

    #0719
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (071A);

071A:

    #071A
    #instruction: LD   DE,1D4C
    advance (10)
    D := 1D;
    E := 4C;
    jump (071D);

071B:

    #071B
    #instruction: LD   C,H
    advance (5)
    C := H;
    jump (071C);

071C:

    #071C
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (071D);

071D:

    #071D
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (071E);

071E:

    #071E
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (071F);

071F:

    #071F
    #instruction: JP   Z,0728
    if (FlagZ) {
      advance (10)
      jump (0728);
    } else {
      advance (10)
      jump (0722);
    }

0720:

    #0720
    #instruction: *NOP
    advance (4)
    jump (0721);

0721:

    #0721
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0722);

0722:

    #0722
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0723);

0723:

    #0723
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0724);

0724:

    #0724
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0725);

0725:

    #0725
    #instruction: JP   NZ,071D
    if (!FlagZ) {
      advance (10)
      jump (071D);
    } else {
      advance (10)
      jump (0728);
    }

0726:

    #0726
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0727);

0727:

    #0727
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0728);

0728:

    #0728
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0729);

0729:

    #0729
    #instruction: LD   (2087),A
    M[2087] := A;
    advance (13)
    jump (072C);

072A:

    #072A
    #instruction: ADD  A
    let:16 a1 = addWithCarry(false,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (072B);

072B:

    #072B
    #instruction: *NOP
    advance (4)
    jump (072C);

072C:

    #072C
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (072E);

072D:

    #072D
    #instruction: NOP
    advance (4)
    jump (072E);

072E:

    #072E
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (072F);

072F:

    #072F
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0730);

0730:

    #0730
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0731);

0731:

    #0731
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0732);

0732:

    #0732
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0733);

0733:

    #0733
    #instruction: LD   (20F2),HL
    M[20F2] := L;
    M[20F3] := H;
    advance (16)
    jump (0736);

0734:

    #0734
    #instruction: JP   P,CD20
    if (!FlagS) {
      advance (10)
      jump (CD20);
    } else {
      advance (10)
      jump (0737);
    }

0735:

    #0735
    #instruction: *NOP
    advance (4)
    jump (0736);

0736:

    #0736
    #instruction: CALL 0742
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0739
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0742);

0737:

    #0737
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (0738);

0738:

    #0738
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0739);

0739:

    #0739
    #instruction: JP   08F1
    advance (10)
    jump (08F1);

073A:

    #073A
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (073B);

073B:

    #073B
    #instruction: *NOP
    advance (4)
    jump (073C);

073C:

    #073C
    #instruction: CALL 0742
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3F;
    #return-to: 073F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0742);

073D:

    #073D
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (073E);

073E:

    #073E
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (073F);

073F:

    #073F
    #instruction: JP   1439
    advance (10)
    jump (1439);

0740:

    #0740
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0741);

0741:

    #0741
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0742);

0742:

    #0742
    #instruction: LD   HL,2087
    advance (10)
    H := 20;
    L := 87;
    jump (0745);

0743:

    #0743
    #instruction: ADD  A
    let:16 a1 = addWithCarry(false,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0744);

0744:

    #0744
    #instruction: *NOP
    advance (4)
    jump (0745);

0745:

    #0745
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 48;
    #return-to: 0748
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

0746:

    #0746
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0747);

0747:

    #0747
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0748);

0748:

    #0748
    #instruction: JP   1A47
    advance (10)
    jump (1A47);

0749:

    #0749
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (074A);

074A:

    #074A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (074B);

074B:

    #074B
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (074D);

074C:

    #074C
    #instruction: *NOP
    advance (4)
    jump (074D);

074D:

    #074D
    #instruction: LD   HL,2098
    advance (10)
    H := 20;
    L := 98;
    jump (0750);

074E:

    #074E
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (074F);

074F:

    #074F
    #instruction: *NOP
    advance (4)
    jump (0750);

0750:

    #0750
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0751);

0751:

    #0751
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0752);

0752:

    #0752
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0753);

0753:

    #0753
    #instruction: CALL 1770
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 56;
    #return-to: 0756
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1770);

0754:

    #0754
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (0755);

0755:

    #0755
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0756);

0756:

    #0756
    #instruction: LD   HL,1D7C
    advance (10)
    H := 1D;
    L := 7C;
    jump (0759);

0757:

    #0757
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0758);

0758:

    #0758
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0759);

0759:

    #0759
    #instruction: LD   (2087),HL
    M[2087] := L;
    M[2088] := H;
    advance (16)
    jump (075C);

075A:

    #075A
    #instruction: ADD  A
    let:16 a1 = addWithCarry(false,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (075B);

075B:

    #075B
    #instruction: *NOP
    advance (4)
    jump (075C);

075C:

    #075C
    #instruction: JP   073C
    advance (10)
    jump (073C);

075D:

    #075D
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (075E);

075E:

    #075E
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (075F);

075F:

    #075F
    #instruction: LD   DE,1B83
    advance (10)
    D := 1B;
    E := 83;
    jump (0762);

0760:

    #0760
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0761);

0761:

    #0761
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0762);

0762:

    #0762
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0763:

    #0763
    #instruction: LD   (3E1A),A
    M[3E1A] := A;
    advance (13)
    jump (0766);

0764:

    #0764
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0765);

0765:

    #0765
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0767);

0766:

    #0766
    #instruction: LD   BC,9332
    advance (10)
    B := 93;
    C := 32;
    jump (0769);

0767:

    #0767
    #instruction: LD   (2093),A
    M[2093] := A;
    advance (13)
    jump (076A);

0768:

    #0768
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0769);

0769:

    #0769
    #instruction: *NOP
    advance (4)
    jump (076A);

076A:

    #076A
    #instruction: LD   SP,2400
    advance (10)
    SPH := 24;
    SPL := 00;
    jump (076D);

076B:

    #076B
    #instruction: NOP
    advance (4)
    jump (076C);

076C:

    #076C
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (076D);

076D:

    #076D
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (076E);

076E:

    #076E
    #instruction: CALL 1979
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 0771
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1979);

076F:

    #076F
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (0770);

0770:

    #0770
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0771);

0771:

    #0771
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 0774
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

0772:

    #0772
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0774);

0773:

    #0773
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0774);

0774:

    #0774
    #instruction: LD   HL,3013
    advance (10)
    H := 30;
    L := 13;
    jump (0777);

0775:

    #0775
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0776);

0776:

    #0776
    #instruction: *NOP
    advance (4)
    jump (0777);

0777:

    #0777
    #instruction: LD   DE,1FF3
    advance (10)
    D := 1F;
    E := F3;
    jump (077A);

0778:

    #0778
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0779);

0779:

    #0779
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (077A);

077A:

    #077A
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (077C);

077B:

    #077B
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (077C);

077C:

    #077C
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7F;
    #return-to: 077F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

077D:

    #077D
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (077E);

077E:

    #077E
    #instruction: *NOP
    advance (4)
    jump (077F);

077F:

    #077F
    #instruction: LD   A,(20EB)
    advance (13)
    A := M[20EB];
    jump (0782);

0780:

    #0780
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0781);

0781:

    #0781
    #instruction: *NOP
    advance (4)
    jump (0782);

0782:

    #0782
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0783);

0783:

    #0783
    #instruction: LD   HL,2810
    advance (10)
    H := 28;
    L := 10;
    jump (0786);

0784:

    #0784
    #instruction: *NOP
    advance (4)
    jump (0785);

0785:

    #0785
    #instruction: *NOP
    advance (4)
    jump (0786);

0786:

    #0786
    #instruction: LD   C,14
    advance (7)
    C := 14;
    jump (0788);

0787:

    #0787
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0788);

0788:

    #0788
    #instruction: JP   NZ,0857
    if (!FlagZ) {
      advance (10)
      jump (0857);
    } else {
      advance (10)
      jump (078B);
    }

0789:

    #0789
    #instruction: LD   D,A
    advance (5)
    D := A;
    jump (078A);

078A:

    #078A
    #instruction: *NOP
    advance (4)
    jump (078B);

078B:

    #078B
    #instruction: LD   DE,1ACF
    advance (10)
    D := 1A;
    E := CF;
    jump (078E);

078C:

    #078C
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 8D;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

078D:

    #078D
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (078E);

078E:

    #078E
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 91;
    #return-to: 0791
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

078F:

    #078F
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0790);

0790:

    #0790
    #instruction: *NOP
    advance (4)
    jump (0791);

0791:

    #0791
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (0793);

0792:

    #0792
    #instruction: LD   BC,04E6
    advance (10)
    B := 04;
    C := E6;
    jump (0795);

0793:

    #0793
    #instruction: AND  04
    let:8 a1 = (04 & A) in
    let:8 a2 = (04 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0795);

0794:

    #0794
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0795);

0795:

    #0795
    #instruction: JP   Z,077F
    if (FlagZ) {
      advance (10)
      jump (077F);
    } else {
      advance (10)
      jump (0798);
    }

0796:

    #0796
    #instruction: LD   A,A
    advance (5)
    jump (0797);

0797:

    #0797
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0798);

0798:

    #0798
    #instruction: LD   B,99
    advance (7)
    B := 99;
    jump (079A);

0799:

    #0799
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (079A);

079A:

    #079A
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (079B);

079B:

    #079B
    #instruction: LD   (20CE),A
    M[20CE] := A;
    advance (13)
    jump (079E);

079C:

    #079C
    #instruction: ADC  20
    let:16 a1 = addWithCarry(FlagCY,20,A) in
    let:8 a2 = (20 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (079E);

079D:

    #079D
    #instruction: *NOP
    advance (4)
    jump (079E);

079E:

    #079E
    #instruction: LD   A,(20EB)
    advance (13)
    A := M[20EB];
    jump (07A1);

079F:

    #079F
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (07A0);

07A0:

    #07A0
    #instruction: *NOP
    advance (4)
    jump (07A1);

07A1:

    #07A1
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (07A2);

07A2:

    #07A2
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (07A3);

07A3:

    #07A3
    #instruction: LD   (20EB),A
    M[20EB] := A;
    advance (13)
    jump (07A6);

07A4:

    #07A4
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (07A5);

07A5:

    #07A5
    #instruction: *NOP
    advance (4)
    jump (07A6);

07A6:

    #07A6
    #instruction: CALL 1947
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := A9;
    #return-to: 07A9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1947);

07A7:

    #07A7
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (07A8);

07A8:

    #07A8
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07A9);

07A9:

    #07A9
    #instruction: LD   HL,0000
    advance (10)
    H := 00;
    L := 00;
    jump (07AC);

07AA:

    #07AA
    #instruction: NOP
    advance (4)
    jump (07AB);

07AB:

    #07AB
    #instruction: NOP
    advance (4)
    jump (07AC);

07AC:

    #07AC
    #instruction: LD   (20F8),HL
    M[20F8] := L;
    M[20F9] := H;
    advance (16)
    jump (07AF);

07AD:

    #07AD
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (07AE);
    }

07AE:

    #07AE
    #instruction: *NOP
    advance (4)
    jump (07AF);

07AF:

    #07AF
    #instruction: LD   (20FC),HL
    M[20FC] := L;
    M[20FD] := H;
    advance (16)
    jump (07B2);

07B0:

    #07B0
    #instruction: CALL MI,CD20
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 07;
      let:16 a2 = (-1 + a1) in
      M[a2] := B3;
      #return-to: 07B3
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (CD20);
    } else {
      advance (11)
      jump (07B3);
    }

07B1:

    #07B1
    #instruction: *NOP
    advance (4)
    jump (07B2);

07B2:

    #07B2
    #instruction: CALL 1925
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := B5;
    #return-to: 07B5
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1925);

07B3:

    #07B3
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (07B4);

07B4:

    #07B4
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07B5);

07B5:

    #07B5
    #instruction: CALL 192B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := B8;
    #return-to: 07B8
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (192B);

07B6:

    #07B6
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (07B7);

07B7:

    #07B7
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07B8);

07B8:

    #07B8
    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := BB;
    #return-to: 07BB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D7);

07B9:

    #07B9
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := BA;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

07BA:

    #07BA
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07BB);

07BB:

    #07BB
    #instruction: LD   HL,0101
    advance (10)
    H := 01;
    L := 01;
    jump (07BE);

07BC:

    #07BC
    #instruction: LD   BC,7C01
    advance (10)
    B := 7C;
    C := 01;
    jump (07BF);

07BD:

    #07BD
    #instruction: LD   BC,327C
    advance (10)
    B := 32;
    C := 7C;
    jump (07C0);

07BE:

    #07BE
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (07BF);

07BF:

    #07BF
    #instruction: LD   (20EF),A
    M[20EF] := A;
    advance (13)
    jump (07C2);

07C0:

    #07C0
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

07C1:

    #07C1
    #instruction: *NOP
    advance (4)
    jump (07C2);

07C2:

    #07C2
    #instruction: LD   (20E7),HL
    M[20E7] := L;
    M[20E8] := H;
    advance (16)
    jump (07C5);

07C3:

    #07C3
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := C4;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

07C4:

    #07C4
    #instruction: *NOP
    advance (4)
    jump (07C5);

07C5:

    #07C5
    #instruction: LD   (20E5),HL
    M[20E5] := L;
    M[20E6] := H;
    advance (16)
    jump (07C8);

07C6:

    #07C6
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (07C7);

07C7:

    #07C7
    #instruction: *NOP
    advance (4)
    jump (07C8);

07C8:

    #07C8
    #instruction: CALL 1956
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := CB;
    #return-to: 07CB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1956);

07C9:

    #07C9
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (07CA);

07CA:

    #07CA
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07CB);

07CB:

    #07CB
    #instruction: CALL 01EF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := CE;
    #return-to: 07CE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01EF);

07CC:

    #07CC
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := CD;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

07CD:

    #07CD
    #instruction: LD   BC,F5CD
    advance (10)
    B := F5;
    C := CD;
    jump (07D0);

07CE:

    #07CE
    #instruction: CALL 01F5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D1;
    #return-to: 07D1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01F5);

07CF:

    #07CF
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (07D0);

07D0:

    #07D0
    #instruction: LD   BC,D1CD
    advance (10)
    B := D1;
    C := CD;
    jump (07D3);

07D1:

    #07D1
    #instruction: CALL 08D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D4;
    #return-to: 07D4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08D1);

07D2:

    #07D2
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (07D3);

07D3:

    #07D3
    #instruction: *NOP
    advance (4)
    jump (07D4);

07D4:

    #07D4
    #instruction: LD   (21FF),A
    M[21FF] := A;
    advance (13)
    jump (07D7);

07D5:

    #07D5
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D6;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

07D6:

    #07D6
    #instruction: LD   HL,FF32
    advance (10)
    H := FF;
    L := 32;
    jump (07D9);

07D7:

    #07D7
    #instruction: LD   (22FF),A
    M[22FF] := A;
    advance (13)
    jump (07DA);

07D8:

    #07D8
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D9;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

07D9:

    #07D9
    #instruction: LD   (D7CD),HL
    M[D7CD] := L;
    M[D7CE] := H;
    advance (16)
    jump (07DC);

07DA:

    #07DA
    #instruction: CALL 00D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := DD;
    #return-to: 07DD
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (00D7);

07DB:

    #07DB
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := DC;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

07DC:

    #07DC
    #instruction: NOP
    advance (4)
    jump (07DD);

07DD:

    #07DD
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (07DE);

07DE:

    #07DE
    #instruction: LD   (21FE),A
    M[21FE] := A;
    advance (13)
    jump (07E1);

07DF:

    #07DF
    #instruction: CP   21
    let:16 a1 = addWithCarry(!false,A,~21) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~21 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (07E1);

07E0:

    #07E0
    #instruction: LD   HL,FE32
    advance (10)
    H := FE;
    L := 32;
    jump (07E3);

07E1:

    #07E1
    #instruction: LD   (22FE),A
    M[22FE] := A;
    advance (13)
    jump (07E4);

07E2:

    #07E2
    #instruction: CP   22
    let:16 a1 = addWithCarry(!false,A,~22) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~22 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (07E4);

07E3:

    #07E3
    #instruction: LD   (C0CD),HL
    M[C0CD] := L;
    M[C0CE] := H;
    advance (16)
    jump (07E6);

07E4:

    #07E4
    #instruction: CALL 01C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := E7;
    #return-to: 07E7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01C0);

07E5:

    #07E5
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (07E6);
    }

07E6:

    #07E6
    #instruction: LD   BC,04CD
    advance (10)
    B := 04;
    C := CD;
    jump (07E9);

07E7:

    #07E7
    #instruction: CALL 1904
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := EA;
    #return-to: 07EA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1904);

07E8:

    #07E8
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (07E9);

07E9:

    #07E9
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07EA);

07EA:

    #07EA
    #instruction: LD   HL,3878
    advance (10)
    H := 38;
    L := 78;
    jump (07ED);

07EB:

    #07EB
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (07EC);

07EC:

    #07EC
    #instruction: *NOP
    advance (4)
    jump (07ED);

07ED:

    #07ED
    #instruction: LD   (21FC),HL
    M[21FC] := L;
    M[21FD] := H;
    advance (16)
    jump (07F0);

07EE:

    #07EE
    #instruction: CALL MI,2221
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 07;
      let:16 a2 = (-1 + a1) in
      M[a2] := F1;
      #return-to: 07F1
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (2221);
    } else {
      advance (11)
      jump (07F1);
    }

07EF:

    #07EF
    #instruction: LD   HL,FC22
    advance (10)
    H := FC;
    L := 22;
    jump (07F2);

07F0:

    #07F0
    #instruction: LD   (22FC),HL
    M[22FC] := L;
    M[22FD] := H;
    advance (16)
    jump (07F3);

07F1:

    #07F1
    #instruction: CALL MI,CD22
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 07;
      let:16 a2 = (-1 + a1) in
      M[a2] := F4;
      #return-to: 07F4
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (CD22);
    } else {
      advance (11)
      jump (07F4);
    }

07F2:

    #07F2
    #instruction: LD   (E4CD),HL
    M[E4CD] := L;
    M[E4CE] := H;
    advance (16)
    jump (07F5);

07F3:

    #07F3
    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 07F6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01E4);

07F4:

    #07F4
    #instruction: CALL PO,CD01
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 07;
      let:16 a2 = (-1 + a1) in
      M[a2] := F7;
      #return-to: 07F7
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (CD01);
    } else {
      advance (11)
      jump (07F7);
    }

07F5:

    #07F5
    #instruction: LD   BC,7FCD
    advance (10)
    B := 7F;
    C := CD;
    jump (07F8);

07F6:

    #07F6
    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := F9;
    #return-to: 07F9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A7F);

07F7:

    #07F7
    #instruction: LD   A,A
    advance (5)
    jump (07F8);

07F8:

    #07F8
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (07F9);

07F9:

    #07F9
    #instruction: CALL 088D
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := FC;
    #return-to: 07FC
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (088D);

07FA:

    #07FA
    #instruction: ADC  L
    let:16 a1 = addWithCarry(FlagCY,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (07FB);

07FB:

    #07FB
    #instruction: *NOP
    advance (4)
    jump (07FC);

07FC:

    #07FC
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 07FF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

07FD:

    #07FD
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (07FF);

07FE:

    #07FE
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (07FF);

07FF:

    #07FF
    #instruction: NOP
    advance (4)
    jump (0800);

0800:

    #0800
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0801);

0801:

    #0801
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (0804);

0802:

    #0802
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0803);

0803:

    #0803
    #instruction: *NOP
    advance (4)
    jump (0804);

0804:

    #0804
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0807
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01CF);

0805:

    #0805
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0806:

    #0806
    #instruction: LD   BC,673A
    advance (10)
    B := 67;
    C := 3A;
    jump (0809);

0807:

    #0807
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (080A);

0808:

    #0808
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0809);

0809:

    #0809
    #instruction: *NOP
    advance (4)
    jump (080A);

080A:

    #080A
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (080B);

080B:

    #080B
    #instruction: JP   CY,0872
    if (FlagCY) {
      advance (10)
      jump (0872);
    } else {
      advance (10)
      jump (080E);
    }

080C:

    #080C
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (080D);

080D:

    #080D
    #instruction: *NOP
    advance (4)
    jump (080E);

080E:

    #080E
    #instruction: CALL 0213
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 11;
    #return-to: 0811
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0213);

080F:

    #080F
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0810);

0810:

    #0810
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0811);

0811:

    #0811
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    #return-to: 0814
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01CF);

0812:

    #0812
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 13;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0813:

    #0813
    #instruction: LD   BC,B1CD
    advance (10)
    B := B1;
    C := CD;
    jump (0816);

0814:

    #0814
    #instruction: CALL 00B1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    #return-to: 0817
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (00B1);

0815:

    #0815
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0816);

0816:

    #0816
    #instruction: NOP
    advance (4)
    jump (0817);

0817:

    #0817
    #instruction: CALL 19D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    #return-to: 081A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D1);

0818:

    #0818
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0819);

0819:

    #0819
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (081A);

081A:

    #081A
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (081C);

081B:

    #081B
    #instruction: *NOP
    advance (4)
    jump (081C);

081C:

    #081C
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1F;
    #return-to: 081F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18FA);

081D:

    #081D
    #instruction: JP   MI,CD18
    if (FlagS) {
      advance (10)
      jump (CD18);
    } else {
      advance (10)
      jump (0820);
    }

081E:

    #081E
    #instruction: *NOP
    advance (4)
    jump (081F);

081F:

    #081F
    #instruction: CALL 1618
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 22;
    #return-to: 0822
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1618);

0820:

    #0820
    #instruction: *NOP
    advance (4)
    jump (0821);

0821:

    #0821
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (0823);

0822:

    #0822
    #instruction: CALL 190A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 25;
    #return-to: 0825
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (190A);

0823:

    #0823
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0824);

0824:

    #0824
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0825);

0825:

    #0825
    #instruction: CALL 15F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 28;
    #return-to: 0828
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15F3);

0826:

    #0826
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0827);

0827:

    #0827
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0828);

0828:

    #0828
    #instruction: CALL 0988
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2B;
    #return-to: 082B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0988);

0829:

    #0829
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (082A);

082A:

    #082A
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (082B);

082B:

    #082B
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (082E);

082C:

    #082C
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (082D);

082D:

    #082D
    #instruction: *NOP
    advance (4)
    jump (082E);

082E:

    #082E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (082F);

082F:

    #082F
    #instruction: JP   Z,09EF
    if (FlagZ) {
      advance (10)
      jump (09EF);
    } else {
      advance (10)
      jump (0832);
    }

0830:

    #0830
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 31;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0831:

    #0831
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0832);

0832:

    #0832
    #instruction: CALL 170E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 35;
    #return-to: 0835
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (170E);

0833:

    #0833
    #instruction: LD   C,17
    advance (7)
    C := 17;
    jump (0835);

0834:

    #0834
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0835);

0835:

    #0835
    #instruction: CALL 0935
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 38;
    #return-to: 0838
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0935);

0836:

    #0836
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0837);

0837:

    #0837
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0838);

0838:

    #0838
    #instruction: CALL 08D8
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3B;
    #return-to: 083B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08D8);

0839:

    #0839
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (083A);
    }

083A:

    #083A
    #instruction: *NOP
    advance (4)
    jump (083B);

083B:

    #083B
    #instruction: CALL 172C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3E;
    #return-to: 083E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (172C);

083C:

    #083C
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (083D);

083D:

    #083D
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (083E);

083E:

    #083E
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 41;
    #return-to: 0841
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

083F:

    #083F
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0840);

0840:

    #0840
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0841);

0841:

    #0841
    #instruction: JP   Z,0849
    if (FlagZ) {
      advance (10)
      jump (0849);
    } else {
      advance (10)
      jump (0844);
    }

0842:

    #0842
    #instruction: LD   C,C
    advance (5)
    jump (0843);

0843:

    #0843
    #instruction: *NOP
    advance (4)
    jump (0844);

0844:

    #0844
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (0846);

0845:

    #0845
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0846);

0846:

    #0846
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 49;
    #return-to: 0849
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18FA);

0847:

    #0847
    #instruction: JP   MI,CD18
    if (FlagS) {
      advance (10)
      jump (CD18);
    } else {
      advance (10)
      jump (084A);
    }

0848:

    #0848
    #instruction: *NOP
    advance (4)
    jump (0849);

0849:

    #0849
    #instruction: CALL 1775
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4C;
    #return-to: 084C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1775);

084A:

    #084A
    #instruction: LD   (HL),L
    M[(H,L)] := L;
    advance (7)
    jump (084B);

084B:

    #084B
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (084C);

084C:

    #084C
    #instruction: OUT  06
    advance (10)
    jump (084E);

084D:

    #084D
    #instruction: LD   B,CD
    advance (7)
    B := CD;
    jump (084F);

084E:

    #084E
    #instruction: CALL 1804
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 51;
    #return-to: 0851
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1804);

084F:

    #084F
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0850);

0850:

    #0850
    #instruction: *NOP
    advance (4)
    jump (0851);

0851:

    #0851
    #instruction: JP   081F
    advance (10)
    jump (081F);

0852:

    #0852
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0853);

0853:

    #0853
    #instruction: *NOP
    advance (4)
    jump (0854);

0854:

    #0854
    #instruction: NOP
    advance (4)
    jump (0855);

0855:

    #0855
    #instruction: NOP
    advance (4)
    jump (0856);

0856:

    #0856
    #instruction: NOP
    advance (4)
    jump (0857);

0857:

    #0857
    #instruction: LD   DE,1ABA
    advance (10)
    D := 1A;
    E := BA;
    jump (085A);

0858:

    #0858
    #instruction: CP   D
    let:16 a1 = addWithCarry(!false,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0859);

0859:

    #0859
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (085A);

085A:

    #085A
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5D;
    #return-to: 085D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

085B:

    #085B
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (085C);

085C:

    #085C
    #instruction: *NOP
    advance (4)
    jump (085D);

085D:

    #085D
    #instruction: LD   B,98
    advance (7)
    B := 98;
    jump (085F);

085E:

    #085E
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (085F);

085F:

    #085F
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (0861);

0860:

    #0860
    #instruction: LD   BC,0F0F
    advance (10)
    B := 0F;
    C := 0F;
    jump (0863);

0861:

    #0861
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0862);

0862:

    #0862
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0863);

0863:

    #0863
    #instruction: JP   CY,086D
    if (FlagCY) {
      advance (10)
      jump (086D);
    } else {
      advance (10)
      jump (0866);
    }

0864:

    #0864
    #instruction: LD   L,L
    advance (5)
    jump (0865);

0865:

    #0865
    #instruction: *NOP
    advance (4)
    jump (0866);

0866:

    #0866
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0867);

0867:

    #0867
    #instruction: JP   CY,0798
    if (FlagCY) {
      advance (10)
      jump (0798);
    } else {
      advance (10)
      jump (086A);
    }

0868:

    #0868
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0869);

0869:

    #0869
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (086A);

086A:

    #086A
    #instruction: JP   077F
    advance (10)
    jump (077F);

086B:

    #086B
    #instruction: LD   A,A
    advance (5)
    jump (086C);

086C:

    #086C
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (086D);

086D:

    #086D
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (086F);

086E:

    #086E
    #instruction: LD   BC,9BC3
    advance (10)
    B := 9B;
    C := C3;
    jump (0871);

086F:

    #086F
    #instruction: JP   079B
    advance (10)
    jump (079B);

0870:

    #0870
    #instruction: SBC  E
    let:16 a1 = addWithCarry(!FlagCY,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0871);

0871:

    #0871
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0872);

0872:

    #0872
    #instruction: CALL 021A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 75;
    #return-to: 0875
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (021A);

0873:

    #0873
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0874);

0874:

    #0874
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0875);

0875:

    #0875
    #instruction: JP   0814
    advance (10)
    jump (0814);

0876:

    #0876
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0877);

0877:

    #0877
    #instruction: *NOP
    advance (4)
    jump (0878);

0878:

    #0878
    #instruction: LD   A,(2008)
    advance (13)
    A := M[2008];
    jump (087B);

0879:

    #0879
    #instruction: *NOP
    advance (4)
    jump (087A);

087A:

    #087A
    #instruction: *NOP
    advance (4)
    jump (087B);

087B:

    #087B
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (087C);

087C:

    #087C
    #instruction: LD   HL,(2009)
    advance (16)
    H := M[200A];
    L := M[2009];
    jump (087F);

087D:

    #087D
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (087E);

087E:

    #087E
    #instruction: *NOP
    advance (4)
    jump (087F);

087F:

    #087F
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0880);

0880:

    #0880
    #instruction: JP   0886
    advance (10)
    jump (0886);

0881:

    #0881
    #instruction: ADD  (HL)
    let:16 a1 = addWithCarry(false,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0882);

0882:

    #0882
    #instruction: *NOP
    advance (4)
    jump (0883);

0883:

    #0883
    #instruction: NOP
    advance (4)
    jump (0884);

0884:

    #0884
    #instruction: NOP
    advance (4)
    jump (0885);

0885:

    #0885
    #instruction: NOP
    advance (4)
    jump (0886);

0886:

    #0886
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (0889);

0887:

    #0887
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0888);

0888:

    #0888
    #instruction: *NOP
    advance (4)
    jump (0889);

0889:

    #0889
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (088A);

088A:

    #088A
    #instruction: LD   L,FC
    advance (7)
    L := FC;
    jump (088C);

088B:

    #088B
    #instruction: CALL MI,21C9
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 08;
      let:16 a2 = (-1 + a1) in
      M[a2] := 8E;
      #return-to: 088E
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (21C9);
    } else {
      advance (11)
      jump (088E);
    }

088C:

    #088C
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

088D:

    #088D
    #instruction: LD   HL,2B11
    advance (10)
    H := 2B;
    L := 11;
    jump (0890);

088E:

    #088E
    #instruction: LD   DE,112B
    advance (10)
    D := 11;
    E := 2B;
    jump (0891);

088F:

    #088F
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0890);

0890:

    #0890
    #instruction: LD   DE,1B70
    advance (10)
    D := 1B;
    E := 70;
    jump (0893);

0891:

    #0891
    #instruction: LD   (HL),B
    M[(H,L)] := B;
    advance (7)
    jump (0892);

0892:

    #0892
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0893);

0893:

    #0893
    #instruction: LD   C,0E
    advance (7)
    C := 0E;
    jump (0895);

0894:

    #0894
    #instruction: LD   C,CD
    advance (7)
    C := CD;
    jump (0896);

0895:

    #0895
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 98;
    #return-to: 0898
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

0896:

    #0896
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0897);

0897:

    #0897
    #instruction: *NOP
    advance (4)
    jump (0898);

0898:

    #0898
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (089B);

0899:

    #0899
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (089A);

089A:

    #089A
    #instruction: *NOP
    advance (4)
    jump (089B);

089B:

    #089B
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (089C);

089C:

    #089C
    #instruction: LD   A,1C
    advance (7)
    A := 1C;
    jump (089E);

089D:

    #089D
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (089E);

089E:

    #089E
    #instruction: LD   HL,3711
    advance (10)
    H := 37;
    L := 11;
    jump (08A1);

089F:

    #089F
    #instruction: LD   DE,D437
    advance (10)
    D := D4;
    E := 37;
    jump (08A2);

08A0:

    #08A0
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (08A1);

08A1:

    #08A1
    #instruction: CALL NC,08FF
    if (!FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 08;
      let:16 a2 = (-1 + a1) in
      M[a2] := A4;
      #return-to: 08A4
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (08FF);
    } else {
      advance (11)
      jump (08A4);
    }

08A2:

    #08A2
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := A3;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

08A3:

    #08A3
    #instruction: *NOP
    advance (4)
    jump (08A4);

08A4:

    #08A4
    #instruction: LD   A,B0
    advance (7)
    A := B0;
    jump (08A6);

08A5:

    #08A5
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (08A6);

08A6:

    #08A6
    #instruction: LD   (20C0),A
    M[20C0] := A;
    advance (13)
    jump (08A9);

08A7:

    #08A7
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (08A8);
    }

08A8:

    #08A8
    #instruction: *NOP
    advance (4)
    jump (08A9);

08A9:

    #08A9
    #instruction: LD   A,(20C0)
    advance (13)
    A := M[20C0];
    jump (08AC);

08AA:

    #08AA
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (08AB);
    }

08AB:

    #08AB
    #instruction: *NOP
    advance (4)
    jump (08AC);

08AC:

    #08AC
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (08AD);

08AD:

    #08AD
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (08AE);
    }

08AE:

    #08AE
    #instruction: AND  04
    let:8 a1 = (04 & A) in
    let:8 a2 = (04 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (08B0);

08AF:

    #08AF
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08B0);

08B0:

    #08B0
    #instruction: JP   NZ,08BC
    if (!FlagZ) {
      advance (10)
      jump (08BC);
    } else {
      advance (10)
      jump (08B3);
    }

08B1:

    #08B1
    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (08B2);

08B2:

    #08B2
    #instruction: *NOP
    advance (4)
    jump (08B3);

08B3:

    #08B3
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := B6;
    #return-to: 08B6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09CA);

08B4:

    #08B4
    #instruction: JP   Z,CD09
    if (FlagZ) {
      advance (10)
      jump (CD09);
    } else {
      advance (10)
      jump (08B7);
    }

08B5:

    #08B5
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (08B6);

08B6:

    #08B6
    #instruction: CALL 1931
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := B9;
    #return-to: 08B9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1931);

08B7:

    #08B7
    #instruction: LD   SP,C319
    advance (10)
    SPH := C3;
    SPL := 19;
    jump (08BA);

08B8:

    #08B8
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (08B9);

08B9:

    #08B9
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08BA:

    #08BA
    #instruction: XOR  C
    let:8 a1 = (C ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (08BB);

08BB:

    #08BB
    #instruction: *NOP
    advance (4)
    jump (08BC);

08BC:

    #08BC
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (08BE);

08BD:

    #08BD
    #instruction: *NOP
    advance (4)
    jump (08BE);

08BE:

    #08BE
    #instruction: LD   HL,271C
    advance (10)
    H := 27;
    L := 1C;
    jump (08C1);

08BF:

    #08BF
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08C0);

08C0:

    #08C0
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (08C1);

08C1:

    #08C1
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (08C4);

08C2:

    #08C2
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (08C3);

08C3:

    #08C3
    #instruction: *NOP
    advance (4)
    jump (08C4);

08C4:

    #08C4
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (08C5);

08C5:

    #08C5
    #instruction: JP   CY,08CB
    if (FlagCY) {
      advance (10)
      jump (08CB);
    } else {
      advance (10)
      jump (08C8);
    }

08C6:

    #08C6
    #instruction: *JP  2108
    advance (10)
    jump (2108);

08C7:

    #08C7
    #instruction: *NOP
    advance (4)
    jump (08C8);

08C8:

    #08C8
    #instruction: LD   HL,391C
    advance (10)
    H := 39;
    L := 1C;
    jump (08CB);

08C9:

    #08C9
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08CA);

08CA:

    #08CA
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (08CB);

08CB:

    #08CB
    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := CE;
    #return-to: 08CE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14CB);

08CC:

    #08CC
    #instruction: *JP  C314
    advance (10)
    jump (C314);

08CD:

    #08CD
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08CE);

08CE:

    #08CE
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08CF:

    #08CF
    #instruction: XOR  C
    let:8 a1 = (C ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (08D0);

08D0:

    #08D0
    #instruction: *NOP
    advance (4)
    jump (08D1);

08D1:

    #08D1
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
    jump (08D3);

08D2:

    #08D2
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (08D3);

08D3:

    #08D3
    #instruction: AND  03
    let:8 a1 = (03 & A) in
    let:8 a2 = (03 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (08D5);

08D4:

    #08D4
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (08D5);

08D5:

    #08D5
    #instruction: ADD  03
    let:16 a1 = addWithCarry(false,03,A) in
    let:8 a2 = (03 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (08D7);

08D6:

    #08D6
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (08D7);

08D7:

    #08D7
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

08D8:

    #08D8
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (08DB);

08D9:

    #08D9
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (08DA);

08DA:

    #08DA
    #instruction: *NOP
    advance (4)
    jump (08DB);

08DB:

    #08DB
    #instruction: CP   09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (08DD);

08DC:

    #08DC
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (08DD);

08DD:

    #08DD
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (08DE);
    }

08DE:

    #08DE
    #instruction: LD   A,FB
    advance (7)
    A := FB;
    jump (08E0);

08DF:

    #08DF
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (08E0);

08E0:

    #08E0
    #instruction: LD   (207E),A
    M[207E] := A;
    advance (13)
    jump (08E3);

08E1:

    #08E1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (08E2);

08E2:

    #08E2
    #instruction: *NOP
    advance (4)
    jump (08E3);

08E3:

    #08E3
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

08E4:

    #08E4
    #instruction: LD   A,(20CE)
    advance (13)
    A := M[20CE];
    jump (08E7);

08E5:

    #08E5
    #instruction: ADC  20
    let:16 a1 = addWithCarry(FlagCY,20,A) in
    let:8 a2 = (20 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (08E7);

08E6:

    #08E6
    #instruction: *NOP
    advance (4)
    jump (08E7);

08E7:

    #08E7
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (08E8);

08E8:

    #08E8
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (08E9);
    }

08E9:

    #08E9
    #instruction: LD   HL,391C
    advance (10)
    H := 39;
    L := 1C;
    jump (08EC);

08EA:

    #08EA
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08EB);

08EB:

    #08EB
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (08EC);

08EC:

    #08EC
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (08EE);

08ED:

    #08ED
    #instruction: *NOP
    advance (4)
    jump (08EE);

08EE:

    #08EE
    #instruction: JP   14CB
    advance (10)
    jump (14CB);

08EF:

    #08EF
    #instruction: *JP  0E14
    advance (10)
    jump (0E14);

08F0:

    #08F0
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08F1);

08F1:

    #08F1
    #instruction: LD   C,03
    advance (7)
    C := 03;
    jump (08F3);

08F2:

    #08F2
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (08F3);

08F3:

    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (08F4);

08F4:

    #08F4
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F5);

08F5:

    #08F5
    #instruction: CALL 08FF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := F8;
    #return-to: 08F8
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08FF);

08F6:

    #08F6
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := F7;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

08F7:

    #08F7
    #instruction: *NOP
    advance (4)
    jump (08F8);

08F8:

    #08F8
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F9);

08F9:

    #08F9
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (08FA);

08FA:

    #08FA
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (08FB);

08FB:

    #08FB
    #instruction: JP   NZ,08F3
    if (!FlagZ) {
      advance (10)
      jump (08F3);
    } else {
      advance (10)
      jump (08FE);
    }

08FC:

    #08FC
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (08FD);

08FD:

    #08FD
    #instruction: *NOP
    advance (4)
    jump (08FE);

08FE:

    #08FE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

08FF:

    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    D := 1E;
    E := 00;
    jump (0902);

0900:

    #0900
    #instruction: NOP
    advance (4)
    jump (0901);

0901:

    #0901
    #instruction: LD   E,E5
    advance (7)
    E := E5;
    jump (0903);

0902:

    #0902
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0903);

0903:

    #0903
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (0905);

0904:

    #0904
    #instruction: NOP
    advance (4)
    jump (0905);

0905:

    #0905
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (0906);

0906:

    #0906
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0907);

0907:

    #0907
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0908);

0908:

    #0908
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0909);

0909:

    #0909
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (090A);

090A:

    #090A
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (090B);

090B:

    #090B
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (090C);

090C:

    #090C
    #instruction: LD   B,08
    advance (7)
    B := 08;
    jump (090E);

090D:

    #090D
    #instruction: *NOP
    advance (4)
    jump (090E);

090E:

    #090E
    #instruction: OUT  06
    advance (10)
    jump (0910);

090F:

    #090F
    #instruction: LD   B,C3
    advance (7)
    B := C3;
    jump (0911);

0910:

    #0910
    #instruction: JP   1439
    advance (10)
    jump (1439);

0911:

    #0911
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0912);

0912:

    #0912
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0913);

0913:

    #0913
    #instruction: LD   A,(2009)
    advance (13)
    A := M[2009];
    jump (0916);

0914:

    #0914
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0915);

0915:

    #0915
    #instruction: *NOP
    advance (4)
    jump (0916);

0916:

    #0916
    #instruction: CP   78
    let:16 a1 = addWithCarry(!false,A,~78) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~78 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0918);

0917:

    #0917
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (0918);

0918:

    #0918
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0919);
    }

0919:

    #0919
    #instruction: LD   HL,(2091)
    advance (16)
    H := M[2092];
    L := M[2091];
    jump (091C);

091A:

    #091A
    #instruction: SUB  C
    let:16 a1 = addWithCarry(!false,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (091B);

091B:

    #091B
    #instruction: *NOP
    advance (4)
    jump (091C);

091C:

    #091C
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (091D);

091D:

    #091D
    #instruction: OR   H
    let:8 a1 = (H | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (091E);

091E:

    #091E
    #instruction: JP   NZ,0929
    if (!FlagZ) {
      advance (10)
      jump (0929);
    } else {
      advance (10)
      jump (0921);
    }

091F:

    #091F
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0920);

0920:

    #0920
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0921);

0921:

    #0921
    #instruction: LD   HL,0600
    advance (10)
    H := 06;
    L := 00;
    jump (0924);

0922:

    #0922
    #instruction: NOP
    advance (4)
    jump (0923);

0923:

    #0923
    #instruction: LD   B,3E
    advance (7)
    B := 3E;
    jump (0925);

0924:

    #0924
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0926);

0925:

    #0925
    #instruction: LD   BC,8332
    advance (10)
    B := 83;
    C := 32;
    jump (0928);

0926:

    #0926
    #instruction: LD   (2083),A
    M[2083] := A;
    advance (13)
    jump (0929);

0927:

    #0927
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0928);

0928:

    #0928
    #instruction: *NOP
    advance (4)
    jump (0929);

0929:

    #0929
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (092A);

092A:

    #092A
    #instruction: LD   (2091),HL
    M[2091] := L;
    M[2092] := H;
    advance (16)
    jump (092D);

092B:

    #092B
    #instruction: SUB  C
    let:16 a1 = addWithCarry(!false,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (092C);

092C:

    #092C
    #instruction: *NOP
    advance (4)
    jump (092D);

092D:

    #092D
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

092E:

    #092E
    #instruction: CALL 1611
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 31;
    #return-to: 0931
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1611);

092F:

    #092F
    #instruction: LD   DE,2E16
    advance (10)
    D := 2E;
    E := 16;
    jump (0932);

0930:

    #0930
    #instruction: LD   D,2E
    advance (7)
    D := 2E;
    jump (0932);

0931:

    #0931
    #instruction: LD   L,FF
    advance (7)
    L := FF;
    jump (0933);

0932:

    #0932
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 33;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0933:

    #0933
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0934);

0934:

    #0934
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0935:

    #0935
    #instruction: CALL 1910
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 38;
    #return-to: 0938
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1910);

0936:

    #0936
    #instruction: *NOP
    advance (4)
    jump (0937);

0937:

    #0937
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0938);

0938:

    #0938
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0939);

0939:

    #0939
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (093A);

093A:

    #093A
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (093B);

093B:

    #093B
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (093C);

093C:

    #093C
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (093D);
    }

093D:

    #093D
    #instruction: LD   B,15
    advance (7)
    B := 15;
    jump (093F);

093E:

    #093E
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (093F);

093F:

    #093F
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
    jump (0941);

0940:

    #0940
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0941);

0941:

    #0941
    #instruction: AND  08
    let:8 a1 = (08 & A) in
    let:8 a2 = (08 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0943);

0942:

    #0942
    #instruction: *NOP
    advance (4)
    jump (0943);

0943:

    #0943
    #instruction: JP   Z,0948
    if (FlagZ) {
      advance (10)
      jump (0948);
    } else {
      advance (10)
      jump (0946);
    }

0944:

    #0944
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (0945);

0945:

    #0945
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0946);

0946:

    #0946
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0948);

0947:

    #0947
    #instruction: *NOP
    advance (4)
    jump (0948);

0948:

    #0948
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4B;
    #return-to: 094B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09CA);

0949:

    #0949
    #instruction: JP   Z,2309
    if (FlagZ) {
      advance (10)
      jump (2309);
    } else {
      advance (10)
      jump (094C);
    }

094A:

    #094A
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (094B);

094B:

    #094B
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (094C);

094C:

    #094C
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (094D);

094D:

    #094D
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (094E);

094E:

    #094E
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (094F);
    }

094F:

    #094F
    #instruction: CALL 092E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 52;
    #return-to: 0952
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (092E);

0950:

    #0950
    #instruction: LD   L,09
    advance (7)
    L := 09;
    jump (0952);

0951:

    #0951
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0952);

0952:

    #0952
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0953);

0953:

    #0953
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0954);

0954:

    #0954
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0955);

0955:

    #0955
    #instruction: LD   HL,2501
    advance (10)
    H := 25;
    L := 01;
    jump (0958);

0956:

    #0956
    #instruction: LD   BC,2425
    advance (10)
    B := 24;
    C := 25;
    jump (0959);

0957:

    #0957
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0958);

0958:

    #0958
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0959);

0959:

    #0959
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (095A);

095A:

    #095A
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (095B);

095B:

    #095B
    #instruction: JP   NZ,0958
    if (!FlagZ) {
      advance (10)
      jump (0958);
    } else {
      advance (10)
      jump (095E);
    }

095C:

    #095C
    #instruction: LD   E,B
    advance (5)
    E := B;
    jump (095D);

095D:

    #095D
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (095E);

095E:

    #095E
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0960);

095F:

    #095F
    #instruction: *NOP
    advance (4)
    jump (0960);

0960:

    #0960
    #instruction: LD   DE,1C60
    advance (10)
    D := 1C;
    E := 60;
    jump (0963);

0961:

    #0961
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (0962);

0962:

    #0962
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0963);

0963:

    #0963
    #instruction: CALL 1439
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 66;
    #return-to: 0966
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1439);

0964:

    #0964
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0965);

0965:

    #0965
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0966);

0966:

    #0966
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0967);

0967:

    #0967
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0968);

0968:

    #0968
    #instruction: CALL 1A8B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6B;
    #return-to: 096B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A8B);

0969:

    #0969
    #instruction: ADC  E
    let:16 a1 = addWithCarry(FlagCY,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (096A);

096A:

    #096A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (096B);

096B:

    #096B
    #instruction: CALL 1910
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6E;
    #return-to: 096E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1910);

096C:

    #096C
    #instruction: *NOP
    advance (4)
    jump (096D);

096D:

    #096D
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (096E);

096E:

    #096E
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (096F);

096F:

    #096F
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0970);

0970:

    #0970
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (0972);

0971:

    #0971
    #instruction: NOP
    advance (4)
    jump (0972);

0972:

    #0972
    #instruction: LD   A,FF
    advance (7)
    A := FF;
    jump (0974);

0973:

    #0973
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0974:

    #0974
    #instruction: LD   (2099),A
    M[2099] := A;
    advance (13)
    jump (0977);

0975:

    #0975
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0976);

0976:

    #0976
    #instruction: *NOP
    advance (4)
    jump (0977);

0977:

    #0977
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0979);

0978:

    #0978
    #instruction: *NOP
    advance (4)
    jump (0979);

0979:

    #0979
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

097A:

    #097A
    #instruction: JP   MI,2118
    if (FlagS) {
      advance (10)
      jump (2118);
    } else {
      advance (10)
      jump (097D);
    }

097B:

    #097B
    #instruction: *NOP
    advance (4)
    jump (097C);

097C:

    #097C
    #instruction: LD   HL,1DA0
    advance (10)
    H := 1D;
    L := A0;
    jump (097F);

097D:

    #097D
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (097E);

097E:

    #097E
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (097F);

097F:

    #097F
    #instruction: CP   02
    let:16 a1 = addWithCarry(!false,A,~02) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~02 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0981);

0980:

    #0980
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0981);

0981:

    #0981
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0982);
    }

0982:

    #0982
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0983);

0983:

    #0983
    #instruction: CP   04
    let:16 a1 = addWithCarry(!false,A,~04) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~04 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0985);

0984:

    #0984
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0985);

0985:

    #0985
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0986);
    }

0986:

    #0986
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0987);

0987:

    #0987
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0988:

    #0988
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 8B;
    #return-to: 098B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09CA);

0989:

    #0989
    #instruction: JP   Z,3A09
    if (FlagZ) {
      advance (10)
      jump (3A09);
    } else {
      advance (10)
      jump (098C);
    }

098A:

    #098A
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (098B);

098B:

    #098B
    #instruction: LD   A,(20F1)
    advance (13)
    A := M[20F1];
    jump (098E);

098C:

    #098C
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (098D);

098D:

    #098D
    #instruction: *NOP
    advance (4)
    jump (098E);

098E:

    #098E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (098F);

098F:

    #098F
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0990);
    }

0990:

    #0990
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0991);

0991:

    #0991
    #instruction: LD   (20F1),A
    M[20F1] := A;
    advance (13)
    jump (0994);

0992:

    #0992
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0993);

0993:

    #0993
    #instruction: *NOP
    advance (4)
    jump (0994);

0994:

    #0994
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0995);

0995:

    #0995
    #instruction: LD   HL,(20F2)
    advance (16)
    H := M[20F3];
    L := M[20F2];
    jump (0998);

0996:

    #0996
    #instruction: JP   P,EB20
    if (!FlagS) {
      advance (10)
      jump (EB20);
    } else {
      advance (10)
      jump (0999);
    }

0997:

    #0997
    #instruction: *NOP
    advance (4)
    jump (0998);

0998:

    #0998
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (0999);

0999:

    #0999
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (099A);

099A:

    #099A
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (099B);

099B:

    #099B
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (099C);

099C:

    #099C
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (099D);

099D:

    #099D
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (099E);

099E:

    #099E
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (099F);

099F:

    #099F
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (09A0);

09A0:

    #09A0
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (09A1);

09A1:

    #09A1
    #instruction: ADC  D
    let:16 a1 = addWithCarry(FlagCY,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (09A2);

09A2:

    #09A2
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (09A3);

09A3:

    #09A3
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (09A4);

09A4:

    #09A4
    #instruction: LD   D,A
    advance (5)
    D := A;
    jump (09A5);

09A5:

    #09A5
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (09A6);

09A6:

    #09A6
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (09A7);

09A7:

    #09A7
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (09A8);

09A8:

    #09A8
    #instruction: LD   H,(HL)
    advance (7)
    H := M[(H,L)];
    jump (09A9);

09A9:

    #09A9
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (09AA);

09AA:

    #09AA
    #instruction: JP   09AD
    advance (10)
    jump (09AD);

09AB:

    #09AB
    #instruction: XOR  L
    let:8 a1 = (L ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (09AC);

09AC:

    #09AC
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09AD);

09AD:

    #09AD
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (09AE);

09AE:

    #09AE
    #instruction: CALL 09B2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := B1;
    #return-to: 09B1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09B2);

09AF:

    #09AF
    #instruction: OR   D
    let:8 a1 = (D | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (09B0);

09B0:

    #09B0
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09B1);

09B1:

    #09B1
    #instruction: LD   A,E
    advance (5)
    A := E;
    jump (09B2);

09B2:

    #09B2
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09B3);

09B3:

    #09B3
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09B4);

09B4:

    #09B4
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09B5);

09B5:

    #09B5
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09B6);

09B6:

    #09B6
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09B7);

09B7:

    #09B7
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09B8);

09B8:

    #09B8
    #instruction: AND  0F
    let:8 a1 = (0F & A) in
    let:8 a2 = (0F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (09BA);

09B9:

    #09B9
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09BA);

09BA:

    #09BA
    #instruction: CALL 09C5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := BD;
    #return-to: 09BD
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09C5);

09BB:

    #09BB
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09BC);

09BC:

    #09BC
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09BD);

09BD:

    #09BD
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (09BE);

09BE:

    #09BE
    #instruction: AND  0F
    let:8 a1 = (0F & A) in
    let:8 a2 = (0F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (09C0);

09BF:

    #09BF
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09C0);

09C0:

    #09C0
    #instruction: CALL 09C5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := C3;
    #return-to: 09C3
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09C5);

09C1:

    #09C1
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09C2);

09C2:

    #09C2
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09C3);

09C3:

    #09C3
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09C4);

09C4:

    #09C4
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

09C5:

    #09C5
    #instruction: ADD  1A
    let:16 a1 = addWithCarry(false,1A,A) in
    let:8 a2 = (1A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (09C7);

09C6:

    #09C6
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (09C7);

09C7:

    #09C7
    #instruction: JP   08FF
    advance (10)
    jump (08FF);

09C8:

    #09C8
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := C9;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

09C9:

    #09C9
    #instruction: *NOP
    advance (4)
    jump (09CA);

09CA:

    #09CA
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (09CD);

09CB:

    #09CB
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (09CC);

09CC:

    #09CC
    #instruction: *NOP
    advance (4)
    jump (09CD);

09CD:

    #09CD
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (09CE);

09CE:

    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    H := 20;
    L := F8;
    jump (09D1);

09CF:

    #09CF
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (09D0);
    }

09D0:

    #09D0
    #instruction: *NOP
    advance (4)
    jump (09D1);

09D1:

    #09D1
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (09D2);
    }

09D2:

    #09D2
    #instruction: LD   HL,20FC
    advance (10)
    H := 20;
    L := FC;
    jump (09D5);

09D3:

    #09D3
    #instruction: CALL MI,C920
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 09;
      let:16 a2 = (-1 + a1) in
      M[a2] := D6;
      #return-to: 09D6
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C920);
    } else {
      advance (11)
      jump (09D6);
    }

09D4:

    #09D4
    #instruction: *NOP
    advance (4)
    jump (09D5);

09D5:

    #09D5
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

09D6:

    #09D6
    #instruction: LD   HL,2402
    advance (10)
    H := 24;
    L := 02;
    jump (09D9);

09D7:

    #09D7
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (09D8);

09D8:

    #09D8
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (09D9);

09D9:

    #09D9
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (09DB);

09DA:

    #09DA
    #instruction: NOP
    advance (4)
    jump (09DB);

09DB:

    #09DB
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (09DC);

09DC:

    #09DC
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (09DD);

09DD:

    #09DD
    #instruction: AND  1F
    let:8 a1 = (1F & A) in
    let:8 a2 = (1F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (09DF);

09DE:

    #09DE
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (09DF);

09DF:

    #09DF
    #instruction: CP   1C
    let:16 a1 = addWithCarry(!false,A,~1C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~1C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (09E1);

09E0:

    #09E0
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (09E1);

09E1:

    #09E1
    #instruction: JP   CY,09E8
    if (FlagCY) {
      advance (10)
      jump (09E8);
    } else {
      advance (10)
      jump (09E4);
    }

09E2:

    #09E2
    #instruction: RET  PE
    if (FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (09E3);
    }

09E3:

    #09E3
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09E4);

09E4:

    #09E4
    #instruction: LD   DE,0006
    advance (10)
    D := 00;
    E := 06;
    jump (09E7);

09E5:

    #09E5
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (09E7);

09E6:

    #09E6
    #instruction: NOP
    advance (4)
    jump (09E7);

09E7:

    #09E7
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09E8);

09E8:

    #09E8
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (09E9);

09E9:

    #09E9
    #instruction: CP   40
    let:16 a1 = addWithCarry(!false,A,~40) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~40 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (09EB);

09EA:

    #09EA
    #instruction: LD   B,B
    advance (5)
    jump (09EB);

09EB:

    #09EB
    #instruction: JP   CY,09D9
    if (FlagCY) {
      advance (10)
      jump (09D9);
    } else {
      advance (10)
      jump (09EE);
    }

09EC:

    #09EC
    #instruction: *RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

09ED:

    #09ED
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09EE);

09EE:

    #09EE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

09EF:

    #09EF
    #instruction: CALL 0A3C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := F2;
    #return-to: 09F2
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A3C);

09F0:

    #09F0
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (09F1);

09F1:

    #09F1
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (09F2);

09F2:

    #09F2
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (09F3);

09F3:

    #09F3
    #instruction: LD   (20E9),A
    M[20E9] := A;
    advance (13)
    jump (09F6);

09F4:

    #09F4
    #instruction: JP   (HL)
    advance (5)
    jump ((H,L));

09F5:

    #09F5
    #instruction: *NOP
    advance (4)
    jump (09F6);

09F6:

    #09F6
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := F9;
    #return-to: 09F9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

09F7:

    #09F7
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (09F9);

09F8:

    #09F8
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (09F9);

09F9:

    #09F9
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (09FC);

09FA:

    #09FA
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (09FB);

09FB:

    #09FB
    #instruction: *NOP
    advance (4)
    jump (09FC);

09FC:

    #09FC
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09FD);

09FD:

    #09FD
    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    #return-to: 0A00
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01E4);

09FE:

    #09FE
    #instruction: CALL PO,F101
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0A;
      let:16 a2 = (-1 + a1) in
      M[a2] := 01;
      #return-to: 0A01
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (F101);
    } else {
      advance (11)
      jump (0A01);
    }

09FF:

    #09FF
    #instruction: LD   BC,32F1
    advance (10)
    B := 32;
    C := F1;
    jump (0A02);

0A00:

    #0A00
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0A01);

0A01:

    #0A01
    #instruction: LD   (2067),A
    M[2067] := A;
    advance (13)
    jump (0A04);

0A02:

    #0A02
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0A03);

0A03:

    #0A03
    #instruction: *NOP
    advance (4)
    jump (0A04);

0A04:

    #0A04
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (0A07);

0A05:

    #0A05
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0A06);

0A06:

    #0A06
    #instruction: *NOP
    advance (4)
    jump (0A07);

0A07:

    #0A07
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (0A08);

0A08:

    #0A08
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A09);

0A09:

    #0A09
    #instruction: LD   L,FE
    advance (7)
    L := FE;
    jump (0A0B);

0A0A:

    #0A0A
    #instruction: CP   7E
    let:16 a1 = addWithCarry(!false,A,~7E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~7E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0A0C);

0A0B:

    #0A0B
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0A0C);

0A0C:

    #0A0C
    #instruction: AND  07
    let:8 a1 = (07 & A) in
    let:8 a2 = (07 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A0E);

0A0D:

    #0A0D
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0A0E);

0A0E:

    #0A0E
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A0F);

0A0F:

    #0A0F
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0A10);

0A10:

    #0A10
    #instruction: LD   HL,1DA2
    advance (10)
    H := 1D;
    L := A2;
    jump (0A13);

0A11:

    #0A11
    #instruction: AND  D
    let:8 a1 = (D & A) in
    let:8 a2 = (D | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A12);

0A12:

    #0A12
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A13);

0A13:

    #0A13
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0A14);

0A14:

    #0A14
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A15);

0A15:

    #0A15
    #instruction: JP   NZ,0A13
    if (!FlagZ) {
      advance (10)
      jump (0A13);
    } else {
      advance (10)
      jump (0A18);
    }

0A16:

    #0A16
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0A17);

0A17:

    #0A17
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A18);

0A18:

    #0A18
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0A19);

0A19:

    #0A19
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A1A);

0A1A:

    #0A1A
    #instruction: LD   L,FC
    advance (7)
    L := FC;
    jump (0A1C);

0A1B:

    #0A1B
    #instruction: CALL MI,2377
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0A;
      let:16 a2 = (-1 + a1) in
      M[a2] := 1E;
      #return-to: 0A1E
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (2377);
    } else {
      advance (11)
      jump (0A1E);
    }

0A1C:

    #0A1C
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0A1D);

0A1D:

    #0A1D
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0A1E);

0A1E:

    #0A1E
    #instruction: LD   (HL),38
    M[(H,L)] := 38;
    advance (10)
    jump (0A20);

0A1F:

    #0A1F
    #instruction: *NOP
    advance (4)
    jump (0A20);

0A20:

    #0A20
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0A21);

0A21:

    #0A21
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0A22);

0A22:

    #0A22
    #instruction: JP   CY,0A33
    if (FlagCY) {
      advance (10)
      jump (0A33);
    } else {
      advance (10)
      jump (0A25);
    }

0A23:

    #0A23
    #instruction: INC  SP
    let:16 a1 = (1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0A24);

0A24:

    #0A24
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A25);

0A25:

    #0A25
    #instruction: LD   A,21
    advance (7)
    A := 21;
    jump (0A27);

0A26:

    #0A26
    #instruction: LD   HL,9832
    advance (10)
    H := 98;
    L := 32;
    jump (0A29);

0A27:

    #0A27
    #instruction: LD   (2098),A
    M[2098] := A;
    advance (13)
    jump (0A2A);

0A28:

    #0A28
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0A29);

0A29:

    #0A29
    #instruction: *NOP
    advance (4)
    jump (0A2A);

0A2A:

    #0A2A
    #instruction: CALL 01F5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2D;
    #return-to: 0A2D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01F5);

0A2B:

    #0A2B
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A2C);

0A2C:

    #0A2C
    #instruction: LD   BC,04CD
    advance (10)
    B := 04;
    C := CD;
    jump (0A2F);

0A2D:

    #0A2D
    #instruction: CALL 1904
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    #return-to: 0A30
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1904);

0A2E:

    #0A2E
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A2F);

0A2F:

    #0A2F
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0A30);

0A30:

    #0A30
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A31:

    #0A31
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A32);

0A32:

    #0A32
    #instruction: *NOP
    advance (4)
    jump (0A33);

0A33:

    #0A33
    #instruction: CALL 01EF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 36;
    #return-to: 0A36
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01EF);

0A34:

    #0A34
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 35;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0A35:

    #0A35
    #instruction: LD   BC,C0CD
    advance (10)
    B := C0;
    C := CD;
    jump (0A38);

0A36:

    #0A36
    #instruction: CALL 01C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0A39
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01C0);

0A37:

    #0A37
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0A38);
    }

0A38:

    #0A38
    #instruction: LD   BC,04C3
    advance (10)
    B := 04;
    C := C3;
    jump (0A3B);

0A39:

    #0A39
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A3A:

    #0A3A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A3B);

0A3B:

    #0A3B
    #instruction: *NOP
    advance (4)
    jump (0A3C);

0A3C:

    #0A3C
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3F;
    #return-to: 0A3F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

0A3D:

    #0A3D
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0A3E);

0A3E:

    #0A3E
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A3F);

0A3F:

    #0A3F
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      jump (0A42);
    }

0A40:

    #0A40
    #instruction: LD   D,D
    advance (5)
    jump (0A41);

0A41:

    #0A41
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A42);

0A42:

    #0A42
    #instruction: LD   A,30
    advance (7)
    A := 30;
    jump (0A44);

0A43:

    #0A43
    #instruction: *NOP
    advance (4)
    jump (0A44);

0A44:

    #0A44
    #instruction: LD   (20C0),A
    M[20C0] := A;
    advance (13)
    jump (0A47);

0A45:

    #0A45
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0A46);
    }

0A46:

    #0A46
    #instruction: *NOP
    advance (4)
    jump (0A47);

0A47:

    #0A47
    #instruction: LD   A,(20C0)
    advance (13)
    A := M[20C0];
    jump (0A4A);

0A48:

    #0A48
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0A49);
    }

0A49:

    #0A49
    #instruction: *NOP
    advance (4)
    jump (0A4A);

0A4A:

    #0A4A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A4B);

0A4B:

    #0A4B
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0A4C);
    }

0A4C:

    #0A4C
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4F;
    #return-to: 0A4F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

0A4D:

    #0A4D
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0A4E);

0A4E:

    #0A4E
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A4F);

0A4F:

    #0A4F
    #instruction: JP   Z,0A47
    if (FlagZ) {
      advance (10)
      jump (0A47);
    } else {
      advance (10)
      jump (0A52);
    }

0A50:

    #0A50
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (0A51);

0A51:

    #0A51
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A52);

0A52:

    #0A52
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 55;
    #return-to: 0A55
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

0A53:

    #0A53
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0A54);

0A54:

    #0A54
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A55);

0A55:

    #0A55
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      jump (0A58);
    }

0A56:

    #0A56
    #instruction: LD   D,D
    advance (5)
    jump (0A57);

0A57:

    #0A57
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A58);

0A58:

    #0A58
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0A59:

    #0A59
    #instruction: LD   A,(2015)
    advance (13)
    A := M[2015];
    jump (0A5C);

0A5A:

    #0A5A
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0A5B);

0A5B:

    #0A5B
    #instruction: *NOP
    advance (4)
    jump (0A5C);

0A5C:

    #0A5C
    #instruction: CP   FF
    let:16 a1 = addWithCarry(!false,A,~FF) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FF & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0A5E);

0A5D:

    #0A5D
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5E;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0A5E:

    #0A5E
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0A5F:

    #0A5F
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (0A62);

0A60:

    #0A60
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 61;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0A61:

    #0A61
    #instruction: *NOP
    advance (4)
    jump (0A62);

0A62:

    #0A62
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A63);

0A63:

    #0A63
    #instruction: JP   Z,0A7C
    if (FlagZ) {
      advance (10)
      jump (0A7C);
    } else {
      advance (10)
      jump (0A66);
    }

0A64:

    #0A64
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0A65);

0A65:

    #0A65
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A66);

0A66:

    #0A66
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (0A67);

0A67:

    #0A67
    #instruction: LD   B,08
    advance (7)
    B := 08;
    jump (0A69);

0A68:

    #0A68
    #instruction: *NOP
    advance (4)
    jump (0A69);

0A69:

    #0A69
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6C;
    #return-to: 0A6C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18FA);

0A6A:

    #0A6A
    #instruction: JP   MI,4118
    if (FlagS) {
      advance (10)
      jump (4118);
    } else {
      advance (10)
      jump (0A6D);
    }

0A6B:

    #0A6B
    #instruction: *NOP
    advance (4)
    jump (0A6C);

0A6C:

    #0A6C
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (0A6D);

0A6D:

    #0A6D
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (0A6E);

0A6E:

    #0A6E
    #instruction: CALL 097C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 0A71
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (097C);

0A6F:

    #0A6F
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (0A70);

0A70:

    #0A70
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0A71);

0A71:

    #0A71
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0A72);

0A72:

    #0A72
    #instruction: LD   HL,20F3
    advance (10)
    H := 20;
    L := F3;
    jump (0A75);

0A73:

    #0A73
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0A74);

0A74:

    #0A74
    #instruction: *NOP
    advance (4)
    jump (0A75);

0A75:

    #0A75
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (0A77);

0A76:

    #0A76
    #instruction: NOP
    advance (4)
    jump (0A77);

0A77:

    #0A77
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0A78);

0A78:

    #0A78
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0A79);

0A79:

    #0A79
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0A7A);

0A7A:

    #0A7A
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (0A7C);

0A7B:

    #0A7B
    #instruction: LD   BC,6221
    advance (10)
    B := 62;
    C := 21;
    jump (0A7E);

0A7C:

    #0A7C
    #instruction: LD   HL,2062
    advance (10)
    H := 20;
    L := 62;
    jump (0A7F);

0A7D:

    #0A7D
    #instruction: LD   H,D
    advance (5)
    H := D;
    jump (0A7E);

0A7E:

    #0A7E
    #instruction: *NOP
    advance (4)
    jump (0A7F);

0A7F:

    #0A7F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0A80:

    #0A80
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (0A82);

0A81:

    #0A81
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0A82);

0A82:

    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (0A85);

0A83:

    #0A83
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A84);

0A84:

    #0A84
    #instruction: *NOP
    advance (4)
    jump (0A85);

0A85:

    #0A85
    #instruction: OUT  06
    advance (10)
    jump (0A87);

0A86:

    #0A86
    #instruction: LD   B,3A
    advance (7)
    B := 3A;
    jump (0A88);

0A87:

    #0A87
    #instruction: LD   A,(20CB)
    advance (13)
    A := M[20CB];
    jump (0A8A);

0A88:

    #0A88
    #instruction: *JP  A720
    advance (10)
    jump (A720);

0A89:

    #0A89
    #instruction: *NOP
    advance (4)
    jump (0A8A);

0A8A:

    #0A8A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A8B);

0A8B:

    #0A8B
    #instruction: JP   Z,0A85
    if (FlagZ) {
      advance (10)
      jump (0A85);
    } else {
      advance (10)
      jump (0A8E);
    }

0A8C:

    #0A8C
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0A8D);

0A8D:

    #0A8D
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0A8E);

0A8E:

    #0A8E
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0A8F);

0A8F:

    #0A8F
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (0A92);

0A90:

    #0A90
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A91);

0A91:

    #0A91
    #instruction: *NOP
    advance (4)
    jump (0A92);

0A92:

    #0A92
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0A93:

    #0A93
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A94);

0A94:

    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0A95);

0A95:

    #0A95
    #instruction: CALL 08FF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 98;
    #return-to: 0A98
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08FF);

0A96:

    #0A96
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 97;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0A97:

    #0A97
    #instruction: *NOP
    advance (4)
    jump (0A98);

0A98:

    #0A98
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A99);

0A99:

    #0A99
    #instruction: LD   A,07
    advance (7)
    A := 07;
    jump (0A9B);

0A9A:

    #0A9A
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0A9B);

0A9B:

    #0A9B
    #instruction: LD   (20C0),A
    M[20C0] := A;
    advance (13)
    jump (0A9E);

0A9C:

    #0A9C
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0A9D);
    }

0A9D:

    #0A9D
    #instruction: *NOP
    advance (4)
    jump (0A9E);

0A9E:

    #0A9E
    #instruction: LD   A,(20C0)
    advance (13)
    A := M[20C0];
    jump (0AA1);

0A9F:

    #0A9F
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0AA0);
    }

0AA0:

    #0AA0
    #instruction: *NOP
    advance (4)
    jump (0AA1);

0AA1:

    #0AA1
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AA2);

0AA2:

    #0AA2
    #instruction: JP   NZ,0A9E
    if (!FlagZ) {
      advance (10)
      jump (0A9E);
    } else {
      advance (10)
      jump (0AA5);
    }

0AA3:

    #0AA3
    #instruction: SBC  (HL)
    let:16 a1 = addWithCarry(!FlagCY,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0AA4);

0AA4:

    #0AA4
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AA5);

0AA5:

    #0AA5
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0AA6);

0AA6:

    #0AA6
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AA7);

0AA7:

    #0AA7
    #instruction: JP   NZ,0A93
    if (!FlagZ) {
      advance (10)
      jump (0A93);
    } else {
      advance (10)
      jump (0AAA);
    }

0AA8:

    #0AA8
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0AA9);

0AA9:

    #0AA9
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AAA);

0AAA:

    #0AAA
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0AAB:

    #0AAB
    #instruction: LD   HL,2050
    advance (10)
    H := 20;
    L := 50;
    jump (0AAE);

0AAC:

    #0AAC
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (0AAD);

0AAD:

    #0AAD
    #instruction: *NOP
    advance (4)
    jump (0AAE);

0AAE:

    #0AAE
    #instruction: JP   024B
    advance (10)
    jump (024B);

0AAF:

    #0AAF
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (0AB0);

0AB0:

    #0AB0
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0AB1);

0AB1:

    #0AB1
    #instruction: LD   A,40
    advance (7)
    A := 40;
    jump (0AB3);

0AB2:

    #0AB2
    #instruction: LD   B,B
    advance (5)
    jump (0AB3);

0AB3:

    #0AB3
    #instruction: JP   0AD7
    advance (10)
    jump (0AD7);

0AB4:

    #0AB4
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := B5;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

0AB5:

    #0AB5
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AB6);

0AB6:

    #0AB6
    #instruction: LD   A,80
    advance (7)
    A := 80;
    jump (0AB8);

0AB7:

    #0AB7
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0AB8);

0AB8:

    #0AB8
    #instruction: JP   0AD7
    advance (10)
    jump (0AD7);

0AB9:

    #0AB9
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := BA;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

0ABA:

    #0ABA
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0ABB);

0ABB:

    #0ABB
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0ABC);

0ABC:

    #0ABC
    #instruction: JP   0072
    advance (10)
    jump (0072);

0ABD:

    #0ABD
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (0ABE);

0ABE:

    #0ABE
    #instruction: NOP
    advance (4)
    jump (0ABF);

0ABF:

    #0ABF
    #instruction: LD   A,(20C1)
    advance (13)
    A := M[20C1];
    jump (0AC2);

0AC0:

    #0AC0
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AC1);

0AC1:

    #0AC1
    #instruction: *NOP
    advance (4)
    jump (0AC2);

0AC2:

    #0AC2
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0AC3);

0AC3:

    #0AC3
    #instruction: JP   CY,0ABB
    if (FlagCY) {
      advance (10)
      jump (0ABB);
    } else {
      advance (10)
      jump (0AC6);
    }

0AC4:

    #0AC4
    #instruction: CP   E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0AC5);

0AC5:

    #0AC5
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AC6);

0AC6:

    #0AC6
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0AC7);

0AC7:

    #0AC7
    #instruction: JP   CY,1868
    if (FlagCY) {
      advance (10)
      jump (1868);
    } else {
      advance (10)
      jump (0ACA);
    }

0AC8:

    #0AC8
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (0AC9);

0AC9:

    #0AC9
    #instruction: *NOP
    advance (4)
    jump (0ACA);

0ACA:

    #0ACA
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0ACB);

0ACB:

    #0ACB
    #instruction: JP   CY,0AAB
    if (FlagCY) {
      advance (10)
      jump (0AAB);
    } else {
      advance (10)
      jump (0ACE);
    }

0ACC:

    #0ACC
    #instruction: XOR  E
    let:8 a1 = (E ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0ACD);

0ACD:

    #0ACD
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0ACE);

0ACE:

    #0ACE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0ACF:

    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    H := 2B;
    L := 14;
    jump (0AD2);

0AD0:

    #0AD0
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AD1);

0AD1:

    #0AD1
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (0AD2);

0AD2:

    #0AD2
    #instruction: LD   C,0F
    advance (7)
    C := 0F;
    jump (0AD4);

0AD3:

    #0AD3
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0AD4);

0AD4:

    #0AD4
    #instruction: JP   0A93
    advance (10)
    jump (0A93);

0AD5:

    #0AD5
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0AD6);

0AD6:

    #0AD6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AD7);

0AD7:

    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := A;
    advance (13)
    jump (0ADA);

0AD8:

    #0AD8
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0AD9);
    }

0AD9:

    #0AD9
    #instruction: *NOP
    advance (4)
    jump (0ADA);

0ADA:

    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    A := M[20C0];
    jump (0ADD);

0ADB:

    #0ADB
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0ADC);
    }

0ADC:

    #0ADC
    #instruction: *NOP
    advance (4)
    jump (0ADD);

0ADD:

    #0ADD
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0ADE);

0ADE:

    #0ADE
    #instruction: JP   NZ,0ADA
    if (!FlagZ) {
      advance (10)
      jump (0ADA);
    } else {
      advance (10)
      jump (0AE1);
    }

0ADF:

    #0ADF
    #instruction: JP   CY,C90A
    if (FlagCY) {
      advance (10)
      jump (C90A);
    } else {
      advance (10)
      jump (0AE2);
    }

0AE0:

    #0AE0
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AE1);

0AE1:

    #0AE1
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0AE2:

    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    H := 20;
    L := C2;
    jump (0AE5);

0AE3:

    #0AE3
    #instruction: JP   NZ,0620
    if (!FlagZ) {
      advance (10)
      jump (0620);
    } else {
      advance (10)
      jump (0AE6);
    }

0AE4:

    #0AE4
    #instruction: *NOP
    advance (4)
    jump (0AE5);

0AE5:

    #0AE5
    #instruction: LD   B,0C
    advance (7)
    B := 0C;
    jump (0AE7);

0AE6:

    #0AE6
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AE7);

0AE7:

    #0AE7
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0AE8:

    #0AE8
    #instruction: LD   (AF1A),A
    M[AF1A] := A;
    advance (13)
    jump (0AEB);

0AE9:

    #0AE9
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0AEA);

0AEA:

    #0AEA
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0AEB);

0AEB:

    #0AEB
    #instruction: OUT  03
    sound_control(Ufo,A[0]);
    sound_control(Shot,A[1]);
    sound_control(PlayerDie,A[2]);
    sound_control(InvaderDie,A[3]);
    sound_control(ExtraLife,A[4]);
    advance (10)
    jump (0AED);

0AEC:

    #0AEC
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0AED);

0AED:

    #0AED
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (0AEF);

0AEE:

    #0AEE
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AEF);

0AEF:

    #0AEF
    #instruction: CALL 1982
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := F2;
    #return-to: 0AF2
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1982);

0AF0:

    #0AF0
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0AF1);

0AF1:

    #0AF1
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0AF2);

0AF2:

    #0AF2
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (0AF3);

0AF3:

    #0AF3
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 0AF6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

0AF4:

    #0AF4
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0AF5);

0AF5:

    #0AF5
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0AF6);

0AF6:

    #0AF6
    #instruction: LD   A,(20EC)
    advance (13)
    A := M[20EC];
    jump (0AF9);

0AF7:

    #0AF7
    #instruction: CALL PE,A720
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0A;
      let:16 a2 = (-1 + a1) in
      M[a2] := FA;
      #return-to: 0AFA
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (A720);
    } else {
      advance (11)
      jump (0AFA);
    }

0AF8:

    #0AF8
    #instruction: *NOP
    advance (4)
    jump (0AF9);

0AF9:

    #0AF9
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0AFA);

0AFA:

    #0AFA
    #instruction: LD   HL,3017
    advance (10)
    H := 30;
    L := 17;
    jump (0AFD);

0AFB:

    #0AFB
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (0AFC);

0AFC:

    #0AFC
    #instruction: *NOP
    advance (4)
    jump (0AFD);

0AFD:

    #0AFD
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (0AFF);

0AFE:

    #0AFE
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0AFF);

0AFF:

    #0AFF
    #instruction: JP   NZ,0BE8
    if (!FlagZ) {
      advance (10)
      jump (0BE8);
    } else {
      advance (10)
      jump (0B02);
    }

0B00:

    #0B00
    #instruction: RET  PE
    if (FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0B01);
    }

0B01:

    #0B01
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B02);

0B02:

    #0B02
    #instruction: LD   DE,1CFA
    advance (10)
    D := 1C;
    E := FA;
    jump (0B05);

0B03:

    #0B03
    #instruction: JP   MI,CD1C
    if (FlagS) {
      advance (10)
      jump (CD1C);
    } else {
      advance (10)
      jump (0B06);
    }

0B04:

    #0B04
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B05);

0B05:

    #0B05
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    #return-to: 0B08
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

0B06:

    #0B06
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0B07);

0B07:

    #0B07
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B08);

0B08:

    #0B08
    #instruction: LD   DE,1DAF
    advance (10)
    D := 1D;
    E := AF;
    jump (0B0B);

0B09:

    #0B09
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B0A);

0B0A:

    #0B0A
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B0B);

0B0B:

    #0B0B
    #instruction: CALL 0ACF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0E;
    #return-to: 0B0E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0ACF);

0B0C:

    #0B0C
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0D;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0B0D:

    #0B0D
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B0E);

0B0E:

    #0B0E
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 11;
    #return-to: 0B11
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

0B0F:

    #0B0F
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B10);

0B10:

    #0B10
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B11);

0B11:

    #0B11
    #instruction: CALL 1815
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    #return-to: 0B14
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1815);

0B12:

    #0B12
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B13);

0B13:

    #0B13
    #instruction: *NOP
    advance (4)
    jump (0B14);

0B14:

    #0B14
    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    #return-to: 0B17
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB6);

0B15:

    #0B15
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B16);

0B16:

    #0B16
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B17);

0B17:

    #0B17
    #instruction: LD   A,(20EC)
    advance (13)
    A := M[20EC];
    jump (0B1A);

0B18:

    #0B18
    #instruction: CALL PE,A720
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := 1B;
      #return-to: 0B1B
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (A720);
    } else {
      advance (11)
      jump (0B1B);
    }

0B19:

    #0B19
    #instruction: *NOP
    advance (4)
    jump (0B1A);

0B1A:

    #0B1A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B1B);

0B1B:

    #0B1B
    #instruction: JP   NZ,0B4A
    if (!FlagZ) {
      advance (10)
      jump (0B4A);
    } else {
      advance (10)
      jump (0B1E);
    }

0B1C:

    #0B1C
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (0B1D);

0B1D:

    #0B1D
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B1E);

0B1E:

    #0B1E
    #instruction: LD   DE,1A95
    advance (10)
    D := 1A;
    E := 95;
    jump (0B21);

0B1F:

    #0B1F
    #instruction: SUB  L
    let:16 a1 = addWithCarry(!false,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0B20);

0B20:

    #0B20
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0B21);

0B21:

    #0B21
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 24;
    #return-to: 0B24
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AE2);

0B22:

    #0B22
    #instruction: JP   PO,CD0A
    if (!FlagP) {
      advance (10)
      jump (CD0A);
    } else {
      advance (10)
      jump (0B25);
    }

0B23:

    #0B23
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B24);

0B24:

    #0B24
    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    #return-to: 0B27
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A80);

0B25:

    #0B25
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0B26);

0B26:

    #0B26
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B27);

0B27:

    #0B27
    #instruction: LD   DE,1BB0
    advance (10)
    D := 1B;
    E := B0;
    jump (0B2A);

0B28:

    #0B28
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B29);

0B29:

    #0B29
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0B2A);

0B2A:

    #0B2A
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2D;
    #return-to: 0B2D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AE2);

0B2B:

    #0B2B
    #instruction: JP   PO,CD0A
    if (!FlagP) {
      advance (10)
      jump (CD0A);
    } else {
      advance (10)
      jump (0B2E);
    }

0B2C:

    #0B2C
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B2D);

0B2D:

    #0B2D
    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    #return-to: 0B30
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A80);

0B2E:

    #0B2E
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0B2F);

0B2F:

    #0B2F
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B30);

0B30:

    #0B30
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 33;
    #return-to: 0B33
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

0B31:

    #0B31
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B32);

0B32:

    #0B32
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B33);

0B33:

    #0B33
    #instruction: LD   DE,1FC9
    advance (10)
    D := 1F;
    E := C9;
    jump (0B36);

0B34:

    #0B34
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0B35:

    #0B35
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0B36);

0B36:

    #0B36
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0B39
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AE2);

0B37:

    #0B37
    #instruction: JP   PO,CD0A
    if (!FlagP) {
      advance (10)
      jump (CD0A);
    } else {
      advance (10)
      jump (0B3A);
    }

0B38:

    #0B38
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B39);

0B39:

    #0B39
    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    #return-to: 0B3C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A80);

0B3A:

    #0B3A
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0B3B);

0B3B:

    #0B3B
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B3C);

0B3C:

    #0B3C
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3F;
    #return-to: 0B3F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

0B3D:

    #0B3D
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B3E);

0B3E:

    #0B3E
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B3F);

0B3F:

    #0B3F
    #instruction: LD   HL,33B7
    advance (10)
    H := 33;
    L := B7;
    jump (0B42);

0B40:

    #0B40
    #instruction: OR   A
    let:8 a1 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B41);

0B41:

    #0B41
    #instruction: INC  SP
    let:16 a1 = (1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0B42);

0B42:

    #0B42
    #instruction: LD   B,0A
    advance (7)
    B := 0A;
    jump (0B44);

0B43:

    #0B43
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B44);

0B44:

    #0B44
    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 47;
    #return-to: 0B47
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14CB);

0B45:

    #0B45
    #instruction: *JP  CD14
    advance (10)
    jump (CD14);

0B46:

    #0B46
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B47);

0B47:

    #0B47
    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4A;
    #return-to: 0B4A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB6);

0B48:

    #0B48
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B49);

0B49:

    #0B49
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B4A);

0B4A:

    #0B4A
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4D;
    #return-to: 0B4D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

0B4B:

    #0B4B
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0B4D);

0B4C:

    #0B4C
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0B4D);

0B4D:

    #0B4D
    #instruction: LD   A,(21FF)
    advance (13)
    A := M[21FF];
    jump (0B50);

0B4E:

    #0B4E
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4F;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0B4F:

    #0B4F
    #instruction: LD   HL,C2A7
    advance (10)
    H := C2;
    L := A7;
    jump (0B52);

0B50:

    #0B50
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B51);

0B51:

    #0B51
    #instruction: JP   NZ,0B5D
    if (!FlagZ) {
      advance (10)
      jump (0B5D);
    } else {
      advance (10)
      jump (0B54);
    }

0B52:

    #0B52
    #instruction: LD   E,L
    advance (5)
    E := L;
    jump (0B53);

0B53:

    #0B53
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B54);

0B54:

    #0B54
    #instruction: CALL 08D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 57;
    #return-to: 0B57
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08D1);

0B55:

    #0B55
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0B56);

0B56:

    #0B56
    #instruction: *NOP
    advance (4)
    jump (0B57);

0B57:

    #0B57
    #instruction: LD   (21FF),A
    M[21FF] := A;
    advance (13)
    jump (0B5A);

0B58:

    #0B58
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 59;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0B59:

    #0B59
    #instruction: LD   HL,7FCD
    advance (10)
    H := 7F;
    L := CD;
    jump (0B5C);

0B5A:

    #0B5A
    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5D;
    #return-to: 0B5D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A7F);

0B5B:

    #0B5B
    #instruction: LD   A,A
    advance (5)
    jump (0B5C);

0B5C:

    #0B5C
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0B5D);

0B5D:

    #0B5D
    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 60;
    #return-to: 0B60
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01E4);

0B5E:

    #0B5E
    #instruction: CALL PO,CD01
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := 61;
      #return-to: 0B61
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (CD01);
    } else {
      advance (11)
      jump (0B61);
    }

0B5F:

    #0B5F
    #instruction: LD   BC,C0CD
    advance (10)
    B := C0;
    C := CD;
    jump (0B62);

0B60:

    #0B60
    #instruction: CALL 01C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 63;
    #return-to: 0B63
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01C0);

0B61:

    #0B61
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (0B62);
    }

0B62:

    #0B62
    #instruction: LD   BC,EFCD
    advance (10)
    B := EF;
    C := CD;
    jump (0B65);

0B63:

    #0B63
    #instruction: CALL 01EF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 66;
    #return-to: 0B66
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01EF);

0B64:

    #0B64
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 65;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

0B65:

    #0B65
    #instruction: LD   BC,1ACD
    advance (10)
    B := 1A;
    C := CD;
    jump (0B68);

0B66:

    #0B66
    #instruction: CALL 021A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 69;
    #return-to: 0B69
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (021A);

0B67:

    #0B67
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (0B68);

0B68:

    #0B68
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0B69);

0B69:

    #0B69
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0B6B);

0B6A:

    #0B6A
    #instruction: LD   BC,C132
    advance (10)
    B := C1;
    C := 32;
    jump (0B6D);

0B6B:

    #0B6B
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (0B6E);

0B6C:

    #0B6C
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0B6D);

0B6D:

    #0B6D
    #instruction: *NOP
    advance (4)
    jump (0B6E);

0B6E:

    #0B6E
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 0B71
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01CF);

0B6F:

    #0B6F
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 70;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

0B70:

    #0B70
    #instruction: LD   BC,18CD
    advance (10)
    B := 18;
    C := CD;
    jump (0B73);

0B71:

    #0B71
    #instruction: CALL 1618
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 0B74
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1618);

0B72:

    #0B72
    #instruction: *NOP
    advance (4)
    jump (0B73);

0B73:

    #0B73
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (0B75);

0B74:

    #0B74
    #instruction: CALL 0BF1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 77;
    #return-to: 0B77
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0BF1);

0B75:

    #0B75
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (0B76);

0B76:

    #0B76
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B77);

0B77:

    #0B77
    #instruction: OUT  06
    advance (10)
    jump (0B79);

0B78:

    #0B78
    #instruction: LD   B,CD
    advance (7)
    B := CD;
    jump (0B7A);

0B79:

    #0B79
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7C;
    #return-to: 0B7C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

0B7A:

    #0B7A
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0B7B);

0B7B:

    #0B7B
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B7C);

0B7C:

    #0B7C
    #instruction: JP   Z,0B71
    if (FlagZ) {
      advance (10)
      jump (0B71);
    } else {
      advance (10)
      jump (0B7F);
    }

0B7D:

    #0B7D
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (0B7E);

0B7E:

    #0B7E
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B7F);

0B7F:

    #0B7F
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B80);

0B80:

    #0B80
    #instruction: LD   (2025),A
    M[2025] := A;
    advance (13)
    jump (0B83);

0B81:

    #0B81
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B82);

0B82:

    #0B82
    #instruction: *NOP
    advance (4)
    jump (0B83);

0B83:

    #0B83
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 86;
    #return-to: 0B86
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

0B84:

    #0B84
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (0B85);

0B85:

    #0B85
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B86);

0B86:

    #0B86
    #instruction: JP   NZ,0B83
    if (!FlagZ) {
      advance (10)
      jump (0B83);
    } else {
      advance (10)
      jump (0B89);
    }

0B87:

    #0B87
    #instruction: ADD  E
    let:16 a1 = addWithCarry(false,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0B88);

0B88:

    #0B88
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0B89);

0B89:

    #0B89
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B8A);

0B8A:

    #0B8A
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (0B8D);

0B8B:

    #0B8B
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0B8C);

0B8C:

    #0B8C
    #instruction: *NOP
    advance (4)
    jump (0B8D);

0B8D:

    #0B8D
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 90;
    #return-to: 0B90
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

0B8E:

    #0B8E
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0B8F);

0B8F:

    #0B8F
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0B90);

0B90:

    #0B90
    #instruction: CALL 1988
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 93;
    #return-to: 0B93
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1988);

0B91:

    #0B91
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0B92);

0B92:

    #0B92
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0B93);

0B93:

    #0B93
    #instruction: LD   C,0C
    advance (7)
    C := 0C;
    jump (0B95);

0B94:

    #0B94
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B95);

0B95:

    #0B95
    #instruction: LD   HL,2C11
    advance (10)
    H := 2C;
    L := 11;
    jump (0B98);

0B96:

    #0B96
    #instruction: LD   DE,112C
    advance (10)
    D := 11;
    E := 2C;
    jump (0B99);

0B97:

    #0B97
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0B98);

0B98:

    #0B98
    #instruction: LD   DE,1F90
    advance (10)
    D := 1F;
    E := 90;
    jump (0B9B);

0B99:

    #0B99
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0B9A);

0B9A:

    #0B9A
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0B9B);

0B9B:

    #0B9B
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 9E;
    #return-to: 0B9E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

0B9C:

    #0B9C
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (0B9D);

0B9D:

    #0B9D
    #instruction: *NOP
    advance (4)
    jump (0B9E);

0B9E:

    #0B9E
    #instruction: LD   A,(20EC)
    advance (13)
    A := M[20EC];
    jump (0BA1);

0B9F:

    #0B9F
    #instruction: CALL PE,FE20
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := A2;
      #return-to: 0BA2
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (FE20);
    } else {
      advance (11)
      jump (0BA2);
    }

0BA0:

    #0BA0
    #instruction: *NOP
    advance (4)
    jump (0BA1);

0BA1:

    #0BA1
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BA3);

0BA2:

    #0BA2
    #instruction: NOP
    advance (4)
    jump (0BA3);

0BA3:

    #0BA3
    #instruction: JP   NZ,0BAE
    if (!FlagZ) {
      advance (10)
      jump (0BAE);
    } else {
      advance (10)
      jump (0BA6);
    }

0BA4:

    #0BA4
    #instruction: XOR  (HL)
    let:8 a1 = (M[(H,L)] ^ A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0BA5);

0BA5:

    #0BA5
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0BA6);

0BA6:

    #0BA6
    #instruction: LD   HL,3311
    advance (10)
    H := 33;
    L := 11;
    jump (0BA9);

0BA7:

    #0BA7
    #instruction: LD   DE,3E33
    advance (10)
    D := 3E;
    E := 33;
    jump (0BAA);

0BA8:

    #0BA8
    #instruction: INC  SP
    let:16 a1 = (1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (0BA9);

0BA9:

    #0BA9
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (0BAB);

0BAA:

    #0BAA
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0BAB);

0BAB:

    #0BAB
    #instruction: CALL 08FF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := AE;
    #return-to: 0BAE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08FF);

0BAC:

    #0BAC
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := AD;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

0BAD:

    #0BAD
    #instruction: *NOP
    advance (4)
    jump (0BAE);

0BAE:

    #0BAE
    #instruction: LD   BC,1F9C
    advance (10)
    B := 1F;
    C := 9C;
    jump (0BB1);

0BAF:

    #0BAF
    #instruction: SBC  H
    let:16 a1 = addWithCarry(!FlagCY,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BB0);

0BB0:

    #0BB0
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0BB1);

0BB1:

    #0BB1
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := B4;
    #return-to: 0BB4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1856);

0BB2:

    #0BB2
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (0BB3);

0BB3:

    #0BB3
    #instruction: *NOP
    advance (4)
    jump (0BB4);

0BB4:

    #0BB4
    #instruction: CALL 184C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := B7;
    #return-to: 0BB7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (184C);

0BB5:

    #0BB5
    #instruction: LD   C,H
    advance (5)
    C := H;
    jump (0BB6);

0BB6:

    #0BB6
    #instruction: *NOP
    advance (4)
    jump (0BB7);

0BB7:

    #0BB7
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
    jump (0BB9);

0BB8:

    #0BB8
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0BB9);

0BB9:

    #0BB9
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (0BBA);

0BBA:

    #0BBA
    #instruction: JP   CY,0BC3
    if (FlagCY) {
      advance (10)
      jump (0BC3);
    } else {
      advance (10)
      jump (0BBD);
    }

0BBB:

    #0BBB
    #instruction: JP   010B
    advance (10)
    jump (010B);

0BBC:

    #0BBC
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0BBD);

0BBD:

    #0BBD
    #instruction: LD   BC,1FA0
    advance (10)
    B := 1F;
    C := A0;
    jump (0BC0);

0BBE:

    #0BBE
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0BBF);

0BBF:

    #0BBF
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0BC0);

0BC0:

    #0BC0
    #instruction: CALL 183A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C3;
    #return-to: 0BC3
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (183A);

0BC1:

    #0BC1
    #instruction: LD   A,(CD18)
    advance (13)
    A := M[CD18];
    jump (0BC4);

0BC2:

    #0BC2
    #instruction: *NOP
    advance (4)
    jump (0BC3);

0BC3:

    #0BC3
    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C6;
    #return-to: 0BC6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB6);

0BC4:

    #0BC4
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0BC5);

0BC5:

    #0BC5
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0BC6);

0BC6:

    #0BC6
    #instruction: LD   A,(20EC)
    advance (13)
    A := M[20EC];
    jump (0BC9);

0BC7:

    #0BC7
    #instruction: CALL PE,FE20
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := CA;
      #return-to: 0BCA
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (FE20);
    } else {
      advance (11)
      jump (0BCA);
    }

0BC8:

    #0BC8
    #instruction: *NOP
    advance (4)
    jump (0BC9);

0BC9:

    #0BC9
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BCB);

0BCA:

    #0BCA
    #instruction: NOP
    advance (4)
    jump (0BCB);

0BCB:

    #0BCB
    #instruction: JP   NZ,0BDA
    if (!FlagZ) {
      advance (10)
      jump (0BDA);
    } else {
      advance (10)
      jump (0BCE);
    }

0BCC:

    #0BCC
    #instruction: JP   CY,110B
    if (FlagCY) {
      advance (10)
      jump (110B);
    } else {
      advance (10)
      jump (0BCF);
    }

0BCD:

    #0BCD
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0BCE);

0BCE:

    #0BCE
    #instruction: LD   DE,1FD5
    advance (10)
    D := 1F;
    E := D5;
    jump (0BD1);

0BCF:

    #0BCF
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0BD0);

0BD0:

    #0BD0
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (0BD1);

0BD1:

    #0BD1
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := D4;
    #return-to: 0BD4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AE2);

0BD2:

    #0BD2
    #instruction: JP   PO,CD0A
    if (!FlagP) {
      advance (10)
      jump (CD0A);
    } else {
      advance (10)
      jump (0BD5);
    }

0BD3:

    #0BD3
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0BD4);

0BD4:

    #0BD4
    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := D7;
    #return-to: 0BD7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A80);

0BD5:

    #0BD5
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (0BD6);

0BD6:

    #0BD6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0BD7);

0BD7:

    #0BD7
    #instruction: CALL 189E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 0BDA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (189E);

0BD8:

    #0BD8
    #instruction: SBC  (HL)
    let:16 a1 = addWithCarry(!FlagCY,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BD9);

0BD9:

    #0BD9
    #instruction: *NOP
    advance (4)
    jump (0BDA);

0BDA:

    #0BDA
    #instruction: LD   HL,20EC
    advance (10)
    H := 20;
    L := EC;
    jump (0BDD);

0BDB:

    #0BDB
    #instruction: CALL PE,7E20
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := DE;
      #return-to: 0BDE
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (7E20);
    } else {
      advance (11)
      jump (0BDE);
    }

0BDC:

    #0BDC
    #instruction: *NOP
    advance (4)
    jump (0BDD);

0BDD:

    #0BDD
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (0BDE);

0BDE:

    #0BDE
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0BDF);

0BDF:

    #0BDF
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (0BE1);

0BE0:

    #0BE0
    #instruction: LD   BC,CD77
    advance (10)
    B := CD;
    C := 77;
    jump (0BE3);

0BE1:

    #0BE1
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (0BE2);

0BE2:

    #0BE2
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := E5;
    #return-to: 0BE5
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

0BE3:

    #0BE3
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BE5);

0BE4:

    #0BE4
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0BE5);

0BE5:

    #0BE5
    #instruction: JP   18DF
    advance (10)
    jump (18DF);

0BE6:

    #0BE6
    #instruction: RST  3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := E7;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0018);

0BE7:

    #0BE7
    #instruction: *NOP
    advance (4)
    jump (0BE8);

0BE8:

    #0BE8
    #instruction: LD   DE,1DAB
    advance (10)
    D := 1D;
    E := AB;
    jump (0BEB);

0BE9:

    #0BE9
    #instruction: XOR  E
    let:8 a1 = (E ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (0BEA);

0BEA:

    #0BEA
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (0BEB);

0BEB:

    #0BEB
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := EE;
    #return-to: 0BEE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

0BEC:

    #0BEC
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BED);

0BED:

    #0BED
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0BEE);

0BEE:

    #0BEE
    #instruction: JP   0B0B
    advance (10)
    jump (0B0B);

0BEF:

    #0BEF
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0BF0);

0BF0:

    #0BF0
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (0BF1);

0BF1:

    #0BF1
    #instruction: CALL 190A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := F4;
    #return-to: 0BF4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (190A);

0BF2:

    #0BF2
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (0BF3);

0BF3:

    #0BF3
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0BF4);

0BF4:

    #0BF4
    #instruction: JP   199A
    advance (10)
    jump (199A);

0BF5:

    #0BF5
    #instruction: SBC  D
    let:16 a1 = addWithCarry(!FlagCY,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (0BF6);

0BF6:

    #0BF6
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (0BF7);

0BF7:

    #0BF7
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0BF8);

0BF8:

    #0BF8
    #instruction: NOP
    advance (4)
    jump (0BF9);

0BF9:

    #0BF9
    #instruction: *NOP
    advance (4)
    jump (0BFA);

0BFA:

    #0BFA
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (0BFB);

0BFB:

    #0BFB
    #instruction: LD   C,26
    advance (7)
    C := 26;
    jump (0BFD);

0BFC:

    #0BFC
    #instruction: LD   H,02
    advance (7)
    H := 02;
    jump (0BFE);

0BFD:

    #0BFD
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (0BFE);

0BFE:

    #0BFE
    #instruction: LD   C,0F
    advance (7)
    C := 0F;
    jump (0C00);

0BFF:

    #0BFF
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (0C00);

0C00:

    #0C00
    #instruction: NOP
    advance (4)
    jump (0C01);

0C01:

    #0C01
    #instruction: NOP
    advance (4)
    jump (0C02);

0C02:

    #0C02
    #instruction: NOP
    advance (4)
    jump (0C03);

0C03:

    #0C03
    #instruction: NOP
    advance (4)
    jump (0C04);

0C04:

    #0C04
    #instruction: NOP
    advance (4)
    jump (0C05);

0C05:

    #0C05
    #instruction: NOP
    advance (4)
    jump (0C06);

0C06:

    #0C06
    #instruction: NOP
    advance (4)
    jump (0C07);

0C07:

    #0C07
    #instruction: NOP
    advance (4)
    jump (0C08);

0C08:

    #0C08
    #instruction: NOP
    advance (4)
    jump (0C09);

0C09:

    #0C09
    #instruction: NOP
    advance (4)
    jump (0C0A);

0C0A:

    #0C0A
    #instruction: NOP
    advance (4)
    jump (0C0B);

0C0B:

    #0C0B
    #instruction: NOP
    advance (4)
    jump (0C0C);

0C0C:

    #0C0C
    #instruction: NOP
    advance (4)
    jump (0C0D);

0C0D:

    #0C0D
    #instruction: NOP
    advance (4)
    jump (0C0E);

0C0E:

    #0C0E
    #instruction: NOP
    advance (4)
    jump (0C0F);

0C0F:

    #0C0F
    #instruction: NOP
    advance (4)
    jump (0C10);

0C10:

    #0C10
    #instruction: NOP
    advance (4)
    jump (0C11);

0C11:

    #0C11
    #instruction: NOP
    advance (4)
    jump (0C12);

0C12:

    #0C12
    #instruction: NOP
    advance (4)
    jump (0C13);

0C13:

    #0C13
    #instruction: NOP
    advance (4)
    jump (0C14);

0C14:

    #0C14
    #instruction: NOP
    advance (4)
    jump (0C15);

0C15:

    #0C15
    #instruction: NOP
    advance (4)
    jump (0C16);

0C16:

    #0C16
    #instruction: NOP
    advance (4)
    jump (0C17);

0C17:

    #0C17
    #instruction: NOP
    advance (4)
    jump (0C18);

0C18:

    #0C18
    #instruction: NOP
    advance (4)
    jump (0C19);

0C19:

    #0C19
    #instruction: NOP
    advance (4)
    jump (0C1A);

0C1A:

    #0C1A
    #instruction: NOP
    advance (4)
    jump (0C1B);

0C1B:

    #0C1B
    #instruction: NOP
    advance (4)
    jump (0C1C);

0C1C:

    #0C1C
    #instruction: NOP
    advance (4)
    jump (0C1D);

0C1D:

    #0C1D
    #instruction: NOP
    advance (4)
    jump (0C1E);

0C1E:

    #0C1E
    #instruction: NOP
    advance (4)
    jump (0C1F);

0C1F:

    #0C1F
    #instruction: NOP
    advance (4)
    jump (0C20);

0C20:

    #0C20
    #instruction: NOP
    advance (4)
    jump (0C21);

0C21:

    #0C21
    #instruction: NOP
    advance (4)
    jump (0C22);

0C22:

    #0C22
    #instruction: NOP
    advance (4)
    jump (0C23);

0C23:

    #0C23
    #instruction: NOP
    advance (4)
    jump (0C24);

0C24:

    #0C24
    #instruction: NOP
    advance (4)
    jump (0C25);

0C25:

    #0C25
    #instruction: NOP
    advance (4)
    jump (0C26);

0C26:

    #0C26
    #instruction: NOP
    advance (4)
    jump (0C27);

0C27:

    #0C27
    #instruction: NOP
    advance (4)
    jump (0C28);

0C28:

    #0C28
    #instruction: NOP
    advance (4)
    jump (0C29);

0C29:

    #0C29
    #instruction: NOP
    advance (4)
    jump (0C2A);

0C2A:

    #0C2A
    #instruction: NOP
    advance (4)
    jump (0C2B);

0C2B:

    #0C2B
    #instruction: NOP
    advance (4)
    jump (0C2C);

0C2C:

    #0C2C
    #instruction: NOP
    advance (4)
    jump (0C2D);

0C2D:

    #0C2D
    #instruction: NOP
    advance (4)
    jump (0C2E);

0C2E:

    #0C2E
    #instruction: NOP
    advance (4)
    jump (0C2F);

0C2F:

    #0C2F
    #instruction: NOP
    advance (4)
    jump (0C30);

0C30:

    #0C30
    #instruction: NOP
    advance (4)
    jump (0C31);

0C31:

    #0C31
    #instruction: NOP
    advance (4)
    jump (0C32);

0C32:

    #0C32
    #instruction: NOP
    advance (4)
    jump (0C33);

0C33:

    #0C33
    #instruction: NOP
    advance (4)
    jump (0C34);

0C34:

    #0C34
    #instruction: NOP
    advance (4)
    jump (0C35);

0C35:

    #0C35
    #instruction: NOP
    advance (4)
    jump (0C36);

0C36:

    #0C36
    #instruction: NOP
    advance (4)
    jump (0C37);

0C37:

    #0C37
    #instruction: NOP
    advance (4)
    jump (0C38);

0C38:

    #0C38
    #instruction: NOP
    advance (4)
    jump (0C39);

0C39:

    #0C39
    #instruction: NOP
    advance (4)
    jump (0C3A);

0C3A:

    #0C3A
    #instruction: NOP
    advance (4)
    jump (0C3B);

0C3B:

    #0C3B
    #instruction: NOP
    advance (4)
    jump (0C3C);

0C3C:

    #0C3C
    #instruction: NOP
    advance (4)
    jump (0C3D);

0C3D:

    #0C3D
    #instruction: NOP
    advance (4)
    jump (0C3E);

0C3E:

    #0C3E
    #instruction: NOP
    advance (4)
    jump (0C3F);

0C3F:

    #0C3F
    #instruction: NOP
    advance (4)
    jump (0C40);

0C40:

    #0C40
    #instruction: NOP
    advance (4)
    jump (0C41);

0C41:

    #0C41
    #instruction: NOP
    advance (4)
    jump (0C42);

0C42:

    #0C42
    #instruction: NOP
    advance (4)
    jump (0C43);

0C43:

    #0C43
    #instruction: NOP
    advance (4)
    jump (0C44);

0C44:

    #0C44
    #instruction: NOP
    advance (4)
    jump (0C45);

0C45:

    #0C45
    #instruction: NOP
    advance (4)
    jump (0C46);

0C46:

    #0C46
    #instruction: NOP
    advance (4)
    jump (0C47);

0C47:

    #0C47
    #instruction: NOP
    advance (4)
    jump (0C48);

0C48:

    #0C48
    #instruction: NOP
    advance (4)
    jump (0C49);

0C49:

    #0C49
    #instruction: NOP
    advance (4)
    jump (0C4A);

0C4A:

    #0C4A
    #instruction: NOP
    advance (4)
    jump (0C4B);

0C4B:

    #0C4B
    #instruction: NOP
    advance (4)
    jump (0C4C);

0C4C:

    #0C4C
    #instruction: NOP
    advance (4)
    jump (0C4D);

0C4D:

    #0C4D
    #instruction: NOP
    advance (4)
    jump (0C4E);

0C4E:

    #0C4E
    #instruction: NOP
    advance (4)
    jump (0C4F);

0C4F:

    #0C4F
    #instruction: NOP
    advance (4)
    jump (0C50);

0C50:

    #0C50
    #instruction: NOP
    advance (4)
    jump (0C51);

0C51:

    #0C51
    #instruction: NOP
    advance (4)
    jump (0C52);

0C52:

    #0C52
    #instruction: NOP
    advance (4)
    jump (0C53);

0C53:

    #0C53
    #instruction: NOP
    advance (4)
    jump (0C54);

0C54:

    #0C54
    #instruction: NOP
    advance (4)
    jump (0C55);

0C55:

    #0C55
    #instruction: NOP
    advance (4)
    jump (0C56);

0C56:

    #0C56
    #instruction: NOP
    advance (4)
    jump (0C57);

0C57:

    #0C57
    #instruction: NOP
    advance (4)
    jump (0C58);

0C58:

    #0C58
    #instruction: NOP
    advance (4)
    jump (0C59);

0C59:

    #0C59
    #instruction: NOP
    advance (4)
    jump (0C5A);

0C5A:

    #0C5A
    #instruction: NOP
    advance (4)
    jump (0C5B);

0C5B:

    #0C5B
    #instruction: NOP
    advance (4)
    jump (0C5C);

0C5C:

    #0C5C
    #instruction: NOP
    advance (4)
    jump (0C5D);

0C5D:

    #0C5D
    #instruction: NOP
    advance (4)
    jump (0C5E);

0C5E:

    #0C5E
    #instruction: NOP
    advance (4)
    jump (0C5F);

0C5F:

    #0C5F
    #instruction: NOP
    advance (4)
    jump (0C60);

0C60:

    #0C60
    #instruction: NOP
    advance (4)
    jump (0C61);

0C61:

    #0C61
    #instruction: NOP
    advance (4)
    jump (0C62);

0C62:

    #0C62
    #instruction: NOP
    advance (4)
    jump (0C63);

0C63:

    #0C63
    #instruction: NOP
    advance (4)
    jump (0C64);

0C64:

    #0C64
    #instruction: NOP
    advance (4)
    jump (0C65);

0C65:

    #0C65
    #instruction: NOP
    advance (4)
    jump (0C66);

0C66:

    #0C66
    #instruction: NOP
    advance (4)
    jump (0C67);

0C67:

    #0C67
    #instruction: NOP
    advance (4)
    jump (0C68);

0C68:

    #0C68
    #instruction: NOP
    advance (4)
    jump (0C69);

0C69:

    #0C69
    #instruction: NOP
    advance (4)
    jump (0C6A);

0C6A:

    #0C6A
    #instruction: NOP
    advance (4)
    jump (0C6B);

0C6B:

    #0C6B
    #instruction: NOP
    advance (4)
    jump (0C6C);

0C6C:

    #0C6C
    #instruction: NOP
    advance (4)
    jump (0C6D);

0C6D:

    #0C6D
    #instruction: NOP
    advance (4)
    jump (0C6E);

0C6E:

    #0C6E
    #instruction: NOP
    advance (4)
    jump (0C6F);

0C6F:

    #0C6F
    #instruction: NOP
    advance (4)
    jump (0C70);

0C70:

    #0C70
    #instruction: NOP
    advance (4)
    jump (0C71);

0C71:

    #0C71
    #instruction: NOP
    advance (4)
    jump (0C72);

0C72:

    #0C72
    #instruction: NOP
    advance (4)
    jump (0C73);

0C73:

    #0C73
    #instruction: NOP
    advance (4)
    jump (0C74);

0C74:

    #0C74
    #instruction: NOP
    advance (4)
    jump (0C75);

0C75:

    #0C75
    #instruction: NOP
    advance (4)
    jump (0C76);

0C76:

    #0C76
    #instruction: NOP
    advance (4)
    jump (0C77);

0C77:

    #0C77
    #instruction: NOP
    advance (4)
    jump (0C78);

0C78:

    #0C78
    #instruction: NOP
    advance (4)
    jump (0C79);

0C79:

    #0C79
    #instruction: NOP
    advance (4)
    jump (0C7A);

0C7A:

    #0C7A
    #instruction: NOP
    advance (4)
    jump (0C7B);

0C7B:

    #0C7B
    #instruction: NOP
    advance (4)
    jump (0C7C);

0C7C:

    #0C7C
    #instruction: NOP
    advance (4)
    jump (0C7D);

0C7D:

    #0C7D
    #instruction: NOP
    advance (4)
    jump (0C7E);

0C7E:

    #0C7E
    #instruction: NOP
    advance (4)
    jump (0C7F);

0C7F:

    #0C7F
    #instruction: NOP
    advance (4)
    jump (0C80);

0C80:

    #0C80
    #instruction: NOP
    advance (4)
    jump (0C81);

0C81:

    #0C81
    #instruction: NOP
    advance (4)
    jump (0C82);

0C82:

    #0C82
    #instruction: NOP
    advance (4)
    jump (0C83);

0C83:

    #0C83
    #instruction: NOP
    advance (4)
    jump (0C84);

0C84:

    #0C84
    #instruction: NOP
    advance (4)
    jump (0C85);

0C85:

    #0C85
    #instruction: NOP
    advance (4)
    jump (0C86);

0C86:

    #0C86
    #instruction: NOP
    advance (4)
    jump (0C87);

0C87:

    #0C87
    #instruction: NOP
    advance (4)
    jump (0C88);

0C88:

    #0C88
    #instruction: NOP
    advance (4)
    jump (0C89);

0C89:

    #0C89
    #instruction: NOP
    advance (4)
    jump (0C8A);

0C8A:

    #0C8A
    #instruction: NOP
    advance (4)
    jump (0C8B);

0C8B:

    #0C8B
    #instruction: NOP
    advance (4)
    jump (0C8C);

0C8C:

    #0C8C
    #instruction: NOP
    advance (4)
    jump (0C8D);

0C8D:

    #0C8D
    #instruction: NOP
    advance (4)
    jump (0C8E);

0C8E:

    #0C8E
    #instruction: NOP
    advance (4)
    jump (0C8F);

0C8F:

    #0C8F
    #instruction: NOP
    advance (4)
    jump (0C90);

0C90:

    #0C90
    #instruction: NOP
    advance (4)
    jump (0C91);

0C91:

    #0C91
    #instruction: NOP
    advance (4)
    jump (0C92);

0C92:

    #0C92
    #instruction: NOP
    advance (4)
    jump (0C93);

0C93:

    #0C93
    #instruction: NOP
    advance (4)
    jump (0C94);

0C94:

    #0C94
    #instruction: NOP
    advance (4)
    jump (0C95);

0C95:

    #0C95
    #instruction: NOP
    advance (4)
    jump (0C96);

0C96:

    #0C96
    #instruction: NOP
    advance (4)
    jump (0C97);

0C97:

    #0C97
    #instruction: NOP
    advance (4)
    jump (0C98);

0C98:

    #0C98
    #instruction: NOP
    advance (4)
    jump (0C99);

0C99:

    #0C99
    #instruction: NOP
    advance (4)
    jump (0C9A);

0C9A:

    #0C9A
    #instruction: NOP
    advance (4)
    jump (0C9B);

0C9B:

    #0C9B
    #instruction: NOP
    advance (4)
    jump (0C9C);

0C9C:

    #0C9C
    #instruction: NOP
    advance (4)
    jump (0C9D);

0C9D:

    #0C9D
    #instruction: NOP
    advance (4)
    jump (0C9E);

0C9E:

    #0C9E
    #instruction: NOP
    advance (4)
    jump (0C9F);

0C9F:

    #0C9F
    #instruction: NOP
    advance (4)
    jump (0CA0);

0CA0:

    #0CA0
    #instruction: NOP
    advance (4)
    jump (0CA1);

0CA1:

    #0CA1
    #instruction: NOP
    advance (4)
    jump (0CA2);

0CA2:

    #0CA2
    #instruction: NOP
    advance (4)
    jump (0CA3);

0CA3:

    #0CA3
    #instruction: NOP
    advance (4)
    jump (0CA4);

0CA4:

    #0CA4
    #instruction: NOP
    advance (4)
    jump (0CA5);

0CA5:

    #0CA5
    #instruction: NOP
    advance (4)
    jump (0CA6);

0CA6:

    #0CA6
    #instruction: NOP
    advance (4)
    jump (0CA7);

0CA7:

    #0CA7
    #instruction: NOP
    advance (4)
    jump (0CA8);

0CA8:

    #0CA8
    #instruction: NOP
    advance (4)
    jump (0CA9);

0CA9:

    #0CA9
    #instruction: NOP
    advance (4)
    jump (0CAA);

0CAA:

    #0CAA
    #instruction: NOP
    advance (4)
    jump (0CAB);

0CAB:

    #0CAB
    #instruction: NOP
    advance (4)
    jump (0CAC);

0CAC:

    #0CAC
    #instruction: NOP
    advance (4)
    jump (0CAD);

0CAD:

    #0CAD
    #instruction: NOP
    advance (4)
    jump (0CAE);

0CAE:

    #0CAE
    #instruction: NOP
    advance (4)
    jump (0CAF);

0CAF:

    #0CAF
    #instruction: NOP
    advance (4)
    jump (0CB0);

0CB0:

    #0CB0
    #instruction: NOP
    advance (4)
    jump (0CB1);

0CB1:

    #0CB1
    #instruction: NOP
    advance (4)
    jump (0CB2);

0CB2:

    #0CB2
    #instruction: NOP
    advance (4)
    jump (0CB3);

0CB3:

    #0CB3
    #instruction: NOP
    advance (4)
    jump (0CB4);

0CB4:

    #0CB4
    #instruction: NOP
    advance (4)
    jump (0CB5);

0CB5:

    #0CB5
    #instruction: NOP
    advance (4)
    jump (0CB6);

0CB6:

    #0CB6
    #instruction: NOP
    advance (4)
    jump (0CB7);

0CB7:

    #0CB7
    #instruction: NOP
    advance (4)
    jump (0CB8);

0CB8:

    #0CB8
    #instruction: NOP
    advance (4)
    jump (0CB9);

0CB9:

    #0CB9
    #instruction: NOP
    advance (4)
    jump (0CBA);

0CBA:

    #0CBA
    #instruction: NOP
    advance (4)
    jump (0CBB);

0CBB:

    #0CBB
    #instruction: NOP
    advance (4)
    jump (0CBC);

0CBC:

    #0CBC
    #instruction: NOP
    advance (4)
    jump (0CBD);

0CBD:

    #0CBD
    #instruction: NOP
    advance (4)
    jump (0CBE);

0CBE:

    #0CBE
    #instruction: NOP
    advance (4)
    jump (0CBF);

0CBF:

    #0CBF
    #instruction: NOP
    advance (4)
    jump (0CC0);

0CC0:

    #0CC0
    #instruction: NOP
    advance (4)
    jump (0CC1);

0CC1:

    #0CC1
    #instruction: NOP
    advance (4)
    jump (0CC2);

0CC2:

    #0CC2
    #instruction: NOP
    advance (4)
    jump (0CC3);

0CC3:

    #0CC3
    #instruction: NOP
    advance (4)
    jump (0CC4);

0CC4:

    #0CC4
    #instruction: NOP
    advance (4)
    jump (0CC5);

0CC5:

    #0CC5
    #instruction: NOP
    advance (4)
    jump (0CC6);

0CC6:

    #0CC6
    #instruction: NOP
    advance (4)
    jump (0CC7);

0CC7:

    #0CC7
    #instruction: NOP
    advance (4)
    jump (0CC8);

0CC8:

    #0CC8
    #instruction: NOP
    advance (4)
    jump (0CC9);

0CC9:

    #0CC9
    #instruction: NOP
    advance (4)
    jump (0CCA);

0CCA:

    #0CCA
    #instruction: NOP
    advance (4)
    jump (0CCB);

0CCB:

    #0CCB
    #instruction: NOP
    advance (4)
    jump (0CCC);

0CCC:

    #0CCC
    #instruction: NOP
    advance (4)
    jump (0CCD);

0CCD:

    #0CCD
    #instruction: NOP
    advance (4)
    jump (0CCE);

0CCE:

    #0CCE
    #instruction: NOP
    advance (4)
    jump (0CCF);

0CCF:

    #0CCF
    #instruction: NOP
    advance (4)
    jump (0CD0);

0CD0:

    #0CD0
    #instruction: NOP
    advance (4)
    jump (0CD1);

0CD1:

    #0CD1
    #instruction: NOP
    advance (4)
    jump (0CD2);

0CD2:

    #0CD2
    #instruction: NOP
    advance (4)
    jump (0CD3);

0CD3:

    #0CD3
    #instruction: NOP
    advance (4)
    jump (0CD4);

0CD4:

    #0CD4
    #instruction: NOP
    advance (4)
    jump (0CD5);

0CD5:

    #0CD5
    #instruction: NOP
    advance (4)
    jump (0CD6);

0CD6:

    #0CD6
    #instruction: NOP
    advance (4)
    jump (0CD7);

0CD7:

    #0CD7
    #instruction: NOP
    advance (4)
    jump (0CD8);

0CD8:

    #0CD8
    #instruction: NOP
    advance (4)
    jump (0CD9);

0CD9:

    #0CD9
    #instruction: NOP
    advance (4)
    jump (0CDA);

0CDA:

    #0CDA
    #instruction: NOP
    advance (4)
    jump (0CDB);

0CDB:

    #0CDB
    #instruction: NOP
    advance (4)
    jump (0CDC);

0CDC:

    #0CDC
    #instruction: NOP
    advance (4)
    jump (0CDD);

0CDD:

    #0CDD
    #instruction: NOP
    advance (4)
    jump (0CDE);

0CDE:

    #0CDE
    #instruction: NOP
    advance (4)
    jump (0CDF);

0CDF:

    #0CDF
    #instruction: NOP
    advance (4)
    jump (0CE0);

0CE0:

    #0CE0
    #instruction: NOP
    advance (4)
    jump (0CE1);

0CE1:

    #0CE1
    #instruction: NOP
    advance (4)
    jump (0CE2);

0CE2:

    #0CE2
    #instruction: NOP
    advance (4)
    jump (0CE3);

0CE3:

    #0CE3
    #instruction: NOP
    advance (4)
    jump (0CE4);

0CE4:

    #0CE4
    #instruction: NOP
    advance (4)
    jump (0CE5);

0CE5:

    #0CE5
    #instruction: NOP
    advance (4)
    jump (0CE6);

0CE6:

    #0CE6
    #instruction: NOP
    advance (4)
    jump (0CE7);

0CE7:

    #0CE7
    #instruction: NOP
    advance (4)
    jump (0CE8);

0CE8:

    #0CE8
    #instruction: NOP
    advance (4)
    jump (0CE9);

0CE9:

    #0CE9
    #instruction: NOP
    advance (4)
    jump (0CEA);

0CEA:

    #0CEA
    #instruction: NOP
    advance (4)
    jump (0CEB);

0CEB:

    #0CEB
    #instruction: NOP
    advance (4)
    jump (0CEC);

0CEC:

    #0CEC
    #instruction: NOP
    advance (4)
    jump (0CED);

0CED:

    #0CED
    #instruction: NOP
    advance (4)
    jump (0CEE);

0CEE:

    #0CEE
    #instruction: NOP
    advance (4)
    jump (0CEF);

0CEF:

    #0CEF
    #instruction: NOP
    advance (4)
    jump (0CF0);

0CF0:

    #0CF0
    #instruction: NOP
    advance (4)
    jump (0CF1);

0CF1:

    #0CF1
    #instruction: NOP
    advance (4)
    jump (0CF2);

0CF2:

    #0CF2
    #instruction: NOP
    advance (4)
    jump (0CF3);

0CF3:

    #0CF3
    #instruction: NOP
    advance (4)
    jump (0CF4);

0CF4:

    #0CF4
    #instruction: NOP
    advance (4)
    jump (0CF5);

0CF5:

    #0CF5
    #instruction: NOP
    advance (4)
    jump (0CF6);

0CF6:

    #0CF6
    #instruction: NOP
    advance (4)
    jump (0CF7);

0CF7:

    #0CF7
    #instruction: NOP
    advance (4)
    jump (0CF8);

0CF8:

    #0CF8
    #instruction: NOP
    advance (4)
    jump (0CF9);

0CF9:

    #0CF9
    #instruction: NOP
    advance (4)
    jump (0CFA);

0CFA:

    #0CFA
    #instruction: NOP
    advance (4)
    jump (0CFB);

0CFB:

    #0CFB
    #instruction: NOP
    advance (4)
    jump (0CFC);

0CFC:

    #0CFC
    #instruction: NOP
    advance (4)
    jump (0CFD);

0CFD:

    #0CFD
    #instruction: NOP
    advance (4)
    jump (0CFE);

0CFE:

    #0CFE
    #instruction: NOP
    advance (4)
    jump (0CFF);

0CFF:

    #0CFF
    #instruction: NOP
    advance (4)
    jump (0D00);

0D00:

    #0D00
    #instruction: NOP
    advance (4)
    jump (0D01);

0D01:

    #0D01
    #instruction: NOP
    advance (4)
    jump (0D02);

0D02:

    #0D02
    #instruction: NOP
    advance (4)
    jump (0D03);

0D03:

    #0D03
    #instruction: NOP
    advance (4)
    jump (0D04);

0D04:

    #0D04
    #instruction: NOP
    advance (4)
    jump (0D05);

0D05:

    #0D05
    #instruction: NOP
    advance (4)
    jump (0D06);

0D06:

    #0D06
    #instruction: NOP
    advance (4)
    jump (0D07);

0D07:

    #0D07
    #instruction: NOP
    advance (4)
    jump (0D08);

0D08:

    #0D08
    #instruction: NOP
    advance (4)
    jump (0D09);

0D09:

    #0D09
    #instruction: NOP
    advance (4)
    jump (0D0A);

0D0A:

    #0D0A
    #instruction: NOP
    advance (4)
    jump (0D0B);

0D0B:

    #0D0B
    #instruction: NOP
    advance (4)
    jump (0D0C);

0D0C:

    #0D0C
    #instruction: NOP
    advance (4)
    jump (0D0D);

0D0D:

    #0D0D
    #instruction: NOP
    advance (4)
    jump (0D0E);

0D0E:

    #0D0E
    #instruction: NOP
    advance (4)
    jump (0D0F);

0D0F:

    #0D0F
    #instruction: NOP
    advance (4)
    jump (0D10);

0D10:

    #0D10
    #instruction: NOP
    advance (4)
    jump (0D11);

0D11:

    #0D11
    #instruction: NOP
    advance (4)
    jump (0D12);

0D12:

    #0D12
    #instruction: NOP
    advance (4)
    jump (0D13);

0D13:

    #0D13
    #instruction: NOP
    advance (4)
    jump (0D14);

0D14:

    #0D14
    #instruction: NOP
    advance (4)
    jump (0D15);

0D15:

    #0D15
    #instruction: NOP
    advance (4)
    jump (0D16);

0D16:

    #0D16
    #instruction: NOP
    advance (4)
    jump (0D17);

0D17:

    #0D17
    #instruction: NOP
    advance (4)
    jump (0D18);

0D18:

    #0D18
    #instruction: NOP
    advance (4)
    jump (0D19);

0D19:

    #0D19
    #instruction: NOP
    advance (4)
    jump (0D1A);

0D1A:

    #0D1A
    #instruction: NOP
    advance (4)
    jump (0D1B);

0D1B:

    #0D1B
    #instruction: NOP
    advance (4)
    jump (0D1C);

0D1C:

    #0D1C
    #instruction: NOP
    advance (4)
    jump (0D1D);

0D1D:

    #0D1D
    #instruction: NOP
    advance (4)
    jump (0D1E);

0D1E:

    #0D1E
    #instruction: NOP
    advance (4)
    jump (0D1F);

0D1F:

    #0D1F
    #instruction: NOP
    advance (4)
    jump (0D20);

0D20:

    #0D20
    #instruction: NOP
    advance (4)
    jump (0D21);

0D21:

    #0D21
    #instruction: NOP
    advance (4)
    jump (0D22);

0D22:

    #0D22
    #instruction: NOP
    advance (4)
    jump (0D23);

0D23:

    #0D23
    #instruction: NOP
    advance (4)
    jump (0D24);

0D24:

    #0D24
    #instruction: NOP
    advance (4)
    jump (0D25);

0D25:

    #0D25
    #instruction: NOP
    advance (4)
    jump (0D26);

0D26:

    #0D26
    #instruction: NOP
    advance (4)
    jump (0D27);

0D27:

    #0D27
    #instruction: NOP
    advance (4)
    jump (0D28);

0D28:

    #0D28
    #instruction: NOP
    advance (4)
    jump (0D29);

0D29:

    #0D29
    #instruction: NOP
    advance (4)
    jump (0D2A);

0D2A:

    #0D2A
    #instruction: NOP
    advance (4)
    jump (0D2B);

0D2B:

    #0D2B
    #instruction: NOP
    advance (4)
    jump (0D2C);

0D2C:

    #0D2C
    #instruction: NOP
    advance (4)
    jump (0D2D);

0D2D:

    #0D2D
    #instruction: NOP
    advance (4)
    jump (0D2E);

0D2E:

    #0D2E
    #instruction: NOP
    advance (4)
    jump (0D2F);

0D2F:

    #0D2F
    #instruction: NOP
    advance (4)
    jump (0D30);

0D30:

    #0D30
    #instruction: NOP
    advance (4)
    jump (0D31);

0D31:

    #0D31
    #instruction: NOP
    advance (4)
    jump (0D32);

0D32:

    #0D32
    #instruction: NOP
    advance (4)
    jump (0D33);

0D33:

    #0D33
    #instruction: NOP
    advance (4)
    jump (0D34);

0D34:

    #0D34
    #instruction: NOP
    advance (4)
    jump (0D35);

0D35:

    #0D35
    #instruction: NOP
    advance (4)
    jump (0D36);

0D36:

    #0D36
    #instruction: NOP
    advance (4)
    jump (0D37);

0D37:

    #0D37
    #instruction: NOP
    advance (4)
    jump (0D38);

0D38:

    #0D38
    #instruction: NOP
    advance (4)
    jump (0D39);

0D39:

    #0D39
    #instruction: NOP
    advance (4)
    jump (0D3A);

0D3A:

    #0D3A
    #instruction: NOP
    advance (4)
    jump (0D3B);

0D3B:

    #0D3B
    #instruction: NOP
    advance (4)
    jump (0D3C);

0D3C:

    #0D3C
    #instruction: NOP
    advance (4)
    jump (0D3D);

0D3D:

    #0D3D
    #instruction: NOP
    advance (4)
    jump (0D3E);

0D3E:

    #0D3E
    #instruction: NOP
    advance (4)
    jump (0D3F);

0D3F:

    #0D3F
    #instruction: NOP
    advance (4)
    jump (0D40);

0D40:

    #0D40
    #instruction: NOP
    advance (4)
    jump (0D41);

0D41:

    #0D41
    #instruction: NOP
    advance (4)
    jump (0D42);

0D42:

    #0D42
    #instruction: NOP
    advance (4)
    jump (0D43);

0D43:

    #0D43
    #instruction: NOP
    advance (4)
    jump (0D44);

0D44:

    #0D44
    #instruction: NOP
    advance (4)
    jump (0D45);

0D45:

    #0D45
    #instruction: NOP
    advance (4)
    jump (0D46);

0D46:

    #0D46
    #instruction: NOP
    advance (4)
    jump (0D47);

0D47:

    #0D47
    #instruction: NOP
    advance (4)
    jump (0D48);

0D48:

    #0D48
    #instruction: NOP
    advance (4)
    jump (0D49);

0D49:

    #0D49
    #instruction: NOP
    advance (4)
    jump (0D4A);

0D4A:

    #0D4A
    #instruction: NOP
    advance (4)
    jump (0D4B);

0D4B:

    #0D4B
    #instruction: NOP
    advance (4)
    jump (0D4C);

0D4C:

    #0D4C
    #instruction: NOP
    advance (4)
    jump (0D4D);

0D4D:

    #0D4D
    #instruction: NOP
    advance (4)
    jump (0D4E);

0D4E:

    #0D4E
    #instruction: NOP
    advance (4)
    jump (0D4F);

0D4F:

    #0D4F
    #instruction: NOP
    advance (4)
    jump (0D50);

0D50:

    #0D50
    #instruction: NOP
    advance (4)
    jump (0D51);

0D51:

    #0D51
    #instruction: NOP
    advance (4)
    jump (0D52);

0D52:

    #0D52
    #instruction: NOP
    advance (4)
    jump (0D53);

0D53:

    #0D53
    #instruction: NOP
    advance (4)
    jump (0D54);

0D54:

    #0D54
    #instruction: NOP
    advance (4)
    jump (0D55);

0D55:

    #0D55
    #instruction: NOP
    advance (4)
    jump (0D56);

0D56:

    #0D56
    #instruction: NOP
    advance (4)
    jump (0D57);

0D57:

    #0D57
    #instruction: NOP
    advance (4)
    jump (0D58);

0D58:

    #0D58
    #instruction: NOP
    advance (4)
    jump (0D59);

0D59:

    #0D59
    #instruction: NOP
    advance (4)
    jump (0D5A);

0D5A:

    #0D5A
    #instruction: NOP
    advance (4)
    jump (0D5B);

0D5B:

    #0D5B
    #instruction: NOP
    advance (4)
    jump (0D5C);

0D5C:

    #0D5C
    #instruction: NOP
    advance (4)
    jump (0D5D);

0D5D:

    #0D5D
    #instruction: NOP
    advance (4)
    jump (0D5E);

0D5E:

    #0D5E
    #instruction: NOP
    advance (4)
    jump (0D5F);

0D5F:

    #0D5F
    #instruction: NOP
    advance (4)
    jump (0D60);

0D60:

    #0D60
    #instruction: NOP
    advance (4)
    jump (0D61);

0D61:

    #0D61
    #instruction: NOP
    advance (4)
    jump (0D62);

0D62:

    #0D62
    #instruction: NOP
    advance (4)
    jump (0D63);

0D63:

    #0D63
    #instruction: NOP
    advance (4)
    jump (0D64);

0D64:

    #0D64
    #instruction: NOP
    advance (4)
    jump (0D65);

0D65:

    #0D65
    #instruction: NOP
    advance (4)
    jump (0D66);

0D66:

    #0D66
    #instruction: NOP
    advance (4)
    jump (0D67);

0D67:

    #0D67
    #instruction: NOP
    advance (4)
    jump (0D68);

0D68:

    #0D68
    #instruction: NOP
    advance (4)
    jump (0D69);

0D69:

    #0D69
    #instruction: NOP
    advance (4)
    jump (0D6A);

0D6A:

    #0D6A
    #instruction: NOP
    advance (4)
    jump (0D6B);

0D6B:

    #0D6B
    #instruction: NOP
    advance (4)
    jump (0D6C);

0D6C:

    #0D6C
    #instruction: NOP
    advance (4)
    jump (0D6D);

0D6D:

    #0D6D
    #instruction: NOP
    advance (4)
    jump (0D6E);

0D6E:

    #0D6E
    #instruction: NOP
    advance (4)
    jump (0D6F);

0D6F:

    #0D6F
    #instruction: NOP
    advance (4)
    jump (0D70);

0D70:

    #0D70
    #instruction: NOP
    advance (4)
    jump (0D71);

0D71:

    #0D71
    #instruction: NOP
    advance (4)
    jump (0D72);

0D72:

    #0D72
    #instruction: NOP
    advance (4)
    jump (0D73);

0D73:

    #0D73
    #instruction: NOP
    advance (4)
    jump (0D74);

0D74:

    #0D74
    #instruction: NOP
    advance (4)
    jump (0D75);

0D75:

    #0D75
    #instruction: NOP
    advance (4)
    jump (0D76);

0D76:

    #0D76
    #instruction: NOP
    advance (4)
    jump (0D77);

0D77:

    #0D77
    #instruction: NOP
    advance (4)
    jump (0D78);

0D78:

    #0D78
    #instruction: NOP
    advance (4)
    jump (0D79);

0D79:

    #0D79
    #instruction: NOP
    advance (4)
    jump (0D7A);

0D7A:

    #0D7A
    #instruction: NOP
    advance (4)
    jump (0D7B);

0D7B:

    #0D7B
    #instruction: NOP
    advance (4)
    jump (0D7C);

0D7C:

    #0D7C
    #instruction: NOP
    advance (4)
    jump (0D7D);

0D7D:

    #0D7D
    #instruction: NOP
    advance (4)
    jump (0D7E);

0D7E:

    #0D7E
    #instruction: NOP
    advance (4)
    jump (0D7F);

0D7F:

    #0D7F
    #instruction: NOP
    advance (4)
    jump (0D80);

0D80:

    #0D80
    #instruction: NOP
    advance (4)
    jump (0D81);

0D81:

    #0D81
    #instruction: NOP
    advance (4)
    jump (0D82);

0D82:

    #0D82
    #instruction: NOP
    advance (4)
    jump (0D83);

0D83:

    #0D83
    #instruction: NOP
    advance (4)
    jump (0D84);

0D84:

    #0D84
    #instruction: NOP
    advance (4)
    jump (0D85);

0D85:

    #0D85
    #instruction: NOP
    advance (4)
    jump (0D86);

0D86:

    #0D86
    #instruction: NOP
    advance (4)
    jump (0D87);

0D87:

    #0D87
    #instruction: NOP
    advance (4)
    jump (0D88);

0D88:

    #0D88
    #instruction: NOP
    advance (4)
    jump (0D89);

0D89:

    #0D89
    #instruction: NOP
    advance (4)
    jump (0D8A);

0D8A:

    #0D8A
    #instruction: NOP
    advance (4)
    jump (0D8B);

0D8B:

    #0D8B
    #instruction: NOP
    advance (4)
    jump (0D8C);

0D8C:

    #0D8C
    #instruction: NOP
    advance (4)
    jump (0D8D);

0D8D:

    #0D8D
    #instruction: NOP
    advance (4)
    jump (0D8E);

0D8E:

    #0D8E
    #instruction: NOP
    advance (4)
    jump (0D8F);

0D8F:

    #0D8F
    #instruction: NOP
    advance (4)
    jump (0D90);

0D90:

    #0D90
    #instruction: NOP
    advance (4)
    jump (0D91);

0D91:

    #0D91
    #instruction: NOP
    advance (4)
    jump (0D92);

0D92:

    #0D92
    #instruction: NOP
    advance (4)
    jump (0D93);

0D93:

    #0D93
    #instruction: NOP
    advance (4)
    jump (0D94);

0D94:

    #0D94
    #instruction: NOP
    advance (4)
    jump (0D95);

0D95:

    #0D95
    #instruction: NOP
    advance (4)
    jump (0D96);

0D96:

    #0D96
    #instruction: NOP
    advance (4)
    jump (0D97);

0D97:

    #0D97
    #instruction: NOP
    advance (4)
    jump (0D98);

0D98:

    #0D98
    #instruction: NOP
    advance (4)
    jump (0D99);

0D99:

    #0D99
    #instruction: NOP
    advance (4)
    jump (0D9A);

0D9A:

    #0D9A
    #instruction: NOP
    advance (4)
    jump (0D9B);

0D9B:

    #0D9B
    #instruction: NOP
    advance (4)
    jump (0D9C);

0D9C:

    #0D9C
    #instruction: NOP
    advance (4)
    jump (0D9D);

0D9D:

    #0D9D
    #instruction: NOP
    advance (4)
    jump (0D9E);

0D9E:

    #0D9E
    #instruction: NOP
    advance (4)
    jump (0D9F);

0D9F:

    #0D9F
    #instruction: NOP
    advance (4)
    jump (0DA0);

0DA0:

    #0DA0
    #instruction: NOP
    advance (4)
    jump (0DA1);

0DA1:

    #0DA1
    #instruction: NOP
    advance (4)
    jump (0DA2);

0DA2:

    #0DA2
    #instruction: NOP
    advance (4)
    jump (0DA3);

0DA3:

    #0DA3
    #instruction: NOP
    advance (4)
    jump (0DA4);

0DA4:

    #0DA4
    #instruction: NOP
    advance (4)
    jump (0DA5);

0DA5:

    #0DA5
    #instruction: NOP
    advance (4)
    jump (0DA6);

0DA6:

    #0DA6
    #instruction: NOP
    advance (4)
    jump (0DA7);

0DA7:

    #0DA7
    #instruction: NOP
    advance (4)
    jump (0DA8);

0DA8:

    #0DA8
    #instruction: NOP
    advance (4)
    jump (0DA9);

0DA9:

    #0DA9
    #instruction: NOP
    advance (4)
    jump (0DAA);

0DAA:

    #0DAA
    #instruction: NOP
    advance (4)
    jump (0DAB);

0DAB:

    #0DAB
    #instruction: NOP
    advance (4)
    jump (0DAC);

0DAC:

    #0DAC
    #instruction: NOP
    advance (4)
    jump (0DAD);

0DAD:

    #0DAD
    #instruction: NOP
    advance (4)
    jump (0DAE);

0DAE:

    #0DAE
    #instruction: NOP
    advance (4)
    jump (0DAF);

0DAF:

    #0DAF
    #instruction: NOP
    advance (4)
    jump (0DB0);

0DB0:

    #0DB0
    #instruction: NOP
    advance (4)
    jump (0DB1);

0DB1:

    #0DB1
    #instruction: NOP
    advance (4)
    jump (0DB2);

0DB2:

    #0DB2
    #instruction: NOP
    advance (4)
    jump (0DB3);

0DB3:

    #0DB3
    #instruction: NOP
    advance (4)
    jump (0DB4);

0DB4:

    #0DB4
    #instruction: NOP
    advance (4)
    jump (0DB5);

0DB5:

    #0DB5
    #instruction: NOP
    advance (4)
    jump (0DB6);

0DB6:

    #0DB6
    #instruction: NOP
    advance (4)
    jump (0DB7);

0DB7:

    #0DB7
    #instruction: NOP
    advance (4)
    jump (0DB8);

0DB8:

    #0DB8
    #instruction: NOP
    advance (4)
    jump (0DB9);

0DB9:

    #0DB9
    #instruction: NOP
    advance (4)
    jump (0DBA);

0DBA:

    #0DBA
    #instruction: NOP
    advance (4)
    jump (0DBB);

0DBB:

    #0DBB
    #instruction: NOP
    advance (4)
    jump (0DBC);

0DBC:

    #0DBC
    #instruction: NOP
    advance (4)
    jump (0DBD);

0DBD:

    #0DBD
    #instruction: NOP
    advance (4)
    jump (0DBE);

0DBE:

    #0DBE
    #instruction: NOP
    advance (4)
    jump (0DBF);

0DBF:

    #0DBF
    #instruction: NOP
    advance (4)
    jump (0DC0);

0DC0:

    #0DC0
    #instruction: NOP
    advance (4)
    jump (0DC1);

0DC1:

    #0DC1
    #instruction: NOP
    advance (4)
    jump (0DC2);

0DC2:

    #0DC2
    #instruction: NOP
    advance (4)
    jump (0DC3);

0DC3:

    #0DC3
    #instruction: NOP
    advance (4)
    jump (0DC4);

0DC4:

    #0DC4
    #instruction: NOP
    advance (4)
    jump (0DC5);

0DC5:

    #0DC5
    #instruction: NOP
    advance (4)
    jump (0DC6);

0DC6:

    #0DC6
    #instruction: NOP
    advance (4)
    jump (0DC7);

0DC7:

    #0DC7
    #instruction: NOP
    advance (4)
    jump (0DC8);

0DC8:

    #0DC8
    #instruction: NOP
    advance (4)
    jump (0DC9);

0DC9:

    #0DC9
    #instruction: NOP
    advance (4)
    jump (0DCA);

0DCA:

    #0DCA
    #instruction: NOP
    advance (4)
    jump (0DCB);

0DCB:

    #0DCB
    #instruction: NOP
    advance (4)
    jump (0DCC);

0DCC:

    #0DCC
    #instruction: NOP
    advance (4)
    jump (0DCD);

0DCD:

    #0DCD
    #instruction: NOP
    advance (4)
    jump (0DCE);

0DCE:

    #0DCE
    #instruction: NOP
    advance (4)
    jump (0DCF);

0DCF:

    #0DCF
    #instruction: NOP
    advance (4)
    jump (0DD0);

0DD0:

    #0DD0
    #instruction: NOP
    advance (4)
    jump (0DD1);

0DD1:

    #0DD1
    #instruction: NOP
    advance (4)
    jump (0DD2);

0DD2:

    #0DD2
    #instruction: NOP
    advance (4)
    jump (0DD3);

0DD3:

    #0DD3
    #instruction: NOP
    advance (4)
    jump (0DD4);

0DD4:

    #0DD4
    #instruction: NOP
    advance (4)
    jump (0DD5);

0DD5:

    #0DD5
    #instruction: NOP
    advance (4)
    jump (0DD6);

0DD6:

    #0DD6
    #instruction: NOP
    advance (4)
    jump (0DD7);

0DD7:

    #0DD7
    #instruction: NOP
    advance (4)
    jump (0DD8);

0DD8:

    #0DD8
    #instruction: NOP
    advance (4)
    jump (0DD9);

0DD9:

    #0DD9
    #instruction: NOP
    advance (4)
    jump (0DDA);

0DDA:

    #0DDA
    #instruction: NOP
    advance (4)
    jump (0DDB);

0DDB:

    #0DDB
    #instruction: NOP
    advance (4)
    jump (0DDC);

0DDC:

    #0DDC
    #instruction: NOP
    advance (4)
    jump (0DDD);

0DDD:

    #0DDD
    #instruction: NOP
    advance (4)
    jump (0DDE);

0DDE:

    #0DDE
    #instruction: NOP
    advance (4)
    jump (0DDF);

0DDF:

    #0DDF
    #instruction: NOP
    advance (4)
    jump (0DE0);

0DE0:

    #0DE0
    #instruction: NOP
    advance (4)
    jump (0DE1);

0DE1:

    #0DE1
    #instruction: NOP
    advance (4)
    jump (0DE2);

0DE2:

    #0DE2
    #instruction: NOP
    advance (4)
    jump (0DE3);

0DE3:

    #0DE3
    #instruction: NOP
    advance (4)
    jump (0DE4);

0DE4:

    #0DE4
    #instruction: NOP
    advance (4)
    jump (0DE5);

0DE5:

    #0DE5
    #instruction: NOP
    advance (4)
    jump (0DE6);

0DE6:

    #0DE6
    #instruction: NOP
    advance (4)
    jump (0DE7);

0DE7:

    #0DE7
    #instruction: NOP
    advance (4)
    jump (0DE8);

0DE8:

    #0DE8
    #instruction: NOP
    advance (4)
    jump (0DE9);

0DE9:

    #0DE9
    #instruction: NOP
    advance (4)
    jump (0DEA);

0DEA:

    #0DEA
    #instruction: NOP
    advance (4)
    jump (0DEB);

0DEB:

    #0DEB
    #instruction: NOP
    advance (4)
    jump (0DEC);

0DEC:

    #0DEC
    #instruction: NOP
    advance (4)
    jump (0DED);

0DED:

    #0DED
    #instruction: NOP
    advance (4)
    jump (0DEE);

0DEE:

    #0DEE
    #instruction: NOP
    advance (4)
    jump (0DEF);

0DEF:

    #0DEF
    #instruction: NOP
    advance (4)
    jump (0DF0);

0DF0:

    #0DF0
    #instruction: NOP
    advance (4)
    jump (0DF1);

0DF1:

    #0DF1
    #instruction: NOP
    advance (4)
    jump (0DF2);

0DF2:

    #0DF2
    #instruction: NOP
    advance (4)
    jump (0DF3);

0DF3:

    #0DF3
    #instruction: NOP
    advance (4)
    jump (0DF4);

0DF4:

    #0DF4
    #instruction: NOP
    advance (4)
    jump (0DF5);

0DF5:

    #0DF5
    #instruction: NOP
    advance (4)
    jump (0DF6);

0DF6:

    #0DF6
    #instruction: NOP
    advance (4)
    jump (0DF7);

0DF7:

    #0DF7
    #instruction: NOP
    advance (4)
    jump (0DF8);

0DF8:

    #0DF8
    #instruction: NOP
    advance (4)
    jump (0DF9);

0DF9:

    #0DF9
    #instruction: NOP
    advance (4)
    jump (0DFA);

0DFA:

    #0DFA
    #instruction: NOP
    advance (4)
    jump (0DFB);

0DFB:

    #0DFB
    #instruction: NOP
    advance (4)
    jump (0DFC);

0DFC:

    #0DFC
    #instruction: NOP
    advance (4)
    jump (0DFD);

0DFD:

    #0DFD
    #instruction: NOP
    advance (4)
    jump (0DFE);

0DFE:

    #0DFE
    #instruction: NOP
    advance (4)
    jump (0DFF);

0DFF:

    #0DFF
    #instruction: NOP
    advance (4)
    jump (0E00);

0E00:

    #0E00
    #instruction: NOP
    advance (4)
    jump (0E01);

0E01:

    #0E01
    #instruction: NOP
    advance (4)
    jump (0E02);

0E02:

    #0E02
    #instruction: NOP
    advance (4)
    jump (0E03);

0E03:

    #0E03
    #instruction: NOP
    advance (4)
    jump (0E04);

0E04:

    #0E04
    #instruction: NOP
    advance (4)
    jump (0E05);

0E05:

    #0E05
    #instruction: NOP
    advance (4)
    jump (0E06);

0E06:

    #0E06
    #instruction: NOP
    advance (4)
    jump (0E07);

0E07:

    #0E07
    #instruction: NOP
    advance (4)
    jump (0E08);

0E08:

    #0E08
    #instruction: NOP
    advance (4)
    jump (0E09);

0E09:

    #0E09
    #instruction: NOP
    advance (4)
    jump (0E0A);

0E0A:

    #0E0A
    #instruction: NOP
    advance (4)
    jump (0E0B);

0E0B:

    #0E0B
    #instruction: NOP
    advance (4)
    jump (0E0C);

0E0C:

    #0E0C
    #instruction: NOP
    advance (4)
    jump (0E0D);

0E0D:

    #0E0D
    #instruction: NOP
    advance (4)
    jump (0E0E);

0E0E:

    #0E0E
    #instruction: NOP
    advance (4)
    jump (0E0F);

0E0F:

    #0E0F
    #instruction: NOP
    advance (4)
    jump (0E10);

0E10:

    #0E10
    #instruction: NOP
    advance (4)
    jump (0E11);

0E11:

    #0E11
    #instruction: NOP
    advance (4)
    jump (0E12);

0E12:

    #0E12
    #instruction: NOP
    advance (4)
    jump (0E13);

0E13:

    #0E13
    #instruction: NOP
    advance (4)
    jump (0E14);

0E14:

    #0E14
    #instruction: NOP
    advance (4)
    jump (0E15);

0E15:

    #0E15
    #instruction: NOP
    advance (4)
    jump (0E16);

0E16:

    #0E16
    #instruction: NOP
    advance (4)
    jump (0E17);

0E17:

    #0E17
    #instruction: NOP
    advance (4)
    jump (0E18);

0E18:

    #0E18
    #instruction: NOP
    advance (4)
    jump (0E19);

0E19:

    #0E19
    #instruction: NOP
    advance (4)
    jump (0E1A);

0E1A:

    #0E1A
    #instruction: NOP
    advance (4)
    jump (0E1B);

0E1B:

    #0E1B
    #instruction: NOP
    advance (4)
    jump (0E1C);

0E1C:

    #0E1C
    #instruction: NOP
    advance (4)
    jump (0E1D);

0E1D:

    #0E1D
    #instruction: NOP
    advance (4)
    jump (0E1E);

0E1E:

    #0E1E
    #instruction: NOP
    advance (4)
    jump (0E1F);

0E1F:

    #0E1F
    #instruction: NOP
    advance (4)
    jump (0E20);

0E20:

    #0E20
    #instruction: NOP
    advance (4)
    jump (0E21);

0E21:

    #0E21
    #instruction: NOP
    advance (4)
    jump (0E22);

0E22:

    #0E22
    #instruction: NOP
    advance (4)
    jump (0E23);

0E23:

    #0E23
    #instruction: NOP
    advance (4)
    jump (0E24);

0E24:

    #0E24
    #instruction: NOP
    advance (4)
    jump (0E25);

0E25:

    #0E25
    #instruction: NOP
    advance (4)
    jump (0E26);

0E26:

    #0E26
    #instruction: NOP
    advance (4)
    jump (0E27);

0E27:

    #0E27
    #instruction: NOP
    advance (4)
    jump (0E28);

0E28:

    #0E28
    #instruction: NOP
    advance (4)
    jump (0E29);

0E29:

    #0E29
    #instruction: NOP
    advance (4)
    jump (0E2A);

0E2A:

    #0E2A
    #instruction: NOP
    advance (4)
    jump (0E2B);

0E2B:

    #0E2B
    #instruction: NOP
    advance (4)
    jump (0E2C);

0E2C:

    #0E2C
    #instruction: NOP
    advance (4)
    jump (0E2D);

0E2D:

    #0E2D
    #instruction: NOP
    advance (4)
    jump (0E2E);

0E2E:

    #0E2E
    #instruction: NOP
    advance (4)
    jump (0E2F);

0E2F:

    #0E2F
    #instruction: NOP
    advance (4)
    jump (0E30);

0E30:

    #0E30
    #instruction: NOP
    advance (4)
    jump (0E31);

0E31:

    #0E31
    #instruction: NOP
    advance (4)
    jump (0E32);

0E32:

    #0E32
    #instruction: NOP
    advance (4)
    jump (0E33);

0E33:

    #0E33
    #instruction: NOP
    advance (4)
    jump (0E34);

0E34:

    #0E34
    #instruction: NOP
    advance (4)
    jump (0E35);

0E35:

    #0E35
    #instruction: NOP
    advance (4)
    jump (0E36);

0E36:

    #0E36
    #instruction: NOP
    advance (4)
    jump (0E37);

0E37:

    #0E37
    #instruction: NOP
    advance (4)
    jump (0E38);

0E38:

    #0E38
    #instruction: NOP
    advance (4)
    jump (0E39);

0E39:

    #0E39
    #instruction: NOP
    advance (4)
    jump (0E3A);

0E3A:

    #0E3A
    #instruction: NOP
    advance (4)
    jump (0E3B);

0E3B:

    #0E3B
    #instruction: NOP
    advance (4)
    jump (0E3C);

0E3C:

    #0E3C
    #instruction: NOP
    advance (4)
    jump (0E3D);

0E3D:

    #0E3D
    #instruction: NOP
    advance (4)
    jump (0E3E);

0E3E:

    #0E3E
    #instruction: NOP
    advance (4)
    jump (0E3F);

0E3F:

    #0E3F
    #instruction: NOP
    advance (4)
    jump (0E40);

0E40:

    #0E40
    #instruction: NOP
    advance (4)
    jump (0E41);

0E41:

    #0E41
    #instruction: NOP
    advance (4)
    jump (0E42);

0E42:

    #0E42
    #instruction: NOP
    advance (4)
    jump (0E43);

0E43:

    #0E43
    #instruction: NOP
    advance (4)
    jump (0E44);

0E44:

    #0E44
    #instruction: NOP
    advance (4)
    jump (0E45);

0E45:

    #0E45
    #instruction: NOP
    advance (4)
    jump (0E46);

0E46:

    #0E46
    #instruction: NOP
    advance (4)
    jump (0E47);

0E47:

    #0E47
    #instruction: NOP
    advance (4)
    jump (0E48);

0E48:

    #0E48
    #instruction: NOP
    advance (4)
    jump (0E49);

0E49:

    #0E49
    #instruction: NOP
    advance (4)
    jump (0E4A);

0E4A:

    #0E4A
    #instruction: NOP
    advance (4)
    jump (0E4B);

0E4B:

    #0E4B
    #instruction: NOP
    advance (4)
    jump (0E4C);

0E4C:

    #0E4C
    #instruction: NOP
    advance (4)
    jump (0E4D);

0E4D:

    #0E4D
    #instruction: NOP
    advance (4)
    jump (0E4E);

0E4E:

    #0E4E
    #instruction: NOP
    advance (4)
    jump (0E4F);

0E4F:

    #0E4F
    #instruction: NOP
    advance (4)
    jump (0E50);

0E50:

    #0E50
    #instruction: NOP
    advance (4)
    jump (0E51);

0E51:

    #0E51
    #instruction: NOP
    advance (4)
    jump (0E52);

0E52:

    #0E52
    #instruction: NOP
    advance (4)
    jump (0E53);

0E53:

    #0E53
    #instruction: NOP
    advance (4)
    jump (0E54);

0E54:

    #0E54
    #instruction: NOP
    advance (4)
    jump (0E55);

0E55:

    #0E55
    #instruction: NOP
    advance (4)
    jump (0E56);

0E56:

    #0E56
    #instruction: NOP
    advance (4)
    jump (0E57);

0E57:

    #0E57
    #instruction: NOP
    advance (4)
    jump (0E58);

0E58:

    #0E58
    #instruction: NOP
    advance (4)
    jump (0E59);

0E59:

    #0E59
    #instruction: NOP
    advance (4)
    jump (0E5A);

0E5A:

    #0E5A
    #instruction: NOP
    advance (4)
    jump (0E5B);

0E5B:

    #0E5B
    #instruction: NOP
    advance (4)
    jump (0E5C);

0E5C:

    #0E5C
    #instruction: NOP
    advance (4)
    jump (0E5D);

0E5D:

    #0E5D
    #instruction: NOP
    advance (4)
    jump (0E5E);

0E5E:

    #0E5E
    #instruction: NOP
    advance (4)
    jump (0E5F);

0E5F:

    #0E5F
    #instruction: NOP
    advance (4)
    jump (0E60);

0E60:

    #0E60
    #instruction: NOP
    advance (4)
    jump (0E61);

0E61:

    #0E61
    #instruction: NOP
    advance (4)
    jump (0E62);

0E62:

    #0E62
    #instruction: NOP
    advance (4)
    jump (0E63);

0E63:

    #0E63
    #instruction: NOP
    advance (4)
    jump (0E64);

0E64:

    #0E64
    #instruction: NOP
    advance (4)
    jump (0E65);

0E65:

    #0E65
    #instruction: NOP
    advance (4)
    jump (0E66);

0E66:

    #0E66
    #instruction: NOP
    advance (4)
    jump (0E67);

0E67:

    #0E67
    #instruction: NOP
    advance (4)
    jump (0E68);

0E68:

    #0E68
    #instruction: NOP
    advance (4)
    jump (0E69);

0E69:

    #0E69
    #instruction: NOP
    advance (4)
    jump (0E6A);

0E6A:

    #0E6A
    #instruction: NOP
    advance (4)
    jump (0E6B);

0E6B:

    #0E6B
    #instruction: NOP
    advance (4)
    jump (0E6C);

0E6C:

    #0E6C
    #instruction: NOP
    advance (4)
    jump (0E6D);

0E6D:

    #0E6D
    #instruction: NOP
    advance (4)
    jump (0E6E);

0E6E:

    #0E6E
    #instruction: NOP
    advance (4)
    jump (0E6F);

0E6F:

    #0E6F
    #instruction: NOP
    advance (4)
    jump (0E70);

0E70:

    #0E70
    #instruction: NOP
    advance (4)
    jump (0E71);

0E71:

    #0E71
    #instruction: NOP
    advance (4)
    jump (0E72);

0E72:

    #0E72
    #instruction: NOP
    advance (4)
    jump (0E73);

0E73:

    #0E73
    #instruction: NOP
    advance (4)
    jump (0E74);

0E74:

    #0E74
    #instruction: NOP
    advance (4)
    jump (0E75);

0E75:

    #0E75
    #instruction: NOP
    advance (4)
    jump (0E76);

0E76:

    #0E76
    #instruction: NOP
    advance (4)
    jump (0E77);

0E77:

    #0E77
    #instruction: NOP
    advance (4)
    jump (0E78);

0E78:

    #0E78
    #instruction: NOP
    advance (4)
    jump (0E79);

0E79:

    #0E79
    #instruction: NOP
    advance (4)
    jump (0E7A);

0E7A:

    #0E7A
    #instruction: NOP
    advance (4)
    jump (0E7B);

0E7B:

    #0E7B
    #instruction: NOP
    advance (4)
    jump (0E7C);

0E7C:

    #0E7C
    #instruction: NOP
    advance (4)
    jump (0E7D);

0E7D:

    #0E7D
    #instruction: NOP
    advance (4)
    jump (0E7E);

0E7E:

    #0E7E
    #instruction: NOP
    advance (4)
    jump (0E7F);

0E7F:

    #0E7F
    #instruction: NOP
    advance (4)
    jump (0E80);

0E80:

    #0E80
    #instruction: NOP
    advance (4)
    jump (0E81);

0E81:

    #0E81
    #instruction: NOP
    advance (4)
    jump (0E82);

0E82:

    #0E82
    #instruction: NOP
    advance (4)
    jump (0E83);

0E83:

    #0E83
    #instruction: NOP
    advance (4)
    jump (0E84);

0E84:

    #0E84
    #instruction: NOP
    advance (4)
    jump (0E85);

0E85:

    #0E85
    #instruction: NOP
    advance (4)
    jump (0E86);

0E86:

    #0E86
    #instruction: NOP
    advance (4)
    jump (0E87);

0E87:

    #0E87
    #instruction: NOP
    advance (4)
    jump (0E88);

0E88:

    #0E88
    #instruction: NOP
    advance (4)
    jump (0E89);

0E89:

    #0E89
    #instruction: NOP
    advance (4)
    jump (0E8A);

0E8A:

    #0E8A
    #instruction: NOP
    advance (4)
    jump (0E8B);

0E8B:

    #0E8B
    #instruction: NOP
    advance (4)
    jump (0E8C);

0E8C:

    #0E8C
    #instruction: NOP
    advance (4)
    jump (0E8D);

0E8D:

    #0E8D
    #instruction: NOP
    advance (4)
    jump (0E8E);

0E8E:

    #0E8E
    #instruction: NOP
    advance (4)
    jump (0E8F);

0E8F:

    #0E8F
    #instruction: NOP
    advance (4)
    jump (0E90);

0E90:

    #0E90
    #instruction: NOP
    advance (4)
    jump (0E91);

0E91:

    #0E91
    #instruction: NOP
    advance (4)
    jump (0E92);

0E92:

    #0E92
    #instruction: NOP
    advance (4)
    jump (0E93);

0E93:

    #0E93
    #instruction: NOP
    advance (4)
    jump (0E94);

0E94:

    #0E94
    #instruction: NOP
    advance (4)
    jump (0E95);

0E95:

    #0E95
    #instruction: NOP
    advance (4)
    jump (0E96);

0E96:

    #0E96
    #instruction: NOP
    advance (4)
    jump (0E97);

0E97:

    #0E97
    #instruction: NOP
    advance (4)
    jump (0E98);

0E98:

    #0E98
    #instruction: NOP
    advance (4)
    jump (0E99);

0E99:

    #0E99
    #instruction: NOP
    advance (4)
    jump (0E9A);

0E9A:

    #0E9A
    #instruction: NOP
    advance (4)
    jump (0E9B);

0E9B:

    #0E9B
    #instruction: NOP
    advance (4)
    jump (0E9C);

0E9C:

    #0E9C
    #instruction: NOP
    advance (4)
    jump (0E9D);

0E9D:

    #0E9D
    #instruction: NOP
    advance (4)
    jump (0E9E);

0E9E:

    #0E9E
    #instruction: NOP
    advance (4)
    jump (0E9F);

0E9F:

    #0E9F
    #instruction: NOP
    advance (4)
    jump (0EA0);

0EA0:

    #0EA0
    #instruction: NOP
    advance (4)
    jump (0EA1);

0EA1:

    #0EA1
    #instruction: NOP
    advance (4)
    jump (0EA2);

0EA2:

    #0EA2
    #instruction: NOP
    advance (4)
    jump (0EA3);

0EA3:

    #0EA3
    #instruction: NOP
    advance (4)
    jump (0EA4);

0EA4:

    #0EA4
    #instruction: NOP
    advance (4)
    jump (0EA5);

0EA5:

    #0EA5
    #instruction: NOP
    advance (4)
    jump (0EA6);

0EA6:

    #0EA6
    #instruction: NOP
    advance (4)
    jump (0EA7);

0EA7:

    #0EA7
    #instruction: NOP
    advance (4)
    jump (0EA8);

0EA8:

    #0EA8
    #instruction: NOP
    advance (4)
    jump (0EA9);

0EA9:

    #0EA9
    #instruction: NOP
    advance (4)
    jump (0EAA);

0EAA:

    #0EAA
    #instruction: NOP
    advance (4)
    jump (0EAB);

0EAB:

    #0EAB
    #instruction: NOP
    advance (4)
    jump (0EAC);

0EAC:

    #0EAC
    #instruction: NOP
    advance (4)
    jump (0EAD);

0EAD:

    #0EAD
    #instruction: NOP
    advance (4)
    jump (0EAE);

0EAE:

    #0EAE
    #instruction: NOP
    advance (4)
    jump (0EAF);

0EAF:

    #0EAF
    #instruction: NOP
    advance (4)
    jump (0EB0);

0EB0:

    #0EB0
    #instruction: NOP
    advance (4)
    jump (0EB1);

0EB1:

    #0EB1
    #instruction: NOP
    advance (4)
    jump (0EB2);

0EB2:

    #0EB2
    #instruction: NOP
    advance (4)
    jump (0EB3);

0EB3:

    #0EB3
    #instruction: NOP
    advance (4)
    jump (0EB4);

0EB4:

    #0EB4
    #instruction: NOP
    advance (4)
    jump (0EB5);

0EB5:

    #0EB5
    #instruction: NOP
    advance (4)
    jump (0EB6);

0EB6:

    #0EB6
    #instruction: NOP
    advance (4)
    jump (0EB7);

0EB7:

    #0EB7
    #instruction: NOP
    advance (4)
    jump (0EB8);

0EB8:

    #0EB8
    #instruction: NOP
    advance (4)
    jump (0EB9);

0EB9:

    #0EB9
    #instruction: NOP
    advance (4)
    jump (0EBA);

0EBA:

    #0EBA
    #instruction: NOP
    advance (4)
    jump (0EBB);

0EBB:

    #0EBB
    #instruction: NOP
    advance (4)
    jump (0EBC);

0EBC:

    #0EBC
    #instruction: NOP
    advance (4)
    jump (0EBD);

0EBD:

    #0EBD
    #instruction: NOP
    advance (4)
    jump (0EBE);

0EBE:

    #0EBE
    #instruction: NOP
    advance (4)
    jump (0EBF);

0EBF:

    #0EBF
    #instruction: NOP
    advance (4)
    jump (0EC0);

0EC0:

    #0EC0
    #instruction: NOP
    advance (4)
    jump (0EC1);

0EC1:

    #0EC1
    #instruction: NOP
    advance (4)
    jump (0EC2);

0EC2:

    #0EC2
    #instruction: NOP
    advance (4)
    jump (0EC3);

0EC3:

    #0EC3
    #instruction: NOP
    advance (4)
    jump (0EC4);

0EC4:

    #0EC4
    #instruction: NOP
    advance (4)
    jump (0EC5);

0EC5:

    #0EC5
    #instruction: NOP
    advance (4)
    jump (0EC6);

0EC6:

    #0EC6
    #instruction: NOP
    advance (4)
    jump (0EC7);

0EC7:

    #0EC7
    #instruction: NOP
    advance (4)
    jump (0EC8);

0EC8:

    #0EC8
    #instruction: NOP
    advance (4)
    jump (0EC9);

0EC9:

    #0EC9
    #instruction: NOP
    advance (4)
    jump (0ECA);

0ECA:

    #0ECA
    #instruction: NOP
    advance (4)
    jump (0ECB);

0ECB:

    #0ECB
    #instruction: NOP
    advance (4)
    jump (0ECC);

0ECC:

    #0ECC
    #instruction: NOP
    advance (4)
    jump (0ECD);

0ECD:

    #0ECD
    #instruction: NOP
    advance (4)
    jump (0ECE);

0ECE:

    #0ECE
    #instruction: NOP
    advance (4)
    jump (0ECF);

0ECF:

    #0ECF
    #instruction: NOP
    advance (4)
    jump (0ED0);

0ED0:

    #0ED0
    #instruction: NOP
    advance (4)
    jump (0ED1);

0ED1:

    #0ED1
    #instruction: NOP
    advance (4)
    jump (0ED2);

0ED2:

    #0ED2
    #instruction: NOP
    advance (4)
    jump (0ED3);

0ED3:

    #0ED3
    #instruction: NOP
    advance (4)
    jump (0ED4);

0ED4:

    #0ED4
    #instruction: NOP
    advance (4)
    jump (0ED5);

0ED5:

    #0ED5
    #instruction: NOP
    advance (4)
    jump (0ED6);

0ED6:

    #0ED6
    #instruction: NOP
    advance (4)
    jump (0ED7);

0ED7:

    #0ED7
    #instruction: NOP
    advance (4)
    jump (0ED8);

0ED8:

    #0ED8
    #instruction: NOP
    advance (4)
    jump (0ED9);

0ED9:

    #0ED9
    #instruction: NOP
    advance (4)
    jump (0EDA);

0EDA:

    #0EDA
    #instruction: NOP
    advance (4)
    jump (0EDB);

0EDB:

    #0EDB
    #instruction: NOP
    advance (4)
    jump (0EDC);

0EDC:

    #0EDC
    #instruction: NOP
    advance (4)
    jump (0EDD);

0EDD:

    #0EDD
    #instruction: NOP
    advance (4)
    jump (0EDE);

0EDE:

    #0EDE
    #instruction: NOP
    advance (4)
    jump (0EDF);

0EDF:

    #0EDF
    #instruction: NOP
    advance (4)
    jump (0EE0);

0EE0:

    #0EE0
    #instruction: NOP
    advance (4)
    jump (0EE1);

0EE1:

    #0EE1
    #instruction: NOP
    advance (4)
    jump (0EE2);

0EE2:

    #0EE2
    #instruction: NOP
    advance (4)
    jump (0EE3);

0EE3:

    #0EE3
    #instruction: NOP
    advance (4)
    jump (0EE4);

0EE4:

    #0EE4
    #instruction: NOP
    advance (4)
    jump (0EE5);

0EE5:

    #0EE5
    #instruction: NOP
    advance (4)
    jump (0EE6);

0EE6:

    #0EE6
    #instruction: NOP
    advance (4)
    jump (0EE7);

0EE7:

    #0EE7
    #instruction: NOP
    advance (4)
    jump (0EE8);

0EE8:

    #0EE8
    #instruction: NOP
    advance (4)
    jump (0EE9);

0EE9:

    #0EE9
    #instruction: NOP
    advance (4)
    jump (0EEA);

0EEA:

    #0EEA
    #instruction: NOP
    advance (4)
    jump (0EEB);

0EEB:

    #0EEB
    #instruction: NOP
    advance (4)
    jump (0EEC);

0EEC:

    #0EEC
    #instruction: NOP
    advance (4)
    jump (0EED);

0EED:

    #0EED
    #instruction: NOP
    advance (4)
    jump (0EEE);

0EEE:

    #0EEE
    #instruction: NOP
    advance (4)
    jump (0EEF);

0EEF:

    #0EEF
    #instruction: NOP
    advance (4)
    jump (0EF0);

0EF0:

    #0EF0
    #instruction: NOP
    advance (4)
    jump (0EF1);

0EF1:

    #0EF1
    #instruction: NOP
    advance (4)
    jump (0EF2);

0EF2:

    #0EF2
    #instruction: NOP
    advance (4)
    jump (0EF3);

0EF3:

    #0EF3
    #instruction: NOP
    advance (4)
    jump (0EF4);

0EF4:

    #0EF4
    #instruction: NOP
    advance (4)
    jump (0EF5);

0EF5:

    #0EF5
    #instruction: NOP
    advance (4)
    jump (0EF6);

0EF6:

    #0EF6
    #instruction: NOP
    advance (4)
    jump (0EF7);

0EF7:

    #0EF7
    #instruction: NOP
    advance (4)
    jump (0EF8);

0EF8:

    #0EF8
    #instruction: NOP
    advance (4)
    jump (0EF9);

0EF9:

    #0EF9
    #instruction: NOP
    advance (4)
    jump (0EFA);

0EFA:

    #0EFA
    #instruction: NOP
    advance (4)
    jump (0EFB);

0EFB:

    #0EFB
    #instruction: NOP
    advance (4)
    jump (0EFC);

0EFC:

    #0EFC
    #instruction: NOP
    advance (4)
    jump (0EFD);

0EFD:

    #0EFD
    #instruction: NOP
    advance (4)
    jump (0EFE);

0EFE:

    #0EFE
    #instruction: NOP
    advance (4)
    jump (0EFF);

0EFF:

    #0EFF
    #instruction: NOP
    advance (4)
    jump (0F00);

0F00:

    #0F00
    #instruction: NOP
    advance (4)
    jump (0F01);

0F01:

    #0F01
    #instruction: NOP
    advance (4)
    jump (0F02);

0F02:

    #0F02
    #instruction: NOP
    advance (4)
    jump (0F03);

0F03:

    #0F03
    #instruction: NOP
    advance (4)
    jump (0F04);

0F04:

    #0F04
    #instruction: NOP
    advance (4)
    jump (0F05);

0F05:

    #0F05
    #instruction: NOP
    advance (4)
    jump (0F06);

0F06:

    #0F06
    #instruction: NOP
    advance (4)
    jump (0F07);

0F07:

    #0F07
    #instruction: NOP
    advance (4)
    jump (0F08);

0F08:

    #0F08
    #instruction: NOP
    advance (4)
    jump (0F09);

0F09:

    #0F09
    #instruction: NOP
    advance (4)
    jump (0F0A);

0F0A:

    #0F0A
    #instruction: NOP
    advance (4)
    jump (0F0B);

0F0B:

    #0F0B
    #instruction: NOP
    advance (4)
    jump (0F0C);

0F0C:

    #0F0C
    #instruction: NOP
    advance (4)
    jump (0F0D);

0F0D:

    #0F0D
    #instruction: NOP
    advance (4)
    jump (0F0E);

0F0E:

    #0F0E
    #instruction: NOP
    advance (4)
    jump (0F0F);

0F0F:

    #0F0F
    #instruction: NOP
    advance (4)
    jump (0F10);

0F10:

    #0F10
    #instruction: NOP
    advance (4)
    jump (0F11);

0F11:

    #0F11
    #instruction: NOP
    advance (4)
    jump (0F12);

0F12:

    #0F12
    #instruction: NOP
    advance (4)
    jump (0F13);

0F13:

    #0F13
    #instruction: NOP
    advance (4)
    jump (0F14);

0F14:

    #0F14
    #instruction: NOP
    advance (4)
    jump (0F15);

0F15:

    #0F15
    #instruction: NOP
    advance (4)
    jump (0F16);

0F16:

    #0F16
    #instruction: NOP
    advance (4)
    jump (0F17);

0F17:

    #0F17
    #instruction: NOP
    advance (4)
    jump (0F18);

0F18:

    #0F18
    #instruction: NOP
    advance (4)
    jump (0F19);

0F19:

    #0F19
    #instruction: NOP
    advance (4)
    jump (0F1A);

0F1A:

    #0F1A
    #instruction: NOP
    advance (4)
    jump (0F1B);

0F1B:

    #0F1B
    #instruction: NOP
    advance (4)
    jump (0F1C);

0F1C:

    #0F1C
    #instruction: NOP
    advance (4)
    jump (0F1D);

0F1D:

    #0F1D
    #instruction: NOP
    advance (4)
    jump (0F1E);

0F1E:

    #0F1E
    #instruction: NOP
    advance (4)
    jump (0F1F);

0F1F:

    #0F1F
    #instruction: NOP
    advance (4)
    jump (0F20);

0F20:

    #0F20
    #instruction: NOP
    advance (4)
    jump (0F21);

0F21:

    #0F21
    #instruction: NOP
    advance (4)
    jump (0F22);

0F22:

    #0F22
    #instruction: NOP
    advance (4)
    jump (0F23);

0F23:

    #0F23
    #instruction: NOP
    advance (4)
    jump (0F24);

0F24:

    #0F24
    #instruction: NOP
    advance (4)
    jump (0F25);

0F25:

    #0F25
    #instruction: NOP
    advance (4)
    jump (0F26);

0F26:

    #0F26
    #instruction: NOP
    advance (4)
    jump (0F27);

0F27:

    #0F27
    #instruction: NOP
    advance (4)
    jump (0F28);

0F28:

    #0F28
    #instruction: NOP
    advance (4)
    jump (0F29);

0F29:

    #0F29
    #instruction: NOP
    advance (4)
    jump (0F2A);

0F2A:

    #0F2A
    #instruction: NOP
    advance (4)
    jump (0F2B);

0F2B:

    #0F2B
    #instruction: NOP
    advance (4)
    jump (0F2C);

0F2C:

    #0F2C
    #instruction: NOP
    advance (4)
    jump (0F2D);

0F2D:

    #0F2D
    #instruction: NOP
    advance (4)
    jump (0F2E);

0F2E:

    #0F2E
    #instruction: NOP
    advance (4)
    jump (0F2F);

0F2F:

    #0F2F
    #instruction: NOP
    advance (4)
    jump (0F30);

0F30:

    #0F30
    #instruction: NOP
    advance (4)
    jump (0F31);

0F31:

    #0F31
    #instruction: NOP
    advance (4)
    jump (0F32);

0F32:

    #0F32
    #instruction: NOP
    advance (4)
    jump (0F33);

0F33:

    #0F33
    #instruction: NOP
    advance (4)
    jump (0F34);

0F34:

    #0F34
    #instruction: NOP
    advance (4)
    jump (0F35);

0F35:

    #0F35
    #instruction: NOP
    advance (4)
    jump (0F36);

0F36:

    #0F36
    #instruction: NOP
    advance (4)
    jump (0F37);

0F37:

    #0F37
    #instruction: NOP
    advance (4)
    jump (0F38);

0F38:

    #0F38
    #instruction: NOP
    advance (4)
    jump (0F39);

0F39:

    #0F39
    #instruction: NOP
    advance (4)
    jump (0F3A);

0F3A:

    #0F3A
    #instruction: NOP
    advance (4)
    jump (0F3B);

0F3B:

    #0F3B
    #instruction: NOP
    advance (4)
    jump (0F3C);

0F3C:

    #0F3C
    #instruction: NOP
    advance (4)
    jump (0F3D);

0F3D:

    #0F3D
    #instruction: NOP
    advance (4)
    jump (0F3E);

0F3E:

    #0F3E
    #instruction: NOP
    advance (4)
    jump (0F3F);

0F3F:

    #0F3F
    #instruction: NOP
    advance (4)
    jump (0F40);

0F40:

    #0F40
    #instruction: NOP
    advance (4)
    jump (0F41);

0F41:

    #0F41
    #instruction: NOP
    advance (4)
    jump (0F42);

0F42:

    #0F42
    #instruction: NOP
    advance (4)
    jump (0F43);

0F43:

    #0F43
    #instruction: NOP
    advance (4)
    jump (0F44);

0F44:

    #0F44
    #instruction: NOP
    advance (4)
    jump (0F45);

0F45:

    #0F45
    #instruction: NOP
    advance (4)
    jump (0F46);

0F46:

    #0F46
    #instruction: NOP
    advance (4)
    jump (0F47);

0F47:

    #0F47
    #instruction: NOP
    advance (4)
    jump (0F48);

0F48:

    #0F48
    #instruction: NOP
    advance (4)
    jump (0F49);

0F49:

    #0F49
    #instruction: NOP
    advance (4)
    jump (0F4A);

0F4A:

    #0F4A
    #instruction: NOP
    advance (4)
    jump (0F4B);

0F4B:

    #0F4B
    #instruction: NOP
    advance (4)
    jump (0F4C);

0F4C:

    #0F4C
    #instruction: NOP
    advance (4)
    jump (0F4D);

0F4D:

    #0F4D
    #instruction: NOP
    advance (4)
    jump (0F4E);

0F4E:

    #0F4E
    #instruction: NOP
    advance (4)
    jump (0F4F);

0F4F:

    #0F4F
    #instruction: NOP
    advance (4)
    jump (0F50);

0F50:

    #0F50
    #instruction: NOP
    advance (4)
    jump (0F51);

0F51:

    #0F51
    #instruction: NOP
    advance (4)
    jump (0F52);

0F52:

    #0F52
    #instruction: NOP
    advance (4)
    jump (0F53);

0F53:

    #0F53
    #instruction: NOP
    advance (4)
    jump (0F54);

0F54:

    #0F54
    #instruction: NOP
    advance (4)
    jump (0F55);

0F55:

    #0F55
    #instruction: NOP
    advance (4)
    jump (0F56);

0F56:

    #0F56
    #instruction: NOP
    advance (4)
    jump (0F57);

0F57:

    #0F57
    #instruction: NOP
    advance (4)
    jump (0F58);

0F58:

    #0F58
    #instruction: NOP
    advance (4)
    jump (0F59);

0F59:

    #0F59
    #instruction: NOP
    advance (4)
    jump (0F5A);

0F5A:

    #0F5A
    #instruction: NOP
    advance (4)
    jump (0F5B);

0F5B:

    #0F5B
    #instruction: NOP
    advance (4)
    jump (0F5C);

0F5C:

    #0F5C
    #instruction: NOP
    advance (4)
    jump (0F5D);

0F5D:

    #0F5D
    #instruction: NOP
    advance (4)
    jump (0F5E);

0F5E:

    #0F5E
    #instruction: NOP
    advance (4)
    jump (0F5F);

0F5F:

    #0F5F
    #instruction: NOP
    advance (4)
    jump (0F60);

0F60:

    #0F60
    #instruction: NOP
    advance (4)
    jump (0F61);

0F61:

    #0F61
    #instruction: NOP
    advance (4)
    jump (0F62);

0F62:

    #0F62
    #instruction: NOP
    advance (4)
    jump (0F63);

0F63:

    #0F63
    #instruction: NOP
    advance (4)
    jump (0F64);

0F64:

    #0F64
    #instruction: NOP
    advance (4)
    jump (0F65);

0F65:

    #0F65
    #instruction: NOP
    advance (4)
    jump (0F66);

0F66:

    #0F66
    #instruction: NOP
    advance (4)
    jump (0F67);

0F67:

    #0F67
    #instruction: NOP
    advance (4)
    jump (0F68);

0F68:

    #0F68
    #instruction: NOP
    advance (4)
    jump (0F69);

0F69:

    #0F69
    #instruction: NOP
    advance (4)
    jump (0F6A);

0F6A:

    #0F6A
    #instruction: NOP
    advance (4)
    jump (0F6B);

0F6B:

    #0F6B
    #instruction: NOP
    advance (4)
    jump (0F6C);

0F6C:

    #0F6C
    #instruction: NOP
    advance (4)
    jump (0F6D);

0F6D:

    #0F6D
    #instruction: NOP
    advance (4)
    jump (0F6E);

0F6E:

    #0F6E
    #instruction: NOP
    advance (4)
    jump (0F6F);

0F6F:

    #0F6F
    #instruction: NOP
    advance (4)
    jump (0F70);

0F70:

    #0F70
    #instruction: NOP
    advance (4)
    jump (0F71);

0F71:

    #0F71
    #instruction: NOP
    advance (4)
    jump (0F72);

0F72:

    #0F72
    #instruction: NOP
    advance (4)
    jump (0F73);

0F73:

    #0F73
    #instruction: NOP
    advance (4)
    jump (0F74);

0F74:

    #0F74
    #instruction: NOP
    advance (4)
    jump (0F75);

0F75:

    #0F75
    #instruction: NOP
    advance (4)
    jump (0F76);

0F76:

    #0F76
    #instruction: NOP
    advance (4)
    jump (0F77);

0F77:

    #0F77
    #instruction: NOP
    advance (4)
    jump (0F78);

0F78:

    #0F78
    #instruction: NOP
    advance (4)
    jump (0F79);

0F79:

    #0F79
    #instruction: NOP
    advance (4)
    jump (0F7A);

0F7A:

    #0F7A
    #instruction: NOP
    advance (4)
    jump (0F7B);

0F7B:

    #0F7B
    #instruction: NOP
    advance (4)
    jump (0F7C);

0F7C:

    #0F7C
    #instruction: NOP
    advance (4)
    jump (0F7D);

0F7D:

    #0F7D
    #instruction: NOP
    advance (4)
    jump (0F7E);

0F7E:

    #0F7E
    #instruction: NOP
    advance (4)
    jump (0F7F);

0F7F:

    #0F7F
    #instruction: NOP
    advance (4)
    jump (0F80);

0F80:

    #0F80
    #instruction: NOP
    advance (4)
    jump (0F81);

0F81:

    #0F81
    #instruction: NOP
    advance (4)
    jump (0F82);

0F82:

    #0F82
    #instruction: NOP
    advance (4)
    jump (0F83);

0F83:

    #0F83
    #instruction: NOP
    advance (4)
    jump (0F84);

0F84:

    #0F84
    #instruction: NOP
    advance (4)
    jump (0F85);

0F85:

    #0F85
    #instruction: NOP
    advance (4)
    jump (0F86);

0F86:

    #0F86
    #instruction: NOP
    advance (4)
    jump (0F87);

0F87:

    #0F87
    #instruction: NOP
    advance (4)
    jump (0F88);

0F88:

    #0F88
    #instruction: NOP
    advance (4)
    jump (0F89);

0F89:

    #0F89
    #instruction: NOP
    advance (4)
    jump (0F8A);

0F8A:

    #0F8A
    #instruction: NOP
    advance (4)
    jump (0F8B);

0F8B:

    #0F8B
    #instruction: NOP
    advance (4)
    jump (0F8C);

0F8C:

    #0F8C
    #instruction: NOP
    advance (4)
    jump (0F8D);

0F8D:

    #0F8D
    #instruction: NOP
    advance (4)
    jump (0F8E);

0F8E:

    #0F8E
    #instruction: NOP
    advance (4)
    jump (0F8F);

0F8F:

    #0F8F
    #instruction: NOP
    advance (4)
    jump (0F90);

0F90:

    #0F90
    #instruction: NOP
    advance (4)
    jump (0F91);

0F91:

    #0F91
    #instruction: NOP
    advance (4)
    jump (0F92);

0F92:

    #0F92
    #instruction: NOP
    advance (4)
    jump (0F93);

0F93:

    #0F93
    #instruction: NOP
    advance (4)
    jump (0F94);

0F94:

    #0F94
    #instruction: NOP
    advance (4)
    jump (0F95);

0F95:

    #0F95
    #instruction: NOP
    advance (4)
    jump (0F96);

0F96:

    #0F96
    #instruction: NOP
    advance (4)
    jump (0F97);

0F97:

    #0F97
    #instruction: NOP
    advance (4)
    jump (0F98);

0F98:

    #0F98
    #instruction: NOP
    advance (4)
    jump (0F99);

0F99:

    #0F99
    #instruction: NOP
    advance (4)
    jump (0F9A);

0F9A:

    #0F9A
    #instruction: NOP
    advance (4)
    jump (0F9B);

0F9B:

    #0F9B
    #instruction: NOP
    advance (4)
    jump (0F9C);

0F9C:

    #0F9C
    #instruction: NOP
    advance (4)
    jump (0F9D);

0F9D:

    #0F9D
    #instruction: NOP
    advance (4)
    jump (0F9E);

0F9E:

    #0F9E
    #instruction: NOP
    advance (4)
    jump (0F9F);

0F9F:

    #0F9F
    #instruction: NOP
    advance (4)
    jump (0FA0);

0FA0:

    #0FA0
    #instruction: NOP
    advance (4)
    jump (0FA1);

0FA1:

    #0FA1
    #instruction: NOP
    advance (4)
    jump (0FA2);

0FA2:

    #0FA2
    #instruction: NOP
    advance (4)
    jump (0FA3);

0FA3:

    #0FA3
    #instruction: NOP
    advance (4)
    jump (0FA4);

0FA4:

    #0FA4
    #instruction: NOP
    advance (4)
    jump (0FA5);

0FA5:

    #0FA5
    #instruction: NOP
    advance (4)
    jump (0FA6);

0FA6:

    #0FA6
    #instruction: NOP
    advance (4)
    jump (0FA7);

0FA7:

    #0FA7
    #instruction: NOP
    advance (4)
    jump (0FA8);

0FA8:

    #0FA8
    #instruction: NOP
    advance (4)
    jump (0FA9);

0FA9:

    #0FA9
    #instruction: NOP
    advance (4)
    jump (0FAA);

0FAA:

    #0FAA
    #instruction: NOP
    advance (4)
    jump (0FAB);

0FAB:

    #0FAB
    #instruction: NOP
    advance (4)
    jump (0FAC);

0FAC:

    #0FAC
    #instruction: NOP
    advance (4)
    jump (0FAD);

0FAD:

    #0FAD
    #instruction: NOP
    advance (4)
    jump (0FAE);

0FAE:

    #0FAE
    #instruction: NOP
    advance (4)
    jump (0FAF);

0FAF:

    #0FAF
    #instruction: NOP
    advance (4)
    jump (0FB0);

0FB0:

    #0FB0
    #instruction: NOP
    advance (4)
    jump (0FB1);

0FB1:

    #0FB1
    #instruction: NOP
    advance (4)
    jump (0FB2);

0FB2:

    #0FB2
    #instruction: NOP
    advance (4)
    jump (0FB3);

0FB3:

    #0FB3
    #instruction: NOP
    advance (4)
    jump (0FB4);

0FB4:

    #0FB4
    #instruction: NOP
    advance (4)
    jump (0FB5);

0FB5:

    #0FB5
    #instruction: NOP
    advance (4)
    jump (0FB6);

0FB6:

    #0FB6
    #instruction: NOP
    advance (4)
    jump (0FB7);

0FB7:

    #0FB7
    #instruction: NOP
    advance (4)
    jump (0FB8);

0FB8:

    #0FB8
    #instruction: NOP
    advance (4)
    jump (0FB9);

0FB9:

    #0FB9
    #instruction: NOP
    advance (4)
    jump (0FBA);

0FBA:

    #0FBA
    #instruction: NOP
    advance (4)
    jump (0FBB);

0FBB:

    #0FBB
    #instruction: NOP
    advance (4)
    jump (0FBC);

0FBC:

    #0FBC
    #instruction: NOP
    advance (4)
    jump (0FBD);

0FBD:

    #0FBD
    #instruction: NOP
    advance (4)
    jump (0FBE);

0FBE:

    #0FBE
    #instruction: NOP
    advance (4)
    jump (0FBF);

0FBF:

    #0FBF
    #instruction: NOP
    advance (4)
    jump (0FC0);

0FC0:

    #0FC0
    #instruction: NOP
    advance (4)
    jump (0FC1);

0FC1:

    #0FC1
    #instruction: NOP
    advance (4)
    jump (0FC2);

0FC2:

    #0FC2
    #instruction: NOP
    advance (4)
    jump (0FC3);

0FC3:

    #0FC3
    #instruction: NOP
    advance (4)
    jump (0FC4);

0FC4:

    #0FC4
    #instruction: NOP
    advance (4)
    jump (0FC5);

0FC5:

    #0FC5
    #instruction: NOP
    advance (4)
    jump (0FC6);

0FC6:

    #0FC6
    #instruction: NOP
    advance (4)
    jump (0FC7);

0FC7:

    #0FC7
    #instruction: NOP
    advance (4)
    jump (0FC8);

0FC8:

    #0FC8
    #instruction: NOP
    advance (4)
    jump (0FC9);

0FC9:

    #0FC9
    #instruction: NOP
    advance (4)
    jump (0FCA);

0FCA:

    #0FCA
    #instruction: NOP
    advance (4)
    jump (0FCB);

0FCB:

    #0FCB
    #instruction: NOP
    advance (4)
    jump (0FCC);

0FCC:

    #0FCC
    #instruction: NOP
    advance (4)
    jump (0FCD);

0FCD:

    #0FCD
    #instruction: NOP
    advance (4)
    jump (0FCE);

0FCE:

    #0FCE
    #instruction: NOP
    advance (4)
    jump (0FCF);

0FCF:

    #0FCF
    #instruction: NOP
    advance (4)
    jump (0FD0);

0FD0:

    #0FD0
    #instruction: NOP
    advance (4)
    jump (0FD1);

0FD1:

    #0FD1
    #instruction: NOP
    advance (4)
    jump (0FD2);

0FD2:

    #0FD2
    #instruction: NOP
    advance (4)
    jump (0FD3);

0FD3:

    #0FD3
    #instruction: NOP
    advance (4)
    jump (0FD4);

0FD4:

    #0FD4
    #instruction: NOP
    advance (4)
    jump (0FD5);

0FD5:

    #0FD5
    #instruction: NOP
    advance (4)
    jump (0FD6);

0FD6:

    #0FD6
    #instruction: NOP
    advance (4)
    jump (0FD7);

0FD7:

    #0FD7
    #instruction: NOP
    advance (4)
    jump (0FD8);

0FD8:

    #0FD8
    #instruction: NOP
    advance (4)
    jump (0FD9);

0FD9:

    #0FD9
    #instruction: NOP
    advance (4)
    jump (0FDA);

0FDA:

    #0FDA
    #instruction: NOP
    advance (4)
    jump (0FDB);

0FDB:

    #0FDB
    #instruction: NOP
    advance (4)
    jump (0FDC);

0FDC:

    #0FDC
    #instruction: NOP
    advance (4)
    jump (0FDD);

0FDD:

    #0FDD
    #instruction: NOP
    advance (4)
    jump (0FDE);

0FDE:

    #0FDE
    #instruction: NOP
    advance (4)
    jump (0FDF);

0FDF:

    #0FDF
    #instruction: NOP
    advance (4)
    jump (0FE0);

0FE0:

    #0FE0
    #instruction: NOP
    advance (4)
    jump (0FE1);

0FE1:

    #0FE1
    #instruction: NOP
    advance (4)
    jump (0FE2);

0FE2:

    #0FE2
    #instruction: NOP
    advance (4)
    jump (0FE3);

0FE3:

    #0FE3
    #instruction: NOP
    advance (4)
    jump (0FE4);

0FE4:

    #0FE4
    #instruction: NOP
    advance (4)
    jump (0FE5);

0FE5:

    #0FE5
    #instruction: NOP
    advance (4)
    jump (0FE6);

0FE6:

    #0FE6
    #instruction: NOP
    advance (4)
    jump (0FE7);

0FE7:

    #0FE7
    #instruction: NOP
    advance (4)
    jump (0FE8);

0FE8:

    #0FE8
    #instruction: NOP
    advance (4)
    jump (0FE9);

0FE9:

    #0FE9
    #instruction: NOP
    advance (4)
    jump (0FEA);

0FEA:

    #0FEA
    #instruction: NOP
    advance (4)
    jump (0FEB);

0FEB:

    #0FEB
    #instruction: NOP
    advance (4)
    jump (0FEC);

0FEC:

    #0FEC
    #instruction: NOP
    advance (4)
    jump (0FED);

0FED:

    #0FED
    #instruction: NOP
    advance (4)
    jump (0FEE);

0FEE:

    #0FEE
    #instruction: NOP
    advance (4)
    jump (0FEF);

0FEF:

    #0FEF
    #instruction: NOP
    advance (4)
    jump (0FF0);

0FF0:

    #0FF0
    #instruction: NOP
    advance (4)
    jump (0FF1);

0FF1:

    #0FF1
    #instruction: NOP
    advance (4)
    jump (0FF2);

0FF2:

    #0FF2
    #instruction: NOP
    advance (4)
    jump (0FF3);

0FF3:

    #0FF3
    #instruction: NOP
    advance (4)
    jump (0FF4);

0FF4:

    #0FF4
    #instruction: NOP
    advance (4)
    jump (0FF5);

0FF5:

    #0FF5
    #instruction: NOP
    advance (4)
    jump (0FF6);

0FF6:

    #0FF6
    #instruction: NOP
    advance (4)
    jump (0FF7);

0FF7:

    #0FF7
    #instruction: NOP
    advance (4)
    jump (0FF8);

0FF8:

    #0FF8
    #instruction: NOP
    advance (4)
    jump (0FF9);

0FF9:

    #0FF9
    #instruction: NOP
    advance (4)
    jump (0FFA);

0FFA:

    #0FFA
    #instruction: NOP
    advance (4)
    jump (0FFB);

0FFB:

    #0FFB
    #instruction: NOP
    advance (4)
    jump (0FFC);

0FFC:

    #0FFC
    #instruction: NOP
    advance (4)
    jump (0FFD);

0FFD:

    #0FFD
    #instruction: NOP
    advance (4)
    jump (0FFE);

0FFE:

    #0FFE
    #instruction: NOP
    advance (4)
    jump (0FFF);

0FFF:

    #0FFF
    #instruction: NOP
    advance (4)
    jump (1000);

1000:

    #1000
    #instruction: NOP
    advance (4)
    jump (1001);

1001:

    #1001
    #instruction: NOP
    advance (4)
    jump (1002);

1002:

    #1002
    #instruction: NOP
    advance (4)
    jump (1003);

1003:

    #1003
    #instruction: NOP
    advance (4)
    jump (1004);

1004:

    #1004
    #instruction: NOP
    advance (4)
    jump (1005);

1005:

    #1005
    #instruction: NOP
    advance (4)
    jump (1006);

1006:

    #1006
    #instruction: NOP
    advance (4)
    jump (1007);

1007:

    #1007
    #instruction: NOP
    advance (4)
    jump (1008);

1008:

    #1008
    #instruction: NOP
    advance (4)
    jump (1009);

1009:

    #1009
    #instruction: NOP
    advance (4)
    jump (100A);

100A:

    #100A
    #instruction: NOP
    advance (4)
    jump (100B);

100B:

    #100B
    #instruction: NOP
    advance (4)
    jump (100C);

100C:

    #100C
    #instruction: NOP
    advance (4)
    jump (100D);

100D:

    #100D
    #instruction: NOP
    advance (4)
    jump (100E);

100E:

    #100E
    #instruction: NOP
    advance (4)
    jump (100F);

100F:

    #100F
    #instruction: NOP
    advance (4)
    jump (1010);

1010:

    #1010
    #instruction: NOP
    advance (4)
    jump (1011);

1011:

    #1011
    #instruction: NOP
    advance (4)
    jump (1012);

1012:

    #1012
    #instruction: NOP
    advance (4)
    jump (1013);

1013:

    #1013
    #instruction: NOP
    advance (4)
    jump (1014);

1014:

    #1014
    #instruction: NOP
    advance (4)
    jump (1015);

1015:

    #1015
    #instruction: NOP
    advance (4)
    jump (1016);

1016:

    #1016
    #instruction: NOP
    advance (4)
    jump (1017);

1017:

    #1017
    #instruction: NOP
    advance (4)
    jump (1018);

1018:

    #1018
    #instruction: NOP
    advance (4)
    jump (1019);

1019:

    #1019
    #instruction: NOP
    advance (4)
    jump (101A);

101A:

    #101A
    #instruction: NOP
    advance (4)
    jump (101B);

101B:

    #101B
    #instruction: NOP
    advance (4)
    jump (101C);

101C:

    #101C
    #instruction: NOP
    advance (4)
    jump (101D);

101D:

    #101D
    #instruction: NOP
    advance (4)
    jump (101E);

101E:

    #101E
    #instruction: NOP
    advance (4)
    jump (101F);

101F:

    #101F
    #instruction: NOP
    advance (4)
    jump (1020);

1020:

    #1020
    #instruction: NOP
    advance (4)
    jump (1021);

1021:

    #1021
    #instruction: NOP
    advance (4)
    jump (1022);

1022:

    #1022
    #instruction: NOP
    advance (4)
    jump (1023);

1023:

    #1023
    #instruction: NOP
    advance (4)
    jump (1024);

1024:

    #1024
    #instruction: NOP
    advance (4)
    jump (1025);

1025:

    #1025
    #instruction: NOP
    advance (4)
    jump (1026);

1026:

    #1026
    #instruction: NOP
    advance (4)
    jump (1027);

1027:

    #1027
    #instruction: NOP
    advance (4)
    jump (1028);

1028:

    #1028
    #instruction: NOP
    advance (4)
    jump (1029);

1029:

    #1029
    #instruction: NOP
    advance (4)
    jump (102A);

102A:

    #102A
    #instruction: NOP
    advance (4)
    jump (102B);

102B:

    #102B
    #instruction: NOP
    advance (4)
    jump (102C);

102C:

    #102C
    #instruction: NOP
    advance (4)
    jump (102D);

102D:

    #102D
    #instruction: NOP
    advance (4)
    jump (102E);

102E:

    #102E
    #instruction: NOP
    advance (4)
    jump (102F);

102F:

    #102F
    #instruction: NOP
    advance (4)
    jump (1030);

1030:

    #1030
    #instruction: NOP
    advance (4)
    jump (1031);

1031:

    #1031
    #instruction: NOP
    advance (4)
    jump (1032);

1032:

    #1032
    #instruction: NOP
    advance (4)
    jump (1033);

1033:

    #1033
    #instruction: NOP
    advance (4)
    jump (1034);

1034:

    #1034
    #instruction: NOP
    advance (4)
    jump (1035);

1035:

    #1035
    #instruction: NOP
    advance (4)
    jump (1036);

1036:

    #1036
    #instruction: NOP
    advance (4)
    jump (1037);

1037:

    #1037
    #instruction: NOP
    advance (4)
    jump (1038);

1038:

    #1038
    #instruction: NOP
    advance (4)
    jump (1039);

1039:

    #1039
    #instruction: NOP
    advance (4)
    jump (103A);

103A:

    #103A
    #instruction: NOP
    advance (4)
    jump (103B);

103B:

    #103B
    #instruction: NOP
    advance (4)
    jump (103C);

103C:

    #103C
    #instruction: NOP
    advance (4)
    jump (103D);

103D:

    #103D
    #instruction: NOP
    advance (4)
    jump (103E);

103E:

    #103E
    #instruction: NOP
    advance (4)
    jump (103F);

103F:

    #103F
    #instruction: NOP
    advance (4)
    jump (1040);

1040:

    #1040
    #instruction: NOP
    advance (4)
    jump (1041);

1041:

    #1041
    #instruction: NOP
    advance (4)
    jump (1042);

1042:

    #1042
    #instruction: NOP
    advance (4)
    jump (1043);

1043:

    #1043
    #instruction: NOP
    advance (4)
    jump (1044);

1044:

    #1044
    #instruction: NOP
    advance (4)
    jump (1045);

1045:

    #1045
    #instruction: NOP
    advance (4)
    jump (1046);

1046:

    #1046
    #instruction: NOP
    advance (4)
    jump (1047);

1047:

    #1047
    #instruction: NOP
    advance (4)
    jump (1048);

1048:

    #1048
    #instruction: NOP
    advance (4)
    jump (1049);

1049:

    #1049
    #instruction: NOP
    advance (4)
    jump (104A);

104A:

    #104A
    #instruction: NOP
    advance (4)
    jump (104B);

104B:

    #104B
    #instruction: NOP
    advance (4)
    jump (104C);

104C:

    #104C
    #instruction: NOP
    advance (4)
    jump (104D);

104D:

    #104D
    #instruction: NOP
    advance (4)
    jump (104E);

104E:

    #104E
    #instruction: NOP
    advance (4)
    jump (104F);

104F:

    #104F
    #instruction: NOP
    advance (4)
    jump (1050);

1050:

    #1050
    #instruction: NOP
    advance (4)
    jump (1051);

1051:

    #1051
    #instruction: NOP
    advance (4)
    jump (1052);

1052:

    #1052
    #instruction: NOP
    advance (4)
    jump (1053);

1053:

    #1053
    #instruction: NOP
    advance (4)
    jump (1054);

1054:

    #1054
    #instruction: NOP
    advance (4)
    jump (1055);

1055:

    #1055
    #instruction: NOP
    advance (4)
    jump (1056);

1056:

    #1056
    #instruction: NOP
    advance (4)
    jump (1057);

1057:

    #1057
    #instruction: NOP
    advance (4)
    jump (1058);

1058:

    #1058
    #instruction: NOP
    advance (4)
    jump (1059);

1059:

    #1059
    #instruction: NOP
    advance (4)
    jump (105A);

105A:

    #105A
    #instruction: NOP
    advance (4)
    jump (105B);

105B:

    #105B
    #instruction: NOP
    advance (4)
    jump (105C);

105C:

    #105C
    #instruction: NOP
    advance (4)
    jump (105D);

105D:

    #105D
    #instruction: NOP
    advance (4)
    jump (105E);

105E:

    #105E
    #instruction: NOP
    advance (4)
    jump (105F);

105F:

    #105F
    #instruction: NOP
    advance (4)
    jump (1060);

1060:

    #1060
    #instruction: NOP
    advance (4)
    jump (1061);

1061:

    #1061
    #instruction: NOP
    advance (4)
    jump (1062);

1062:

    #1062
    #instruction: NOP
    advance (4)
    jump (1063);

1063:

    #1063
    #instruction: NOP
    advance (4)
    jump (1064);

1064:

    #1064
    #instruction: NOP
    advance (4)
    jump (1065);

1065:

    #1065
    #instruction: NOP
    advance (4)
    jump (1066);

1066:

    #1066
    #instruction: NOP
    advance (4)
    jump (1067);

1067:

    #1067
    #instruction: NOP
    advance (4)
    jump (1068);

1068:

    #1068
    #instruction: NOP
    advance (4)
    jump (1069);

1069:

    #1069
    #instruction: NOP
    advance (4)
    jump (106A);

106A:

    #106A
    #instruction: NOP
    advance (4)
    jump (106B);

106B:

    #106B
    #instruction: NOP
    advance (4)
    jump (106C);

106C:

    #106C
    #instruction: NOP
    advance (4)
    jump (106D);

106D:

    #106D
    #instruction: NOP
    advance (4)
    jump (106E);

106E:

    #106E
    #instruction: NOP
    advance (4)
    jump (106F);

106F:

    #106F
    #instruction: NOP
    advance (4)
    jump (1070);

1070:

    #1070
    #instruction: NOP
    advance (4)
    jump (1071);

1071:

    #1071
    #instruction: NOP
    advance (4)
    jump (1072);

1072:

    #1072
    #instruction: NOP
    advance (4)
    jump (1073);

1073:

    #1073
    #instruction: NOP
    advance (4)
    jump (1074);

1074:

    #1074
    #instruction: NOP
    advance (4)
    jump (1075);

1075:

    #1075
    #instruction: NOP
    advance (4)
    jump (1076);

1076:

    #1076
    #instruction: NOP
    advance (4)
    jump (1077);

1077:

    #1077
    #instruction: NOP
    advance (4)
    jump (1078);

1078:

    #1078
    #instruction: NOP
    advance (4)
    jump (1079);

1079:

    #1079
    #instruction: NOP
    advance (4)
    jump (107A);

107A:

    #107A
    #instruction: NOP
    advance (4)
    jump (107B);

107B:

    #107B
    #instruction: NOP
    advance (4)
    jump (107C);

107C:

    #107C
    #instruction: NOP
    advance (4)
    jump (107D);

107D:

    #107D
    #instruction: NOP
    advance (4)
    jump (107E);

107E:

    #107E
    #instruction: NOP
    advance (4)
    jump (107F);

107F:

    #107F
    #instruction: NOP
    advance (4)
    jump (1080);

1080:

    #1080
    #instruction: NOP
    advance (4)
    jump (1081);

1081:

    #1081
    #instruction: NOP
    advance (4)
    jump (1082);

1082:

    #1082
    #instruction: NOP
    advance (4)
    jump (1083);

1083:

    #1083
    #instruction: NOP
    advance (4)
    jump (1084);

1084:

    #1084
    #instruction: NOP
    advance (4)
    jump (1085);

1085:

    #1085
    #instruction: NOP
    advance (4)
    jump (1086);

1086:

    #1086
    #instruction: NOP
    advance (4)
    jump (1087);

1087:

    #1087
    #instruction: NOP
    advance (4)
    jump (1088);

1088:

    #1088
    #instruction: NOP
    advance (4)
    jump (1089);

1089:

    #1089
    #instruction: NOP
    advance (4)
    jump (108A);

108A:

    #108A
    #instruction: NOP
    advance (4)
    jump (108B);

108B:

    #108B
    #instruction: NOP
    advance (4)
    jump (108C);

108C:

    #108C
    #instruction: NOP
    advance (4)
    jump (108D);

108D:

    #108D
    #instruction: NOP
    advance (4)
    jump (108E);

108E:

    #108E
    #instruction: NOP
    advance (4)
    jump (108F);

108F:

    #108F
    #instruction: NOP
    advance (4)
    jump (1090);

1090:

    #1090
    #instruction: NOP
    advance (4)
    jump (1091);

1091:

    #1091
    #instruction: NOP
    advance (4)
    jump (1092);

1092:

    #1092
    #instruction: NOP
    advance (4)
    jump (1093);

1093:

    #1093
    #instruction: NOP
    advance (4)
    jump (1094);

1094:

    #1094
    #instruction: NOP
    advance (4)
    jump (1095);

1095:

    #1095
    #instruction: NOP
    advance (4)
    jump (1096);

1096:

    #1096
    #instruction: NOP
    advance (4)
    jump (1097);

1097:

    #1097
    #instruction: NOP
    advance (4)
    jump (1098);

1098:

    #1098
    #instruction: NOP
    advance (4)
    jump (1099);

1099:

    #1099
    #instruction: NOP
    advance (4)
    jump (109A);

109A:

    #109A
    #instruction: NOP
    advance (4)
    jump (109B);

109B:

    #109B
    #instruction: NOP
    advance (4)
    jump (109C);

109C:

    #109C
    #instruction: NOP
    advance (4)
    jump (109D);

109D:

    #109D
    #instruction: NOP
    advance (4)
    jump (109E);

109E:

    #109E
    #instruction: NOP
    advance (4)
    jump (109F);

109F:

    #109F
    #instruction: NOP
    advance (4)
    jump (10A0);

10A0:

    #10A0
    #instruction: NOP
    advance (4)
    jump (10A1);

10A1:

    #10A1
    #instruction: NOP
    advance (4)
    jump (10A2);

10A2:

    #10A2
    #instruction: NOP
    advance (4)
    jump (10A3);

10A3:

    #10A3
    #instruction: NOP
    advance (4)
    jump (10A4);

10A4:

    #10A4
    #instruction: NOP
    advance (4)
    jump (10A5);

10A5:

    #10A5
    #instruction: NOP
    advance (4)
    jump (10A6);

10A6:

    #10A6
    #instruction: NOP
    advance (4)
    jump (10A7);

10A7:

    #10A7
    #instruction: NOP
    advance (4)
    jump (10A8);

10A8:

    #10A8
    #instruction: NOP
    advance (4)
    jump (10A9);

10A9:

    #10A9
    #instruction: NOP
    advance (4)
    jump (10AA);

10AA:

    #10AA
    #instruction: NOP
    advance (4)
    jump (10AB);

10AB:

    #10AB
    #instruction: NOP
    advance (4)
    jump (10AC);

10AC:

    #10AC
    #instruction: NOP
    advance (4)
    jump (10AD);

10AD:

    #10AD
    #instruction: NOP
    advance (4)
    jump (10AE);

10AE:

    #10AE
    #instruction: NOP
    advance (4)
    jump (10AF);

10AF:

    #10AF
    #instruction: NOP
    advance (4)
    jump (10B0);

10B0:

    #10B0
    #instruction: NOP
    advance (4)
    jump (10B1);

10B1:

    #10B1
    #instruction: NOP
    advance (4)
    jump (10B2);

10B2:

    #10B2
    #instruction: NOP
    advance (4)
    jump (10B3);

10B3:

    #10B3
    #instruction: NOP
    advance (4)
    jump (10B4);

10B4:

    #10B4
    #instruction: NOP
    advance (4)
    jump (10B5);

10B5:

    #10B5
    #instruction: NOP
    advance (4)
    jump (10B6);

10B6:

    #10B6
    #instruction: NOP
    advance (4)
    jump (10B7);

10B7:

    #10B7
    #instruction: NOP
    advance (4)
    jump (10B8);

10B8:

    #10B8
    #instruction: NOP
    advance (4)
    jump (10B9);

10B9:

    #10B9
    #instruction: NOP
    advance (4)
    jump (10BA);

10BA:

    #10BA
    #instruction: NOP
    advance (4)
    jump (10BB);

10BB:

    #10BB
    #instruction: NOP
    advance (4)
    jump (10BC);

10BC:

    #10BC
    #instruction: NOP
    advance (4)
    jump (10BD);

10BD:

    #10BD
    #instruction: NOP
    advance (4)
    jump (10BE);

10BE:

    #10BE
    #instruction: NOP
    advance (4)
    jump (10BF);

10BF:

    #10BF
    #instruction: NOP
    advance (4)
    jump (10C0);

10C0:

    #10C0
    #instruction: NOP
    advance (4)
    jump (10C1);

10C1:

    #10C1
    #instruction: NOP
    advance (4)
    jump (10C2);

10C2:

    #10C2
    #instruction: NOP
    advance (4)
    jump (10C3);

10C3:

    #10C3
    #instruction: NOP
    advance (4)
    jump (10C4);

10C4:

    #10C4
    #instruction: NOP
    advance (4)
    jump (10C5);

10C5:

    #10C5
    #instruction: NOP
    advance (4)
    jump (10C6);

10C6:

    #10C6
    #instruction: NOP
    advance (4)
    jump (10C7);

10C7:

    #10C7
    #instruction: NOP
    advance (4)
    jump (10C8);

10C8:

    #10C8
    #instruction: NOP
    advance (4)
    jump (10C9);

10C9:

    #10C9
    #instruction: NOP
    advance (4)
    jump (10CA);

10CA:

    #10CA
    #instruction: NOP
    advance (4)
    jump (10CB);

10CB:

    #10CB
    #instruction: NOP
    advance (4)
    jump (10CC);

10CC:

    #10CC
    #instruction: NOP
    advance (4)
    jump (10CD);

10CD:

    #10CD
    #instruction: NOP
    advance (4)
    jump (10CE);

10CE:

    #10CE
    #instruction: NOP
    advance (4)
    jump (10CF);

10CF:

    #10CF
    #instruction: NOP
    advance (4)
    jump (10D0);

10D0:

    #10D0
    #instruction: NOP
    advance (4)
    jump (10D1);

10D1:

    #10D1
    #instruction: NOP
    advance (4)
    jump (10D2);

10D2:

    #10D2
    #instruction: NOP
    advance (4)
    jump (10D3);

10D3:

    #10D3
    #instruction: NOP
    advance (4)
    jump (10D4);

10D4:

    #10D4
    #instruction: NOP
    advance (4)
    jump (10D5);

10D5:

    #10D5
    #instruction: NOP
    advance (4)
    jump (10D6);

10D6:

    #10D6
    #instruction: NOP
    advance (4)
    jump (10D7);

10D7:

    #10D7
    #instruction: NOP
    advance (4)
    jump (10D8);

10D8:

    #10D8
    #instruction: NOP
    advance (4)
    jump (10D9);

10D9:

    #10D9
    #instruction: NOP
    advance (4)
    jump (10DA);

10DA:

    #10DA
    #instruction: NOP
    advance (4)
    jump (10DB);

10DB:

    #10DB
    #instruction: NOP
    advance (4)
    jump (10DC);

10DC:

    #10DC
    #instruction: NOP
    advance (4)
    jump (10DD);

10DD:

    #10DD
    #instruction: NOP
    advance (4)
    jump (10DE);

10DE:

    #10DE
    #instruction: NOP
    advance (4)
    jump (10DF);

10DF:

    #10DF
    #instruction: NOP
    advance (4)
    jump (10E0);

10E0:

    #10E0
    #instruction: NOP
    advance (4)
    jump (10E1);

10E1:

    #10E1
    #instruction: NOP
    advance (4)
    jump (10E2);

10E2:

    #10E2
    #instruction: NOP
    advance (4)
    jump (10E3);

10E3:

    #10E3
    #instruction: NOP
    advance (4)
    jump (10E4);

10E4:

    #10E4
    #instruction: NOP
    advance (4)
    jump (10E5);

10E5:

    #10E5
    #instruction: NOP
    advance (4)
    jump (10E6);

10E6:

    #10E6
    #instruction: NOP
    advance (4)
    jump (10E7);

10E7:

    #10E7
    #instruction: NOP
    advance (4)
    jump (10E8);

10E8:

    #10E8
    #instruction: NOP
    advance (4)
    jump (10E9);

10E9:

    #10E9
    #instruction: NOP
    advance (4)
    jump (10EA);

10EA:

    #10EA
    #instruction: NOP
    advance (4)
    jump (10EB);

10EB:

    #10EB
    #instruction: NOP
    advance (4)
    jump (10EC);

10EC:

    #10EC
    #instruction: NOP
    advance (4)
    jump (10ED);

10ED:

    #10ED
    #instruction: NOP
    advance (4)
    jump (10EE);

10EE:

    #10EE
    #instruction: NOP
    advance (4)
    jump (10EF);

10EF:

    #10EF
    #instruction: NOP
    advance (4)
    jump (10F0);

10F0:

    #10F0
    #instruction: NOP
    advance (4)
    jump (10F1);

10F1:

    #10F1
    #instruction: NOP
    advance (4)
    jump (10F2);

10F2:

    #10F2
    #instruction: NOP
    advance (4)
    jump (10F3);

10F3:

    #10F3
    #instruction: NOP
    advance (4)
    jump (10F4);

10F4:

    #10F4
    #instruction: NOP
    advance (4)
    jump (10F5);

10F5:

    #10F5
    #instruction: NOP
    advance (4)
    jump (10F6);

10F6:

    #10F6
    #instruction: NOP
    advance (4)
    jump (10F7);

10F7:

    #10F7
    #instruction: NOP
    advance (4)
    jump (10F8);

10F8:

    #10F8
    #instruction: NOP
    advance (4)
    jump (10F9);

10F9:

    #10F9
    #instruction: NOP
    advance (4)
    jump (10FA);

10FA:

    #10FA
    #instruction: NOP
    advance (4)
    jump (10FB);

10FB:

    #10FB
    #instruction: NOP
    advance (4)
    jump (10FC);

10FC:

    #10FC
    #instruction: NOP
    advance (4)
    jump (10FD);

10FD:

    #10FD
    #instruction: NOP
    advance (4)
    jump (10FE);

10FE:

    #10FE
    #instruction: NOP
    advance (4)
    jump (10FF);

10FF:

    #10FF
    #instruction: NOP
    advance (4)
    jump (1100);

1100:

    #1100
    #instruction: NOP
    advance (4)
    jump (1101);

1101:

    #1101
    #instruction: NOP
    advance (4)
    jump (1102);

1102:

    #1102
    #instruction: NOP
    advance (4)
    jump (1103);

1103:

    #1103
    #instruction: NOP
    advance (4)
    jump (1104);

1104:

    #1104
    #instruction: NOP
    advance (4)
    jump (1105);

1105:

    #1105
    #instruction: NOP
    advance (4)
    jump (1106);

1106:

    #1106
    #instruction: NOP
    advance (4)
    jump (1107);

1107:

    #1107
    #instruction: NOP
    advance (4)
    jump (1108);

1108:

    #1108
    #instruction: NOP
    advance (4)
    jump (1109);

1109:

    #1109
    #instruction: NOP
    advance (4)
    jump (110A);

110A:

    #110A
    #instruction: NOP
    advance (4)
    jump (110B);

110B:

    #110B
    #instruction: NOP
    advance (4)
    jump (110C);

110C:

    #110C
    #instruction: NOP
    advance (4)
    jump (110D);

110D:

    #110D
    #instruction: NOP
    advance (4)
    jump (110E);

110E:

    #110E
    #instruction: NOP
    advance (4)
    jump (110F);

110F:

    #110F
    #instruction: NOP
    advance (4)
    jump (1110);

1110:

    #1110
    #instruction: NOP
    advance (4)
    jump (1111);

1111:

    #1111
    #instruction: NOP
    advance (4)
    jump (1112);

1112:

    #1112
    #instruction: NOP
    advance (4)
    jump (1113);

1113:

    #1113
    #instruction: NOP
    advance (4)
    jump (1114);

1114:

    #1114
    #instruction: NOP
    advance (4)
    jump (1115);

1115:

    #1115
    #instruction: NOP
    advance (4)
    jump (1116);

1116:

    #1116
    #instruction: NOP
    advance (4)
    jump (1117);

1117:

    #1117
    #instruction: NOP
    advance (4)
    jump (1118);

1118:

    #1118
    #instruction: NOP
    advance (4)
    jump (1119);

1119:

    #1119
    #instruction: NOP
    advance (4)
    jump (111A);

111A:

    #111A
    #instruction: NOP
    advance (4)
    jump (111B);

111B:

    #111B
    #instruction: NOP
    advance (4)
    jump (111C);

111C:

    #111C
    #instruction: NOP
    advance (4)
    jump (111D);

111D:

    #111D
    #instruction: NOP
    advance (4)
    jump (111E);

111E:

    #111E
    #instruction: NOP
    advance (4)
    jump (111F);

111F:

    #111F
    #instruction: NOP
    advance (4)
    jump (1120);

1120:

    #1120
    #instruction: NOP
    advance (4)
    jump (1121);

1121:

    #1121
    #instruction: NOP
    advance (4)
    jump (1122);

1122:

    #1122
    #instruction: NOP
    advance (4)
    jump (1123);

1123:

    #1123
    #instruction: NOP
    advance (4)
    jump (1124);

1124:

    #1124
    #instruction: NOP
    advance (4)
    jump (1125);

1125:

    #1125
    #instruction: NOP
    advance (4)
    jump (1126);

1126:

    #1126
    #instruction: NOP
    advance (4)
    jump (1127);

1127:

    #1127
    #instruction: NOP
    advance (4)
    jump (1128);

1128:

    #1128
    #instruction: NOP
    advance (4)
    jump (1129);

1129:

    #1129
    #instruction: NOP
    advance (4)
    jump (112A);

112A:

    #112A
    #instruction: NOP
    advance (4)
    jump (112B);

112B:

    #112B
    #instruction: NOP
    advance (4)
    jump (112C);

112C:

    #112C
    #instruction: NOP
    advance (4)
    jump (112D);

112D:

    #112D
    #instruction: NOP
    advance (4)
    jump (112E);

112E:

    #112E
    #instruction: NOP
    advance (4)
    jump (112F);

112F:

    #112F
    #instruction: NOP
    advance (4)
    jump (1130);

1130:

    #1130
    #instruction: NOP
    advance (4)
    jump (1131);

1131:

    #1131
    #instruction: NOP
    advance (4)
    jump (1132);

1132:

    #1132
    #instruction: NOP
    advance (4)
    jump (1133);

1133:

    #1133
    #instruction: NOP
    advance (4)
    jump (1134);

1134:

    #1134
    #instruction: NOP
    advance (4)
    jump (1135);

1135:

    #1135
    #instruction: NOP
    advance (4)
    jump (1136);

1136:

    #1136
    #instruction: NOP
    advance (4)
    jump (1137);

1137:

    #1137
    #instruction: NOP
    advance (4)
    jump (1138);

1138:

    #1138
    #instruction: NOP
    advance (4)
    jump (1139);

1139:

    #1139
    #instruction: NOP
    advance (4)
    jump (113A);

113A:

    #113A
    #instruction: NOP
    advance (4)
    jump (113B);

113B:

    #113B
    #instruction: NOP
    advance (4)
    jump (113C);

113C:

    #113C
    #instruction: NOP
    advance (4)
    jump (113D);

113D:

    #113D
    #instruction: NOP
    advance (4)
    jump (113E);

113E:

    #113E
    #instruction: NOP
    advance (4)
    jump (113F);

113F:

    #113F
    #instruction: NOP
    advance (4)
    jump (1140);

1140:

    #1140
    #instruction: NOP
    advance (4)
    jump (1141);

1141:

    #1141
    #instruction: NOP
    advance (4)
    jump (1142);

1142:

    #1142
    #instruction: NOP
    advance (4)
    jump (1143);

1143:

    #1143
    #instruction: NOP
    advance (4)
    jump (1144);

1144:

    #1144
    #instruction: NOP
    advance (4)
    jump (1145);

1145:

    #1145
    #instruction: NOP
    advance (4)
    jump (1146);

1146:

    #1146
    #instruction: NOP
    advance (4)
    jump (1147);

1147:

    #1147
    #instruction: NOP
    advance (4)
    jump (1148);

1148:

    #1148
    #instruction: NOP
    advance (4)
    jump (1149);

1149:

    #1149
    #instruction: NOP
    advance (4)
    jump (114A);

114A:

    #114A
    #instruction: NOP
    advance (4)
    jump (114B);

114B:

    #114B
    #instruction: NOP
    advance (4)
    jump (114C);

114C:

    #114C
    #instruction: NOP
    advance (4)
    jump (114D);

114D:

    #114D
    #instruction: NOP
    advance (4)
    jump (114E);

114E:

    #114E
    #instruction: NOP
    advance (4)
    jump (114F);

114F:

    #114F
    #instruction: NOP
    advance (4)
    jump (1150);

1150:

    #1150
    #instruction: NOP
    advance (4)
    jump (1151);

1151:

    #1151
    #instruction: NOP
    advance (4)
    jump (1152);

1152:

    #1152
    #instruction: NOP
    advance (4)
    jump (1153);

1153:

    #1153
    #instruction: NOP
    advance (4)
    jump (1154);

1154:

    #1154
    #instruction: NOP
    advance (4)
    jump (1155);

1155:

    #1155
    #instruction: NOP
    advance (4)
    jump (1156);

1156:

    #1156
    #instruction: NOP
    advance (4)
    jump (1157);

1157:

    #1157
    #instruction: NOP
    advance (4)
    jump (1158);

1158:

    #1158
    #instruction: NOP
    advance (4)
    jump (1159);

1159:

    #1159
    #instruction: NOP
    advance (4)
    jump (115A);

115A:

    #115A
    #instruction: NOP
    advance (4)
    jump (115B);

115B:

    #115B
    #instruction: NOP
    advance (4)
    jump (115C);

115C:

    #115C
    #instruction: NOP
    advance (4)
    jump (115D);

115D:

    #115D
    #instruction: NOP
    advance (4)
    jump (115E);

115E:

    #115E
    #instruction: NOP
    advance (4)
    jump (115F);

115F:

    #115F
    #instruction: NOP
    advance (4)
    jump (1160);

1160:

    #1160
    #instruction: NOP
    advance (4)
    jump (1161);

1161:

    #1161
    #instruction: NOP
    advance (4)
    jump (1162);

1162:

    #1162
    #instruction: NOP
    advance (4)
    jump (1163);

1163:

    #1163
    #instruction: NOP
    advance (4)
    jump (1164);

1164:

    #1164
    #instruction: NOP
    advance (4)
    jump (1165);

1165:

    #1165
    #instruction: NOP
    advance (4)
    jump (1166);

1166:

    #1166
    #instruction: NOP
    advance (4)
    jump (1167);

1167:

    #1167
    #instruction: NOP
    advance (4)
    jump (1168);

1168:

    #1168
    #instruction: NOP
    advance (4)
    jump (1169);

1169:

    #1169
    #instruction: NOP
    advance (4)
    jump (116A);

116A:

    #116A
    #instruction: NOP
    advance (4)
    jump (116B);

116B:

    #116B
    #instruction: NOP
    advance (4)
    jump (116C);

116C:

    #116C
    #instruction: NOP
    advance (4)
    jump (116D);

116D:

    #116D
    #instruction: NOP
    advance (4)
    jump (116E);

116E:

    #116E
    #instruction: NOP
    advance (4)
    jump (116F);

116F:

    #116F
    #instruction: NOP
    advance (4)
    jump (1170);

1170:

    #1170
    #instruction: NOP
    advance (4)
    jump (1171);

1171:

    #1171
    #instruction: NOP
    advance (4)
    jump (1172);

1172:

    #1172
    #instruction: NOP
    advance (4)
    jump (1173);

1173:

    #1173
    #instruction: NOP
    advance (4)
    jump (1174);

1174:

    #1174
    #instruction: NOP
    advance (4)
    jump (1175);

1175:

    #1175
    #instruction: NOP
    advance (4)
    jump (1176);

1176:

    #1176
    #instruction: NOP
    advance (4)
    jump (1177);

1177:

    #1177
    #instruction: NOP
    advance (4)
    jump (1178);

1178:

    #1178
    #instruction: NOP
    advance (4)
    jump (1179);

1179:

    #1179
    #instruction: NOP
    advance (4)
    jump (117A);

117A:

    #117A
    #instruction: NOP
    advance (4)
    jump (117B);

117B:

    #117B
    #instruction: NOP
    advance (4)
    jump (117C);

117C:

    #117C
    #instruction: NOP
    advance (4)
    jump (117D);

117D:

    #117D
    #instruction: NOP
    advance (4)
    jump (117E);

117E:

    #117E
    #instruction: NOP
    advance (4)
    jump (117F);

117F:

    #117F
    #instruction: NOP
    advance (4)
    jump (1180);

1180:

    #1180
    #instruction: NOP
    advance (4)
    jump (1181);

1181:

    #1181
    #instruction: NOP
    advance (4)
    jump (1182);

1182:

    #1182
    #instruction: NOP
    advance (4)
    jump (1183);

1183:

    #1183
    #instruction: NOP
    advance (4)
    jump (1184);

1184:

    #1184
    #instruction: NOP
    advance (4)
    jump (1185);

1185:

    #1185
    #instruction: NOP
    advance (4)
    jump (1186);

1186:

    #1186
    #instruction: NOP
    advance (4)
    jump (1187);

1187:

    #1187
    #instruction: NOP
    advance (4)
    jump (1188);

1188:

    #1188
    #instruction: NOP
    advance (4)
    jump (1189);

1189:

    #1189
    #instruction: NOP
    advance (4)
    jump (118A);

118A:

    #118A
    #instruction: NOP
    advance (4)
    jump (118B);

118B:

    #118B
    #instruction: NOP
    advance (4)
    jump (118C);

118C:

    #118C
    #instruction: NOP
    advance (4)
    jump (118D);

118D:

    #118D
    #instruction: NOP
    advance (4)
    jump (118E);

118E:

    #118E
    #instruction: NOP
    advance (4)
    jump (118F);

118F:

    #118F
    #instruction: NOP
    advance (4)
    jump (1190);

1190:

    #1190
    #instruction: NOP
    advance (4)
    jump (1191);

1191:

    #1191
    #instruction: NOP
    advance (4)
    jump (1192);

1192:

    #1192
    #instruction: NOP
    advance (4)
    jump (1193);

1193:

    #1193
    #instruction: NOP
    advance (4)
    jump (1194);

1194:

    #1194
    #instruction: NOP
    advance (4)
    jump (1195);

1195:

    #1195
    #instruction: NOP
    advance (4)
    jump (1196);

1196:

    #1196
    #instruction: NOP
    advance (4)
    jump (1197);

1197:

    #1197
    #instruction: NOP
    advance (4)
    jump (1198);

1198:

    #1198
    #instruction: NOP
    advance (4)
    jump (1199);

1199:

    #1199
    #instruction: NOP
    advance (4)
    jump (119A);

119A:

    #119A
    #instruction: NOP
    advance (4)
    jump (119B);

119B:

    #119B
    #instruction: NOP
    advance (4)
    jump (119C);

119C:

    #119C
    #instruction: NOP
    advance (4)
    jump (119D);

119D:

    #119D
    #instruction: NOP
    advance (4)
    jump (119E);

119E:

    #119E
    #instruction: NOP
    advance (4)
    jump (119F);

119F:

    #119F
    #instruction: NOP
    advance (4)
    jump (11A0);

11A0:

    #11A0
    #instruction: NOP
    advance (4)
    jump (11A1);

11A1:

    #11A1
    #instruction: NOP
    advance (4)
    jump (11A2);

11A2:

    #11A2
    #instruction: NOP
    advance (4)
    jump (11A3);

11A3:

    #11A3
    #instruction: NOP
    advance (4)
    jump (11A4);

11A4:

    #11A4
    #instruction: NOP
    advance (4)
    jump (11A5);

11A5:

    #11A5
    #instruction: NOP
    advance (4)
    jump (11A6);

11A6:

    #11A6
    #instruction: NOP
    advance (4)
    jump (11A7);

11A7:

    #11A7
    #instruction: NOP
    advance (4)
    jump (11A8);

11A8:

    #11A8
    #instruction: NOP
    advance (4)
    jump (11A9);

11A9:

    #11A9
    #instruction: NOP
    advance (4)
    jump (11AA);

11AA:

    #11AA
    #instruction: NOP
    advance (4)
    jump (11AB);

11AB:

    #11AB
    #instruction: NOP
    advance (4)
    jump (11AC);

11AC:

    #11AC
    #instruction: NOP
    advance (4)
    jump (11AD);

11AD:

    #11AD
    #instruction: NOP
    advance (4)
    jump (11AE);

11AE:

    #11AE
    #instruction: NOP
    advance (4)
    jump (11AF);

11AF:

    #11AF
    #instruction: NOP
    advance (4)
    jump (11B0);

11B0:

    #11B0
    #instruction: NOP
    advance (4)
    jump (11B1);

11B1:

    #11B1
    #instruction: NOP
    advance (4)
    jump (11B2);

11B2:

    #11B2
    #instruction: NOP
    advance (4)
    jump (11B3);

11B3:

    #11B3
    #instruction: NOP
    advance (4)
    jump (11B4);

11B4:

    #11B4
    #instruction: NOP
    advance (4)
    jump (11B5);

11B5:

    #11B5
    #instruction: NOP
    advance (4)
    jump (11B6);

11B6:

    #11B6
    #instruction: NOP
    advance (4)
    jump (11B7);

11B7:

    #11B7
    #instruction: NOP
    advance (4)
    jump (11B8);

11B8:

    #11B8
    #instruction: NOP
    advance (4)
    jump (11B9);

11B9:

    #11B9
    #instruction: NOP
    advance (4)
    jump (11BA);

11BA:

    #11BA
    #instruction: NOP
    advance (4)
    jump (11BB);

11BB:

    #11BB
    #instruction: NOP
    advance (4)
    jump (11BC);

11BC:

    #11BC
    #instruction: NOP
    advance (4)
    jump (11BD);

11BD:

    #11BD
    #instruction: NOP
    advance (4)
    jump (11BE);

11BE:

    #11BE
    #instruction: NOP
    advance (4)
    jump (11BF);

11BF:

    #11BF
    #instruction: NOP
    advance (4)
    jump (11C0);

11C0:

    #11C0
    #instruction: NOP
    advance (4)
    jump (11C1);

11C1:

    #11C1
    #instruction: NOP
    advance (4)
    jump (11C2);

11C2:

    #11C2
    #instruction: NOP
    advance (4)
    jump (11C3);

11C3:

    #11C3
    #instruction: NOP
    advance (4)
    jump (11C4);

11C4:

    #11C4
    #instruction: NOP
    advance (4)
    jump (11C5);

11C5:

    #11C5
    #instruction: NOP
    advance (4)
    jump (11C6);

11C6:

    #11C6
    #instruction: NOP
    advance (4)
    jump (11C7);

11C7:

    #11C7
    #instruction: NOP
    advance (4)
    jump (11C8);

11C8:

    #11C8
    #instruction: NOP
    advance (4)
    jump (11C9);

11C9:

    #11C9
    #instruction: NOP
    advance (4)
    jump (11CA);

11CA:

    #11CA
    #instruction: NOP
    advance (4)
    jump (11CB);

11CB:

    #11CB
    #instruction: NOP
    advance (4)
    jump (11CC);

11CC:

    #11CC
    #instruction: NOP
    advance (4)
    jump (11CD);

11CD:

    #11CD
    #instruction: NOP
    advance (4)
    jump (11CE);

11CE:

    #11CE
    #instruction: NOP
    advance (4)
    jump (11CF);

11CF:

    #11CF
    #instruction: NOP
    advance (4)
    jump (11D0);

11D0:

    #11D0
    #instruction: NOP
    advance (4)
    jump (11D1);

11D1:

    #11D1
    #instruction: NOP
    advance (4)
    jump (11D2);

11D2:

    #11D2
    #instruction: NOP
    advance (4)
    jump (11D3);

11D3:

    #11D3
    #instruction: NOP
    advance (4)
    jump (11D4);

11D4:

    #11D4
    #instruction: NOP
    advance (4)
    jump (11D5);

11D5:

    #11D5
    #instruction: NOP
    advance (4)
    jump (11D6);

11D6:

    #11D6
    #instruction: NOP
    advance (4)
    jump (11D7);

11D7:

    #11D7
    #instruction: NOP
    advance (4)
    jump (11D8);

11D8:

    #11D8
    #instruction: NOP
    advance (4)
    jump (11D9);

11D9:

    #11D9
    #instruction: NOP
    advance (4)
    jump (11DA);

11DA:

    #11DA
    #instruction: NOP
    advance (4)
    jump (11DB);

11DB:

    #11DB
    #instruction: NOP
    advance (4)
    jump (11DC);

11DC:

    #11DC
    #instruction: NOP
    advance (4)
    jump (11DD);

11DD:

    #11DD
    #instruction: NOP
    advance (4)
    jump (11DE);

11DE:

    #11DE
    #instruction: NOP
    advance (4)
    jump (11DF);

11DF:

    #11DF
    #instruction: NOP
    advance (4)
    jump (11E0);

11E0:

    #11E0
    #instruction: NOP
    advance (4)
    jump (11E1);

11E1:

    #11E1
    #instruction: NOP
    advance (4)
    jump (11E2);

11E2:

    #11E2
    #instruction: NOP
    advance (4)
    jump (11E3);

11E3:

    #11E3
    #instruction: NOP
    advance (4)
    jump (11E4);

11E4:

    #11E4
    #instruction: NOP
    advance (4)
    jump (11E5);

11E5:

    #11E5
    #instruction: NOP
    advance (4)
    jump (11E6);

11E6:

    #11E6
    #instruction: NOP
    advance (4)
    jump (11E7);

11E7:

    #11E7
    #instruction: NOP
    advance (4)
    jump (11E8);

11E8:

    #11E8
    #instruction: NOP
    advance (4)
    jump (11E9);

11E9:

    #11E9
    #instruction: NOP
    advance (4)
    jump (11EA);

11EA:

    #11EA
    #instruction: NOP
    advance (4)
    jump (11EB);

11EB:

    #11EB
    #instruction: NOP
    advance (4)
    jump (11EC);

11EC:

    #11EC
    #instruction: NOP
    advance (4)
    jump (11ED);

11ED:

    #11ED
    #instruction: NOP
    advance (4)
    jump (11EE);

11EE:

    #11EE
    #instruction: NOP
    advance (4)
    jump (11EF);

11EF:

    #11EF
    #instruction: NOP
    advance (4)
    jump (11F0);

11F0:

    #11F0
    #instruction: NOP
    advance (4)
    jump (11F1);

11F1:

    #11F1
    #instruction: NOP
    advance (4)
    jump (11F2);

11F2:

    #11F2
    #instruction: NOP
    advance (4)
    jump (11F3);

11F3:

    #11F3
    #instruction: NOP
    advance (4)
    jump (11F4);

11F4:

    #11F4
    #instruction: NOP
    advance (4)
    jump (11F5);

11F5:

    #11F5
    #instruction: NOP
    advance (4)
    jump (11F6);

11F6:

    #11F6
    #instruction: NOP
    advance (4)
    jump (11F7);

11F7:

    #11F7
    #instruction: NOP
    advance (4)
    jump (11F8);

11F8:

    #11F8
    #instruction: NOP
    advance (4)
    jump (11F9);

11F9:

    #11F9
    #instruction: NOP
    advance (4)
    jump (11FA);

11FA:

    #11FA
    #instruction: NOP
    advance (4)
    jump (11FB);

11FB:

    #11FB
    #instruction: NOP
    advance (4)
    jump (11FC);

11FC:

    #11FC
    #instruction: NOP
    advance (4)
    jump (11FD);

11FD:

    #11FD
    #instruction: NOP
    advance (4)
    jump (11FE);

11FE:

    #11FE
    #instruction: NOP
    advance (4)
    jump (11FF);

11FF:

    #11FF
    #instruction: NOP
    advance (4)
    jump (1200);

1200:

    #1200
    #instruction: NOP
    advance (4)
    jump (1201);

1201:

    #1201
    #instruction: NOP
    advance (4)
    jump (1202);

1202:

    #1202
    #instruction: NOP
    advance (4)
    jump (1203);

1203:

    #1203
    #instruction: NOP
    advance (4)
    jump (1204);

1204:

    #1204
    #instruction: NOP
    advance (4)
    jump (1205);

1205:

    #1205
    #instruction: NOP
    advance (4)
    jump (1206);

1206:

    #1206
    #instruction: NOP
    advance (4)
    jump (1207);

1207:

    #1207
    #instruction: NOP
    advance (4)
    jump (1208);

1208:

    #1208
    #instruction: NOP
    advance (4)
    jump (1209);

1209:

    #1209
    #instruction: NOP
    advance (4)
    jump (120A);

120A:

    #120A
    #instruction: NOP
    advance (4)
    jump (120B);

120B:

    #120B
    #instruction: NOP
    advance (4)
    jump (120C);

120C:

    #120C
    #instruction: NOP
    advance (4)
    jump (120D);

120D:

    #120D
    #instruction: NOP
    advance (4)
    jump (120E);

120E:

    #120E
    #instruction: NOP
    advance (4)
    jump (120F);

120F:

    #120F
    #instruction: NOP
    advance (4)
    jump (1210);

1210:

    #1210
    #instruction: NOP
    advance (4)
    jump (1211);

1211:

    #1211
    #instruction: NOP
    advance (4)
    jump (1212);

1212:

    #1212
    #instruction: NOP
    advance (4)
    jump (1213);

1213:

    #1213
    #instruction: NOP
    advance (4)
    jump (1214);

1214:

    #1214
    #instruction: NOP
    advance (4)
    jump (1215);

1215:

    #1215
    #instruction: NOP
    advance (4)
    jump (1216);

1216:

    #1216
    #instruction: NOP
    advance (4)
    jump (1217);

1217:

    #1217
    #instruction: NOP
    advance (4)
    jump (1218);

1218:

    #1218
    #instruction: NOP
    advance (4)
    jump (1219);

1219:

    #1219
    #instruction: NOP
    advance (4)
    jump (121A);

121A:

    #121A
    #instruction: NOP
    advance (4)
    jump (121B);

121B:

    #121B
    #instruction: NOP
    advance (4)
    jump (121C);

121C:

    #121C
    #instruction: NOP
    advance (4)
    jump (121D);

121D:

    #121D
    #instruction: NOP
    advance (4)
    jump (121E);

121E:

    #121E
    #instruction: NOP
    advance (4)
    jump (121F);

121F:

    #121F
    #instruction: NOP
    advance (4)
    jump (1220);

1220:

    #1220
    #instruction: NOP
    advance (4)
    jump (1221);

1221:

    #1221
    #instruction: NOP
    advance (4)
    jump (1222);

1222:

    #1222
    #instruction: NOP
    advance (4)
    jump (1223);

1223:

    #1223
    #instruction: NOP
    advance (4)
    jump (1224);

1224:

    #1224
    #instruction: NOP
    advance (4)
    jump (1225);

1225:

    #1225
    #instruction: NOP
    advance (4)
    jump (1226);

1226:

    #1226
    #instruction: NOP
    advance (4)
    jump (1227);

1227:

    #1227
    #instruction: NOP
    advance (4)
    jump (1228);

1228:

    #1228
    #instruction: NOP
    advance (4)
    jump (1229);

1229:

    #1229
    #instruction: NOP
    advance (4)
    jump (122A);

122A:

    #122A
    #instruction: NOP
    advance (4)
    jump (122B);

122B:

    #122B
    #instruction: NOP
    advance (4)
    jump (122C);

122C:

    #122C
    #instruction: NOP
    advance (4)
    jump (122D);

122D:

    #122D
    #instruction: NOP
    advance (4)
    jump (122E);

122E:

    #122E
    #instruction: NOP
    advance (4)
    jump (122F);

122F:

    #122F
    #instruction: NOP
    advance (4)
    jump (1230);

1230:

    #1230
    #instruction: NOP
    advance (4)
    jump (1231);

1231:

    #1231
    #instruction: NOP
    advance (4)
    jump (1232);

1232:

    #1232
    #instruction: NOP
    advance (4)
    jump (1233);

1233:

    #1233
    #instruction: NOP
    advance (4)
    jump (1234);

1234:

    #1234
    #instruction: NOP
    advance (4)
    jump (1235);

1235:

    #1235
    #instruction: NOP
    advance (4)
    jump (1236);

1236:

    #1236
    #instruction: NOP
    advance (4)
    jump (1237);

1237:

    #1237
    #instruction: NOP
    advance (4)
    jump (1238);

1238:

    #1238
    #instruction: NOP
    advance (4)
    jump (1239);

1239:

    #1239
    #instruction: NOP
    advance (4)
    jump (123A);

123A:

    #123A
    #instruction: NOP
    advance (4)
    jump (123B);

123B:

    #123B
    #instruction: NOP
    advance (4)
    jump (123C);

123C:

    #123C
    #instruction: NOP
    advance (4)
    jump (123D);

123D:

    #123D
    #instruction: NOP
    advance (4)
    jump (123E);

123E:

    #123E
    #instruction: NOP
    advance (4)
    jump (123F);

123F:

    #123F
    #instruction: NOP
    advance (4)
    jump (1240);

1240:

    #1240
    #instruction: NOP
    advance (4)
    jump (1241);

1241:

    #1241
    #instruction: NOP
    advance (4)
    jump (1242);

1242:

    #1242
    #instruction: NOP
    advance (4)
    jump (1243);

1243:

    #1243
    #instruction: NOP
    advance (4)
    jump (1244);

1244:

    #1244
    #instruction: NOP
    advance (4)
    jump (1245);

1245:

    #1245
    #instruction: NOP
    advance (4)
    jump (1246);

1246:

    #1246
    #instruction: NOP
    advance (4)
    jump (1247);

1247:

    #1247
    #instruction: NOP
    advance (4)
    jump (1248);

1248:

    #1248
    #instruction: NOP
    advance (4)
    jump (1249);

1249:

    #1249
    #instruction: NOP
    advance (4)
    jump (124A);

124A:

    #124A
    #instruction: NOP
    advance (4)
    jump (124B);

124B:

    #124B
    #instruction: NOP
    advance (4)
    jump (124C);

124C:

    #124C
    #instruction: NOP
    advance (4)
    jump (124D);

124D:

    #124D
    #instruction: NOP
    advance (4)
    jump (124E);

124E:

    #124E
    #instruction: NOP
    advance (4)
    jump (124F);

124F:

    #124F
    #instruction: NOP
    advance (4)
    jump (1250);

1250:

    #1250
    #instruction: NOP
    advance (4)
    jump (1251);

1251:

    #1251
    #instruction: NOP
    advance (4)
    jump (1252);

1252:

    #1252
    #instruction: NOP
    advance (4)
    jump (1253);

1253:

    #1253
    #instruction: NOP
    advance (4)
    jump (1254);

1254:

    #1254
    #instruction: NOP
    advance (4)
    jump (1255);

1255:

    #1255
    #instruction: NOP
    advance (4)
    jump (1256);

1256:

    #1256
    #instruction: NOP
    advance (4)
    jump (1257);

1257:

    #1257
    #instruction: NOP
    advance (4)
    jump (1258);

1258:

    #1258
    #instruction: NOP
    advance (4)
    jump (1259);

1259:

    #1259
    #instruction: NOP
    advance (4)
    jump (125A);

125A:

    #125A
    #instruction: NOP
    advance (4)
    jump (125B);

125B:

    #125B
    #instruction: NOP
    advance (4)
    jump (125C);

125C:

    #125C
    #instruction: NOP
    advance (4)
    jump (125D);

125D:

    #125D
    #instruction: NOP
    advance (4)
    jump (125E);

125E:

    #125E
    #instruction: NOP
    advance (4)
    jump (125F);

125F:

    #125F
    #instruction: NOP
    advance (4)
    jump (1260);

1260:

    #1260
    #instruction: NOP
    advance (4)
    jump (1261);

1261:

    #1261
    #instruction: NOP
    advance (4)
    jump (1262);

1262:

    #1262
    #instruction: NOP
    advance (4)
    jump (1263);

1263:

    #1263
    #instruction: NOP
    advance (4)
    jump (1264);

1264:

    #1264
    #instruction: NOP
    advance (4)
    jump (1265);

1265:

    #1265
    #instruction: NOP
    advance (4)
    jump (1266);

1266:

    #1266
    #instruction: NOP
    advance (4)
    jump (1267);

1267:

    #1267
    #instruction: NOP
    advance (4)
    jump (1268);

1268:

    #1268
    #instruction: NOP
    advance (4)
    jump (1269);

1269:

    #1269
    #instruction: NOP
    advance (4)
    jump (126A);

126A:

    #126A
    #instruction: NOP
    advance (4)
    jump (126B);

126B:

    #126B
    #instruction: NOP
    advance (4)
    jump (126C);

126C:

    #126C
    #instruction: NOP
    advance (4)
    jump (126D);

126D:

    #126D
    #instruction: NOP
    advance (4)
    jump (126E);

126E:

    #126E
    #instruction: NOP
    advance (4)
    jump (126F);

126F:

    #126F
    #instruction: NOP
    advance (4)
    jump (1270);

1270:

    #1270
    #instruction: NOP
    advance (4)
    jump (1271);

1271:

    #1271
    #instruction: NOP
    advance (4)
    jump (1272);

1272:

    #1272
    #instruction: NOP
    advance (4)
    jump (1273);

1273:

    #1273
    #instruction: NOP
    advance (4)
    jump (1274);

1274:

    #1274
    #instruction: NOP
    advance (4)
    jump (1275);

1275:

    #1275
    #instruction: NOP
    advance (4)
    jump (1276);

1276:

    #1276
    #instruction: NOP
    advance (4)
    jump (1277);

1277:

    #1277
    #instruction: NOP
    advance (4)
    jump (1278);

1278:

    #1278
    #instruction: NOP
    advance (4)
    jump (1279);

1279:

    #1279
    #instruction: NOP
    advance (4)
    jump (127A);

127A:

    #127A
    #instruction: NOP
    advance (4)
    jump (127B);

127B:

    #127B
    #instruction: NOP
    advance (4)
    jump (127C);

127C:

    #127C
    #instruction: NOP
    advance (4)
    jump (127D);

127D:

    #127D
    #instruction: NOP
    advance (4)
    jump (127E);

127E:

    #127E
    #instruction: NOP
    advance (4)
    jump (127F);

127F:

    #127F
    #instruction: NOP
    advance (4)
    jump (1280);

1280:

    #1280
    #instruction: NOP
    advance (4)
    jump (1281);

1281:

    #1281
    #instruction: NOP
    advance (4)
    jump (1282);

1282:

    #1282
    #instruction: NOP
    advance (4)
    jump (1283);

1283:

    #1283
    #instruction: NOP
    advance (4)
    jump (1284);

1284:

    #1284
    #instruction: NOP
    advance (4)
    jump (1285);

1285:

    #1285
    #instruction: NOP
    advance (4)
    jump (1286);

1286:

    #1286
    #instruction: NOP
    advance (4)
    jump (1287);

1287:

    #1287
    #instruction: NOP
    advance (4)
    jump (1288);

1288:

    #1288
    #instruction: NOP
    advance (4)
    jump (1289);

1289:

    #1289
    #instruction: NOP
    advance (4)
    jump (128A);

128A:

    #128A
    #instruction: NOP
    advance (4)
    jump (128B);

128B:

    #128B
    #instruction: NOP
    advance (4)
    jump (128C);

128C:

    #128C
    #instruction: NOP
    advance (4)
    jump (128D);

128D:

    #128D
    #instruction: NOP
    advance (4)
    jump (128E);

128E:

    #128E
    #instruction: NOP
    advance (4)
    jump (128F);

128F:

    #128F
    #instruction: NOP
    advance (4)
    jump (1290);

1290:

    #1290
    #instruction: NOP
    advance (4)
    jump (1291);

1291:

    #1291
    #instruction: NOP
    advance (4)
    jump (1292);

1292:

    #1292
    #instruction: NOP
    advance (4)
    jump (1293);

1293:

    #1293
    #instruction: NOP
    advance (4)
    jump (1294);

1294:

    #1294
    #instruction: NOP
    advance (4)
    jump (1295);

1295:

    #1295
    #instruction: NOP
    advance (4)
    jump (1296);

1296:

    #1296
    #instruction: NOP
    advance (4)
    jump (1297);

1297:

    #1297
    #instruction: NOP
    advance (4)
    jump (1298);

1298:

    #1298
    #instruction: NOP
    advance (4)
    jump (1299);

1299:

    #1299
    #instruction: NOP
    advance (4)
    jump (129A);

129A:

    #129A
    #instruction: NOP
    advance (4)
    jump (129B);

129B:

    #129B
    #instruction: NOP
    advance (4)
    jump (129C);

129C:

    #129C
    #instruction: NOP
    advance (4)
    jump (129D);

129D:

    #129D
    #instruction: NOP
    advance (4)
    jump (129E);

129E:

    #129E
    #instruction: NOP
    advance (4)
    jump (129F);

129F:

    #129F
    #instruction: NOP
    advance (4)
    jump (12A0);

12A0:

    #12A0
    #instruction: NOP
    advance (4)
    jump (12A1);

12A1:

    #12A1
    #instruction: NOP
    advance (4)
    jump (12A2);

12A2:

    #12A2
    #instruction: NOP
    advance (4)
    jump (12A3);

12A3:

    #12A3
    #instruction: NOP
    advance (4)
    jump (12A4);

12A4:

    #12A4
    #instruction: NOP
    advance (4)
    jump (12A5);

12A5:

    #12A5
    #instruction: NOP
    advance (4)
    jump (12A6);

12A6:

    #12A6
    #instruction: NOP
    advance (4)
    jump (12A7);

12A7:

    #12A7
    #instruction: NOP
    advance (4)
    jump (12A8);

12A8:

    #12A8
    #instruction: NOP
    advance (4)
    jump (12A9);

12A9:

    #12A9
    #instruction: NOP
    advance (4)
    jump (12AA);

12AA:

    #12AA
    #instruction: NOP
    advance (4)
    jump (12AB);

12AB:

    #12AB
    #instruction: NOP
    advance (4)
    jump (12AC);

12AC:

    #12AC
    #instruction: NOP
    advance (4)
    jump (12AD);

12AD:

    #12AD
    #instruction: NOP
    advance (4)
    jump (12AE);

12AE:

    #12AE
    #instruction: NOP
    advance (4)
    jump (12AF);

12AF:

    #12AF
    #instruction: NOP
    advance (4)
    jump (12B0);

12B0:

    #12B0
    #instruction: NOP
    advance (4)
    jump (12B1);

12B1:

    #12B1
    #instruction: NOP
    advance (4)
    jump (12B2);

12B2:

    #12B2
    #instruction: NOP
    advance (4)
    jump (12B3);

12B3:

    #12B3
    #instruction: NOP
    advance (4)
    jump (12B4);

12B4:

    #12B4
    #instruction: NOP
    advance (4)
    jump (12B5);

12B5:

    #12B5
    #instruction: NOP
    advance (4)
    jump (12B6);

12B6:

    #12B6
    #instruction: NOP
    advance (4)
    jump (12B7);

12B7:

    #12B7
    #instruction: NOP
    advance (4)
    jump (12B8);

12B8:

    #12B8
    #instruction: NOP
    advance (4)
    jump (12B9);

12B9:

    #12B9
    #instruction: NOP
    advance (4)
    jump (12BA);

12BA:

    #12BA
    #instruction: NOP
    advance (4)
    jump (12BB);

12BB:

    #12BB
    #instruction: NOP
    advance (4)
    jump (12BC);

12BC:

    #12BC
    #instruction: NOP
    advance (4)
    jump (12BD);

12BD:

    #12BD
    #instruction: NOP
    advance (4)
    jump (12BE);

12BE:

    #12BE
    #instruction: NOP
    advance (4)
    jump (12BF);

12BF:

    #12BF
    #instruction: NOP
    advance (4)
    jump (12C0);

12C0:

    #12C0
    #instruction: NOP
    advance (4)
    jump (12C1);

12C1:

    #12C1
    #instruction: NOP
    advance (4)
    jump (12C2);

12C2:

    #12C2
    #instruction: NOP
    advance (4)
    jump (12C3);

12C3:

    #12C3
    #instruction: NOP
    advance (4)
    jump (12C4);

12C4:

    #12C4
    #instruction: NOP
    advance (4)
    jump (12C5);

12C5:

    #12C5
    #instruction: NOP
    advance (4)
    jump (12C6);

12C6:

    #12C6
    #instruction: NOP
    advance (4)
    jump (12C7);

12C7:

    #12C7
    #instruction: NOP
    advance (4)
    jump (12C8);

12C8:

    #12C8
    #instruction: NOP
    advance (4)
    jump (12C9);

12C9:

    #12C9
    #instruction: NOP
    advance (4)
    jump (12CA);

12CA:

    #12CA
    #instruction: NOP
    advance (4)
    jump (12CB);

12CB:

    #12CB
    #instruction: NOP
    advance (4)
    jump (12CC);

12CC:

    #12CC
    #instruction: NOP
    advance (4)
    jump (12CD);

12CD:

    #12CD
    #instruction: NOP
    advance (4)
    jump (12CE);

12CE:

    #12CE
    #instruction: NOP
    advance (4)
    jump (12CF);

12CF:

    #12CF
    #instruction: NOP
    advance (4)
    jump (12D0);

12D0:

    #12D0
    #instruction: NOP
    advance (4)
    jump (12D1);

12D1:

    #12D1
    #instruction: NOP
    advance (4)
    jump (12D2);

12D2:

    #12D2
    #instruction: NOP
    advance (4)
    jump (12D3);

12D3:

    #12D3
    #instruction: NOP
    advance (4)
    jump (12D4);

12D4:

    #12D4
    #instruction: NOP
    advance (4)
    jump (12D5);

12D5:

    #12D5
    #instruction: NOP
    advance (4)
    jump (12D6);

12D6:

    #12D6
    #instruction: NOP
    advance (4)
    jump (12D7);

12D7:

    #12D7
    #instruction: NOP
    advance (4)
    jump (12D8);

12D8:

    #12D8
    #instruction: NOP
    advance (4)
    jump (12D9);

12D9:

    #12D9
    #instruction: NOP
    advance (4)
    jump (12DA);

12DA:

    #12DA
    #instruction: NOP
    advance (4)
    jump (12DB);

12DB:

    #12DB
    #instruction: NOP
    advance (4)
    jump (12DC);

12DC:

    #12DC
    #instruction: NOP
    advance (4)
    jump (12DD);

12DD:

    #12DD
    #instruction: NOP
    advance (4)
    jump (12DE);

12DE:

    #12DE
    #instruction: NOP
    advance (4)
    jump (12DF);

12DF:

    #12DF
    #instruction: NOP
    advance (4)
    jump (12E0);

12E0:

    #12E0
    #instruction: NOP
    advance (4)
    jump (12E1);

12E1:

    #12E1
    #instruction: NOP
    advance (4)
    jump (12E2);

12E2:

    #12E2
    #instruction: NOP
    advance (4)
    jump (12E3);

12E3:

    #12E3
    #instruction: NOP
    advance (4)
    jump (12E4);

12E4:

    #12E4
    #instruction: NOP
    advance (4)
    jump (12E5);

12E5:

    #12E5
    #instruction: NOP
    advance (4)
    jump (12E6);

12E6:

    #12E6
    #instruction: NOP
    advance (4)
    jump (12E7);

12E7:

    #12E7
    #instruction: NOP
    advance (4)
    jump (12E8);

12E8:

    #12E8
    #instruction: NOP
    advance (4)
    jump (12E9);

12E9:

    #12E9
    #instruction: NOP
    advance (4)
    jump (12EA);

12EA:

    #12EA
    #instruction: NOP
    advance (4)
    jump (12EB);

12EB:

    #12EB
    #instruction: NOP
    advance (4)
    jump (12EC);

12EC:

    #12EC
    #instruction: NOP
    advance (4)
    jump (12ED);

12ED:

    #12ED
    #instruction: NOP
    advance (4)
    jump (12EE);

12EE:

    #12EE
    #instruction: NOP
    advance (4)
    jump (12EF);

12EF:

    #12EF
    #instruction: NOP
    advance (4)
    jump (12F0);

12F0:

    #12F0
    #instruction: NOP
    advance (4)
    jump (12F1);

12F1:

    #12F1
    #instruction: NOP
    advance (4)
    jump (12F2);

12F2:

    #12F2
    #instruction: NOP
    advance (4)
    jump (12F3);

12F3:

    #12F3
    #instruction: NOP
    advance (4)
    jump (12F4);

12F4:

    #12F4
    #instruction: NOP
    advance (4)
    jump (12F5);

12F5:

    #12F5
    #instruction: NOP
    advance (4)
    jump (12F6);

12F6:

    #12F6
    #instruction: NOP
    advance (4)
    jump (12F7);

12F7:

    #12F7
    #instruction: NOP
    advance (4)
    jump (12F8);

12F8:

    #12F8
    #instruction: NOP
    advance (4)
    jump (12F9);

12F9:

    #12F9
    #instruction: NOP
    advance (4)
    jump (12FA);

12FA:

    #12FA
    #instruction: NOP
    advance (4)
    jump (12FB);

12FB:

    #12FB
    #instruction: NOP
    advance (4)
    jump (12FC);

12FC:

    #12FC
    #instruction: NOP
    advance (4)
    jump (12FD);

12FD:

    #12FD
    #instruction: NOP
    advance (4)
    jump (12FE);

12FE:

    #12FE
    #instruction: NOP
    advance (4)
    jump (12FF);

12FF:

    #12FF
    #instruction: NOP
    advance (4)
    jump (1300);

1300:

    #1300
    #instruction: NOP
    advance (4)
    jump (1301);

1301:

    #1301
    #instruction: NOP
    advance (4)
    jump (1302);

1302:

    #1302
    #instruction: NOP
    advance (4)
    jump (1303);

1303:

    #1303
    #instruction: NOP
    advance (4)
    jump (1304);

1304:

    #1304
    #instruction: NOP
    advance (4)
    jump (1305);

1305:

    #1305
    #instruction: NOP
    advance (4)
    jump (1306);

1306:

    #1306
    #instruction: NOP
    advance (4)
    jump (1307);

1307:

    #1307
    #instruction: NOP
    advance (4)
    jump (1308);

1308:

    #1308
    #instruction: NOP
    advance (4)
    jump (1309);

1309:

    #1309
    #instruction: NOP
    advance (4)
    jump (130A);

130A:

    #130A
    #instruction: NOP
    advance (4)
    jump (130B);

130B:

    #130B
    #instruction: NOP
    advance (4)
    jump (130C);

130C:

    #130C
    #instruction: NOP
    advance (4)
    jump (130D);

130D:

    #130D
    #instruction: NOP
    advance (4)
    jump (130E);

130E:

    #130E
    #instruction: NOP
    advance (4)
    jump (130F);

130F:

    #130F
    #instruction: NOP
    advance (4)
    jump (1310);

1310:

    #1310
    #instruction: NOP
    advance (4)
    jump (1311);

1311:

    #1311
    #instruction: NOP
    advance (4)
    jump (1312);

1312:

    #1312
    #instruction: NOP
    advance (4)
    jump (1313);

1313:

    #1313
    #instruction: NOP
    advance (4)
    jump (1314);

1314:

    #1314
    #instruction: NOP
    advance (4)
    jump (1315);

1315:

    #1315
    #instruction: NOP
    advance (4)
    jump (1316);

1316:

    #1316
    #instruction: NOP
    advance (4)
    jump (1317);

1317:

    #1317
    #instruction: NOP
    advance (4)
    jump (1318);

1318:

    #1318
    #instruction: NOP
    advance (4)
    jump (1319);

1319:

    #1319
    #instruction: NOP
    advance (4)
    jump (131A);

131A:

    #131A
    #instruction: NOP
    advance (4)
    jump (131B);

131B:

    #131B
    #instruction: NOP
    advance (4)
    jump (131C);

131C:

    #131C
    #instruction: NOP
    advance (4)
    jump (131D);

131D:

    #131D
    #instruction: NOP
    advance (4)
    jump (131E);

131E:

    #131E
    #instruction: NOP
    advance (4)
    jump (131F);

131F:

    #131F
    #instruction: NOP
    advance (4)
    jump (1320);

1320:

    #1320
    #instruction: NOP
    advance (4)
    jump (1321);

1321:

    #1321
    #instruction: NOP
    advance (4)
    jump (1322);

1322:

    #1322
    #instruction: NOP
    advance (4)
    jump (1323);

1323:

    #1323
    #instruction: NOP
    advance (4)
    jump (1324);

1324:

    #1324
    #instruction: NOP
    advance (4)
    jump (1325);

1325:

    #1325
    #instruction: NOP
    advance (4)
    jump (1326);

1326:

    #1326
    #instruction: NOP
    advance (4)
    jump (1327);

1327:

    #1327
    #instruction: NOP
    advance (4)
    jump (1328);

1328:

    #1328
    #instruction: NOP
    advance (4)
    jump (1329);

1329:

    #1329
    #instruction: NOP
    advance (4)
    jump (132A);

132A:

    #132A
    #instruction: NOP
    advance (4)
    jump (132B);

132B:

    #132B
    #instruction: NOP
    advance (4)
    jump (132C);

132C:

    #132C
    #instruction: NOP
    advance (4)
    jump (132D);

132D:

    #132D
    #instruction: NOP
    advance (4)
    jump (132E);

132E:

    #132E
    #instruction: NOP
    advance (4)
    jump (132F);

132F:

    #132F
    #instruction: NOP
    advance (4)
    jump (1330);

1330:

    #1330
    #instruction: NOP
    advance (4)
    jump (1331);

1331:

    #1331
    #instruction: NOP
    advance (4)
    jump (1332);

1332:

    #1332
    #instruction: NOP
    advance (4)
    jump (1333);

1333:

    #1333
    #instruction: NOP
    advance (4)
    jump (1334);

1334:

    #1334
    #instruction: NOP
    advance (4)
    jump (1335);

1335:

    #1335
    #instruction: NOP
    advance (4)
    jump (1336);

1336:

    #1336
    #instruction: NOP
    advance (4)
    jump (1337);

1337:

    #1337
    #instruction: NOP
    advance (4)
    jump (1338);

1338:

    #1338
    #instruction: NOP
    advance (4)
    jump (1339);

1339:

    #1339
    #instruction: NOP
    advance (4)
    jump (133A);

133A:

    #133A
    #instruction: NOP
    advance (4)
    jump (133B);

133B:

    #133B
    #instruction: NOP
    advance (4)
    jump (133C);

133C:

    #133C
    #instruction: NOP
    advance (4)
    jump (133D);

133D:

    #133D
    #instruction: NOP
    advance (4)
    jump (133E);

133E:

    #133E
    #instruction: NOP
    advance (4)
    jump (133F);

133F:

    #133F
    #instruction: NOP
    advance (4)
    jump (1340);

1340:

    #1340
    #instruction: NOP
    advance (4)
    jump (1341);

1341:

    #1341
    #instruction: NOP
    advance (4)
    jump (1342);

1342:

    #1342
    #instruction: NOP
    advance (4)
    jump (1343);

1343:

    #1343
    #instruction: NOP
    advance (4)
    jump (1344);

1344:

    #1344
    #instruction: NOP
    advance (4)
    jump (1345);

1345:

    #1345
    #instruction: NOP
    advance (4)
    jump (1346);

1346:

    #1346
    #instruction: NOP
    advance (4)
    jump (1347);

1347:

    #1347
    #instruction: NOP
    advance (4)
    jump (1348);

1348:

    #1348
    #instruction: NOP
    advance (4)
    jump (1349);

1349:

    #1349
    #instruction: NOP
    advance (4)
    jump (134A);

134A:

    #134A
    #instruction: NOP
    advance (4)
    jump (134B);

134B:

    #134B
    #instruction: NOP
    advance (4)
    jump (134C);

134C:

    #134C
    #instruction: NOP
    advance (4)
    jump (134D);

134D:

    #134D
    #instruction: NOP
    advance (4)
    jump (134E);

134E:

    #134E
    #instruction: NOP
    advance (4)
    jump (134F);

134F:

    #134F
    #instruction: NOP
    advance (4)
    jump (1350);

1350:

    #1350
    #instruction: NOP
    advance (4)
    jump (1351);

1351:

    #1351
    #instruction: NOP
    advance (4)
    jump (1352);

1352:

    #1352
    #instruction: NOP
    advance (4)
    jump (1353);

1353:

    #1353
    #instruction: NOP
    advance (4)
    jump (1354);

1354:

    #1354
    #instruction: NOP
    advance (4)
    jump (1355);

1355:

    #1355
    #instruction: NOP
    advance (4)
    jump (1356);

1356:

    #1356
    #instruction: NOP
    advance (4)
    jump (1357);

1357:

    #1357
    #instruction: NOP
    advance (4)
    jump (1358);

1358:

    #1358
    #instruction: NOP
    advance (4)
    jump (1359);

1359:

    #1359
    #instruction: NOP
    advance (4)
    jump (135A);

135A:

    #135A
    #instruction: NOP
    advance (4)
    jump (135B);

135B:

    #135B
    #instruction: NOP
    advance (4)
    jump (135C);

135C:

    #135C
    #instruction: NOP
    advance (4)
    jump (135D);

135D:

    #135D
    #instruction: NOP
    advance (4)
    jump (135E);

135E:

    #135E
    #instruction: NOP
    advance (4)
    jump (135F);

135F:

    #135F
    #instruction: NOP
    advance (4)
    jump (1360);

1360:

    #1360
    #instruction: NOP
    advance (4)
    jump (1361);

1361:

    #1361
    #instruction: NOP
    advance (4)
    jump (1362);

1362:

    #1362
    #instruction: NOP
    advance (4)
    jump (1363);

1363:

    #1363
    #instruction: NOP
    advance (4)
    jump (1364);

1364:

    #1364
    #instruction: NOP
    advance (4)
    jump (1365);

1365:

    #1365
    #instruction: NOP
    advance (4)
    jump (1366);

1366:

    #1366
    #instruction: NOP
    advance (4)
    jump (1367);

1367:

    #1367
    #instruction: NOP
    advance (4)
    jump (1368);

1368:

    #1368
    #instruction: NOP
    advance (4)
    jump (1369);

1369:

    #1369
    #instruction: NOP
    advance (4)
    jump (136A);

136A:

    #136A
    #instruction: NOP
    advance (4)
    jump (136B);

136B:

    #136B
    #instruction: NOP
    advance (4)
    jump (136C);

136C:

    #136C
    #instruction: NOP
    advance (4)
    jump (136D);

136D:

    #136D
    #instruction: NOP
    advance (4)
    jump (136E);

136E:

    #136E
    #instruction: NOP
    advance (4)
    jump (136F);

136F:

    #136F
    #instruction: NOP
    advance (4)
    jump (1370);

1370:

    #1370
    #instruction: NOP
    advance (4)
    jump (1371);

1371:

    #1371
    #instruction: NOP
    advance (4)
    jump (1372);

1372:

    #1372
    #instruction: NOP
    advance (4)
    jump (1373);

1373:

    #1373
    #instruction: NOP
    advance (4)
    jump (1374);

1374:

    #1374
    #instruction: NOP
    advance (4)
    jump (1375);

1375:

    #1375
    #instruction: NOP
    advance (4)
    jump (1376);

1376:

    #1376
    #instruction: NOP
    advance (4)
    jump (1377);

1377:

    #1377
    #instruction: NOP
    advance (4)
    jump (1378);

1378:

    #1378
    #instruction: NOP
    advance (4)
    jump (1379);

1379:

    #1379
    #instruction: NOP
    advance (4)
    jump (137A);

137A:

    #137A
    #instruction: NOP
    advance (4)
    jump (137B);

137B:

    #137B
    #instruction: NOP
    advance (4)
    jump (137C);

137C:

    #137C
    #instruction: NOP
    advance (4)
    jump (137D);

137D:

    #137D
    #instruction: NOP
    advance (4)
    jump (137E);

137E:

    #137E
    #instruction: NOP
    advance (4)
    jump (137F);

137F:

    #137F
    #instruction: NOP
    advance (4)
    jump (1380);

1380:

    #1380
    #instruction: NOP
    advance (4)
    jump (1381);

1381:

    #1381
    #instruction: NOP
    advance (4)
    jump (1382);

1382:

    #1382
    #instruction: NOP
    advance (4)
    jump (1383);

1383:

    #1383
    #instruction: NOP
    advance (4)
    jump (1384);

1384:

    #1384
    #instruction: NOP
    advance (4)
    jump (1385);

1385:

    #1385
    #instruction: NOP
    advance (4)
    jump (1386);

1386:

    #1386
    #instruction: NOP
    advance (4)
    jump (1387);

1387:

    #1387
    #instruction: NOP
    advance (4)
    jump (1388);

1388:

    #1388
    #instruction: NOP
    advance (4)
    jump (1389);

1389:

    #1389
    #instruction: NOP
    advance (4)
    jump (138A);

138A:

    #138A
    #instruction: NOP
    advance (4)
    jump (138B);

138B:

    #138B
    #instruction: NOP
    advance (4)
    jump (138C);

138C:

    #138C
    #instruction: NOP
    advance (4)
    jump (138D);

138D:

    #138D
    #instruction: NOP
    advance (4)
    jump (138E);

138E:

    #138E
    #instruction: NOP
    advance (4)
    jump (138F);

138F:

    #138F
    #instruction: NOP
    advance (4)
    jump (1390);

1390:

    #1390
    #instruction: NOP
    advance (4)
    jump (1391);

1391:

    #1391
    #instruction: NOP
    advance (4)
    jump (1392);

1392:

    #1392
    #instruction: NOP
    advance (4)
    jump (1393);

1393:

    #1393
    #instruction: NOP
    advance (4)
    jump (1394);

1394:

    #1394
    #instruction: NOP
    advance (4)
    jump (1395);

1395:

    #1395
    #instruction: NOP
    advance (4)
    jump (1396);

1396:

    #1396
    #instruction: NOP
    advance (4)
    jump (1397);

1397:

    #1397
    #instruction: NOP
    advance (4)
    jump (1398);

1398:

    #1398
    #instruction: NOP
    advance (4)
    jump (1399);

1399:

    #1399
    #instruction: NOP
    advance (4)
    jump (139A);

139A:

    #139A
    #instruction: NOP
    advance (4)
    jump (139B);

139B:

    #139B
    #instruction: NOP
    advance (4)
    jump (139C);

139C:

    #139C
    #instruction: NOP
    advance (4)
    jump (139D);

139D:

    #139D
    #instruction: NOP
    advance (4)
    jump (139E);

139E:

    #139E
    #instruction: NOP
    advance (4)
    jump (139F);

139F:

    #139F
    #instruction: NOP
    advance (4)
    jump (13A0);

13A0:

    #13A0
    #instruction: NOP
    advance (4)
    jump (13A1);

13A1:

    #13A1
    #instruction: NOP
    advance (4)
    jump (13A2);

13A2:

    #13A2
    #instruction: NOP
    advance (4)
    jump (13A3);

13A3:

    #13A3
    #instruction: NOP
    advance (4)
    jump (13A4);

13A4:

    #13A4
    #instruction: NOP
    advance (4)
    jump (13A5);

13A5:

    #13A5
    #instruction: NOP
    advance (4)
    jump (13A6);

13A6:

    #13A6
    #instruction: NOP
    advance (4)
    jump (13A7);

13A7:

    #13A7
    #instruction: NOP
    advance (4)
    jump (13A8);

13A8:

    #13A8
    #instruction: NOP
    advance (4)
    jump (13A9);

13A9:

    #13A9
    #instruction: NOP
    advance (4)
    jump (13AA);

13AA:

    #13AA
    #instruction: NOP
    advance (4)
    jump (13AB);

13AB:

    #13AB
    #instruction: NOP
    advance (4)
    jump (13AC);

13AC:

    #13AC
    #instruction: NOP
    advance (4)
    jump (13AD);

13AD:

    #13AD
    #instruction: NOP
    advance (4)
    jump (13AE);

13AE:

    #13AE
    #instruction: NOP
    advance (4)
    jump (13AF);

13AF:

    #13AF
    #instruction: NOP
    advance (4)
    jump (13B0);

13B0:

    #13B0
    #instruction: NOP
    advance (4)
    jump (13B1);

13B1:

    #13B1
    #instruction: NOP
    advance (4)
    jump (13B2);

13B2:

    #13B2
    #instruction: NOP
    advance (4)
    jump (13B3);

13B3:

    #13B3
    #instruction: NOP
    advance (4)
    jump (13B4);

13B4:

    #13B4
    #instruction: NOP
    advance (4)
    jump (13B5);

13B5:

    #13B5
    #instruction: NOP
    advance (4)
    jump (13B6);

13B6:

    #13B6
    #instruction: NOP
    advance (4)
    jump (13B7);

13B7:

    #13B7
    #instruction: NOP
    advance (4)
    jump (13B8);

13B8:

    #13B8
    #instruction: NOP
    advance (4)
    jump (13B9);

13B9:

    #13B9
    #instruction: NOP
    advance (4)
    jump (13BA);

13BA:

    #13BA
    #instruction: NOP
    advance (4)
    jump (13BB);

13BB:

    #13BB
    #instruction: NOP
    advance (4)
    jump (13BC);

13BC:

    #13BC
    #instruction: NOP
    advance (4)
    jump (13BD);

13BD:

    #13BD
    #instruction: NOP
    advance (4)
    jump (13BE);

13BE:

    #13BE
    #instruction: NOP
    advance (4)
    jump (13BF);

13BF:

    #13BF
    #instruction: NOP
    advance (4)
    jump (13C0);

13C0:

    #13C0
    #instruction: NOP
    advance (4)
    jump (13C1);

13C1:

    #13C1
    #instruction: NOP
    advance (4)
    jump (13C2);

13C2:

    #13C2
    #instruction: NOP
    advance (4)
    jump (13C3);

13C3:

    #13C3
    #instruction: NOP
    advance (4)
    jump (13C4);

13C4:

    #13C4
    #instruction: NOP
    advance (4)
    jump (13C5);

13C5:

    #13C5
    #instruction: NOP
    advance (4)
    jump (13C6);

13C6:

    #13C6
    #instruction: NOP
    advance (4)
    jump (13C7);

13C7:

    #13C7
    #instruction: NOP
    advance (4)
    jump (13C8);

13C8:

    #13C8
    #instruction: NOP
    advance (4)
    jump (13C9);

13C9:

    #13C9
    #instruction: NOP
    advance (4)
    jump (13CA);

13CA:

    #13CA
    #instruction: NOP
    advance (4)
    jump (13CB);

13CB:

    #13CB
    #instruction: NOP
    advance (4)
    jump (13CC);

13CC:

    #13CC
    #instruction: NOP
    advance (4)
    jump (13CD);

13CD:

    #13CD
    #instruction: NOP
    advance (4)
    jump (13CE);

13CE:

    #13CE
    #instruction: NOP
    advance (4)
    jump (13CF);

13CF:

    #13CF
    #instruction: NOP
    advance (4)
    jump (13D0);

13D0:

    #13D0
    #instruction: NOP
    advance (4)
    jump (13D1);

13D1:

    #13D1
    #instruction: NOP
    advance (4)
    jump (13D2);

13D2:

    #13D2
    #instruction: NOP
    advance (4)
    jump (13D3);

13D3:

    #13D3
    #instruction: NOP
    advance (4)
    jump (13D4);

13D4:

    #13D4
    #instruction: NOP
    advance (4)
    jump (13D5);

13D5:

    #13D5
    #instruction: NOP
    advance (4)
    jump (13D6);

13D6:

    #13D6
    #instruction: NOP
    advance (4)
    jump (13D7);

13D7:

    #13D7
    #instruction: NOP
    advance (4)
    jump (13D8);

13D8:

    #13D8
    #instruction: NOP
    advance (4)
    jump (13D9);

13D9:

    #13D9
    #instruction: NOP
    advance (4)
    jump (13DA);

13DA:

    #13DA
    #instruction: NOP
    advance (4)
    jump (13DB);

13DB:

    #13DB
    #instruction: NOP
    advance (4)
    jump (13DC);

13DC:

    #13DC
    #instruction: NOP
    advance (4)
    jump (13DD);

13DD:

    #13DD
    #instruction: NOP
    advance (4)
    jump (13DE);

13DE:

    #13DE
    #instruction: NOP
    advance (4)
    jump (13DF);

13DF:

    #13DF
    #instruction: NOP
    advance (4)
    jump (13E0);

13E0:

    #13E0
    #instruction: NOP
    advance (4)
    jump (13E1);

13E1:

    #13E1
    #instruction: NOP
    advance (4)
    jump (13E2);

13E2:

    #13E2
    #instruction: NOP
    advance (4)
    jump (13E3);

13E3:

    #13E3
    #instruction: NOP
    advance (4)
    jump (13E4);

13E4:

    #13E4
    #instruction: NOP
    advance (4)
    jump (13E5);

13E5:

    #13E5
    #instruction: NOP
    advance (4)
    jump (13E6);

13E6:

    #13E6
    #instruction: NOP
    advance (4)
    jump (13E7);

13E7:

    #13E7
    #instruction: NOP
    advance (4)
    jump (13E8);

13E8:

    #13E8
    #instruction: NOP
    advance (4)
    jump (13E9);

13E9:

    #13E9
    #instruction: NOP
    advance (4)
    jump (13EA);

13EA:

    #13EA
    #instruction: NOP
    advance (4)
    jump (13EB);

13EB:

    #13EB
    #instruction: NOP
    advance (4)
    jump (13EC);

13EC:

    #13EC
    #instruction: NOP
    advance (4)
    jump (13ED);

13ED:

    #13ED
    #instruction: NOP
    advance (4)
    jump (13EE);

13EE:

    #13EE
    #instruction: NOP
    advance (4)
    jump (13EF);

13EF:

    #13EF
    #instruction: NOP
    advance (4)
    jump (13F0);

13F0:

    #13F0
    #instruction: NOP
    advance (4)
    jump (13F1);

13F1:

    #13F1
    #instruction: NOP
    advance (4)
    jump (13F2);

13F2:

    #13F2
    #instruction: NOP
    advance (4)
    jump (13F3);

13F3:

    #13F3
    #instruction: NOP
    advance (4)
    jump (13F4);

13F4:

    #13F4
    #instruction: NOP
    advance (4)
    jump (13F5);

13F5:

    #13F5
    #instruction: NOP
    advance (4)
    jump (13F6);

13F6:

    #13F6
    #instruction: NOP
    advance (4)
    jump (13F7);

13F7:

    #13F7
    #instruction: NOP
    advance (4)
    jump (13F8);

13F8:

    #13F8
    #instruction: NOP
    advance (4)
    jump (13F9);

13F9:

    #13F9
    #instruction: NOP
    advance (4)
    jump (13FA);

13FA:

    #13FA
    #instruction: NOP
    advance (4)
    jump (13FB);

13FB:

    #13FB
    #instruction: NOP
    advance (4)
    jump (13FC);

13FC:

    #13FC
    #instruction: NOP
    advance (4)
    jump (13FD);

13FD:

    #13FD
    #instruction: NOP
    advance (4)
    jump (13FE);

13FE:

    #13FE
    #instruction: NOP
    advance (4)
    jump (13FF);

13FF:

    #13FF
    #instruction: NOP
    advance (4)
    jump (1400);

1400:

    #1400
    #instruction: NOP
    advance (4)
    jump (1401);

1401:

    #1401
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    #return-to: 1404
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1474);

1402:

    #1402
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1403);

1403:

    #1403
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1404);

1404:

    #1404
    #instruction: NOP
    advance (4)
    jump (1405);

1405:

    #1405
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1406);

1406:

    #1406
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1407);

1407:

    #1407
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1408);

1408:

    #1408
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (140A);

1409:

    #1409
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (140A);

140A:

    #140A
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (140C);

140B:

    #140B
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (140C);

140C:

    #140C
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (140D);

140D:

    #140D
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (140E);

140E:

    #140E
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (140F);

140F:

    #140F
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1410);

1410:

    #1410
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1411);

1411:

    #1411
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (1413);

1412:

    #1412
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1413);

1413:

    #1413
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (1415);

1414:

    #1414
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1415);

1415:

    #1415
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1416);

1416:

    #1416
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1417);

1417:

    #1417
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1418);

1418:

    #1418
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (141B);

1419:

    #1419
    #instruction: *NOP
    advance (4)
    jump (141A);

141A:

    #141A
    #instruction: NOP
    advance (4)
    jump (141B);

141B:

    #141B
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (141C);

141C:

    #141C
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (141D);

141D:

    #141D
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (141E);

141E:

    #141E
    #instruction: JP   NZ,1405
    if (!FlagZ) {
      advance (10)
      jump (1405);
    } else {
      advance (10)
      jump (1421);
    }

141F:

    #141F
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1420);

1420:

    #1420
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1421);

1421:

    #1421
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1422:

    #1422
    #instruction: NOP
    advance (4)
    jump (1423);

1423:

    #1423
    #instruction: NOP
    advance (4)
    jump (1424);

1424:

    #1424
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    #return-to: 1427
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1474);

1425:

    #1425
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1426);

1426:

    #1426
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1427);

1427:

    #1427
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1428);

1428:

    #1428
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1429);

1429:

    #1429
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (142A);

142A:

    #142A
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (142B);

142B:

    #142B
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (142C);

142C:

    #142C
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (142D);

142D:

    #142D
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (142E);

142E:

    #142E
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (142F);

142F:

    #142F
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1432);

1430:

    #1430
    #instruction: *NOP
    advance (4)
    jump (1431);

1431:

    #1431
    #instruction: NOP
    advance (4)
    jump (1432);

1432:

    #1432
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1433);

1433:

    #1433
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1434);

1434:

    #1434
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1435);

1435:

    #1435
    #instruction: JP   NZ,1427
    if (!FlagZ) {
      advance (10)
      jump (1427);
    } else {
      advance (10)
      jump (1438);
    }

1436:

    #1436
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1437);

1437:

    #1437
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1438);

1438:

    #1438
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1439:

    #1439
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (143A);

143A:

    #143A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (143B);

143B:

    #143B
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (143C);

143C:

    #143C
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (143D);

143D:

    #143D
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1440);

143E:

    #143E
    #instruction: *NOP
    advance (4)
    jump (143F);

143F:

    #143F
    #instruction: NOP
    advance (4)
    jump (1440);

1440:

    #1440
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1441);

1441:

    #1441
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1442);

1442:

    #1442
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1443);

1443:

    #1443
    #instruction: JP   NZ,1439
    if (!FlagZ) {
      advance (10)
      jump (1439);
    } else {
      advance (10)
      jump (1446);
    }

1444:

    #1444
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1445);

1445:

    #1445
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1446);

1446:

    #1446
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1447:

    #1447
    #instruction: NOP
    advance (4)
    jump (1448);

1448:

    #1448
    #instruction: NOP
    advance (4)
    jump (1449);

1449:

    #1449
    #instruction: NOP
    advance (4)
    jump (144A);

144A:

    #144A
    #instruction: NOP
    advance (4)
    jump (144B);

144B:

    #144B
    #instruction: NOP
    advance (4)
    jump (144C);

144C:

    #144C
    #instruction: NOP
    advance (4)
    jump (144D);

144D:

    #144D
    #instruction: NOP
    advance (4)
    jump (144E);

144E:

    #144E
    #instruction: NOP
    advance (4)
    jump (144F);

144F:

    #144F
    #instruction: NOP
    advance (4)
    jump (1450);

1450:

    #1450
    #instruction: NOP
    advance (4)
    jump (1451);

1451:

    #1451
    #instruction: NOP
    advance (4)
    jump (1452);

1452:

    #1452
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 55;
    #return-to: 1455
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1474);

1453:

    #1453
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1454);

1454:

    #1454
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1455);

1455:

    #1455
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1456);

1456:

    #1456
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1457);

1457:

    #1457
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1458);

1458:

    #1458
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (145A);

1459:

    #1459
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (145A);

145A:

    #145A
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (145C);

145B:

    #145B
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (145C);

145C:

    #145C
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (145D);

145D:

    #145D
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (145E);

145E:

    #145E
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (145F);

145F:

    #145F
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1460);

1460:

    #1460
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1461);

1461:

    #1461
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1462);

1462:

    #1462
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (1464);

1463:

    #1463
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1464);

1464:

    #1464
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (1466);

1465:

    #1465
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1466);

1466:

    #1466
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (1467);

1467:

    #1467
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1468);

1468:

    #1468
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1469);

1469:

    #1469
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (146A);

146A:

    #146A
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (146D);

146B:

    #146B
    #instruction: *NOP
    advance (4)
    jump (146C);

146C:

    #146C
    #instruction: NOP
    advance (4)
    jump (146D);

146D:

    #146D
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (146E);

146E:

    #146E
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (146F);

146F:

    #146F
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1470);

1470:

    #1470
    #instruction: JP   NZ,1455
    if (!FlagZ) {
      advance (10)
      jump (1455);
    } else {
      advance (10)
      jump (1473);
    }

1471:

    #1471
    #instruction: LD   D,L
    advance (5)
    D := L;
    jump (1472);

1472:

    #1472
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1473);

1473:

    #1473
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1474:

    #1474
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (1475);

1475:

    #1475
    #instruction: AND  07
    let:8 a1 = (07 & A) in
    let:8 a2 = (07 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1477);

1476:

    #1476
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1477);

1477:

    #1477
    #instruction: OUT  02
    advance (10)
    Shifter_OFF := A;
    jump (1479);

1478:

    #1478
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1479);

1479:

    #1479
    #instruction: JP   1A47
    advance (10)
    jump (1A47);

147A:

    #147A
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (147B);

147B:

    #147B
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (147C);

147C:

    #147C
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (147D);

147D:

    #147D
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (147E);

147E:

    #147E
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (147F);

147F:

    #147F
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1480);

1480:

    #1480
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1481);

1481:

    #1481
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1482);

1482:

    #1482
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1483);

1483:

    #1483
    #instruction: JP   NZ,147E
    if (!FlagZ) {
      advance (10)
      jump (147E);
    } else {
      advance (10)
      jump (1486);
    }

1484:

    #1484
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1485);

1485:

    #1485
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1486);

1486:

    #1486
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1487);

1487:

    #1487
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (148A);

1488:

    #1488
    #instruction: *NOP
    advance (4)
    jump (1489);

1489:

    #1489
    #instruction: NOP
    advance (4)
    jump (148A);

148A:

    #148A
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (148B);

148B:

    #148B
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (148C);

148C:

    #148C
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (148D);

148D:

    #148D
    #instruction: JP   NZ,147C
    if (!FlagZ) {
      advance (10)
      jump (147C);
    } else {
      advance (10)
      jump (1490);
    }

148E:

    #148E
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (148F);

148F:

    #148F
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1490);

1490:

    #1490
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1491:

    #1491
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 94;
    #return-to: 1494
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1474);

1492:

    #1492
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1493);

1493:

    #1493
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1494);

1494:

    #1494
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1495);

1495:

    #1495
    #instruction: LD   (2061),A
    M[2061] := A;
    advance (13)
    jump (1498);

1496:

    #1496
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (1497);

1497:

    #1497
    #instruction: *NOP
    advance (4)
    jump (1498);

1498:

    #1498
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1499);

1499:

    #1499
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (149A);

149A:

    #149A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (149B);

149B:

    #149B
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (149D);

149C:

    #149C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (149D);

149D:

    #149D
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (149F);

149E:

    #149E
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (149F);

149F:

    #149F
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14A0);

14A0:

    #14A0
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (14A1);

14A1:

    #14A1
    #instruction: JP   Z,14A9
    if (FlagZ) {
      advance (10)
      jump (14A9);
    } else {
      advance (10)
      jump (14A4);
    }

14A2:

    #14A2
    #instruction: XOR  C
    let:8 a1 = (C ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (14A3);

14A3:

    #14A3
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14A4);

14A4:

    #14A4
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (14A6);

14A5:

    #14A5
    #instruction: LD   BC,6132
    advance (10)
    B := 61;
    C := 32;
    jump (14A8);

14A6:

    #14A6
    #instruction: LD   (2061),A
    M[2061] := A;
    advance (13)
    jump (14A9);

14A7:

    #14A7
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (14A8);

14A8:

    #14A8
    #instruction: *NOP
    advance (4)
    jump (14A9);

14A9:

    #14A9
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (14AA);

14AA:

    #14AA
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (14AB);

14AB:

    #14AB
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (14AC);

14AC:

    #14AC
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (14AD);

14AD:

    #14AD
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (14AE);

14AE:

    #14AE
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (14AF);

14AF:

    #14AF
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (14B1);

14B0:

    #14B0
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14B1);

14B1:

    #14B1
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (14B3);

14B2:

    #14B2
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (14B3);

14B3:

    #14B3
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14B4);

14B4:

    #14B4
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (14B5);

14B5:

    #14B5
    #instruction: JP   Z,14BD
    if (FlagZ) {
      advance (10)
      jump (14BD);
    } else {
      advance (10)
      jump (14B8);
    }

14B6:

    #14B6
    #instruction: CP   L
    let:16 a1 = addWithCarry(!false,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14B7);

14B7:

    #14B7
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14B8);

14B8:

    #14B8
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (14BA);

14B9:

    #14B9
    #instruction: LD   BC,6132
    advance (10)
    B := 61;
    C := 32;
    jump (14BC);

14BA:

    #14BA
    #instruction: LD   (2061),A
    M[2061] := A;
    advance (13)
    jump (14BD);

14BB:

    #14BB
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (14BC);

14BC:

    #14BC
    #instruction: *NOP
    advance (4)
    jump (14BD);

14BD:

    #14BD
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (14BE);

14BE:

    #14BE
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (14BF);

14BF:

    #14BF
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (14C0);

14C0:

    #14C0
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14C1);

14C1:

    #14C1
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (14C4);

14C2:

    #14C2
    #instruction: *NOP
    advance (4)
    jump (14C3);

14C3:

    #14C3
    #instruction: NOP
    advance (4)
    jump (14C4);

14C4:

    #14C4
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (14C5);

14C5:

    #14C5
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14C6);

14C6:

    #14C6
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14C7);

14C7:

    #14C7
    #instruction: JP   NZ,1498
    if (!FlagZ) {
      advance (10)
      jump (1498);
    } else {
      advance (10)
      jump (14CA);
    }

14C8:

    #14C8
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14C9);

14C9:

    #14C9
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14CA);

14CA:

    #14CA
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

14CB:

    #14CB
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (14CC);

14CC:

    #14CC
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14CD);

14CD:

    #14CD
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (14CE);

14CE:

    #14CE
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (14D1);

14CF:

    #14CF
    #instruction: *NOP
    advance (4)
    jump (14D0);

14D0:

    #14D0
    #instruction: NOP
    advance (4)
    jump (14D1);

14D1:

    #14D1
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (14D2);

14D2:

    #14D2
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14D3);

14D3:

    #14D3
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14D4);

14D4:

    #14D4
    #instruction: JP   NZ,14CC
    if (!FlagZ) {
      advance (10)
      jump (14CC);
    } else {
      advance (10)
      jump (14D7);
    }

14D5:

    #14D5
    #instruction: CALL Z,C914
    if (FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 14;
      let:16 a2 = (-1 + a1) in
      M[a2] := D8;
      #return-to: 14D8
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C914);
    } else {
      advance (11)
      jump (14D8);
    }

14D6:

    #14D6
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14D7);

14D7:

    #14D7
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

14D8:

    #14D8
    #instruction: LD   A,(2025)
    advance (13)
    A := M[2025];
    jump (14DB);

14D9:

    #14D9
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14DA);

14DA:

    #14DA
    #instruction: *NOP
    advance (4)
    jump (14DB);

14DB:

    #14DB
    #instruction: CP   05
    let:16 a1 = addWithCarry(!false,A,~05) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~05 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14DD);

14DC:

    #14DC
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14DD);

14DD:

    #14DD
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (14DE);
    }

14DE:

    #14DE
    #instruction: CP   02
    let:16 a1 = addWithCarry(!false,A,~02) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~02 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14E0);

14DF:

    #14DF
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (14E0);

14E0:

    #14E0
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (14E1);
    }

14E1:

    #14E1
    #instruction: LD   A,(2029)
    advance (13)
    A := M[2029];
    jump (14E4);

14E2:

    #14E2
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (14E3);

14E3:

    #14E3
    #instruction: *NOP
    advance (4)
    jump (14E4);

14E4:

    #14E4
    #instruction: CP   D8
    let:16 a1 = addWithCarry(!false,A,~D8) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D8 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14E6);

14E5:

    #14E5
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (14E6);
    }

14E6:

    #14E6
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (14E7);

14E7:

    #14E7
    #instruction: JP   NC,1530
    if (!FlagCY) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (14EA);
    }

14E8:

    #14E8
    #instruction: *NOP
    advance (4)
    jump (14E9);

14E9:

    #14E9
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14EA);

14EA:

    #14EA
    #instruction: LD   A,(2002)
    advance (13)
    A := M[2002];
    jump (14ED);

14EB:

    #14EB
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (14EC);

14EC:

    #14EC
    #instruction: *NOP
    advance (4)
    jump (14ED);

14ED:

    #14ED
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (14EE);

14EE:

    #14EE
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (14EF);
    }

14EF:

    #14EF
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (14F0);

14F0:

    #14F0
    #instruction: CP   CE
    let:16 a1 = addWithCarry(!false,A,~CE) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~CE & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14F2);

14F1:

    #14F1
    #instruction: ADC  D2
    let:16 a1 = addWithCarry(FlagCY,D2,A) in
    let:8 a2 = (D2 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (14F3);

14F2:

    #14F2
    #instruction: JP   NC,1579
    if (!FlagCY) {
      advance (10)
      jump (1579);
    } else {
      advance (10)
      jump (14F5);
    }

14F3:

    #14F3
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (14F4);

14F4:

    #14F4
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14F5);

14F5:

    #14F5
    #instruction: ADD  06
    let:16 a1 = addWithCarry(false,06,A) in
    let:8 a2 = (06 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (14F7);

14F6:

    #14F6
    #instruction: LD   B,47
    advance (7)
    B := 47;
    jump (14F8);

14F7:

    #14F7
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (14F8);

14F8:

    #14F8
    #instruction: LD   A,(2009)
    advance (13)
    A := M[2009];
    jump (14FB);

14F9:

    #14F9
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (14FA);

14FA:

    #14FA
    #instruction: *NOP
    advance (4)
    jump (14FB);

14FB:

    #14FB
    #instruction: CP   90
    let:16 a1 = addWithCarry(!false,A,~90) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~90 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14FD);

14FC:

    #14FC
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (14FD);

14FD:

    #14FD
    #instruction: JP   NC,1504
    if (!FlagCY) {
      advance (10)
      jump (1504);
    } else {
      advance (10)
      jump (1500);
    }

14FE:

    #14FE
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (14FF);

14FF:

    #14FF
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1500);

1500:

    #1500
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1501);

1501:

    #1501
    #instruction: JP   NC,1530
    if (!FlagCY) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (1504);
    }

1502:

    #1502
    #instruction: *NOP
    advance (4)
    jump (1503);

1503:

    #1503
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1504);

1504:

    #1504
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1505);

1505:

    #1505
    #instruction: CALL 1562
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    #return-to: 1508
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1562);

1506:

    #1506
    #instruction: LD   H,D
    advance (5)
    H := D;
    jump (1507);

1507:

    #1507
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1508);

1508:

    #1508
    #instruction: LD   A,(202A)
    advance (13)
    A := M[202A];
    jump (150B);

1509:

    #1509
    #instruction: LD   HL,(6720)
    advance (16)
    H := M[6721];
    L := M[6720];
    jump (150C);

150A:

    #150A
    #instruction: *NOP
    advance (4)
    jump (150B);

150B:

    #150B
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (150C);

150C:

    #150C
    #instruction: CALL 156F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0F;
    #return-to: 150F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (156F);

150D:

    #150D
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (150E);

150E:

    #150E
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (150F);

150F:

    #150F
    #instruction: LD   (2064),HL
    M[2064] := L;
    M[2065] := H;
    advance (16)
    jump (1512);

1510:

    #1510
    #instruction: LD   H,H
    advance (5)
    jump (1511);

1511:

    #1511
    #instruction: *NOP
    advance (4)
    jump (1512);

1512:

    #1512
    #instruction: LD   A,05
    advance (7)
    A := 05;
    jump (1514);

1513:

    #1513
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1514);

1514:

    #1514
    #instruction: LD   (2025),A
    M[2025] := A;
    advance (13)
    jump (1517);

1515:

    #1515
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1516);

1516:

    #1516
    #instruction: *NOP
    advance (4)
    jump (1517);

1517:

    #1517
    #instruction: CALL 1581
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    #return-to: 151A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1581);

1518:

    #1518
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1519);

1519:

    #1519
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (151A);

151A:

    #151A
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (151B);

151B:

    #151B
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (151C);

151C:

    #151C
    #instruction: JP   Z,1530
    if (FlagZ) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (151F);
    }

151D:

    #151D
    #instruction: *NOP
    advance (4)
    jump (151E);

151E:

    #151E
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (151F);

151F:

    #151F
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (1521);

1520:

    #1520
    #instruction: NOP
    advance (4)
    jump (1521);

1521:

    #1521
    #instruction: CALL 0A5F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 24;
    #return-to: 1524
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A5F);

1522:

    #1522
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (1523);

1523:

    #1523
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1524);

1524:

    #1524
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    #return-to: 1527
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

1525:

    #1525
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (1526);

1526:

    #1526
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1527);

1527:

    #1527
    #instruction: CALL 15D3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2A;
    #return-to: 152A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15D3);

1528:

    #1528
    #instruction: OUT  15
    unknown_output(21);
    advance (10)
    jump (152A);

1529:

    #1529
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (152A);

152A:

    #152A
    #instruction: LD   A,10
    advance (7)
    A := 10;
    jump (152C);

152B:

    #152B
    #instruction: *NOP
    advance (4)
    jump (152C);

152C:

    #152C
    #instruction: LD   (2003),A
    M[2003] := A;
    advance (13)
    jump (152F);

152D:

    #152D
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (152E);

152E:

    #152E
    #instruction: *NOP
    advance (4)
    jump (152F);

152F:

    #152F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1530:

    #1530
    #instruction: LD   A,03
    advance (7)
    A := 03;
    jump (1532);

1531:

    #1531
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1532);

1532:

    #1532
    #instruction: LD   (2025),A
    M[2025] := A;
    advance (13)
    jump (1535);

1533:

    #1533
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1534);

1534:

    #1534
    #instruction: *NOP
    advance (4)
    jump (1535);

1535:

    #1535
    #instruction: JP   154A
    advance (10)
    jump (154A);

1536:

    #1536
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (1537);

1537:

    #1537
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1538);

1538:

    #1538
    #instruction: LD   HL,2003
    advance (10)
    H := 20;
    L := 03;
    jump (153B);

1539:

    #1539
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (153A);

153A:

    #153A
    #instruction: *NOP
    advance (4)
    jump (153B);

153B:

    #153B
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (153C);

153C:

    #153C
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (153D);
    }

153D:

    #153D
    #instruction: LD   HL,(2064)
    advance (16)
    H := M[2065];
    L := M[2064];
    jump (1540);

153E:

    #153E
    #instruction: LD   H,H
    advance (5)
    jump (153F);

153F:

    #153F
    #instruction: *NOP
    advance (4)
    jump (1540);

1540:

    #1540
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (1542);

1541:

    #1541
    #instruction: *NOP
    advance (4)
    jump (1542);

1542:

    #1542
    #instruction: CALL 1424
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 45;
    #return-to: 1545
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1424);

1543:

    #1543
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1544);

1544:

    #1544
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1545);

1545:

    #1545
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (1547);

1546:

    #1546
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1547);

1547:

    #1547
    #instruction: LD   (2025),A
    M[2025] := A;
    advance (13)
    jump (154A);

1548:

    #1548
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1549);

1549:

    #1549
    #instruction: *NOP
    advance (4)
    jump (154A);

154A:

    #154A
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (154B);

154B:

    #154B
    #instruction: LD   (2002),A
    M[2002] := A;
    advance (13)
    jump (154E);

154C:

    #154C
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (154D);

154D:

    #154D
    #instruction: *NOP
    advance (4)
    jump (154E);

154E:

    #154E
    #instruction: LD   B,F7
    advance (7)
    B := F7;
    jump (1550);

154F:

    #154F
    #instruction: RST  6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 50;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0030);

1550:

    #1550
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

1551:

    #1551
    #instruction: CALL CY,0019
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 15;
      let:16 a2 = (-1 + a1) in
      M[a2] := 54;
      #return-to: 1554
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0019);
    } else {
      advance (11)
      jump (1554);
    }

1552:

    #1552
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1553);

1553:

    #1553
    #instruction: NOP
    advance (4)
    jump (1554);

1554:

    #1554
    #instruction: LD   C,00
    advance (7)
    C := 00;
    jump (1556);

1555:

    #1555
    #instruction: NOP
    advance (4)
    jump (1556);

1556:

    #1556
    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1557);

1557:

    #1557
    #instruction: CALL NC,1590
    if (!FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 15;
      let:16 a2 = (-1 + a1) in
      M[a2] := 5A;
      #return-to: 155A
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (1590);
    } else {
      advance (11)
      jump (155A);
    }

1558:

    #1558
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1559);

1559:

    #1559
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (155A);

155A:

    #155A
    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (155B);

155B:

    #155B
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (155C);
    }

155C:

    #155C
    #instruction: ADD  10
    let:16 a1 = addWithCarry(false,10,A) in
    let:8 a2 = (10 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (155E);

155D:

    #155D
    #instruction: *NOP
    advance (4)
    jump (155E);

155E:

    #155E
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (155F);

155F:

    #155F
    #instruction: JP   155A
    advance (10)
    jump (155A);

1560:

    #1560
    #instruction: LD   E,D
    advance (5)
    E := D;
    jump (1561);

1561:

    #1561
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1562);

1562:

    #1562
    #instruction: LD   A,(2009)
    advance (13)
    A := M[2009];
    jump (1565);

1563:

    #1563
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1564);

1564:

    #1564
    #instruction: *NOP
    advance (4)
    jump (1565);

1565:

    #1565
    #instruction: LD   H,L
    advance (5)
    H := L;
    jump (1566);

1566:

    #1566
    #instruction: CALL 1554
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 69;
    #return-to: 1569
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1554);

1567:

    #1567
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (1568);

1568:

    #1568
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1569);

1569:

    #1569
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (156A);

156A:

    #156A
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (156B);

156B:

    #156B
    #instruction: SBC  10
    let:16 a1 = addWithCarry(!FlagCY,A,~10) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (156D);

156C:

    #156C
    #instruction: *NOP
    advance (4)
    jump (156D);

156D:

    #156D
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (156E);

156E:

    #156E
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

156F:

    #156F
    #instruction: LD   A,(200A)
    advance (13)
    A := M[200A];
    jump (1572);

1570:

    #1570
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1571);

1571:

    #1571
    #instruction: *NOP
    advance (4)
    jump (1572);

1572:

    #1572
    #instruction: CALL 1554
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 75;
    #return-to: 1575
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1554);

1573:

    #1573
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (1574);

1574:

    #1574
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1575);

1575:

    #1575
    #instruction: SBC  10
    let:16 a1 = addWithCarry(!FlagCY,A,~10) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1577);

1576:

    #1576
    #instruction: *NOP
    advance (4)
    jump (1577);

1577:

    #1577
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1578);

1578:

    #1578
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1579:

    #1579
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (157B);

157A:

    #157A
    #instruction: LD   BC,8532
    advance (10)
    B := 85;
    C := 32;
    jump (157D);

157B:

    #157B
    #instruction: LD   (2085),A
    M[2085] := A;
    advance (13)
    jump (157E);

157C:

    #157C
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (157D);

157D:

    #157D
    #instruction: *NOP
    advance (4)
    jump (157E);

157E:

    #157E
    #instruction: JP   1545
    advance (10)
    jump (1545);

157F:

    #157F
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1580);

1580:

    #1580
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1581);

1581:

    #1581
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1582);

1582:

    #1582
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1583);

1583:

    #1583
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1584);

1584:

    #1584
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1585);

1585:

    #1585
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1586);

1586:

    #1586
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1587);

1587:

    #1587
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1588);

1588:

    #1588
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1589);

1589:

    #1589
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (158A);

158A:

    #158A
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (158B);

158B:

    #158B
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (158E);

158C:

    #158C
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (158D);

158D:

    #158D
    #instruction: *NOP
    advance (4)
    jump (158E);

158E:

    #158E
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (158F);

158F:

    #158F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1590:

    #1590
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1591);

1591:

    #1591
    #instruction: ADD  10
    let:16 a1 = addWithCarry(false,10,A) in
    let:8 a2 = (10 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1593);

1592:

    #1592
    #instruction: *NOP
    advance (4)
    jump (1593);

1593:

    #1593
    #instruction: JP   MI,1590
    if (FlagS) {
      advance (10)
      jump (1590);
    } else {
      advance (10)
      jump (1596);
    }

1594:

    #1594
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1595);

1595:

    #1595
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1596);

1596:

    #1596
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1597:

    #1597
    #instruction: LD   A,(200D)
    advance (13)
    A := M[200D];
    jump (159A);

1598:

    #1598
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1599);

1599:

    #1599
    #instruction: *NOP
    advance (4)
    jump (159A);

159A:

    #159A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (159B);

159B:

    #159B
    #instruction: JP   NZ,15B7
    if (!FlagZ) {
      advance (10)
      jump (15B7);
    } else {
      advance (10)
      jump (159E);
    }

159C:

    #159C
    #instruction: OR   A
    let:8 a1 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (159D);

159D:

    #159D
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (159E);

159E:

    #159E
    #instruction: LD   HL,3EA4
    advance (10)
    H := 3E;
    L := A4;
    jump (15A1);

159F:

    #159F
    #instruction: AND  H
    let:8 a1 = (H & A) in
    let:8 a2 = (H | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (15A0);

15A0:

    #15A0
    #instruction: LD   A,CD
    advance (7)
    A := CD;
    jump (15A2);

15A1:

    #15A1
    #instruction: CALL 15C5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := A4;
    #return-to: 15A4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15C5);

15A2:

    #15A2
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15A3);

15A3:

    #15A3
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15A4);

15A4:

    #15A4
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (15A5);
    }

15A5:

    #15A5
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (15A7);

15A6:

    #15A6
    #instruction: CP   3E
    let:16 a1 = addWithCarry(!false,A,~3E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~3E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (15A8);

15A7:

    #15A7
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (15A9);

15A8:

    #15A8
    #instruction: LD   BC,0D32
    advance (10)
    B := 0D;
    C := 32;
    jump (15AB);

15A9:

    #15A9
    #instruction: LD   (200D),A
    M[200D] := A;
    advance (13)
    jump (15AC);

15AA:

    #15AA
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15AB);

15AB:

    #15AB
    #instruction: *NOP
    advance (4)
    jump (15AC);

15AC:

    #15AC
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (15AD);

15AD:

    #15AD
    #instruction: LD   (2008),A
    M[2008] := A;
    advance (13)
    jump (15B0);

15AE:

    #15AE
    #instruction: *NOP
    advance (4)
    jump (15AF);

15AF:

    #15AF
    #instruction: *NOP
    advance (4)
    jump (15B0);

15B0:

    #15B0
    #instruction: LD   A,(200E)
    advance (13)
    A := M[200E];
    jump (15B3);

15B1:

    #15B1
    #instruction: LD   C,20
    advance (7)
    C := 20;
    jump (15B3);

15B2:

    #15B2
    #instruction: *NOP
    advance (4)
    jump (15B3);

15B3:

    #15B3
    #instruction: LD   (2007),A
    M[2007] := A;
    advance (13)
    jump (15B6);

15B4:

    #15B4
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (15B5);

15B5:

    #15B5
    #instruction: *NOP
    advance (4)
    jump (15B6);

15B6:

    #15B6
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

15B7:

    #15B7
    #instruction: LD   HL,2524
    advance (10)
    H := 25;
    L := 24;
    jump (15BA);

15B8:

    #15B8
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15B9);

15B9:

    #15B9
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15BA);

15BA:

    #15BA
    #instruction: CALL 15C5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := BD;
    #return-to: 15BD
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15C5);

15BB:

    #15BB
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15BC);

15BC:

    #15BC
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15BD);

15BD:

    #15BD
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (15BE);
    }

15BE:

    #15BE
    #instruction: CALL 18F1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 15C1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18F1);

15BF:

    #15BF
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (15C0);

15C0:

    #15C0
    #instruction: *NOP
    advance (4)
    jump (15C1);

15C1:

    #15C1
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (15C2);

15C2:

    #15C2
    #instruction: JP   15A9
    advance (10)
    jump (15A9);

15C3:

    #15C3
    #instruction: XOR  C
    let:8 a1 = (C ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (15C4);

15C4:

    #15C4
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15C5);

15C5:

    #15C5
    #instruction: LD   B,17
    advance (7)
    B := 17;
    jump (15C7);

15C6:

    #15C6
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (15C7);

15C7:

    #15C7
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (15C8);

15C8:

    #15C8
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (15C9);

15C9:

    #15C9
    #instruction: JP   NZ,166B
    if (!FlagZ) {
      advance (10)
      jump (166B);
    } else {
      advance (10)
      jump (15CC);
    }

15CA:

    #15CA
    #instruction: LD   L,E
    advance (5)
    L := E;
    jump (15CB);

15CB:

    #15CB
    #instruction: LD   D,23
    advance (7)
    D := 23;
    jump (15CD);

15CC:

    #15CC
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (15CD);

15CD:

    #15CD
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15CE);

15CE:

    #15CE
    #instruction: JP   NZ,15C7
    if (!FlagZ) {
      advance (10)
      jump (15C7);
    } else {
      advance (10)
      jump (15D1);
    }

15CF:

    #15CF
    #instruction: RST  0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := D0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0000);

15D0:

    #15D0
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15D1);

15D1:

    #15D1
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

15D2:

    #15D2
    #instruction: NOP
    advance (4)
    jump (15D3);

15D3:

    #15D3
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := D6;
    #return-to: 15D6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1474);

15D4:

    #15D4
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (15D5);

15D5:

    #15D5
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15D6);

15D6:

    #15D6
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15D7);

15D7:

    #15D7
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15D8);

15D8:

    #15D8
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15D9);

15D9:

    #15D9
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (15DA);

15DA:

    #15DA
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (15DC);

15DB:

    #15DB
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15DC);

15DC:

    #15DC
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (15DE);

15DD:

    #15DD
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (15DE);

15DE:

    #15DE
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (15DF);

15DF:

    #15DF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (15E0);

15E0:

    #15E0
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (15E1);

15E1:

    #15E1
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (15E2);

15E2:

    #15E2
    #instruction: OUT  04
    advance (10)
    Shifter_HI := A;
    Shifter_LO := Shifter_HI;
    jump (15E4);

15E3:

    #15E3
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15E4);

15E4:

    #15E4
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (15E6);

15E5:

    #15E5
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (15E6);

15E6:

    #15E6
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (15E7);

15E7:

    #15E7
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15E8);

15E8:

    #15E8
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (15EB);

15E9:

    #15E9
    #instruction: *NOP
    advance (4)
    jump (15EA);

15EA:

    #15EA
    #instruction: NOP
    advance (4)
    jump (15EB);

15EB:

    #15EB
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (15EC);

15EC:

    #15EC
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15ED);

15ED:

    #15ED
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15EE);

15EE:

    #15EE
    #instruction: JP   NZ,15D7
    if (!FlagZ) {
      advance (10)
      jump (15D7);
    } else {
      advance (10)
      jump (15F1);
    }

15EF:

    #15EF
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := F0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

15F0:

    #15F0
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15F1);

15F1:

    #15F1
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (15F2);

15F2:

    #15F2
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

15F3:

    #15F3
    #instruction: CALL 1611
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 15F6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1611);

15F4:

    #15F4
    #instruction: LD   DE,0116
    advance (10)
    D := 01;
    E := 16;
    jump (15F7);

15F5:

    #15F5
    #instruction: LD   D,01
    advance (7)
    D := 01;
    jump (15F7);

15F6:

    #15F6
    #instruction: LD   BC,3700
    advance (10)
    B := 37;
    C := 00;
    jump (15F9);

15F7:

    #15F7
    #instruction: NOP
    advance (4)
    jump (15F8);

15F8:

    #15F8
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (15F9);

15F9:

    #15F9
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (15FA);

15FA:

    #15FA
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (15FB);

15FB:

    #15FB
    #instruction: JP   Z,15FF
    if (FlagZ) {
      advance (10)
      jump (15FF);
    } else {
      advance (10)
      jump (15FE);
    }

15FC:

    #15FC
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := FD;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

15FD:

    #15FD
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15FE);

15FE:

    #15FE
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (15FF);

15FF:

    #15FF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1600);

1600:

    #1600
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1601);

1601:

    #1601
    #instruction: JP   NZ,15F9
    if (!FlagZ) {
      advance (10)
      jump (15F9);
    } else {
      advance (10)
      jump (1604);
    }

1602:

    #1602
    #instruction: LD   SP,HL
    advance (5)
    SPH := H;
    SPL := L;
    jump (1603);

1603:

    #1603
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1604);

1604:

    #1604
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (1605);

1605:

    #1605
    #instruction: LD   (2082),A
    M[2082] := A;
    advance (13)
    jump (1608);

1606:

    #1606
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1607);

1607:

    #1607
    #instruction: *NOP
    advance (4)
    jump (1608);

1608:

    #1608
    #instruction: CP   01
    let:16 a1 = addWithCarry(!false,A,~01) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~01 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (160A);

1609:

    #1609
    #instruction: LD   BC,21C0
    advance (10)
    B := 21;
    C := C0;
    jump (160C);

160A:

    #160A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (160B);
    }

160B:

    #160B
    #instruction: LD   HL,206B
    advance (10)
    H := 20;
    L := 6B;
    jump (160E);

160C:

    #160C
    #instruction: LD   L,E
    advance (5)
    L := E;
    jump (160D);

160D:

    #160D
    #instruction: *NOP
    advance (4)
    jump (160E);

160E:

    #160E
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (1610);

160F:

    #160F
    #instruction: LD   BC,2EC9
    advance (10)
    B := 2E;
    C := C9;
    jump (1612);

1610:

    #1610
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1611:

    #1611
    #instruction: LD   L,00
    advance (7)
    L := 00;
    jump (1613);

1612:

    #1612
    #instruction: NOP
    advance (4)
    jump (1613);

1613:

    #1613
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (1616);

1614:

    #1614
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1615);

1615:

    #1615
    #instruction: *NOP
    advance (4)
    jump (1616);

1616:

    #1616
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1617);

1617:

    #1617
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1618:

    #1618
    #instruction: LD   A,(2015)
    advance (13)
    A := M[2015];
    jump (161B);

1619:

    #1619
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (161A);

161A:

    #161A
    #instruction: *NOP
    advance (4)
    jump (161B);

161B:

    #161B
    #instruction: CP   FF
    let:16 a1 = addWithCarry(!false,A,~FF) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FF & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (161D);

161C:

    #161C
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1D;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

161D:

    #161D
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (161E);
    }

161E:

    #161E
    #instruction: LD   HL,2010
    advance (10)
    H := 20;
    L := 10;
    jump (1621);

161F:

    #161F
    #instruction: *NOP
    advance (4)
    jump (1620);

1620:

    #1620
    #instruction: *NOP
    advance (4)
    jump (1621);

1621:

    #1621
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1622);

1622:

    #1622
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1623);

1623:

    #1623
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (1624);

1624:

    #1624
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1625);

1625:

    #1625
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1626);
    }

1626:

    #1626
    #instruction: LD   A,(2025)
    advance (13)
    A := M[2025];
    jump (1629);

1627:

    #1627
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1628);

1628:

    #1628
    #instruction: *NOP
    advance (4)
    jump (1629);

1629:

    #1629
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (162A);

162A:

    #162A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (162B);
    }

162B:

    #162B
    #instruction: LD   A,(20EF)
    advance (13)
    A := M[20EF];
    jump (162E);

162C:

    #162C
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2D;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

162D:

    #162D
    #instruction: *NOP
    advance (4)
    jump (162E);

162E:

    #162E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (162F);

162F:

    #162F
    #instruction: JP   Z,1652
    if (FlagZ) {
      advance (10)
      jump (1652);
    } else {
      advance (10)
      jump (1632);
    }

1630:

    #1630
    #instruction: LD   D,D
    advance (5)
    jump (1631);

1631:

    #1631
    #instruction: LD   D,3A
    advance (7)
    D := 3A;
    jump (1633);

1632:

    #1632
    #instruction: LD   A,(202D)
    advance (13)
    A := M[202D];
    jump (1635);

1633:

    #1633
    #instruction: DEC  L
    let:16 a1 = addWithCarry(!true,L,~00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1634);

1634:

    #1634
    #instruction: *NOP
    advance (4)
    jump (1635);

1635:

    #1635
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1636);

1636:

    #1636
    #instruction: JP   NZ,1648
    if (!FlagZ) {
      advance (10)
      jump (1648);
    } else {
      advance (10)
      jump (1639);
    }

1637:

    #1637
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1638);

1638:

    #1638
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (163A);

1639:

    #1639
    #instruction: CALL 17C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    #return-to: 163C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (17C0);

163A:

    #163A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (163B);
    }

163B:

    #163B
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (163C);

163C:

    #163C
    #instruction: AND  10
    let:8 a1 = (10 & A) in
    let:8 a2 = (10 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (163E);

163D:

    #163D
    #instruction: *NOP
    advance (4)
    jump (163E);

163E:

    #163E
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (163F);
    }

163F:

    #163F
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (1641);

1640:

    #1640
    #instruction: LD   BC,2532
    advance (10)
    B := 25;
    C := 32;
    jump (1643);

1641:

    #1641
    #instruction: LD   (2025),A
    M[2025] := A;
    advance (13)
    jump (1644);

1642:

    #1642
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1643);

1643:

    #1643
    #instruction: *NOP
    advance (4)
    jump (1644);

1644:

    #1644
    #instruction: LD   (202D),A
    M[202D] := A;
    advance (13)
    jump (1647);

1645:

    #1645
    #instruction: DEC  L
    let:16 a1 = addWithCarry(!true,L,~00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1646);

1646:

    #1646
    #instruction: *NOP
    advance (4)
    jump (1647);

1647:

    #1647
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1648:

    #1648
    #instruction: CALL 17C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4B;
    #return-to: 164B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (17C0);

1649:

    #1649
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (164A);
    }

164A:

    #164A
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (164B);

164B:

    #164B
    #instruction: AND  10
    let:8 a1 = (10 & A) in
    let:8 a2 = (10 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (164D);

164C:

    #164C
    #instruction: *NOP
    advance (4)
    jump (164D);

164D:

    #164D
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (164E);
    }

164E:

    #164E
    #instruction: LD   (202D),A
    M[202D] := A;
    advance (13)
    jump (1651);

164F:

    #164F
    #instruction: DEC  L
    let:16 a1 = addWithCarry(!true,L,~00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1650);

1650:

    #1650
    #instruction: *NOP
    advance (4)
    jump (1651);

1651:

    #1651
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1652:

    #1652
    #instruction: LD   HL,2025
    advance (10)
    H := 20;
    L := 25;
    jump (1655);

1653:

    #1653
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1654);

1654:

    #1654
    #instruction: *NOP
    advance (4)
    jump (1655);

1655:

    #1655
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (1657);

1656:

    #1656
    #instruction: LD   BC,ED2A
    advance (10)
    B := ED;
    C := 2A;
    jump (1659);

1657:

    #1657
    #instruction: LD   HL,(20ED)
    advance (16)
    H := M[20EE];
    L := M[20ED];
    jump (165A);

1658:

    #1658
    #instruction: *CAL 2320
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5B;
    #return-to: 165B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (2320);

1659:

    #1659
    #instruction: *NOP
    advance (4)
    jump (165A);

165A:

    #165A
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (165B);

165B:

    #165B
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (165C);

165C:

    #165C
    #instruction: CP   7E
    let:16 a1 = addWithCarry(!false,A,~7E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~7E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (165E);

165D:

    #165D
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (165E);

165E:

    #165E
    #instruction: JP   CY,1663
    if (FlagCY) {
      advance (10)
      jump (1663);
    } else {
      advance (10)
      jump (1661);
    }

165F:

    #165F
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (1660);

1660:

    #1660
    #instruction: LD   D,2E
    advance (7)
    D := 2E;
    jump (1662);

1661:

    #1661
    #instruction: LD   L,74
    advance (7)
    L := 74;
    jump (1663);

1662:

    #1662
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1663);

1663:

    #1663
    #instruction: LD   (20ED),HL
    M[20ED] := L;
    M[20EE] := H;
    advance (16)
    jump (1666);

1664:

    #1664
    #instruction: *CAL 7E20
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 67;
    #return-to: 1667
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (7E20);

1665:

    #1665
    #instruction: *NOP
    advance (4)
    jump (1666);

1666:

    #1666
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1667);

1667:

    #1667
    #instruction: LD   (201D),A
    M[201D] := A;
    advance (13)
    jump (166A);

1668:

    #1668
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1669);

1669:

    #1669
    #instruction: *NOP
    advance (4)
    jump (166A);

166A:

    #166A
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

166B:

    #166B
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (166C);

166C:

    #166C
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

166D:

    #166D
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (166E);

166E:

    #166E
    #instruction: CALL 1A8B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 1671
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A8B);

166F:

    #166F
    #instruction: ADC  E
    let:16 a1 = addWithCarry(FlagCY,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1670);

1670:

    #1670
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1671);

1671:

    #1671
    #instruction: CALL 1910
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 1674
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1910);

1672:

    #1672
    #instruction: *NOP
    advance (4)
    jump (1673);

1673:

    #1673
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1674);

1674:

    #1674
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (1676);

1675:

    #1675
    #instruction: NOP
    advance (4)
    jump (1676);

1676:

    #1676
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 79;
    #return-to: 1679
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09CA);

1677:

    #1677
    #instruction: JP   Z,2309
    if (FlagZ) {
      advance (10)
      jump (2309);
    } else {
      advance (10)
      jump (167A);
    }

1678:

    #1678
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1679);

1679:

    #1679
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (167A);

167A:

    #167A
    #instruction: LD   DE,20F5
    advance (10)
    D := 20;
    E := F5;
    jump (167D);

167B:

    #167B
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (167C);

167C:

    #167C
    #instruction: *NOP
    advance (4)
    jump (167D);

167D:

    #167D
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (167E);

167E:

    #167E
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (167F);

167F:

    #167F
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1680);

1680:

    #1680
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1681);

1681:

    #1681
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1682);

1682:

    #1682
    #instruction: JP   Z,168B
    if (FlagZ) {
      advance (10)
      jump (168B);
    } else {
      advance (10)
      jump (1685);
    }

1683:

    #1683
    #instruction: ADC  E
    let:16 a1 = addWithCarry(FlagCY,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1684);

1684:

    #1684
    #instruction: LD   D,D2
    advance (7)
    D := D2;
    jump (1686);

1685:

    #1685
    #instruction: JP   NC,1698
    if (!FlagCY) {
      advance (10)
      jump (1698);
    } else {
      advance (10)
      jump (1688);
    }

1686:

    #1686
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1687);

1687:

    #1687
    #instruction: LD   D,C3
    advance (7)
    D := C3;
    jump (1689);

1688:

    #1688
    #instruction: JP   168F
    advance (10)
    jump (168F);

1689:

    #1689
    #instruction: ADC  A
    let:16 a1 = addWithCarry(FlagCY,A,A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (168A);

168A:

    #168A
    #instruction: LD   D,BE
    advance (7)
    D := BE;
    jump (168C);

168B:

    #168B
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (168C);

168C:

    #168C
    #instruction: JP   NC,1698
    if (!FlagCY) {
      advance (10)
      jump (1698);
    } else {
      advance (10)
      jump (168F);
    }

168D:

    #168D
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (168E);

168E:

    #168E
    #instruction: LD   D,7E
    advance (7)
    D := 7E;
    jump (1690);

168F:

    #168F
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1690);

1690:

    #1690
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1691);

1691:

    #1691
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1692);

1692:

    #1692
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1693);

1693:

    #1693
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1694);

1694:

    #1694
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1695);

1695:

    #1695
    #instruction: CALL 1950
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 98;
    #return-to: 1698
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1950);

1696:

    #1696
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1697);

1697:

    #1697
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1698);

1698:

    #1698
    #instruction: LD   A,(20CE)
    advance (13)
    A := M[20CE];
    jump (169B);

1699:

    #1699
    #instruction: ADC  20
    let:16 a1 = addWithCarry(FlagCY,20,A) in
    let:8 a2 = (20 & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (169B);

169A:

    #169A
    #instruction: *NOP
    advance (4)
    jump (169B);

169B:

    #169B
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (169C);

169C:

    #169C
    #instruction: JP   Z,16C9
    if (FlagZ) {
      advance (10)
      jump (16C9);
    } else {
      advance (10)
      jump (169F);
    }

169D:

    #169D
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

169E:

    #169E
    #instruction: LD   D,21
    advance (7)
    D := 21;
    jump (16A0);

169F:

    #169F
    #instruction: LD   HL,2803
    advance (10)
    H := 28;
    L := 03;
    jump (16A2);

16A0:

    #16A0
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (16A1);

16A1:

    #16A1
    #instruction: *NOP
    advance (4)
    jump (16A2);

16A2:

    #16A2
    #instruction: LD   DE,1AA6
    advance (10)
    D := 1A;
    E := A6;
    jump (16A5);

16A3:

    #16A3
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (16A4);

16A4:

    #16A4
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (16A5);

16A5:

    #16A5
    #instruction: LD   C,14
    advance (7)
    C := 14;
    jump (16A7);

16A6:

    #16A6
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16A7);

16A7:

    #16A7
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := AA;
    #return-to: 16AA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

16A8:

    #16A8
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (16A9);

16A9:

    #16A9
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16AA);

16AA:

    #16AA
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16AB);

16AB:

    #16AB
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16AC);

16AC:

    #16AC
    #instruction: LD   B,1B
    advance (7)
    B := 1B;
    jump (16AE);

16AD:

    #16AD
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (16AE);

16AE:

    #16AE
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (16B1);

16AF:

    #16AF
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (16B0);

16B0:

    #16B0
    #instruction: *NOP
    advance (4)
    jump (16B1);

16B1:

    #16B1
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (16B2);

16B2:

    #16B2
    #instruction: JP   CY,16B7
    if (FlagCY) {
      advance (10)
      jump (16B7);
    } else {
      advance (10)
      jump (16B5);
    }

16B3:

    #16B3
    #instruction: OR   A
    let:8 a1 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16B4);

16B4:

    #16B4
    #instruction: LD   D,06
    advance (7)
    D := 06;
    jump (16B6);

16B5:

    #16B5
    #instruction: LD   B,1C
    advance (7)
    B := 1C;
    jump (16B7);

16B6:

    #16B6
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16B7);

16B7:

    #16B7
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (16B8);

16B8:

    #16B8
    #instruction: CALL 08FF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := BB;
    #return-to: 16BB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08FF);

16B9:

    #16B9
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := BA;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

16BA:

    #16BA
    #instruction: *NOP
    advance (4)
    jump (16BB);

16BB:

    #16BB
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := BE;
    #return-to: 16BE
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

16BC:

    #16BC
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16BD);

16BD:

    #16BD
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16BE);

16BE:

    #16BE
    #instruction: CALL 18E7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 16C1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18E7);

16BF:

    #16BF
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := C0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

16C0:

    #16C0
    #instruction: *NOP
    advance (4)
    jump (16C1);

16C1:

    #16C1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (16C2);

16C2:

    #16C2
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (16C3);

16C3:

    #16C3
    #instruction: JP   Z,16C9
    if (FlagZ) {
      advance (10)
      jump (16C9);
    } else {
      advance (10)
      jump (16C6);
    }

16C4:

    #16C4
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

16C5:

    #16C5
    #instruction: LD   D,C3
    advance (7)
    D := C3;
    jump (16C7);

16C6:

    #16C6
    #instruction: JP   02ED
    advance (10)
    jump (02ED);

16C7:

    #16C7
    #instruction: *CAL 2102
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := CA;
    #return-to: 16CA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (2102);

16C8:

    #16C8
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (16C9);

16C9:

    #16C9
    #instruction: LD   HL,2D18
    advance (10)
    H := 2D;
    L := 18;
    jump (16CC);

16CA:

    #16CA
    #instruction: *NOP
    advance (4)
    jump (16CB);

16CB:

    #16CB
    #instruction: DEC  L
    let:16 a1 = addWithCarry(!true,L,~00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16CC);

16CC:

    #16CC
    #instruction: LD   DE,1AA6
    advance (10)
    D := 1A;
    E := A6;
    jump (16CF);

16CD:

    #16CD
    #instruction: AND  (HL)
    let:8 a1 = (M[(H,L)] & A) in
    let:8 a2 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (16CE);

16CE:

    #16CE
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (16CF);

16CF:

    #16CF
    #instruction: LD   C,0A
    advance (7)
    C := 0A;
    jump (16D1);

16D0:

    #16D0
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16D1);

16D1:

    #16D1
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := D4;
    #return-to: 16D4
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

16D2:

    #16D2
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (16D3);

16D3:

    #16D3
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16D4);

16D4:

    #16D4
    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := D7;
    #return-to: 16D7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB6);

16D5:

    #16D5
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16D6);

16D6:

    #16D6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16D7);

16D7:

    #16D7
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 16DA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

16D8:

    #16D8
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (16DA);

16D9:

    #16D9
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (16DA);

16DA:

    #16DA
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16DB);

16DB:

    #16DB
    #instruction: LD   (20EF),A
    M[20EF] := A;
    advance (13)
    jump (16DE);

16DC:

    #16DC
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := DD;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

16DD:

    #16DD
    #instruction: *NOP
    advance (4)
    jump (16DE);

16DE:

    #16DE
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (16E0);

16DF:

    #16DF
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16E0);

16E0:

    #16E0
    #instruction: CALL 19D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := E3;
    #return-to: 16E3
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D1);

16E1:

    #16E1
    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (16E2);

16E2:

    #16E2
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (16E3);

16E3:

    #16E3
    #instruction: JP   0B89
    advance (10)
    jump (0B89);

16E4:

    #16E4
    #instruction: ADC  C
    let:16 a1 = addWithCarry(FlagCY,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (16E5);

16E5:

    #16E5
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (16E6);

16E6:

    #16E6
    #instruction: LD   SP,2400
    advance (10)
    SPH := 24;
    SPL := 00;
    jump (16E9);

16E7:

    #16E7
    #instruction: NOP
    advance (4)
    jump (16E8);

16E8:

    #16E8
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16E9);

16E9:

    #16E9
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (16EA);

16EA:

    #16EA
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16EB);

16EB:

    #16EB
    #instruction: LD   (2015),A
    M[2015] := A;
    advance (13)
    jump (16EE);

16EC:

    #16EC
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16ED);

16ED:

    #16ED
    #instruction: *NOP
    advance (4)
    jump (16EE);

16EE:

    #16EE
    #instruction: CALL 14D8
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := F1;
    #return-to: 16F1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14D8);

16EF:

    #16EF
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (16F0);
    }

16F0:

    #16F0
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16F1);

16F1:

    #16F1
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (16F3);

16F2:

    #16F2
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (16F3);

16F3:

    #16F3
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 16F6
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18FA);

16F4:

    #16F4
    #instruction: JP   MI,CD18
    if (FlagS) {
      advance (10)
      jump (CD18);
    } else {
      advance (10)
      jump (16F7);
    }

16F5:

    #16F5
    #instruction: *NOP
    advance (4)
    jump (16F6);

16F6:

    #16F6
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := F9;
    #return-to: 16F9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A59);

16F7:

    #16F7
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (16F8);

16F8:

    #16F8
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (16F9);

16F9:

    #16F9
    #instruction: JP   NZ,16EE
    if (!FlagZ) {
      advance (10)
      jump (16EE);
    } else {
      advance (10)
      jump (16FC);
    }

16FA:

    #16FA
    #instruction: XOR  16
    let:8 a1 = (16 ^ A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (16FC);

16FB:

    #16FB
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (16FD);

16FC:

    #16FC
    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 16FF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D7);

16FD:

    #16FD
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := FE;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

16FE:

    #16FE
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (16FF);

16FF:

    #16FF
    #instruction: LD   HL,2701
    advance (10)
    H := 27;
    L := 01;
    jump (1702);

1700:

    #1700
    #instruction: LD   BC,CD27
    advance (10)
    B := CD;
    C := 27;
    jump (1703);

1701:

    #1701
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1702);

1702:

    #1702
    #instruction: CALL 19FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    #return-to: 1705
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19FA);

1703:

    #1703
    #instruction: JP   MI,AF19
    if (FlagS) {
      advance (10)
      jump (AF19);
    } else {
      advance (10)
      jump (1706);
    }

1704:

    #1704
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1705);

1705:

    #1705
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1706);

1706:

    #1706
    #instruction: CALL 1A8B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    #return-to: 1709
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A8B);

1707:

    #1707
    #instruction: ADC  E
    let:16 a1 = addWithCarry(FlagCY,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1708);

1708:

    #1708
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1709);

1709:

    #1709
    #instruction: LD   B,FB
    advance (7)
    B := FB;
    jump (170B);

170A:

    #170A
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (170B);

170B:

    #170B
    #instruction: JP   196B
    advance (10)
    jump (196B);

170C:

    #170C
    #instruction: LD   L,E
    advance (5)
    L := E;
    jump (170D);

170D:

    #170D
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (170E);

170E:

    #170E
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 11;
    #return-to: 1711
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09CA);

170F:

    #170F
    #instruction: JP   Z,2309
    if (FlagZ) {
      advance (10)
      jump (2309);
    } else {
      advance (10)
      jump (1712);
    }

1710:

    #1710
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1711);

1711:

    #1711
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1712);

1712:

    #1712
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1713);

1713:

    #1713
    #instruction: LD   DE,1CB8
    advance (10)
    D := 1C;
    E := B8;
    jump (1716);

1714:

    #1714
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1715);

1715:

    #1715
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1716);

1716:

    #1716
    #instruction: LD   HL,1AA1
    advance (10)
    H := 1A;
    L := A1;
    jump (1719);

1717:

    #1717
    #instruction: AND  C
    let:8 a1 = (C & A) in
    let:8 a2 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1718);

1718:

    #1718
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1719);

1719:

    #1719
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (171B);

171A:

    #171A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (171B);

171B:

    #171B
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (171C);

171C:

    #171C
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (171D);

171D:

    #171D
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (171E);

171E:

    #171E
    #instruction: JP   NC,1727
    if (!FlagCY) {
      advance (10)
      jump (1727);
    } else {
      advance (10)
      jump (1721);
    }

171F:

    #171F
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1720);

1720:

    #1720
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1721);

1721:

    #1721
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1722);

1722:

    #1722
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1723);

1723:

    #1723
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1724);

1724:

    #1724
    #instruction: JP   NZ,171C
    if (!FlagZ) {
      advance (10)
      jump (171C);
    } else {
      advance (10)
      jump (1727);
    }

1725:

    #1725
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1726);

1726:

    #1726
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1727);

1727:

    #1727
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1728);

1728:

    #1728
    #instruction: LD   (20CF),A
    M[20CF] := A;
    advance (13)
    jump (172B);

1729:

    #1729
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2A;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

172A:

    #172A
    #instruction: *NOP
    advance (4)
    jump (172B);

172B:

    #172B
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

172C:

    #172C
    #instruction: LD   A,(2025)
    advance (13)
    A := M[2025];
    jump (172F);

172D:

    #172D
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (172E);

172E:

    #172E
    #instruction: *NOP
    advance (4)
    jump (172F);

172F:

    #172F
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1731);

1730:

    #1730
    #instruction: NOP
    advance (4)
    jump (1731);

1731:

    #1731
    #instruction: JP   NZ,1739
    if (!FlagZ) {
      advance (10)
      jump (1739);
    } else {
      advance (10)
      jump (1734);
    }

1732:

    #1732
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1733);

1733:

    #1733
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1734);

1734:

    #1734
    #instruction: LD   B,FD
    advance (7)
    B := FD;
    jump (1736);

1735:

    #1735
    #instruction: *CAL DCC3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 38;
    #return-to: 1738
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (DCC3);

1736:

    #1736
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

1737:

    #1737
    #instruction: CALL CY,0619
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 17;
      let:16 a2 = (-1 + a1) in
      M[a2] := 3A;
      #return-to: 173A
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0619);
    } else {
      advance (11)
      jump (173A);
    }

1738:

    #1738
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1739);

1739:

    #1739
    #instruction: LD   B,02
    advance (7)
    B := 02;
    jump (173B);

173A:

    #173A
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (173B);

173B:

    #173B
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

173C:

    #173C
    #instruction: JP   MI,0018
    if (FlagS) {
      advance (10)
      jump (0018);
    } else {
      advance (10)
      jump (173F);
    }

173D:

    #173D
    #instruction: *NOP
    advance (4)
    jump (173E);

173E:

    #173E
    #instruction: NOP
    advance (4)
    jump (173F);

173F:

    #173F
    #instruction: NOP
    advance (4)
    jump (1740);

1740:

    #1740
    #instruction: LD   HL,209B
    advance (10)
    H := 20;
    L := 9B;
    jump (1743);

1741:

    #1741
    #instruction: SBC  E
    let:16 a1 = addWithCarry(!FlagCY,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1742);

1742:

    #1742
    #instruction: *NOP
    advance (4)
    jump (1743);

1743:

    #1743
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1744);

1744:

    #1744
    #instruction: CALL Z,176D
    if (FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 17;
      let:16 a2 = (-1 + a1) in
      M[a2] := 47;
      #return-to: 1747
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (176D);
    } else {
      advance (11)
      jump (1747);
    }

1745:

    #1745
    #instruction: LD   L,L
    advance (5)
    jump (1746);

1746:

    #1746
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1747);

1747:

    #1747
    #instruction: LD   A,(2068)
    advance (13)
    A := M[2068];
    jump (174A);

1748:

    #1748
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1749);

1749:

    #1749
    #instruction: *NOP
    advance (4)
    jump (174A);

174A:

    #174A
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (174B);

174B:

    #174B
    #instruction: JP   Z,176D
    if (FlagZ) {
      advance (10)
      jump (176D);
    } else {
      advance (10)
      jump (174E);
    }

174C:

    #174C
    #instruction: LD   L,L
    advance (5)
    jump (174D);

174D:

    #174D
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (174E);

174E:

    #174E
    #instruction: LD   HL,2096
    advance (10)
    H := 20;
    L := 96;
    jump (1751);

174F:

    #174F
    #instruction: SUB  (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1750);

1750:

    #1750
    #instruction: *NOP
    advance (4)
    jump (1751);

1751:

    #1751
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1752);

1752:

    #1752
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1753);
    }

1753:

    #1753
    #instruction: LD   HL,2098
    advance (10)
    H := 20;
    L := 98;
    jump (1756);

1754:

    #1754
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1755);

1755:

    #1755
    #instruction: *NOP
    advance (4)
    jump (1756);

1756:

    #1756
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1757);

1757:

    #1757
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (1759);

1758:

    #1758
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1759);

1759:

    #1759
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (175C);

175A:

    #175A
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (175B);

175B:

    #175B
    #instruction: *NOP
    advance (4)
    jump (175C);

175C:

    #175C
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (175D);

175D:

    #175D
    #instruction: JP   Z,176D
    if (FlagZ) {
      advance (10)
      jump (176D);
    } else {
      advance (10)
      jump (1760);
    }

175E:

    #175E
    #instruction: LD   L,L
    advance (5)
    jump (175F);

175F:

    #175F
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1760);

1760:

    #1760
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1761);

1761:

    #1761
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1762);

1762:

    #1762
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1763);

1763:

    #1763
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1764);

1764:

    #1764
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1765);

1765:

    #1765
    #instruction: LD   (HL),01
    M[(H,L)] := 01;
    advance (10)
    jump (1767);

1766:

    #1766
    #instruction: LD   BC,043E
    advance (10)
    B := 04;
    C := 3E;
    jump (1769);

1767:

    #1767
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (1769);

1768:

    #1768
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1769);

1769:

    #1769
    #instruction: LD   (209B),A
    M[209B] := A;
    advance (13)
    jump (176C);

176A:

    #176A
    #instruction: SBC  E
    let:16 a1 = addWithCarry(!FlagCY,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (176B);

176B:

    #176B
    #instruction: *NOP
    advance (4)
    jump (176C);

176C:

    #176C
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

176D:

    #176D
    #instruction: LD   A,(2098)
    advance (13)
    A := M[2098];
    jump (1770);

176E:

    #176E
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (176F);

176F:

    #176F
    #instruction: *NOP
    advance (4)
    jump (1770);

1770:

    #1770
    #instruction: AND  30
    let:8 a1 = (30 & A) in
    let:8 a2 = (30 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1772);

1771:

    #1771
    #instruction: *NOP
    advance (4)
    jump (1772);

1772:

    #1772
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (1774);

1773:

    #1773
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1774);

1774:

    #1774
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1775:

    #1775
    #instruction: LD   A,(2095)
    advance (13)
    A := M[2095];
    jump (1778);

1776:

    #1776
    #instruction: SUB  L
    let:16 a1 = addWithCarry(!false,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1777);

1777:

    #1777
    #instruction: *NOP
    advance (4)
    jump (1778);

1778:

    #1778
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1779);

1779:

    #1779
    #instruction: JP   Z,17AA
    if (FlagZ) {
      advance (10)
      jump (17AA);
    } else {
      advance (10)
      jump (177C);
    }

177A:

    #177A
    #instruction: XOR  D
    let:8 a1 = (D ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (177B);

177B:

    #177B
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (177C);

177C:

    #177C
    #instruction: LD   HL,1A11
    advance (10)
    H := 1A;
    L := 11;
    jump (177F);

177D:

    #177D
    #instruction: LD   DE,111A
    advance (10)
    D := 11;
    E := 1A;
    jump (1780);

177E:

    #177E
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (177F);

177F:

    #177F
    #instruction: LD   DE,1A21
    advance (10)
    D := 1A;
    E := 21;
    jump (1782);

1780:

    #1780
    #instruction: LD   HL,3A1A
    advance (10)
    H := 3A;
    L := 1A;
    jump (1783);

1781:

    #1781
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1782);

1782:

    #1782
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (1785);

1783:

    #1783
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1784);

1784:

    #1784
    #instruction: *NOP
    advance (4)
    jump (1785);

1785:

    #1785
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1786);

1786:

    #1786
    #instruction: JP   NC,178E
    if (!FlagCY) {
      advance (10)
      jump (178E);
    } else {
      advance (10)
      jump (1789);
    }

1787:

    #1787
    #instruction: ADC  (HL)
    let:16 a1 = addWithCarry(FlagCY,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1788);

1788:

    #1788
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (1789);

1789:

    #1789
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (178A);

178A:

    #178A
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (178B);

178B:

    #178B
    #instruction: JP   1785
    advance (10)
    jump (1785);

178C:

    #178C
    #instruction: ADD  L
    let:16 a1 = addWithCarry(false,L,A) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (178D);

178D:

    #178D
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (178E);

178E:

    #178E
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (178F);

178F:

    #178F
    #instruction: LD   (2097),A
    M[2097] := A;
    advance (13)
    jump (1792);

1790:

    #1790
    #instruction: SUB  A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1791);

1791:

    #1791
    #instruction: *NOP
    advance (4)
    jump (1792);

1792:

    #1792
    #instruction: LD   HL,2098
    advance (10)
    H := 20;
    L := 98;
    jump (1795);

1793:

    #1793
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1794);

1794:

    #1794
    #instruction: *NOP
    advance (4)
    jump (1795);

1795:

    #1795
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1796);

1796:

    #1796
    #instruction: AND  30
    let:8 a1 = (30 & A) in
    let:8 a2 = (30 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1798);

1797:

    #1797
    #instruction: *NOP
    advance (4)
    jump (1798);

1798:

    #1798
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (1799);

1799:

    #1799
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (179A);

179A:

    #179A
    #instruction: AND  0F
    let:8 a1 = (0F & A) in
    let:8 a2 = (0F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (179C);

179B:

    #179B
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (179C);

179C:

    #179C
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (179D);

179D:

    #179D
    #instruction: CP   10
    let:16 a1 = addWithCarry(!false,A,~10) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (179F);

179E:

    #179E
    #instruction: *NOP
    advance (4)
    jump (179F);

179F:

    #179F
    #instruction: JP   NZ,17A4
    if (!FlagZ) {
      advance (10)
      jump (17A4);
    } else {
      advance (10)
      jump (17A2);
    }

17A0:

    #17A0
    #instruction: AND  H
    let:8 a1 = (H & A) in
    let:8 a2 = (H | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (17A1);

17A1:

    #17A1
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (17A2);

17A2:

    #17A2
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (17A4);

17A3:

    #17A3
    #instruction: LD   BC,77B0
    advance (10)
    B := 77;
    C := B0;
    jump (17A6);

17A4:

    #17A4
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (17A5);

17A5:

    #17A5
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (17A6);

17A6:

    #17A6
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (17A7);

17A7:

    #17A7
    #instruction: LD   (2095),A
    M[2095] := A;
    advance (13)
    jump (17AA);

17A8:

    #17A8
    #instruction: SUB  L
    let:16 a1 = addWithCarry(!false,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17A9);

17A9:

    #17A9
    #instruction: *NOP
    advance (4)
    jump (17AA);

17AA:

    #17AA
    #instruction: LD   HL,2099
    advance (10)
    H := 20;
    L := 99;
    jump (17AD);

17AB:

    #17AB
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17AC);

17AC:

    #17AC
    #instruction: *NOP
    advance (4)
    jump (17AD);

17AD:

    #17AD
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17AE);

17AE:

    #17AE
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (17AF);
    }

17AF:

    #17AF
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (17B1);

17B0:

    #17B0
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := B1;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

17B1:

    #17B1
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

17B2:

    #17B2
    #instruction: CALL CY,0619
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 17;
      let:16 a2 = (-1 + a1) in
      M[a2] := B5;
      #return-to: 17B5
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0619);
    } else {
      advance (11)
      jump (17B5);
    }

17B3:

    #17B3
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (17B4);

17B4:

    #17B4
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (17B6);

17B5:

    #17B5
    #instruction: RST  5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := B6;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0028);

17B6:

    #17B6
    #instruction: LD   HL,2098
    advance (10)
    H := 20;
    L := 98;
    jump (17B9);

17B7:

    #17B7
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17B8);

17B8:

    #17B8
    #instruction: *NOP
    advance (4)
    jump (17B9);

17B9:

    #17B9
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (17BA);

17BA:

    #17BA
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (17BB);

17BB:

    #17BB
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (17BC);

17BC:

    #17BC
    #instruction: OUT  05
    sound_control(FleetMovement1,A[0]);
    sound_control(FleetMovement2,A[1]);
    sound_control(FleetMovement3,A[2]);
    sound_control(FleetMovement4,A[3]);
    sound_control(UfoHit,A[4]);
    advance (10)
    jump (17BE);

17BD:

    #17BD
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17BE);

17BE:

    #17BE
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

17BF:

    #17BF
    #instruction: NOP
    advance (4)
    jump (17C0);

17C0:

    #17C0
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (17C3);

17C1:

    #17C1
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (17C2);

17C2:

    #17C2
    #instruction: *NOP
    advance (4)
    jump (17C3);

17C3:

    #17C3
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (17C4);

17C4:

    #17C4
    #instruction: JP   NC,17CA
    if (!FlagCY) {
      advance (10)
      jump (17CA);
    } else {
      advance (10)
      jump (17C7);
    }

17C5:

    #17C5
    #instruction: JP   Z,DB17
    if (FlagZ) {
      advance (10)
      jump (DB17);
    } else {
      advance (10)
      jump (17C8);
    }

17C6:

    #17C6
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (17C7);

17C7:

    #17C7
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (17C9);

17C8:

    #17C8
    #instruction: LD   BC,DBC9
    advance (10)
    B := DB;
    C := C9;
    jump (17CB);

17C9:

    #17C9
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

17CA:

    #17CA
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
    jump (17CC);

17CB:

    #17CB
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (17CC);

17CC:

    #17CC
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

17CD:

    #17CD
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
    jump (17CF);

17CE:

    #17CE
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (17CF);

17CF:

    #17CF
    #instruction: AND  04
    let:8 a1 = (04 & A) in
    let:8 a2 = (04 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (17D1);

17D0:

    #17D0
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17D1);

17D1:

    #17D1
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (17D2);
    }

17D2:

    #17D2
    #instruction: LD   A,(209A)
    advance (13)
    A := M[209A];
    jump (17D5);

17D3:

    #17D3
    #instruction: SBC  D
    let:16 a1 = addWithCarry(!FlagCY,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17D4);

17D4:

    #17D4
    #instruction: *NOP
    advance (4)
    jump (17D5);

17D5:

    #17D5
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (17D6);

17D6:

    #17D6
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (17D7);
    }

17D7:

    #17D7
    #instruction: LD   SP,2400
    advance (10)
    SPH := 24;
    SPL := 00;
    jump (17DA);

17D8:

    #17D8
    #instruction: NOP
    advance (4)
    jump (17D9);

17D9:

    #17D9
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17DA);

17DA:

    #17DA
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (17DC);

17DB:

    #17DB
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17DC);

17DC:

    #17DC
    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := DF;
    #return-to: 17DF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (09D6);

17DD:

    #17DD
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17DF);

17DE:

    #17DE
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (17DF);

17DF:

    #17DF
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17E0);

17E0:

    #17E0
    #instruction: JP   NZ,17DC
    if (!FlagZ) {
      advance (10)
      jump (17DC);
    } else {
      advance (10)
      jump (17E3);
    }

17E1:

    #17E1
    #instruction: CALL CY,3E17
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 17;
      let:16 a2 = (-1 + a1) in
      M[a2] := E4;
      #return-to: 17E4
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3E17);
    } else {
      advance (11)
      jump (17E4);
    }

17E2:

    #17E2
    #instruction: RAL
    advance (4)
    A := updateBit((A << 01),0,FlagCY);
    FlagCY := A[7];
    jump (17E3);

17E3:

    #17E3
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (17E5);

17E4:

    #17E4
    #instruction: LD   BC,9A32
    advance (10)
    B := 9A;
    C := 32;
    jump (17E7);

17E5:

    #17E5
    #instruction: LD   (209A),A
    M[209A] := A;
    advance (13)
    jump (17E8);

17E6:

    #17E6
    #instruction: SBC  D
    let:16 a1 = addWithCarry(!FlagCY,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17E7);

17E7:

    #17E7
    #instruction: *NOP
    advance (4)
    jump (17E8);

17E8:

    #17E8
    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := EB;
    #return-to: 17EB
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D7);

17E9:

    #17E9
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := EA;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

17EA:

    #17EA
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (17EB);

17EB:

    #17EB
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (17EC);

17EC:

    #17EC
    #instruction: LD   DE,1CBC
    advance (10)
    D := 1C;
    E := BC;
    jump (17EF);

17ED:

    #17ED
    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17EE);

17EE:

    #17EE
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17EF);

17EF:

    #17EF
    #instruction: LD   HL,3016
    advance (10)
    H := 30;
    L := 16;
    jump (17F2);

17F0:

    #17F0
    #instruction: LD   D,30
    advance (7)
    D := 30;
    jump (17F2);

17F1:

    #17F1
    #instruction: *NOP
    advance (4)
    jump (17F2);

17F2:

    #17F2
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (17F4);

17F3:

    #17F3
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (17F4);

17F4:

    #17F4
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := F7;
    #return-to: 17F7
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

17F5:

    #17F5
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17F6);

17F6:

    #17F6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (17F7);

17F7:

    #17F7
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := FA;
    #return-to: 17FA
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

17F8:

    #17F8
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (17F9);

17F9:

    #17F9
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (17FA);

17FA:

    #17FA
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (17FB);

17FB:

    #17FB
    #instruction: LD   (209A),A
    M[209A] := A;
    advance (13)
    jump (17FE);

17FC:

    #17FC
    #instruction: SBC  D
    let:16 a1 = addWithCarry(!FlagCY,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (17FD);

17FD:

    #17FD
    #instruction: *NOP
    advance (4)
    jump (17FE);

17FE:

    #17FE
    #instruction: LD   (2093),A
    M[2093] := A;
    advance (13)
    jump (1801);

17FF:

    #17FF
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1800);

1800:

    #1800
    #instruction: *NOP
    advance (4)
    jump (1801);

1801:

    #1801
    #instruction: JP   16C9
    advance (10)
    jump (16C9);

1802:

    #1802
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1803:

    #1803
    #instruction: LD   D,21
    advance (7)
    D := 21;
    jump (1805);

1804:

    #1804
    #instruction: LD   HL,2084
    advance (10)
    H := 20;
    L := 84;
    jump (1807);

1805:

    #1805
    #instruction: ADD  H
    let:16 a1 = addWithCarry(false,H,A) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1806);

1806:

    #1806
    #instruction: *NOP
    advance (4)
    jump (1807);

1807:

    #1807
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1808);

1808:

    #1808
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1809);

1809:

    #1809
    #instruction: JP   Z,0707
    if (FlagZ) {
      advance (10)
      jump (0707);
    } else {
      advance (10)
      jump (180C);
    }

180A:

    #180A
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (180B);

180B:

    #180B
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (180C);

180C:

    #180C
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (180D);

180D:

    #180D
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (180E);

180E:

    #180E
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (180F);

180F:

    #180F
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1810);
    }

1810:

    #1810
    #instruction: LD   B,01
    advance (7)
    B := 01;
    jump (1812);

1811:

    #1811
    #instruction: LD   BC,FAC3
    advance (10)
    B := FA;
    C := C3;
    jump (1814);

1812:

    #1812
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

1813:

    #1813
    #instruction: JP   MI,2118
    if (FlagS) {
      advance (10)
      jump (2118);
    } else {
      advance (10)
      jump (1816);
    }

1814:

    #1814
    #instruction: *NOP
    advance (4)
    jump (1815);

1815:

    #1815
    #instruction: LD   HL,2810
    advance (10)
    H := 28;
    L := 10;
    jump (1818);

1816:

    #1816
    #instruction: *NOP
    advance (4)
    jump (1817);

1817:

    #1817
    #instruction: *NOP
    advance (4)
    jump (1818);

1818:

    #1818
    #instruction: LD   DE,1CA3
    advance (10)
    D := 1C;
    E := A3;
    jump (181B);

1819:

    #1819
    #instruction: AND  E
    let:8 a1 = (E & A) in
    let:8 a2 = (E | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (181A);

181A:

    #181A
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (181B);

181B:

    #181B
    #instruction: LD   C,15
    advance (7)
    C := 15;
    jump (181D);

181C:

    #181C
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (181D);

181D:

    #181D
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 20;
    #return-to: 1820
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08F3);

181E:

    #181E
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (181F);

181F:

    #181F
    #instruction: *NOP
    advance (4)
    jump (1820);

1820:

    #1820
    #instruction: LD   A,0A
    advance (7)
    A := 0A;
    jump (1822);

1821:

    #1821
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1822);

1822:

    #1822
    #instruction: LD   (206C),A
    M[206C] := A;
    advance (13)
    jump (1825);

1823:

    #1823
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (1824);

1824:

    #1824
    #instruction: *NOP
    advance (4)
    jump (1825);

1825:

    #1825
    #instruction: LD   BC,1DBE
    advance (10)
    B := 1D;
    C := BE;
    jump (1828);

1826:

    #1826
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1827);

1827:

    #1827
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1828);

1828:

    #1828
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2B;
    #return-to: 182B
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1856);

1829:

    #1829
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (182A);

182A:

    #182A
    #instruction: *NOP
    advance (4)
    jump (182B);

182B:

    #182B
    #instruction: JP   CY,1837
    if (FlagCY) {
      advance (10)
      jump (1837);
    } else {
      advance (10)
      jump (182E);
    }

182C:

    #182C
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (182D);

182D:

    #182D
    #instruction: *NOP
    advance (4)
    jump (182E);

182E:

    #182E
    #instruction: CALL 1844
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 31;
    #return-to: 1831
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1844);

182F:

    #182F
    #instruction: LD   B,H
    advance (5)
    B := H;
    jump (1830);

1830:

    #1830
    #instruction: *NOP
    advance (4)
    jump (1831);

1831:

    #1831
    #instruction: JP   1828
    advance (10)
    jump (1828);

1832:

    #1832
    #instruction: *NOP
    advance (4)
    jump (1833);

1833:

    #1833
    #instruction: *NOP
    advance (4)
    jump (1834);

1834:

    #1834
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 37;
    #return-to: 1837
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0AB1);

1835:

    #1835
    #instruction: OR   C
    let:8 a1 = (C | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1836);

1836:

    #1836
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1837);

1837:

    #1837
    #instruction: LD   BC,1DCF
    advance (10)
    B := 1D;
    C := CF;
    jump (183A);

1838:

    #1838
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

1839:

    #1839
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (183A);

183A:

    #183A
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3D;
    #return-to: 183D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1856);

183B:

    #183B
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (183C);

183C:

    #183C
    #instruction: *NOP
    advance (4)
    jump (183D);

183D:

    #183D
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (183E);
    }

183E:

    #183E
    #instruction: CALL 184C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 41;
    #return-to: 1841
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (184C);

183F:

    #183F
    #instruction: LD   C,H
    advance (5)
    C := H;
    jump (1840);

1840:

    #1840
    #instruction: *NOP
    advance (4)
    jump (1841);

1841:

    #1841
    #instruction: JP   183A
    advance (10)
    jump (183A);

1842:

    #1842
    #instruction: LD   A,(C518)
    advance (13)
    A := M[C518];
    jump (1845);

1843:

    #1843
    #instruction: *NOP
    advance (4)
    jump (1844);

1844:

    #1844
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1845);

1845:

    #1845
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (1847);

1846:

    #1846
    #instruction: *NOP
    advance (4)
    jump (1847);

1847:

    #1847
    #instruction: CALL 1439
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4A;
    #return-to: 184A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1439);

1848:

    #1848
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1849);

1849:

    #1849
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (184A);

184A:

    #184A
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (184B);

184B:

    #184B
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

184C:

    #184C
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (184D);

184D:

    #184D
    #instruction: LD   A,(206C)
    advance (13)
    A := M[206C];
    jump (1850);

184E:

    #184E
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (184F);

184F:

    #184F
    #instruction: *NOP
    advance (4)
    jump (1850);

1850:

    #1850
    #instruction: LD   C,A
    advance (5)
    C := A;
    jump (1851);

1851:

    #1851
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 54;
    #return-to: 1854
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0A93);

1852:

    #1852
    #instruction: SUB  E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1853);

1853:

    #1853
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1854);

1854:

    #1854
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1855);

1855:

    #1855
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1856:

    #1856
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1857);

1857:

    #1857
    #instruction: CP   FF
    let:16 a1 = addWithCarry(!false,A,~FF) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~FF & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1859);

1858:

    #1858
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 59;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1859:

    #1859
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (185A);

185A:

    #185A
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (185B);
    }

185B:

    #185B
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (185C);

185C:

    #185C
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (185D);

185D:

    #185D
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (185E);

185E:

    #185E
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (185F);

185F:

    #185F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1860);

1860:

    #1860
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1861);

1861:

    #1861
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (1862);

1862:

    #1862
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1863);

1863:

    #1863
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1864);

1864:

    #1864
    #instruction: LD   D,A
    advance (5)
    D := A;
    jump (1865);

1865:

    #1865
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1866);

1866:

    #1866
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1867);

1867:

    #1867
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1868:

    #1868
    #instruction: LD   HL,20C2
    advance (10)
    H := 20;
    L := C2;
    jump (186B);

1869:

    #1869
    #instruction: JP   NZ,3420
    if (!FlagZ) {
      advance (10)
      jump (3420);
    } else {
      advance (10)
      jump (186C);
    }

186A:

    #186A
    #instruction: *NOP
    advance (4)
    jump (186B);

186B:

    #186B
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (186C);

186C:

    #186C
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (186D);

186D:

    #186D
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (186E);

186E:

    #186E
    #instruction: CALL 01D9
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 1871
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01D9);

186F:

    #186F
    #instruction: *RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1870:

    #1870
    #instruction: LD   BC,3A47
    advance (10)
    B := 3A;
    C := 47;
    jump (1873);

1871:

    #1871
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (1872);

1872:

    #1872
    #instruction: LD   A,(20CA)
    advance (13)
    A := M[20CA];
    jump (1875);

1873:

    #1873
    #instruction: JP   Z,B820
    if (FlagZ) {
      advance (10)
      jump (B820);
    } else {
      advance (10)
      jump (1876);
    }

1874:

    #1874
    #instruction: *NOP
    advance (4)
    jump (1875);

1875:

    #1875
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1876);

1876:

    #1876
    #instruction: JP   Z,1898
    if (FlagZ) {
      advance (10)
      jump (1898);
    } else {
      advance (10)
      jump (1879);
    }

1877:

    #1877
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1878);

1878:

    #1878
    #instruction: *NOP
    advance (4)
    jump (1879);

1879:

    #1879
    #instruction: LD   A,(20C2)
    advance (13)
    A := M[20C2];
    jump (187C);

187A:

    #187A
    #instruction: JP   NZ,E620
    if (!FlagZ) {
      advance (10)
      jump (E620);
    } else {
      advance (10)
      jump (187D);
    }

187B:

    #187B
    #instruction: *NOP
    advance (4)
    jump (187C);

187C:

    #187C
    #instruction: AND  04
    let:8 a1 = (04 & A) in
    let:8 a2 = (04 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (187E);

187D:

    #187D
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (187E);

187E:

    #187E
    #instruction: LD   HL,(20CC)
    advance (16)
    H := M[20CD];
    L := M[20CC];
    jump (1881);

187F:

    #187F
    #instruction: CALL Z,C220
    if (FlagZ) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 18;
      let:16 a2 = (-1 + a1) in
      M[a2] := 82;
      #return-to: 1882
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C220);
    } else {
      advance (11)
      jump (1882);
    }

1880:

    #1880
    #instruction: *NOP
    advance (4)
    jump (1881);

1881:

    #1881
    #instruction: JP   NZ,1888
    if (!FlagZ) {
      advance (10)
      jump (1888);
    } else {
      advance (10)
      jump (1884);
    }

1882:

    #1882
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1883);

1883:

    #1883
    #instruction: *NOP
    advance (4)
    jump (1884);

1884:

    #1884
    #instruction: LD   DE,0030
    advance (10)
    D := 00;
    E := 30;
    jump (1887);

1885:

    #1885
    #instruction: *NOP
    advance (4)
    jump (1886);

1886:

    #1886
    #instruction: NOP
    advance (4)
    jump (1887);

1887:

    #1887
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1888);

1888:

    #1888
    #instruction: LD   (20C7),HL
    M[20C7] := L;
    M[20C8] := H;
    advance (16)
    jump (188B);

1889:

    #1889
    #instruction: RST  0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 8A;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0000);

188A:

    #188A
    #instruction: *NOP
    advance (4)
    jump (188B);

188B:

    #188B
    #instruction: LD   HL,20C5
    advance (10)
    H := 20;
    L := C5;
    jump (188E);

188C:

    #188C
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (188D);

188D:

    #188D
    #instruction: *NOP
    advance (4)
    jump (188E);

188E:

    #188E
    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 91;
    #return-to: 1891
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A3B);

188F:

    #188F
    #instruction: DEC  SP
    let:16 a1 = (-1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (1890);

1890:

    #1890
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1891);

1891:

    #1891
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (1892);

1892:

    #1892
    #instruction: JP   15D3
    advance (10)
    jump (15D3);

1893:

    #1893
    #instruction: OUT  15
    unknown_output(21);
    advance (10)
    jump (1895);

1894:

    #1894
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1895);

1895:

    #1895
    #instruction: NOP
    advance (4)
    jump (1896);

1896:

    #1896
    #instruction: NOP
    advance (4)
    jump (1897);

1897:

    #1897
    #instruction: NOP
    advance (4)
    jump (1898);

1898:

    #1898
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (189A);

1899:

    #1899
    #instruction: LD   BC,CB32
    advance (10)
    B := CB;
    C := 32;
    jump (189C);

189A:

    #189A
    #instruction: LD   (20CB),A
    M[20CB] := A;
    advance (13)
    jump (189D);

189B:

    #189B
    #instruction: *JP  C920
    advance (10)
    jump (C920);

189C:

    #189C
    #instruction: *NOP
    advance (4)
    jump (189D);

189D:

    #189D
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

189E:

    #189E
    #instruction: LD   HL,2050
    advance (10)
    H := 20;
    L := 50;
    jump (18A1);

189F:

    #189F
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (18A0);

18A0:

    #18A0
    #instruction: *NOP
    advance (4)
    jump (18A1);

18A1:

    #18A1
    #instruction: LD   DE,1BC0
    advance (10)
    D := 1B;
    E := C0;
    jump (18A4);

18A2:

    #18A2
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (18A3);
    }

18A3:

    #18A3
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (18A4);

18A4:

    #18A4
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (18A6);

18A5:

    #18A5
    #instruction: *NOP
    advance (4)
    jump (18A6);

18A6:

    #18A6
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := A9;
    #return-to: 18A9
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A32);

18A7:

    #18A7
    #instruction: LD   (3E1A),A
    M[3E1A] := A;
    advance (13)
    jump (18AA);

18A8:

    #18A8
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (18A9);

18A9:

    #18A9
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (18AB);

18AA:

    #18AA
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (18AB);

18AB:

    #18AB
    #instruction: LD   (2080),A
    M[2080] := A;
    advance (13)
    jump (18AE);

18AC:

    #18AC
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (18AD);

18AD:

    #18AD
    #instruction: *NOP
    advance (4)
    jump (18AE);

18AE:

    #18AE
    #instruction: LD   A,FF
    advance (7)
    A := FF;
    jump (18B0);

18AF:

    #18AF
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := B0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

18B0:

    #18B0
    #instruction: LD   (207E),A
    M[207E] := A;
    advance (13)
    jump (18B3);

18B1:

    #18B1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (18B2);

18B2:

    #18B2
    #instruction: *NOP
    advance (4)
    jump (18B3);

18B3:

    #18B3
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (18B5);

18B4:

    #18B4
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (18B5);

18B5:

    #18B5
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (18B8);

18B6:

    #18B6
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (18B7);

18B7:

    #18B7
    #instruction: *NOP
    advance (4)
    jump (18B8);

18B8:

    #18B8
    #instruction: LD   A,(2055)
    advance (13)
    A := M[2055];
    jump (18BB);

18B9:

    #18B9
    #instruction: LD   D,L
    advance (5)
    D := L;
    jump (18BA);

18BA:

    #18BA
    #instruction: *NOP
    advance (4)
    jump (18BB);

18BB:

    #18BB
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (18BD);

18BC:

    #18BC
    #instruction: LD   BC,B8CA
    advance (10)
    B := B8;
    C := CA;
    jump (18BF);

18BD:

    #18BD
    #instruction: JP   Z,18B8
    if (FlagZ) {
      advance (10)
      jump (18B8);
    } else {
      advance (10)
      jump (18C0);
    }

18BE:

    #18BE
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (18BF);

18BF:

    #18BF
    #instruction: *NOP
    advance (4)
    jump (18C0);

18C0:

    #18C0
    #instruction: LD   A,(2055)
    advance (13)
    A := M[2055];
    jump (18C3);

18C1:

    #18C1
    #instruction: LD   D,L
    advance (5)
    D := L;
    jump (18C2);

18C2:

    #18C2
    #instruction: *NOP
    advance (4)
    jump (18C3);

18C3:

    #18C3
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (18C5);

18C4:

    #18C4
    #instruction: LD   BC,C0C2
    advance (10)
    B := C0;
    C := C2;
    jump (18C7);

18C5:

    #18C5
    #instruction: JP   NZ,18C0
    if (!FlagZ) {
      advance (10)
      jump (18C0);
    } else {
      advance (10)
      jump (18C8);
    }

18C6:

    #18C6
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (18C7);
    }

18C7:

    #18C7
    #instruction: *NOP
    advance (4)
    jump (18C8);

18C8:

    #18C8
    #instruction: LD   HL,3311
    advance (10)
    H := 33;
    L := 11;
    jump (18CB);

18C9:

    #18C9
    #instruction: LD   DE,3E33
    advance (10)
    D := 3E;
    E := 33;
    jump (18CC);

18CA:

    #18CA
    #instruction: INC  SP
    let:16 a1 = (1 + (SPH,SPL)) in
    advance (5)
    SPH := a1[15:8];
    SPL := a1[7:0];
    jump (18CB);

18CB:

    #18CB
    #instruction: LD   A,26
    advance (7)
    A := 26;
    jump (18CD);

18CC:

    #18CC
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (18CE);

18CD:

    #18CD
    #instruction: NOP
    advance (4)
    jump (18CE);

18CE:

    #18CE
    #instruction: CALL 08FF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := D1;
    #return-to: 18D1
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (08FF);

18CF:

    #18CF
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := D0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

18D0:

    #18D0
    #instruction: *NOP
    advance (4)
    jump (18D1);

18D1:

    #18D1
    #instruction: JP   0AB6
    advance (10)
    jump (0AB6);

18D2:

    #18D2
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (18D3);

18D3:

    #18D3
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (18D4);

18D4:

    #18D4
    #instruction: LD   SP,2400
    advance (10)
    SPH := 24;
    SPL := 00;
    jump (18D7);

18D5:

    #18D5
    #instruction: NOP
    advance (4)
    jump (18D6);

18D6:

    #18D6
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (18D7);

18D7:

    #18D7
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (18D9);

18D8:

    #18D8
    #instruction: NOP
    advance (4)
    jump (18D9);

18D9:

    #18D9
    #instruction: CALL 01E6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := DC;
    #return-to: 18DC
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (01E6);

18DA:

    #18DA
    #instruction: AND  01
    let:8 a1 = (01 & A) in
    let:8 a2 = (01 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (18DC);

18DB:

    #18DB
    #instruction: LD   BC,56CD
    advance (10)
    B := 56;
    C := CD;
    jump (18DE);

18DC:

    #18DC
    #instruction: CALL 1956
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := DF;
    #return-to: 18DF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1956);

18DD:

    #18DD
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (18DE);

18DE:

    #18DE
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (18DF);

18DF:

    #18DF
    #instruction: LD   A,08
    advance (7)
    A := 08;
    jump (18E1);

18E0:

    #18E0
    #instruction: *NOP
    advance (4)
    jump (18E1);

18E1:

    #18E1
    #instruction: LD   (20CF),A
    M[20CF] := A;
    advance (13)
    jump (18E4);

18E2:

    #18E2
    #instruction: RST  1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := E3;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0008);

18E3:

    #18E3
    #instruction: *NOP
    advance (4)
    jump (18E4);

18E4:

    #18E4
    #instruction: JP   0AEA
    advance (10)
    jump (0AEA);

18E5:

    #18E5
    #instruction: JP   PE,3A0A
    if (FlagP) {
      advance (10)
      jump (3A0A);
    } else {
      advance (10)
      jump (18E8);
    }

18E6:

    #18E6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (18E7);

18E7:

    #18E7
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (18EA);

18E8:

    #18E8
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (18E9);

18E9:

    #18E9
    #instruction: *NOP
    advance (4)
    jump (18EA);

18EA:

    #18EA
    #instruction: LD   HL,20E7
    advance (10)
    H := 20;
    L := E7;
    jump (18ED);

18EB:

    #18EB
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := EC;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

18EC:

    #18EC
    #instruction: *NOP
    advance (4)
    jump (18ED);

18ED:

    #18ED
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (18EE);

18EE:

    #18EE
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (18EF);
    }

18EF:

    #18EF
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (18F0);

18F0:

    #18F0
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

18F1:

    #18F1
    #instruction: LD   B,02
    advance (7)
    B := 02;
    jump (18F3);

18F2:

    #18F2
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (18F3);

18F3:

    #18F3
    #instruction: LD   A,(2082)
    advance (13)
    A := M[2082];
    jump (18F6);

18F4:

    #18F4
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (18F5);

18F5:

    #18F5
    #instruction: *NOP
    advance (4)
    jump (18F6);

18F6:

    #18F6
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (18F7);

18F7:

    #18F7
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (18F8);
    }

18F8:

    #18F8
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (18F9);

18F9:

    #18F9
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

18FA:

    #18FA
    #instruction: LD   A,(2094)
    advance (13)
    A := M[2094];
    jump (18FD);

18FB:

    #18FB
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (18FC);

18FC:

    #18FC
    #instruction: *NOP
    advance (4)
    jump (18FD);

18FD:

    #18FD
    #instruction: OR   B
    let:8 a1 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (18FE);

18FE:

    #18FE
    #instruction: LD   (2094),A
    M[2094] := A;
    advance (13)
    jump (1901);

18FF:

    #18FF
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1900);

1900:

    #1900
    #instruction: *NOP
    advance (4)
    jump (1901);

1901:

    #1901
    #instruction: OUT  03
    sound_control(Ufo,A[0]);
    sound_control(Shot,A[1]);
    sound_control(PlayerDie,A[2]);
    sound_control(InvaderDie,A[3]);
    sound_control(ExtraLife,A[4]);
    advance (10)
    jump (1903);

1902:

    #1902
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1903);

1903:

    #1903
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1904:

    #1904
    #instruction: LD   HL,2200
    advance (10)
    H := 22;
    L := 00;
    jump (1907);

1905:

    #1905
    #instruction: NOP
    advance (4)
    jump (1906);

1906:

    #1906
    #instruction: LD   (C3C3),HL
    M[C3C3] := L;
    M[C3C4] := H;
    advance (16)
    jump (1909);

1907:

    #1907
    #instruction: JP   01C3
    advance (10)
    jump (01C3);

1908:

    #1908
    #instruction: JP   CD01
    advance (10)
    jump (CD01);

1909:

    #1909
    #instruction: LD   BC,D8CD
    advance (10)
    B := D8;
    C := CD;
    jump (190C);

190A:

    #190A
    #instruction: CALL 14D8
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0D;
    #return-to: 190D
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14D8);

190B:

    #190B
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (190C);
    }

190C:

    #190C
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (190D);

190D:

    #190D
    #instruction: JP   1597
    advance (10)
    jump (1597);

190E:

    #190E
    #instruction: SUB  A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (190F);

190F:

    #190F
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1910);

1910:

    #1910
    #instruction: LD   HL,20E7
    advance (10)
    H := 20;
    L := E7;
    jump (1913);

1911:

    #1911
    #instruction: RST  4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 12;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0020);

1912:

    #1912
    #instruction: *NOP
    advance (4)
    jump (1913);

1913:

    #1913
    #instruction: LD   A,(2067)
    advance (13)
    A := M[2067];
    jump (1916);

1914:

    #1914
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1915);

1915:

    #1915
    #instruction: *NOP
    advance (4)
    jump (1916);

1916:

    #1916
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1917);

1917:

    #1917
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1918);
    }

1918:

    #1918
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1919);

1919:

    #1919
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

191A:

    #191A
    #instruction: LD   C,1C
    advance (7)
    C := 1C;
    jump (191C);

191B:

    #191B
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (191C);

191C:

    #191C
    #instruction: LD   HL,241E
    advance (10)
    H := 24;
    L := 1E;
    jump (191F);

191D:

    #191D
    #instruction: LD   E,24
    advance (7)
    E := 24;
    jump (191F);

191E:

    #191E
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (191F);

191F:

    #191F
    #instruction: LD   DE,1AE4
    advance (10)
    D := 1A;
    E := E4;
    jump (1922);

1920:

    #1920
    #instruction: CALL PO,C31A
    if (!FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 19;
      let:16 a2 = (-1 + a1) in
      M[a2] := 23;
      #return-to: 1923
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C31A);
    } else {
      advance (11)
      jump (1923);
    }

1921:

    #1921
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1922);

1922:

    #1922
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

1923:

    #1923
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (1924);

1924:

    #1924
    #instruction: *NOP
    advance (4)
    jump (1925);

1925:

    #1925
    #instruction: LD   HL,20F8
    advance (10)
    H := 20;
    L := F8;
    jump (1928);

1926:

    #1926
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1927);
    }

1927:

    #1927
    #instruction: *NOP
    advance (4)
    jump (1928);

1928:

    #1928
    #instruction: JP   1931
    advance (10)
    jump (1931);

1929:

    #1929
    #instruction: LD   SP,2119
    advance (10)
    SPH := 21;
    SPL := 19;
    jump (192C);

192A:

    #192A
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (192B);

192B:

    #192B
    #instruction: LD   HL,20FC
    advance (10)
    H := 20;
    L := FC;
    jump (192E);

192C:

    #192C
    #instruction: CALL MI,C320
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 19;
      let:16 a2 = (-1 + a1) in
      M[a2] := 2F;
      #return-to: 192F
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C320);
    } else {
      advance (11)
      jump (192F);
    }

192D:

    #192D
    #instruction: *NOP
    advance (4)
    jump (192E);

192E:

    #192E
    #instruction: JP   1931
    advance (10)
    jump (1931);

192F:

    #192F
    #instruction: LD   SP,5E19
    advance (10)
    SPH := 5E;
    SPL := 19;
    jump (1932);

1930:

    #1930
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1931);

1931:

    #1931
    #instruction: LD   E,(HL)
    advance (7)
    E := M[(H,L)];
    jump (1932);

1932:

    #1932
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1933);

1933:

    #1933
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (1934);

1934:

    #1934
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1935);

1935:

    #1935
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1936);

1936:

    #1936
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1937);

1937:

    #1937
    #instruction: LD   H,(HL)
    advance (7)
    H := M[(H,L)];
    jump (1938);

1938:

    #1938
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (1939);

1939:

    #1939
    #instruction: JP   09AD
    advance (10)
    jump (09AD);

193A:

    #193A
    #instruction: XOR  L
    let:8 a1 = (L ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (193B);

193B:

    #193B
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (193C);

193C:

    #193C
    #instruction: LD   C,07
    advance (7)
    C := 07;
    jump (193E);

193D:

    #193D
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (193E);

193E:

    #193E
    #instruction: LD   HL,3501
    advance (10)
    H := 35;
    L := 01;
    jump (1941);

193F:

    #193F
    #instruction: LD   BC,1135
    advance (10)
    B := 11;
    C := 35;
    jump (1942);

1940:

    #1940
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1941);

1941:

    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    D := 1F;
    E := A9;
    jump (1944);

1942:

    #1942
    #instruction: XOR  C
    let:8 a1 = (C ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1943);

1943:

    #1943
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1944);

1944:

    #1944
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

1945:

    #1945
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (1946);

1946:

    #1946
    #instruction: *NOP
    advance (4)
    jump (1947);

1947:

    #1947
    #instruction: LD   A,(20EB)
    advance (13)
    A := M[20EB];
    jump (194A);

1948:

    #1948
    #instruction: EX   DE,HL
    advance (4)
    D := H;
    E := L;
    H := D;
    L := E;
    jump (1949);

1949:

    #1949
    #instruction: *NOP
    advance (4)
    jump (194A);

194A:

    #194A
    #instruction: LD   HL,3C01
    advance (10)
    H := 3C;
    L := 01;
    jump (194D);

194B:

    #194B
    #instruction: LD   BC,C33C
    advance (10)
    B := C3;
    C := 3C;
    jump (194E);

194C:

    #194C
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (194D);

194D:

    #194D
    #instruction: JP   09B2
    advance (10)
    jump (09B2);

194E:

    #194E
    #instruction: OR   D
    let:8 a1 = (D | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (194F);

194F:

    #194F
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1950);

1950:

    #1950
    #instruction: LD   HL,20F4
    advance (10)
    H := 20;
    L := F4;
    jump (1953);

1951:

    #1951
    #instruction: CALL P,C320
    if (!FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 19;
      let:16 a2 = (-1 + a1) in
      M[a2] := 54;
      #return-to: 1954
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C320);
    } else {
      advance (11)
      jump (1954);
    }

1952:

    #1952
    #instruction: *NOP
    advance (4)
    jump (1953);

1953:

    #1953
    #instruction: JP   1931
    advance (10)
    jump (1931);

1954:

    #1954
    #instruction: LD   SP,CD19
    advance (10)
    SPH := CD;
    SPL := 19;
    jump (1957);

1955:

    #1955
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1956);

1956:

    #1956
    #instruction: CALL 1A5C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 59;
    #return-to: 1959
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A5C);

1957:

    #1957
    #instruction: LD   E,H
    advance (5)
    E := H;
    jump (1958);

1958:

    #1958
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1959);

1959:

    #1959
    #instruction: CALL 191A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5C;
    #return-to: 195C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (191A);

195A:

    #195A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (195B);

195B:

    #195B
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (195C);

195C:

    #195C
    #instruction: CALL 1925
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5F;
    #return-to: 195F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1925);

195D:

    #195D
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (195E);

195E:

    #195E
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (195F);

195F:

    #195F
    #instruction: CALL 192B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 62;
    #return-to: 1962
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (192B);

1960:

    #1960
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1961);

1961:

    #1961
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1962);

1962:

    #1962
    #instruction: CALL 1950
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 65;
    #return-to: 1965
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1950);

1963:

    #1963
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1964);

1964:

    #1964
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1965);

1965:

    #1965
    #instruction: CALL 193C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 68;
    #return-to: 1968
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (193C);

1966:

    #1966
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1967);

1967:

    #1967
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1968);

1968:

    #1968
    #instruction: JP   1947
    advance (10)
    jump (1947);

1969:

    #1969
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (196A);

196A:

    #196A
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (196B);

196B:

    #196B
    #instruction: CALL 19DC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6E;
    #return-to: 196E
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19DC);

196C:

    #196C
    #instruction: CALL CY,C319
    if (FlagCY) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 19;
      let:16 a2 = (-1 + a1) in
      M[a2] := 6F;
      #return-to: 196F
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (C319);
    } else {
      advance (11)
      jump (196F);
    }

196D:

    #196D
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (196E);

196E:

    #196E
    #instruction: JP   1671
    advance (10)
    jump (1671);

196F:

    #196F
    #instruction: LD   (HL),C
    M[(H,L)] := C;
    advance (7)
    jump (1970);

1970:

    #1970
    #instruction: LD   D,3E
    advance (7)
    D := 3E;
    jump (1972);

1971:

    #1971
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (1973);

1972:

    #1972
    #instruction: LD   BC,6D32
    advance (10)
    B := 6D;
    C := 32;
    jump (1975);

1973:

    #1973
    #instruction: LD   (206D),A
    M[206D] := A;
    advance (13)
    jump (1976);

1974:

    #1974
    #instruction: LD   L,L
    advance (5)
    jump (1975);

1975:

    #1975
    #instruction: *NOP
    advance (4)
    jump (1976);

1976:

    #1976
    #instruction: JP   16E6
    advance (10)
    jump (16E6);

1977:

    #1977
    #instruction: AND  16
    let:8 a1 = (16 & A) in
    let:8 a2 = (16 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1979);

1978:

    #1978
    #instruction: LD   D,CD
    advance (7)
    D := CD;
    jump (197A);

1979:

    #1979
    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7C;
    #return-to: 197C
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19D7);

197A:

    #197A
    #instruction: RST  2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0010);

197B:

    #197B
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (197C);

197C:

    #197C
    #instruction: CALL 1947
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7F;
    #return-to: 197F
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1947);

197D:

    #197D
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (197E);

197E:

    #197E
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (197F);

197F:

    #197F
    #instruction: JP   193C
    advance (10)
    jump (193C);

1980:

    #1980
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1981);

1981:

    #1981
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1982);

1982:

    #1982
    #instruction: LD   (20C1),A
    M[20C1] := A;
    advance (13)
    jump (1985);

1983:

    #1983
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1984);

1984:

    #1984
    #instruction: *NOP
    advance (4)
    jump (1985);

1985:

    #1985
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1986:

    #1986
    #instruction: ADC  E
    let:16 a1 = addWithCarry(FlagCY,E,A) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1987);

1987:

    #1987
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1988);

1988:

    #1988
    #instruction: JP   09D6
    advance (10)
    jump (09D6);

1989:

    #1989
    #instruction: SUB  09
    let:16 a1 = addWithCarry(!false,A,~09) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~09 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (198B);

198A:

    #198A
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (198B);

198B:

    #198B
    #instruction: LD   HL,2803
    advance (10)
    H := 28;
    L := 03;
    jump (198E);

198C:

    #198C
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (198D);

198D:

    #198D
    #instruction: *NOP
    advance (4)
    jump (198E);

198E:

    #198E
    #instruction: LD   DE,19BE
    advance (10)
    D := 19;
    E := BE;
    jump (1991);

198F:

    #198F
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1990);

1990:

    #1990
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1991);

1991:

    #1991
    #instruction: LD   C,13
    advance (7)
    C := 13;
    jump (1993);

1992:

    #1992
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1993);

1993:

    #1993
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

1994:

    #1994
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (1995);

1995:

    #1995
    #instruction: *NOP
    advance (4)
    jump (1996);

1996:

    #1996
    #instruction: NOP
    advance (4)
    jump (1997);

1997:

    #1997
    #instruction: NOP
    advance (4)
    jump (1998);

1998:

    #1998
    #instruction: NOP
    advance (4)
    jump (1999);

1999:

    #1999
    #instruction: NOP
    advance (4)
    jump (199A);

199A:

    #199A
    #instruction: LD   A,(201E)
    advance (13)
    A := M[201E];
    jump (199D);

199B:

    #199B
    #instruction: LD   E,20
    advance (7)
    E := 20;
    jump (199D);

199C:

    #199C
    #instruction: *NOP
    advance (4)
    jump (199D);

199D:

    #199D
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (199E);

199E:

    #199E
    #instruction: JP   NZ,19AC
    if (!FlagZ) {
      advance (10)
      jump (19AC);
    } else {
      advance (10)
      jump (19A1);
    }

199F:

    #199F
    #instruction: XOR  H
    let:8 a1 = (H ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (19A0);

19A0:

    #19A0
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19A1);

19A1:

    #19A1
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (19A3);

19A2:

    #19A2
    #instruction: LD   BC,76E6
    advance (10)
    B := 76;
    C := E6;
    jump (19A5);

19A3:

    #19A3
    #instruction: AND  76
    let:8 a1 = (76 & A) in
    let:8 a2 = (76 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (19A5);

19A4:

    #19A4
    #instruction: HLT
    advance (7)
    jump (19A4);

19A5:

    #19A5
    #instruction: SUB  72
    let:16 a1 = addWithCarry(!false,A,~72) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~72 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (19A7);

19A6:

    #19A6
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (19A7);

19A7:

    #19A7
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (19A8);
    }

19A8:

    #19A8
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19A9);

19A9:

    #19A9
    #instruction: LD   (201E),A
    M[201E] := A;
    advance (13)
    jump (19AC);

19AA:

    #19AA
    #instruction: LD   E,20
    advance (7)
    E := 20;
    jump (19AC);

19AB:

    #19AB
    #instruction: *NOP
    advance (4)
    jump (19AC);

19AC:

    #19AC
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
    jump (19AE);

19AD:

    #19AD
    #instruction: LD   BC,76E6
    advance (10)
    B := 76;
    C := E6;
    jump (19B0);

19AE:

    #19AE
    #instruction: AND  76
    let:8 a1 = (76 & A) in
    let:8 a2 = (76 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (19B0);

19AF:

    #19AF
    #instruction: HLT
    advance (7)
    jump (19AF);

19B0:

    #19B0
    #instruction: CP   34
    let:16 a1 = addWithCarry(!false,A,~34) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~34 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (19B2);

19B1:

    #19B1
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19B2);

19B2:

    #19B2
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (19B3);
    }

19B3:

    #19B3
    #instruction: LD   HL,2E1B
    advance (10)
    H := 2E;
    L := 1B;
    jump (19B6);

19B4:

    #19B4
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (19B5);

19B5:

    #19B5
    #instruction: LD   L,11
    advance (7)
    L := 11;
    jump (19B7);

19B6:

    #19B6
    #instruction: LD   DE,0BF7
    advance (10)
    D := 0B;
    E := F7;
    jump (19B9);

19B7:

    #19B7
    #instruction: RST  6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := B8;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0030);

19B8:

    #19B8
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (19B9);

19B9:

    #19B9
    #instruction: LD   C,09
    advance (7)
    C := 09;
    jump (19BB);

19BA:

    #19BA
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19BB);

19BB:

    #19BB
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

19BC:

    #19BC
    #instruction: DI
    disable_interrupts()
    advance (4)
    jump (19BD);

19BD:

    #19BD
    #instruction: *NOP
    advance (4)
    jump (19BE);

19BE:

    #19BE
    #instruction: *NOP
    advance (4)
    jump (19BF);

19BF:

    #19BF
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (19C0);

19C0:

    #19C0
    #instruction: NOP
    advance (4)
    jump (19C1);

19C1:

    #19C1
    #instruction: *NOP
    advance (4)
    jump (19C2);

19C2:

    #19C2
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (19C3);

19C3:

    #19C3
    #instruction: LD   C,26
    advance (7)
    C := 26;
    jump (19C5);

19C4:

    #19C4
    #instruction: LD   H,02
    advance (7)
    H := 02;
    jump (19C6);

19C5:

    #19C5
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (19C6);

19C6:

    #19C6
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (19C8);

19C7:

    #19C7
    #instruction: LD   DE,0E0F
    advance (10)
    D := 0E;
    E := 0F;
    jump (19CA);

19C8:

    #19C8
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (19C9);

19C9:

    #19C9
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (19CB);

19CA:

    #19CA
    #instruction: LD   DE,1300
    advance (10)
    D := 13;
    E := 00;
    jump (19CD);

19CB:

    #19CB
    #instruction: NOP
    advance (4)
    jump (19CC);

19CC:

    #19CC
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (19CD);

19CD:

    #19CD
    #instruction: *NOP
    advance (4)
    jump (19CE);

19CE:

    #19CE
    #instruction: LD   C,0D
    advance (7)
    C := 0D;
    jump (19D0);

19CF:

    #19CF
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19D0);

19D0:

    #19D0
    #instruction: *NOP
    advance (4)
    jump (19D1);

19D1:

    #19D1
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (19D3);

19D2:

    #19D2
    #instruction: LD   BC,E932
    advance (10)
    B := E9;
    C := 32;
    jump (19D5);

19D3:

    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := A;
    advance (13)
    jump (19D6);

19D4:

    #19D4
    #instruction: JP   (HL)
    advance (5)
    jump ((H,L));

19D5:

    #19D5
    #instruction: *NOP
    advance (4)
    jump (19D6);

19D6:

    #19D6
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

19D7:

    #19D7
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (19D8);

19D8:

    #19D8
    #instruction: JP   19D3
    advance (10)
    jump (19D3);

19D9:

    #19D9
    #instruction: OUT  19
    unknown_output(25);
    advance (10)
    jump (19DB);

19DA:

    #19DA
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19DB);

19DB:

    #19DB
    #instruction: NOP
    advance (4)
    jump (19DC);

19DC:

    #19DC
    #instruction: LD   A,(2094)
    advance (13)
    A := M[2094];
    jump (19DF);

19DD:

    #19DD
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (19DE);

19DE:

    #19DE
    #instruction: *NOP
    advance (4)
    jump (19DF);

19DF:

    #19DF
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (19E0);

19E0:

    #19E0
    #instruction: LD   (2094),A
    M[2094] := A;
    advance (13)
    jump (19E3);

19E1:

    #19E1
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (19E2);

19E2:

    #19E2
    #instruction: *NOP
    advance (4)
    jump (19E3);

19E3:

    #19E3
    #instruction: OUT  03
    sound_control(Ufo,A[0]);
    sound_control(Shot,A[1]);
    sound_control(PlayerDie,A[2]);
    sound_control(InvaderDie,A[3]);
    sound_control(ExtraLife,A[4]);
    advance (10)
    jump (19E5);

19E4:

    #19E4
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (19E5);

19E5:

    #19E5
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

19E6:

    #19E6
    #instruction: LD   HL,2701
    advance (10)
    H := 27;
    L := 01;
    jump (19E9);

19E7:

    #19E7
    #instruction: LD   BC,CA27
    advance (10)
    B := CA;
    C := 27;
    jump (19EA);

19E8:

    #19E8
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (19E9);

19E9:

    #19E9
    #instruction: JP   Z,19FA
    if (FlagZ) {
      advance (10)
      jump (19FA);
    } else {
      advance (10)
      jump (19EC);
    }

19EA:

    #19EA
    #instruction: JP   MI,1119
    if (FlagS) {
      advance (10)
      jump (1119);
    } else {
      advance (10)
      jump (19ED);
    }

19EB:

    #19EB
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19EC);

19EC:

    #19EC
    #instruction: LD   DE,1C60
    advance (10)
    D := 1C;
    E := 60;
    jump (19EF);

19ED:

    #19ED
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (19EE);

19EE:

    #19EE
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19EF);

19EF:

    #19EF
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (19F1);

19F0:

    #19F0
    #instruction: *NOP
    advance (4)
    jump (19F1);

19F1:

    #19F1
    #instruction: LD   C,A
    advance (5)
    C := A;
    jump (19F2);

19F2:

    #19F2
    #instruction: CALL 1439
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := F5;
    #return-to: 19F5
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1439);

19F3:

    #19F3
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19F4);

19F4:

    #19F4
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19F5);

19F5:

    #19F5
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (19F6);

19F6:

    #19F6
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19F7);

19F7:

    #19F7
    #instruction: JP   NZ,19EC
    if (!FlagZ) {
      advance (10)
      jump (19EC);
    } else {
      advance (10)
      jump (19FA);
    }

19F8:

    #19F8
    #instruction: CALL PE,0619
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 19;
      let:16 a2 = (-1 + a1) in
      M[a2] := FB;
      #return-to: 19FB
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0619);
    } else {
      advance (11)
      jump (19FB);
    }

19F9:

    #19F9
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (19FA);

19FA:

    #19FA
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (19FC);

19FB:

    #19FB
    #instruction: *NOP
    advance (4)
    jump (19FC);

19FC:

    #19FC
    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 19FF
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (14CB);

19FD:

    #19FD
    #instruction: *JP  7C14
    advance (10)
    jump (7C14);

19FE:

    #19FE
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (19FF);

19FF:

    #19FF
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1A00);

1A00:

    #1A00
    #instruction: CP   35
    let:16 a1 = addWithCarry(!false,A,~35) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~35 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1A02);

1A01:

    #1A01
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A02);

1A02:

    #1A02
    #instruction: JP   NZ,19FA
    if (!FlagZ) {
      advance (10)
      jump (19FA);
    } else {
      advance (10)
      jump (1A05);
    }

1A03:

    #1A03
    #instruction: JP   MI,C919
    if (FlagS) {
      advance (10)
      jump (C919);
    } else {
      advance (10)
      jump (1A06);
    }

1A04:

    #1A04
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A05);

1A05:

    #1A05
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A06:

    #1A06
    #instruction: LD   HL,2072
    advance (10)
    H := 20;
    L := 72;
    jump (1A09);

1A07:

    #1A07
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (1A08);

1A08:

    #1A08
    #instruction: *NOP
    advance (4)
    jump (1A09);

1A09:

    #1A09
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (1A0A);

1A0A:

    #1A0A
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A0B);

1A0B:

    #1A0B
    #instruction: AND  80
    let:8 a1 = (80 & A) in
    let:8 a2 = (80 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A0D);

1A0C:

    #1A0C
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1A0D);

1A0D:

    #1A0D
    #instruction: XOR  B
    let:8 a1 = (B ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A0E);

1A0E:

    #1A0E
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1A0F);
    }

1A0F:

    #1A0F
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (1A10);

1A10:

    #1A10
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A11:

    #1A11
    #instruction: LD   (242B),A
    M[242B] := A;
    advance (13)
    jump (1A14);

1A12:

    #1A12
    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A13);

1A13:

    #1A13
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A14);

1A14:

    #1A14
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A15);

1A15:

    #1A15
    #instruction: LD   D,11
    advance (7)
    D := 11;
    jump (1A17);

1A16:

    #1A16
    #instruction: LD   DE,0A0D
    advance (10)
    D := 0A;
    E := 0D;
    jump (1A19);

1A17:

    #1A17
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A18);

1A18:

    #1A18
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1A19);

1A19:

    #1A19
    #instruction: *NOP
    advance (4)
    jump (1A1A);

1A1A:

    #1A1A
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1A1B);

1A1B:

    #1A1B
    #instruction: LD   B,05
    advance (7)
    B := 05;
    jump (1A1D);

1A1C:

    #1A1C
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A1D);

1A1D:

    #1A1D
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A1E);

1A1E:

    #1A1E
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1A1F);

1A1F:

    #1A1F
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1A20);

1A20:

    #1A20
    #instruction: LD   BC,2E34
    advance (10)
    B := 2E;
    C := 34;
    jump (1A23);

1A21:

    #1A21
    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A22);

1A22:

    #1A22
    #instruction: LD   L,27
    advance (7)
    L := 27;
    jump (1A24);

1A23:

    #1A23
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1A24);

1A24:

    #1A24
    #instruction: LD   (181C),HL
    M[181C] := L;
    M[181D] := H;
    advance (16)
    jump (1A27);

1A25:

    #1A25
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A26);

1A26:

    #1A26
    #instruction: *NOP
    advance (4)
    jump (1A27);

1A27:

    #1A27
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A28);

1A28:

    #1A28
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1A29);

1A29:

    #1A29
    #instruction: *NOP
    advance (4)
    jump (1A2A);

1A2A:

    #1A2A
    #instruction: LD   C,0D
    advance (7)
    C := 0D;
    jump (1A2C);

1A2B:

    #1A2B
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A2C);

1A2C:

    #1A2C
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A2D);

1A2D:

    #1A2D
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1A2E);

1A2E:

    #1A2E
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A2F);

1A2F:

    #1A2F
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1A30);

1A30:

    #1A30
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A31);

1A31:

    #1A31
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 32;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1A32:

    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A33);

1A33:

    #1A33
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1A34);

1A34:

    #1A34
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A35);

1A35:

    #1A35
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1A36);

1A36:

    #1A36
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A37);

1A37:

    #1A37
    #instruction: JP   NZ,1A32
    if (!FlagZ) {
      advance (10)
      jump (1A32);
    } else {
      advance (10)
      jump (1A3A);
    }

1A38:

    #1A38
    #instruction: LD   (C91A),A
    M[C91A] := A;
    advance (13)
    jump (1A3B);

1A39:

    #1A39
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A3A);

1A3A:

    #1A3A
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A3B:

    #1A3B
    #instruction: LD   E,(HL)
    advance (7)
    E := M[(H,L)];
    jump (1A3C);

1A3C:

    #1A3C
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A3D);

1A3D:

    #1A3D
    #instruction: LD   D,(HL)
    advance (7)
    D := M[(H,L)];
    jump (1A3E);

1A3E:

    #1A3E
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A3F);

1A3F:

    #1A3F
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1A40);

1A40:

    #1A40
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A41);

1A41:

    #1A41
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (1A42);

1A42:

    #1A42
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A43);

1A43:

    #1A43
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (1A44);

1A44:

    #1A44
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (1A45);

1A45:

    #1A45
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (1A46);

1A46:

    #1A46
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A47:

    #1A47
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A48);

1A48:

    #1A48
    #instruction: LD   B,03
    advance (7)
    B := 03;
    jump (1A4A);

1A49:

    #1A49
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1A4A);

1A4A:

    #1A4A
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1A4B);

1A4B:

    #1A4B
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1A4C);

1A4C:

    #1A4C
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1A4D);

1A4D:

    #1A4D
    #instruction: LD   A,L
    advance (5)
    A := L;
    jump (1A4E);

1A4E:

    #1A4E
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1A4F);

1A4F:

    #1A4F
    #instruction: LD   L,A
    advance (5)
    L := A;
    jump (1A50);

1A50:

    #1A50
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A51);

1A51:

    #1A51
    #instruction: JP   NZ,1A4A
    if (!FlagZ) {
      advance (10)
      jump (1A4A);
    } else {
      advance (10)
      jump (1A54);
    }

1A52:

    #1A52
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (1A53);

1A53:

    #1A53
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A54);

1A54:

    #1A54
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1A55);

1A55:

    #1A55
    #instruction: AND  3F
    let:8 a1 = (3F & A) in
    let:8 a2 = (3F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A57);

1A56:

    #1A56
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (1A57);

1A57:

    #1A57
    #instruction: OR   20
    let:8 a1 = (20 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A59);

1A58:

    #1A58
    #instruction: *NOP
    advance (4)
    jump (1A59);

1A59:

    #1A59
    #instruction: LD   H,A
    advance (5)
    H := A;
    jump (1A5A);

1A5A:

    #1A5A
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A5B);

1A5B:

    #1A5B
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A5C:

    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    H := 24;
    L := 00;
    jump (1A5F);

1A5D:

    #1A5D
    #instruction: NOP
    advance (4)
    jump (1A5E);

1A5E:

    #1A5E
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A5F);

1A5F:

    #1A5F
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (1A61);

1A60:

    #1A60
    #instruction: NOP
    advance (4)
    jump (1A61);

1A61:

    #1A61
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A62);

1A62:

    #1A62
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1A63);

1A63:

    #1A63
    #instruction: CP   40
    let:16 a1 = addWithCarry(!false,A,~40) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~40 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1A65);

1A64:

    #1A64
    #instruction: LD   B,B
    advance (5)
    jump (1A65);

1A65:

    #1A65
    #instruction: JP   NZ,1A5F
    if (!FlagZ) {
      advance (10)
      jump (1A5F);
    } else {
      advance (10)
      jump (1A68);
    }

1A66:

    #1A66
    #instruction: LD   E,A
    advance (5)
    E := A;
    jump (1A67);

1A67:

    #1A67
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A68);

1A68:

    #1A68
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A69:

    #1A69
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A6A);

1A6A:

    #1A6A
    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A6B);

1A6B:

    #1A6B
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A6C);

1A6C:

    #1A6C
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A6D);

1A6D:

    #1A6D
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1A6E);

1A6E:

    #1A6E
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1A6F);

1A6F:

    #1A6F
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1A70);

1A70:

    #1A70
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A71);

1A71:

    #1A71
    #instruction: JP   NZ,1A6B
    if (!FlagZ) {
      advance (10)
      jump (1A6B);
    } else {
      advance (10)
      jump (1A74);
    }

1A72:

    #1A72
    #instruction: LD   L,E
    advance (5)
    L := E;
    jump (1A73);

1A73:

    #1A73
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A74);

1A74:

    #1A74
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A75);

1A75:

    #1A75
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1A78);

1A76:

    #1A76
    #instruction: *NOP
    advance (4)
    jump (1A77);

1A77:

    #1A77
    #instruction: NOP
    advance (4)
    jump (1A78);

1A78:

    #1A78
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A79);

1A79:

    #1A79
    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A7A);

1A7A:

    #1A7A
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A7B);

1A7B:

    #1A7B
    #instruction: JP   NZ,1A69
    if (!FlagZ) {
      advance (10)
      jump (1A69);
    } else {
      advance (10)
      jump (1A7E);
    }

1A7C:

    #1A7C
    #instruction: LD   L,C
    advance (5)
    L := C;
    jump (1A7D);

1A7D:

    #1A7D
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1A7E);

1A7E:

    #1A7E
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1A7F:

    #1A7F
    #instruction: CALL 092E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 82;
    #return-to: 1A82
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (092E);

1A80:

    #1A80
    #instruction: LD   L,09
    advance (7)
    L := 09;
    jump (1A82);

1A81:

    #1A81
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A82);

1A82:

    #1A82
    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A83);

1A83:

    #1A83
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1A84);
    }

1A84:

    #1A84
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A85);

1A85:

    #1A85
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A86);

1A86:

    #1A86
    #instruction: LD   (HL),A
    M[(H,L)] := A;
    advance (7)
    jump (1A87);

1A87:

    #1A87
    #instruction: CALL 19E6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 8A;
    #return-to: 1A8A
    advance (17)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (19E6);

1A88:

    #1A88
    #instruction: AND  19
    let:8 a1 = (19 & A) in
    let:8 a2 = (19 | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A8A);

1A89:

    #1A89
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A8A);

1A8A:

    #1A8A
    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[a1];
    SPH := a2[15:8];
    SPL := a2[7:0];
    FlagS := M[(SPH,SPL)][7];
    FlagZ := M[(SPH,SPL)][6];
    FlagA := M[(SPH,SPL)][4];
    FlagP := M[(SPH,SPL)][2];
    FlagCY := M[(SPH,SPL)][0];
    jump (1A8B);

1A8B:

    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    H := 25;
    L := 01;
    jump (1A8E);

1A8C:

    #1A8C
    #instruction: LD   BC,E625
    advance (10)
    B := E6;
    C := 25;
    jump (1A8F);

1A8D:

    #1A8D
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A8E);

1A8E:

    #1A8E
    #instruction: AND  0F
    let:8 a1 = (0F & A) in
    let:8 a2 = (0F | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1A90);

1A8F:

    #1A8F
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1A90);

1A90:

    #1A90
    #instruction: JP   09C5
    advance (10)
    jump (09C5);

1A91:

    #1A91
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1A92);

1A92:

    #1A92
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1A93);

1A93:

    #1A93
    #instruction: NOP
    advance (4)
    jump (1A94);

1A94:

    #1A94
    #instruction: NOP
    advance (4)
    jump (1A95);

1A95:

    #1A95
    #instruction: NOP
    advance (4)
    jump (1A96);

1A96:

    #1A96
    #instruction: NOP
    advance (4)
    jump (1A97);

1A97:

    #1A97
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 98;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1A98:

    #1A98
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1A99);

1A99:

    #1A99
    #instruction: CP   20
    let:16 a1 = addWithCarry(!false,A,~20) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~20 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1A9B);

1A9A:

    #1A9A
    #instruction: *NOP
    advance (4)
    jump (1A9B);

1A9B:

    #1A9B
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1A9C);

1A9C:

    #1A9C
    #instruction: *NOP
    advance (4)
    jump (1A9D);

1A9D:

    #1A9D
    #instruction: SBC  (HL)
    let:16 a1 = addWithCarry(!FlagCY,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1A9E);

1A9E:

    #1A9E
    #instruction: NOP
    advance (4)
    jump (1A9F);

1A9F:

    #1A9F
    #instruction: *NOP
    advance (4)
    jump (1AA0);

1AA0:

    #1AA0
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AA1);

1AA1:

    #1AA1
    #instruction: *NOP
    advance (4)
    jump (1AA2);

1AA2:

    #1AA2
    #instruction: *NOP
    advance (4)
    jump (1AA3);

1AA3:

    #1AA3
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1AA4);

1AA4:

    #1AA4
    #instruction: *NOP
    advance (4)
    jump (1AA5);

1AA5:

    #1AA5
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1AA6);

1AA6:

    #1AA6
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (1AA8);

1AA7:

    #1AA7
    #instruction: NOP
    advance (4)
    jump (1AA8);

1AA8:

    #1AA8
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AA9);

1AA9:

    #1AA9
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AAA);

1AAA:

    #1AAA
    #instruction: LD   H,0E
    advance (7)
    H := 0E;
    jump (1AAC);

1AAB:

    #1AAB
    #instruction: LD   C,15
    advance (7)
    C := 15;
    jump (1AAD);

1AAC:

    #1AAC
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AAD);

1AAD:

    #1AAD
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AAE);

1AAE:

    #1AAE
    #instruction: LD   DE,2626
    advance (10)
    D := 26;
    E := 26;
    jump (1AB1);

1AAF:

    #1AAF
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1AB1);

1AB0:

    #1AB0
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1AB2);

1AB1:

    #1AB1
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1AB2);

1AB2:

    #1AB2
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1AB3);

1AB3:

    #1AB3
    #instruction: NOP
    advance (4)
    jump (1AB4);

1AB4:

    #1AB4
    #instruction: *NOP
    advance (4)
    jump (1AB5);

1AB5:

    #1AB5
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AB6);

1AB6:

    #1AB6
    #instruction: LD   DE,2624
    advance (10)
    D := 26;
    E := 24;
    jump (1AB9);

1AB7:

    #1AB7
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AB8);

1AB8:

    #1AB8
    #instruction: LD   H,25
    advance (7)
    H := 25;
    jump (1ABA);

1AB9:

    #1AB9
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1ABA);

1ABA:

    #1ABA
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1ABB);

1ABB:

    #1ABB
    #instruction: LD   H,0E
    advance (7)
    H := 0E;
    jump (1ABD);

1ABC:

    #1ABC
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1ABE);

1ABD:

    #1ABD
    #instruction: LD   DE,1C26
    advance (10)
    D := 1C;
    E := 26;
    jump (1AC0);

1ABE:

    #1ABE
    #instruction: LD   H,1C
    advance (7)
    H := 1C;
    jump (1AC0);

1ABF:

    #1ABF
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AC0);

1AC0:

    #1AC0
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1AC1);

1AC1:

    #1AC1
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1AC2);

1AC2:

    #1AC2
    #instruction: NOP
    advance (4)
    jump (1AC3);

1AC3:

    #1AC3
    #instruction: *NOP
    advance (4)
    jump (1AC4);

1AC4:

    #1AC4
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AC5);

1AC5:

    #1AC5
    #instruction: LD   DE,2612
    advance (10)
    D := 26;
    E := 12;
    jump (1AC8);

1AC6:

    #1AC6
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1AC7);

1AC7:

    #1AC7
    #instruction: LD   H,01
    advance (7)
    H := 01;
    jump (1AC9);

1AC8:

    #1AC8
    #instruction: LD   BC,1314
    advance (10)
    B := 13;
    C := 14;
    jump (1ACB);

1AC9:

    #1AC9
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1ACA);

1ACA:

    #1ACA
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1ACB);

1ACB:

    #1ACB
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1ACC);

1ACC:

    #1ACC
    #instruction: LD   C,0D
    advance (7)
    C := 0D;
    jump (1ACE);

1ACD:

    #1ACD
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1ACE);

1ACE:

    #1ACE
    #instruction: LD   H,0E
    advance (7)
    H := 0E;
    jump (1AD0);

1ACF:

    #1ACF
    #instruction: LD   C,0D
    advance (7)
    C := 0D;
    jump (1AD1);

1AD0:

    #1AD0
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AD1);

1AD1:

    #1AD1
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1AD2);

1AD2:

    #1AD2
    #instruction: *NOP
    advance (4)
    jump (1AD3);

1AD3:

    #1AD3
    #instruction: LD   H,1B
    advance (7)
    H := 1B;
    jump (1AD5);

1AD4:

    #1AD4
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1AD5);

1AD5:

    #1AD5
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1AD6);

1AD6:

    #1AD6
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1AD7);

1AD7:

    #1AD7
    #instruction: NOP
    advance (4)
    jump (1AD8);

1AD8:

    #1AD8
    #instruction: *NOP
    advance (4)
    jump (1AD9);

1AD9:

    #1AD9
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1ADA);

1ADA:

    #1ADA
    #instruction: LD   DE,2626
    advance (10)
    D := 26;
    E := 26;
    jump (1ADD);

1ADB:

    #1ADB
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1ADD);

1ADC:

    #1ADC
    #instruction: LD   H,01
    advance (7)
    H := 01;
    jump (1ADE);

1ADD:

    #1ADD
    #instruction: LD   BC,1314
    advance (10)
    B := 13;
    C := 14;
    jump (1AE0);

1ADE:

    #1ADE
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1ADF);

1ADF:

    #1ADF
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1AE0);

1AE0:

    #1AE0
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1AE1);

1AE1:

    #1AE1
    #instruction: LD   C,0D
    advance (7)
    C := 0D;
    jump (1AE3);

1AE2:

    #1AE2
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AE3);

1AE3:

    #1AE3
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1AE5);

1AE4:

    #1AE4
    #instruction: LD   H,12
    advance (7)
    H := 12;
    jump (1AE6);

1AE5:

    #1AE5
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1AE6);

1AE6:

    #1AE6
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1AE7);

1AE7:

    #1AE7
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1AE9);

1AE8:

    #1AE8
    #instruction: LD   DE,2404
    advance (10)
    D := 24;
    E := 04;
    jump (1AEB);

1AE9:

    #1AE9
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AEA);

1AEA:

    #1AEA
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AEB);

1AEB:

    #1AEB
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1AEC);

1AEC:

    #1AEC
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AED);

1AED:

    #1AED
    #instruction: LD   H,07
    advance (7)
    H := 07;
    jump (1AEF);

1AEE:

    #1AEE
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1AEF);

1AEF:

    #1AEF
    #instruction: *NOP
    advance (4)
    jump (1AF0);

1AF0:

    #1AF0
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (1AF1);

1AF1:

    #1AF1
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1AF2);

1AF2:

    #1AF2
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1AF3);

1AF3:

    #1AF3
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1AF5);

1AF4:

    #1AF4
    #instruction: LD   DE,2604
    advance (10)
    D := 26;
    E := 04;
    jump (1AF7);

1AF5:

    #1AF5
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AF6);

1AF6:

    #1AF6
    #instruction: LD   H,12
    advance (7)
    H := 12;
    jump (1AF8);

1AF7:

    #1AF7
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1AF8);

1AF8:

    #1AF8
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1AF9);

1AF9:

    #1AF9
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1AFB);

1AFA:

    #1AFA
    #instruction: LD   DE,2404
    advance (10)
    D := 24;
    E := 04;
    jump (1AFD);

1AFB:

    #1AFB
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AFC);

1AFC:

    #1AFC
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AFD);

1AFD:

    #1AFD
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AFE);

1AFE:

    #1AFE
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1AFF);

1AFF:

    #1AFF
    #instruction: LD   H,01
    advance (7)
    H := 01;
    jump (1B01);

1B00:

    #1B00
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1B03);

1B01:

    #1B01
    #instruction: NOP
    advance (4)
    jump (1B02);

1B02:

    #1B02
    #instruction: NOP
    advance (4)
    jump (1B03);

1B03:

    #1B03
    #instruction: *NOP
    advance (4)
    jump (1B04);

1B04:

    #1B04
    #instruction: NOP
    advance (4)
    jump (1B05);

1B05:

    #1B05
    #instruction: NOP
    advance (4)
    jump (1B06);

1B06:

    #1B06
    #instruction: NOP
    advance (4)
    jump (1B07);

1B07:

    #1B07
    #instruction: NOP
    advance (4)
    jump (1B08);

1B08:

    #1B08
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1B09);

1B09:

    #1B09
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1B0A);

1B0A:

    #1B0A
    #instruction: *NOP
    advance (4)
    jump (1B0B);

1B0B:

    #1B0B
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1B0C);

1B0C:

    #1B0C
    #instruction: *NOP
    advance (4)
    jump (1B0D);

1B0D:

    #1B0D
    #instruction: NOP
    advance (4)
    jump (1B0E);

1B0E:

    #1B0E
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1B0F);
    }

1B0F:

    #1B0F
    #instruction: NOP
    advance (4)
    jump (1B10);

1B10:

    #1B10
    #instruction: NOP
    advance (4)
    jump (1B11);

1B11:

    #1B11
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1B12);

1B12:

    #1B12
    #instruction: NOP
    advance (4)
    jump (1B13);

1B13:

    #1B13
    #instruction: ADC  (HL)
    let:16 a1 = addWithCarry(FlagCY,M[(H,L)],A) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1B14);

1B14:

    #1B14
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1B15);

1B15:

    #1B15
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B16:

    #1B16
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B17);

1B17:

    #1B17
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B18);

1B18:

    #1B18
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1B19);

1B19:

    #1B19
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B1A);

1B1A:

    #1B1A
    #instruction: *NOP
    advance (4)
    jump (1B1B);

1B1B:

    #1B1B
    #instruction: *NOP
    advance (4)
    jump (1B1C);

1B1C:

    #1B1C
    #instruction: *NOP
    advance (4)
    jump (1B1D);

1B1D:

    #1B1D
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1B20);

1B1E:

    #1B1E
    #instruction: NOP
    advance (4)
    jump (1B1F);

1B1F:

    #1B1F
    #instruction: NOP
    advance (4)
    jump (1B20);

1B20:

    #1B20
    #instruction: NOP
    advance (4)
    jump (1B21);

1B21:

    #1B21
    #instruction: NOP
    advance (4)
    jump (1B22);

1B22:

    #1B22
    #instruction: NOP
    advance (4)
    jump (1B23);

1B23:

    #1B23
    #instruction: CP   E
    let:16 a1 = addWithCarry(!false,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1B24);

1B24:

    #1B24
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B25);

1B25:

    #1B25
    #instruction: NOP
    advance (4)
    jump (1B26);

1B26:

    #1B26
    #instruction: *NOP
    advance (4)
    jump (1B27);

1B27:

    #1B27
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1B28);

1B28:

    #1B28
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B29);

1B29:

    #1B29
    #instruction: *NOP
    advance (4)
    jump (1B2A);

1B2A:

    #1B2A
    #instruction: *NOP
    advance (4)
    jump (1B2B);

1B2B:

    #1B2B
    #instruction: LD   BC,0004
    advance (10)
    B := 00;
    C := 04;
    jump (1B2E);

1B2C:

    #1B2C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B2D);

1B2D:

    #1B2D
    #instruction: NOP
    advance (4)
    jump (1B2E);

1B2E:

    #1B2E
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2F;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B2F:

    #1B2F
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B30:

    #1B30
    #instruction: NOP
    advance (4)
    jump (1B31);

1B31:

    #1B31
    #instruction: NOP
    advance (4)
    jump (1B32);

1B32:

    #1B32
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1B33);

1B33:

    #1B33
    #instruction: HLT
    advance (7)
    jump (1B33);

1B34:

    #1B34
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B35);

1B35:

    #1B35
    #instruction: NOP
    advance (4)
    jump (1B36);

1B36:

    #1B36
    #instruction: NOP
    advance (4)
    jump (1B37);

1B37:

    #1B37
    #instruction: NOP
    advance (4)
    jump (1B38);

1B38:

    #1B38
    #instruction: NOP
    advance (4)
    jump (1B39);

1B39:

    #1B39
    #instruction: NOP
    advance (4)
    jump (1B3A);

1B3A:

    #1B3A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B3B);

1B3B:

    #1B3B
    #instruction: XOR  1C
    let:8 a1 = (1C ^ A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1B3D);

1B3C:

    #1B3C
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B3D);

1B3D:

    #1B3D
    #instruction: NOP
    advance (4)
    jump (1B3E);

1B3E:

    #1B3E
    #instruction: NOP
    advance (4)
    jump (1B3F);

1B3F:

    #1B3F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B40);

1B40:

    #1B40
    #instruction: NOP
    advance (4)
    jump (1B41);

1B41:

    #1B41
    #instruction: NOP
    advance (4)
    jump (1B42);

1B42:

    #1B42
    #instruction: NOP
    advance (4)
    jump (1B43);

1B43:

    #1B43
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1B44);

1B44:

    #1B44
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B45);

1B45:

    #1B45
    #instruction: NOP
    advance (4)
    jump (1B46);

1B46:

    #1B46
    #instruction: NOP
    advance (4)
    jump (1B47);

1B47:

    #1B47
    #instruction: LD   BC,1D00
    advance (10)
    B := 1D;
    C := 00;
    jump (1B4A);

1B48:

    #1B48
    #instruction: NOP
    advance (4)
    jump (1B49);

1B49:

    #1B49
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B4A);

1B4A:

    #1B4A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B4B);

1B4B:

    #1B4B
    #instruction: JP   PO,001C
    if (!FlagP) {
      advance (10)
      jump (001C);
    } else {
      advance (10)
      jump (1B4E);
    }

1B4C:

    #1B4C
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B4D);

1B4D:

    #1B4D
    #instruction: NOP
    advance (4)
    jump (1B4E);

1B4E:

    #1B4E
    #instruction: NOP
    advance (4)
    jump (1B4F);

1B4F:

    #1B4F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B50);

1B50:

    #1B50
    #instruction: NOP
    advance (4)
    jump (1B51);

1B51:

    #1B51
    #instruction: NOP
    advance (4)
    jump (1B52);

1B52:

    #1B52
    #instruction: NOP
    advance (4)
    jump (1B53);

1B53:

    #1B53
    #instruction: ADD  D
    let:16 a1 = addWithCarry(false,D,A) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1B54);

1B54:

    #1B54
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (1B56);

1B55:

    #1B55
    #instruction: NOP
    advance (4)
    jump (1B56);

1B56:

    #1B56
    #instruction: NOP
    advance (4)
    jump (1B57);

1B57:

    #1B57
    #instruction: LD   BC,1D06
    advance (10)
    B := 1D;
    C := 06;
    jump (1B5A);

1B58:

    #1B58
    #instruction: LD   B,1D
    advance (7)
    B := 1D;
    jump (1B5A);

1B59:

    #1B59
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B5A);

1B5A:

    #1B5A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B5B);

1B5B:

    #1B5B
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1B5C);
    }

1B5C:

    #1B5C
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B5D);

1B5D:

    #1B5D
    #instruction: NOP
    advance (4)
    jump (1B5E);

1B5E:

    #1B5E
    #instruction: NOP
    advance (4)
    jump (1B5F);

1B5F:

    #1B5F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B60);

1B60:

    #1B60
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 61;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B61:

    #1B61
    #instruction: NOP
    advance (4)
    jump (1B62);

1B62:

    #1B62
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1B63);
    }

1B63:

    #1B63
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B64);

1B64:

    #1B64
    #instruction: NOP
    advance (4)
    jump (1B65);

1B65:

    #1B65
    #instruction: NOP
    advance (4)
    jump (1B66);

1B66:

    #1B66
    #instruction: *NOP
    advance (4)
    jump (1B67);

1B67:

    #1B67
    #instruction: LD   HL,0001
    advance (10)
    H := 00;
    L := 01;
    jump (1B6A);

1B68:

    #1B68
    #instruction: LD   BC,3000
    advance (10)
    B := 30;
    C := 00;
    jump (1B6B);

1B69:

    #1B69
    #instruction: NOP
    advance (4)
    jump (1B6A);

1B6A:

    #1B6A
    #instruction: *NOP
    advance (4)
    jump (1B6B);

1B6B:

    #1B6B
    #instruction: NOP
    advance (4)
    jump (1B6C);

1B6C:

    #1B6C
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1B6D);

1B6D:

    #1B6D
    #instruction: NOP
    advance (4)
    jump (1B6E);

1B6E:

    #1B6E
    #instruction: NOP
    advance (4)
    jump (1B6F);

1B6F:

    #1B6F
    #instruction: NOP
    advance (4)
    jump (1B70);

1B70:

    #1B70
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1B71);

1B71:

    #1B71
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B72);

1B72:

    #1B72
    #instruction: NOP
    advance (4)
    jump (1B73);

1B73:

    #1B73
    #instruction: *NOP
    advance (4)
    jump (1B74);

1B74:

    #1B74
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1B76);

1B75:

    #1B75
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1B76);

1B76:

    #1B76
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1B77);

1B77:

    #1B77
    #instruction: NOP
    advance (4)
    jump (1B78);

1B78:

    #1B78
    #instruction: *NOP
    advance (4)
    jump (1B79);

1B79:

    #1B79
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B7A);

1B7A:

    #1B7A
    #instruction: LD   DE,1B24
    advance (10)
    D := 1B;
    E := 24;
    jump (1B7D);

1B7B:

    #1B7B
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B7C);

1B7C:

    #1B7C
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1B7D);

1B7D:

    #1B7D
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B7E);

1B7E:

    #1B7E
    #instruction: CALL MI,0100
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1B;
      let:16 a2 = (-1 + a1) in
      M[a2] := 81;
      #return-to: 1B81
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0100);
    } else {
      advance (11)
      jump (1B81);
    }

1B7F:

    #1B7F
    #instruction: NOP
    advance (4)
    jump (1B80);

1B80:

    #1B80
    #instruction: LD   BC,FFFF
    advance (10)
    B := FF;
    C := FF;
    jump (1B83);

1B81:

    #1B81
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 82;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B82:

    #1B82
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 83;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1B83:

    #1B83
    #instruction: NOP
    advance (4)
    jump (1B84);

1B84:

    #1B84
    #instruction: NOP
    advance (4)
    jump (1B85);

1B85:

    #1B85
    #instruction: NOP
    advance (4)
    jump (1B86);

1B86:

    #1B86
    #instruction: *NOP
    advance (4)
    jump (1B87);

1B87:

    #1B87
    #instruction: LD   H,H
    advance (5)
    jump (1B88);

1B88:

    #1B88
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B89);

1B89:

    #1B89
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1B8A);
    }

1B8A:

    #1B8A
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1B8B);

1B8B:

    #1B8B
    #instruction: *NOP
    advance (4)
    jump (1B8C);

1B8C:

    #1B8C
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1B8D);

1B8D:

    #1B8D
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (1B8E);

1B8E:

    #1B8E
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1B8F);

1B8F:

    #1B8F
    #instruction: NOP
    advance (4)
    jump (1B90);

1B90:

    #1B90
    #instruction: *NOP
    advance (4)
    jump (1B91);

1B91:

    #1B91
    #instruction: NOP
    advance (4)
    jump (1B92);

1B92:

    #1B92
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (1B94);

1B93:

    #1B93
    #instruction: NOP
    advance (4)
    jump (1B94);

1B94:

    #1B94
    #instruction: NOP
    advance (4)
    jump (1B95);

1B95:

    #1B95
    #instruction: LD   BC,0040
    advance (10)
    B := 00;
    C := 40;
    jump (1B98);

1B96:

    #1B96
    #instruction: LD   B,B
    advance (5)
    jump (1B97);

1B97:

    #1B97
    #instruction: NOP
    advance (4)
    jump (1B98);

1B98:

    #1B98
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1B9B);

1B99:

    #1B99
    #instruction: NOP
    advance (4)
    jump (1B9A);

1B9A:

    #1B9A
    #instruction: NOP
    advance (4)
    jump (1B9B);

1B9B:

    #1B9B
    #instruction: *NOP
    advance (4)
    jump (1B9C);

1B9C:

    #1B9C
    #instruction: SBC  (HL)
    let:16 a1 = addWithCarry(!FlagCY,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1B9D);

1B9D:

    #1B9D
    #instruction: NOP
    advance (4)
    jump (1B9E);

1B9E:

    #1B9E
    #instruction: *NOP
    advance (4)
    jump (1B9F);

1B9F:

    #1B9F
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BA0);

1BA0:

    #1BA0
    #instruction: NOP
    advance (4)
    jump (1BA1);

1BA1:

    #1BA1
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1BA2);

1BA2:

    #1BA2
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BA3);

1BA3:

    #1BA3
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1BA4);

1BA4:

    #1BA4
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BA5);

1BA5:

    #1BA5
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1BA6);

1BA6:

    #1BA6
    #instruction: *NOP
    advance (4)
    jump (1BA7);

1BA7:

    #1BA7
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1BA8);

1BA8:

    #1BA8
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BA9);

1BA9:

    #1BA9
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1BAA);

1BAA:

    #1BAA
    #instruction: CALL MI,68FC
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1B;
      let:16 a2 = (-1 + a1) in
      M[a2] := AD;
      #return-to: 1BAD
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (68FC);
    } else {
      advance (11)
      jump (1BAD);
    }

1BAB:

    #1BAB
    #instruction: CALL MI,3D68
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1B;
      let:16 a2 = (-1 + a1) in
      M[a2] := AE;
      #return-to: 1BAE
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3D68);
    } else {
      advance (11)
      jump (1BAE);
    }

1BAC:

    #1BAC
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1BAD);

1BAD:

    #1BAD
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BAE);

1BAE:

    #1BAE
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1BAF);

1BAF:

    #1BAF
    #instruction: NOP
    advance (4)
    jump (1BB0);

1BB0:

    #1BB0
    #instruction: NOP
    advance (4)
    jump (1BB1);

1BB1:

    #1BB1
    #instruction: NOP
    advance (4)
    jump (1BB2);

1BB2:

    #1BB2
    #instruction: LD   BC,98B8
    advance (10)
    B := 98;
    C := B8;
    jump (1BB5);

1BB3:

    #1BB3
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1BB4);

1BB4:

    #1BB4
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1BB5);

1BB5:

    #1BB5
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1BB6);

1BB6:

    #1BB6
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1BB7);

1BB7:

    #1BB7
    #instruction: *NOP
    advance (4)
    jump (1BB8);

1BB8:

    #1BB8
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1B;
    let:16 a2 = (-1 + a1) in
    M[a2] := B9;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1BB9:

    #1BB9
    #instruction: NOP
    advance (4)
    jump (1BBA);

1BBA:

    #1BBA
    #instruction: AND  B
    let:8 a1 = (B & A) in
    let:8 a2 = (B | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1BBB);

1BBB:

    #1BBB
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1BBC);

1BBC:

    #1BBC
    #instruction: NOP
    advance (4)
    jump (1BBD);

1BBD:

    #1BBD
    #instruction: NOP
    advance (4)
    jump (1BBE);

1BBE:

    #1BBE
    #instruction: NOP
    advance (4)
    jump (1BBF);

1BBF:

    #1BBF
    #instruction: NOP
    advance (4)
    jump (1BC0);

1BC0:

    #1BC0
    #instruction: NOP
    advance (4)
    jump (1BC1);

1BC1:

    #1BC1
    #instruction: *NOP
    advance (4)
    jump (1BC2);

1BC2:

    #1BC2
    #instruction: NOP
    advance (4)
    jump (1BC3);

1BC3:

    #1BC3
    #instruction: LD   C,05
    advance (7)
    C := 05;
    jump (1BC5);

1BC4:

    #1BC4
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BC5);

1BC5:

    #1BC5
    #instruction: NOP
    advance (4)
    jump (1BC6);

1BC6:

    #1BC6
    #instruction: NOP
    advance (4)
    jump (1BC7);

1BC7:

    #1BC7
    #instruction: NOP
    advance (4)
    jump (1BC8);

1BC8:

    #1BC8
    #instruction: NOP
    advance (4)
    jump (1BC9);

1BC9:

    #1BC9
    #instruction: NOP
    advance (4)
    jump (1BCA);

1BCA:

    #1BCA
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1BCB);

1BCB:

    #1BCB
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1BCC);
    }

1BCC:

    #1BCC
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BCD);

1BCD:

    #1BCD
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1BCE);
    }

1BCE:

    #1BCE
    #instruction: SBC  E
    let:16 a1 = addWithCarry(!FlagCY,A,~E) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~E & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1BCF);

1BCF:

    #1BCF
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1BD0);

1BD0:

    #1BD0
    #instruction: NOP
    advance (4)
    jump (1BD1);

1BD1:

    #1BD1
    #instruction: NOP
    advance (4)
    jump (1BD2);

1BD2:

    #1BD2
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1BD3);

1BD3:

    #1BD3
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BD4);

1BD4:

    #1BD4
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1BD5);

1BD5:

    #1BD5
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BD6);

1BD6:

    #1BD6
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1BD7);

1BD7:

    #1BD7
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1BD8);

1BD8:

    #1BD8
    #instruction: LD   A,(FA6D)
    advance (13)
    A := M[FA6D];
    jump (1BDB);

1BD9:

    #1BD9
    #instruction: LD   L,L
    advance (5)
    jump (1BDA);

1BDA:

    #1BDA
    #instruction: JP   MI,6DFA
    if (FlagS) {
      advance (10)
      jump (6DFA);
    } else {
      advance (10)
      jump (1BDD);
    }

1BDB:

    #1BDB
    #instruction: JP   MI,3A6D
    if (FlagS) {
      advance (10)
      jump (3A6D);
    } else {
      advance (10)
      jump (1BDE);
    }

1BDC:

    #1BDC
    #instruction: LD   L,L
    advance (5)
    jump (1BDD);

1BDD:

    #1BDD
    #instruction: LD   A,(0019)
    advance (13)
    A := 21;
    jump (1BE0);

1BDE:

    #1BDE
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1BDF);

1BDF:

    #1BDF
    #instruction: NOP
    advance (4)
    jump (1BE0);

1BE0:

    #1BE0
    #instruction: NOP
    advance (4)
    jump (1BE1);

1BE1:

    #1BE1
    #instruction: NOP
    advance (4)
    jump (1BE2);

1BE2:

    #1BE2
    #instruction: NOP
    advance (4)
    jump (1BE3);

1BE3:

    #1BE3
    #instruction: NOP
    advance (4)
    jump (1BE4);

1BE4:

    #1BE4
    #instruction: NOP
    advance (4)
    jump (1BE5);

1BE5:

    #1BE5
    #instruction: NOP
    advance (4)
    jump (1BE6);

1BE6:

    #1BE6
    #instruction: NOP
    advance (4)
    jump (1BE7);

1BE7:

    #1BE7
    #instruction: NOP
    advance (4)
    jump (1BE8);

1BE8:

    #1BE8
    #instruction: NOP
    advance (4)
    jump (1BE9);

1BE9:

    #1BE9
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1BEC);

1BEA:

    #1BEA
    #instruction: NOP
    advance (4)
    jump (1BEB);

1BEB:

    #1BEB
    #instruction: NOP
    advance (4)
    jump (1BEC);

1BEC:

    #1BEC
    #instruction: LD   BC,1F74
    advance (10)
    B := 1F;
    C := 74;
    jump (1BEF);

1BED:

    #1BED
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1BEE);

1BEE:

    #1BEE
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1BEF);

1BEF:

    #1BEF
    #instruction: NOP
    advance (4)
    jump (1BF0);

1BF0:

    #1BF0
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1BF1);

1BF1:

    #1BF1
    #instruction: NOP
    advance (4)
    jump (1BF2);

1BF2:

    #1BF2
    #instruction: NOP
    advance (4)
    jump (1BF3);

1BF3:

    #1BF3
    #instruction: NOP
    advance (4)
    jump (1BF4);

1BF4:

    #1BF4
    #instruction: NOP
    advance (4)
    jump (1BF5);

1BF5:

    #1BF5
    #instruction: NOP
    advance (4)
    jump (1BF6);

1BF6:

    #1BF6
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BF7);

1BF7:

    #1BF7
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (1BF8);

1BF8:

    #1BF8
    #instruction: NOP
    advance (4)
    jump (1BF9);

1BF9:

    #1BF9
    #instruction: NOP
    advance (4)
    jump (1BFA);

1BFA:

    #1BFA
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BFB);

1BFB:

    #1BFB
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1BFC);

1BFC:

    #1BFC
    #instruction: NOP
    advance (4)
    jump (1BFD);

1BFD:

    #1BFD
    #instruction: NOP
    advance (4)
    jump (1BFE);

1BFE:

    #1BFE
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1BFF);

1BFF:

    #1BFF
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1C00);

1C00:

    #1C00
    #instruction: NOP
    advance (4)
    jump (1C01);

1C01:

    #1C01
    #instruction: NOP
    advance (4)
    jump (1C02);

1C02:

    #1C02
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1C03);

1C03:

    #1C03
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (1C04);

1C04:

    #1C04
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (1C05);

1C05:

    #1C05
    #instruction: LD   L,(HL)
    advance (7)
    L := M[(H,L)];
    jump (1C06);

1C06:

    #1C06
    #instruction: CALL PE,FAFA
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 09;
      #return-to: 1C09
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (FAFA);
    } else {
      advance (11)
      jump (1C09);
    }

1C07:

    #1C07
    #instruction: JP   MI,ECFA
    if (FlagS) {
      advance (10)
      jump (ECFA);
    } else {
      advance (10)
      jump (1C0A);
    }

1C08:

    #1C08
    #instruction: JP   MI,6EEC
    if (FlagS) {
      advance (10)
      jump (6EEC);
    } else {
      advance (10)
      jump (1C0B);
    }

1C09:

    #1C09
    #instruction: CALL PE,7A6E
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 0C;
      #return-to: 1C0C
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (7A6E);
    } else {
      advance (11)
      jump (1C0C);
    }

1C0A:

    #1C0A
    #instruction: LD   L,(HL)
    advance (7)
    L := M[(H,L)];
    jump (1C0B);

1C0B:

    #1C0B
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (1C0C);

1C0C:

    #1C0C
    #instruction: LD   A,C
    advance (5)
    A := C;
    jump (1C0D);

1C0D:

    #1C0D
    #instruction: ADD  HL,SP
    let:17 a1 = add17((SPH,SPL),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1C0E);

1C0E:

    #1C0E
    #instruction: NOP
    advance (4)
    jump (1C0F);

1C0F:

    #1C0F
    #instruction: NOP
    advance (4)
    jump (1C10);

1C10:

    #1C10
    #instruction: NOP
    advance (4)
    jump (1C11);

1C11:

    #1C11
    #instruction: NOP
    advance (4)
    jump (1C12);

1C12:

    #1C12
    #instruction: NOP
    advance (4)
    jump (1C13);

1C13:

    #1C13
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1C14);

1C14:

    #1C14
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C15);

1C15:

    #1C15
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C16);

1C16:

    #1C16
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (1C17);

1C17:

    #1C17
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C18);

1C18:

    #1C18
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C19);

1C19:

    #1C19
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C1A);

1C1A:

    #1C1A
    #instruction: LD   L,H
    advance (5)
    L := H;
    jump (1C1B);

1C1B:

    #1C1B
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C1C);

1C1C:

    #1C1C
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C1D);

1C1D:

    #1C1D
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1C1E);

1C1E:

    #1C1E
    #instruction: NOP
    advance (4)
    jump (1C1F);

1C1F:

    #1C1F
    #instruction: NOP
    advance (4)
    jump (1C20);

1C20:

    #1C20
    #instruction: NOP
    advance (4)
    jump (1C21);

1C21:

    #1C21
    #instruction: NOP
    advance (4)
    jump (1C22);

1C22:

    #1C22
    #instruction: NOP
    advance (4)
    jump (1C23);

1C23:

    #1C23
    #instruction: NOP
    advance (4)
    jump (1C24);

1C24:

    #1C24
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1C25);

1C25:

    #1C25
    #instruction: LD   A,(FA6D)
    advance (13)
    A := M[FA6D];
    jump (1C28);

1C26:

    #1C26
    #instruction: LD   L,L
    advance (5)
    jump (1C27);

1C27:

    #1C27
    #instruction: JP   MI,6DFA
    if (FlagS) {
      advance (10)
      jump (6DFA);
    } else {
      advance (10)
      jump (1C2A);
    }

1C28:

    #1C28
    #instruction: JP   MI,3A6D
    if (FlagS) {
      advance (10)
      jump (3A6D);
    } else {
      advance (10)
      jump (1C2B);
    }

1C29:

    #1C29
    #instruction: LD   L,L
    advance (5)
    jump (1C2A);

1C2A:

    #1C2A
    #instruction: LD   A,(0019)
    advance (13)
    A := 21;
    jump (1C2D);

1C2B:

    #1C2B
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1C2C);

1C2C:

    #1C2C
    #instruction: NOP
    advance (4)
    jump (1C2D);

1C2D:

    #1C2D
    #instruction: NOP
    advance (4)
    jump (1C2E);

1C2E:

    #1C2E
    #instruction: NOP
    advance (4)
    jump (1C2F);

1C2F:

    #1C2F
    #instruction: NOP
    advance (4)
    jump (1C30);

1C30:

    #1C30
    #instruction: NOP
    advance (4)
    jump (1C31);

1C31:

    #1C31
    #instruction: NOP
    advance (4)
    jump (1C32);

1C32:

    #1C32
    #instruction: *NOP
    advance (4)
    jump (1C33);

1C33:

    #1C33
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (1C34);

1C34:

    #1C34
    #instruction: LD   A,A
    advance (5)
    jump (1C35);

1C35:

    #1C35
    #instruction: LD   L,L
    advance (5)
    jump (1C36);

1C36:

    #1C36
    #instruction: CALL PE,FAFA
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 39;
      #return-to: 1C39
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (FAFA);
    } else {
      advance (11)
      jump (1C39);
    }

1C37:

    #1C37
    #instruction: JP   MI,ECFA
    if (FlagS) {
      advance (10)
      jump (ECFA);
    } else {
      advance (10)
      jump (1C3A);
    }

1C38:

    #1C38
    #instruction: JP   MI,6DEC
    if (FlagS) {
      advance (10)
      jump (6DEC);
    } else {
      advance (10)
      jump (1C3B);
    }

1C39:

    #1C39
    #instruction: CALL PE,7F6D
    if (FlagP) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 3C;
      #return-to: 1C3C
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (7F6D);
    } else {
      advance (11)
      jump (1C3C);
    }

1C3A:

    #1C3A
    #instruction: LD   L,L
    advance (5)
    jump (1C3B);

1C3B:

    #1C3B
    #instruction: LD   A,A
    advance (5)
    jump (1C3C);

1C3C:

    #1C3C
    #instruction: LD   A,D
    advance (5)
    A := D;
    jump (1C3D);

1C3D:

    #1C3D
    #instruction: *NOP
    advance (4)
    jump (1C3E);

1C3E:

    #1C3E
    #instruction: NOP
    advance (4)
    jump (1C3F);

1C3F:

    #1C3F
    #instruction: NOP
    advance (4)
    jump (1C40);

1C40:

    #1C40
    #instruction: NOP
    advance (4)
    jump (1C41);

1C41:

    #1C41
    #instruction: NOP
    advance (4)
    jump (1C42);

1C42:

    #1C42
    #instruction: NOP
    advance (4)
    jump (1C43);

1C43:

    #1C43
    #instruction: LD   C,18
    advance (7)
    C := 18;
    jump (1C45);

1C44:

    #1C44
    #instruction: *NOP
    advance (4)
    jump (1C45);

1C45:

    #1C45
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C46);

1C46:

    #1C46
    #instruction: LD   L,L
    advance (5)
    jump (1C47);

1C47:

    #1C47
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C48);

1C48:

    #1C48
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C49);

1C49:

    #1C49
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C4A);

1C4A:

    #1C4A
    #instruction: LD   L,L
    advance (5)
    jump (1C4B);

1C4B:

    #1C4B
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C4C);

1C4C:

    #1C4C
    #instruction: *NOP
    advance (4)
    jump (1C4D);

1C4D:

    #1C4D
    #instruction: LD   C,00
    advance (7)
    C := 00;
    jump (1C4F);

1C4E:

    #1C4E
    #instruction: NOP
    advance (4)
    jump (1C4F);

1C4F:

    #1C4F
    #instruction: NOP
    advance (4)
    jump (1C50);

1C50:

    #1C50
    #instruction: NOP
    advance (4)
    jump (1C51);

1C51:

    #1C51
    #instruction: NOP
    advance (4)
    jump (1C52);

1C52:

    #1C52
    #instruction: NOP
    advance (4)
    jump (1C53);

1C53:

    #1C53
    #instruction: NOP
    advance (4)
    jump (1C54);

1C54:

    #1C54
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1C55);

1C55:

    #1C55
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C56);

1C56:

    #1C56
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1C57);

1C57:

    #1C57
    #instruction: CALL MI,68FC
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 5A;
      #return-to: 1C5A
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (68FC);
    } else {
      advance (11)
      jump (1C5A);
    }

1C58:

    #1C58
    #instruction: CALL MI,3D68
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := 5B;
      #return-to: 1C5B
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3D68);
    } else {
      advance (11)
      jump (1C5B);
    }

1C59:

    #1C59
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1C5A);

1C5A:

    #1C5A
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C5B);

1C5B:

    #1C5B
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1C5C);

1C5C:

    #1C5C
    #instruction: NOP
    advance (4)
    jump (1C5D);

1C5D:

    #1C5D
    #instruction: NOP
    advance (4)
    jump (1C5E);

1C5E:

    #1C5E
    #instruction: NOP
    advance (4)
    jump (1C5F);

1C5F:

    #1C5F
    #instruction: NOP
    advance (4)
    jump (1C60);

1C60:

    #1C60
    #instruction: NOP
    advance (4)
    jump (1C61);

1C61:

    #1C61
    #instruction: NOP
    advance (4)
    jump (1C62);

1C62:

    #1C62
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C63);

1C63:

    #1C63
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C64);

1C64:

    #1C64
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C65);

1C65:

    #1C65
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C66);

1C66:

    #1C66
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C67);

1C67:

    #1C67
    #instruction: LD   A,A
    advance (5)
    jump (1C68);

1C68:

    #1C68
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1C;
    let:16 a2 = (-1 + a1) in
    M[a2] := 69;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1C69:

    #1C69
    #instruction: LD   A,A
    advance (5)
    jump (1C6A);

1C6A:

    #1C6A
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C6B);

1C6B:

    #1C6B
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C6C);

1C6C:

    #1C6C
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C6D);

1C6D:

    #1C6D
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1C6E);

1C6E:

    #1C6E
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C6F);

1C6F:

    #1C6F
    #instruction: NOP
    advance (4)
    jump (1C70);

1C70:

    #1C70
    #instruction: NOP
    advance (4)
    jump (1C71);

1C71:

    #1C71
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C72);

1C72:

    #1C72
    #instruction: LD   BC,0313
    advance (10)
    B := 03;
    C := 13;
    jump (1C75);

1C73:

    #1C73
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1C74);

1C74:

    #1C74
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1C75);

1C75:

    #1C75
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1C76);

1C76:

    #1C76
    #instruction: OR   E
    let:8 a1 = (E | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1C77);

1C77:

    #1C77
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C78);

1C78:

    #1C78
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (1C79);

1C79:

    #1C79
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1C7A);

1C7A:

    #1C7A
    #instruction: CPL
    advance (4)
    A := ~A;
    jump (1C7B);

1C7B:

    #1C7B
    #instruction: LD   C,C
    advance (5)
    jump (1C7C);

1C7C:

    #1C7C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C7D);

1C7D:

    #1C7D
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1C7E);

1C7E:

    #1C7E
    #instruction: NOP
    advance (4)
    jump (1C7F);

1C7F:

    #1C7F
    #instruction: LD   BC,0840
    advance (10)
    B := 08;
    C := 40;
    jump (1C82);

1C80:

    #1C80
    #instruction: LD   B,B
    advance (5)
    jump (1C81);

1C81:

    #1C81
    #instruction: *NOP
    advance (4)
    jump (1C82);

1C82:

    #1C82
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C83);

1C83:

    #1C83
    #instruction: AND  E
    let:8 a1 = (E & A) in
    let:8 a2 = (E | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1C84);

1C84:

    #1C84
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1C85);

1C85:

    #1C85
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1C86);

1C86:

    #1C86
    #instruction: LD   E,E
    advance (5)
    jump (1C87);

1C87:

    #1C87
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C88);

1C88:

    #1C88
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1C89);

1C89:

    #1C89
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1C8A);

1C8A:

    #1C8A
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1C8B);

1C8B:

    #1C8B
    #instruction: LD   C,E
    advance (5)
    C := E;
    jump (1C8C);

1C8C:

    #1C8C
    #instruction: LD   B,B
    advance (5)
    jump (1C8D);

1C8D:

    #1C8D
    #instruction: ADD  H
    let:16 a1 = addWithCarry(false,H,A) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1C8E);

1C8E:

    #1C8E
    #instruction: LD   DE,0F48
    advance (10)
    D := 0F;
    E := 48;
    jump (1C91);

1C8F:

    #1C8F
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1C90);

1C90:

    #1C90
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C91);

1C91:

    #1C91
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C92);

1C92:

    #1C92
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C93);

1C93:

    #1C93
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1C94);

1C94:

    #1C94
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1C95);

1C95:

    #1C95
    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C96);

1C96:

    #1C96
    #instruction: LD   A,7C
    advance (7)
    A := 7C;
    jump (1C98);

1C97:

    #1C97
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1C98);

1C98:

    #1C98
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1C99);

1C99:

    #1C99
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1C9A);

1C9A:

    #1C9A
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1C9B);

1C9B:

    #1C9B
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1C9C);

1C9C:

    #1C9C
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1C9E);

1C9D:

    #1C9D
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1C9E);

1C9E:

    #1C9E
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1CA0);

1C9F:

    #1C9F
    #instruction: *NOP
    advance (4)
    jump (1CA0);

1CA0:

    #1CA0
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CA1);

1CA1:

    #1CA1
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1CA2);

1CA2:

    #1CA2
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1CA3);

1CA3:

    #1CA3
    #instruction: *NOP
    advance (4)
    jump (1CA4);

1CA4:

    #1CA4
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1CA5);

1CA5:

    #1CA5
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1CA6);

1CA6:

    #1CA6
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1CA8);

1CA7:

    #1CA7
    #instruction: LD   DE,2604
    advance (10)
    D := 26;
    E := 04;
    jump (1CAA);

1CA8:

    #1CA8
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CA9);

1CA9:

    #1CA9
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (1CAB);

1CAA:

    #1CAA
    #instruction: NOP
    advance (4)
    jump (1CAB);

1CAB:

    #1CAB
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1CAC);

1CAC:

    #1CAC
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CAD);

1CAD:

    #1CAD
    #instruction: NOP
    advance (4)
    jump (1CAE);

1CAE:

    #1CAE
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CAF);

1CAF:

    #1CAF
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1CB0);

1CB0:

    #1CB0
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CB1);

1CB1:

    #1CB1
    #instruction: LD   H,13
    advance (7)
    H := 13;
    jump (1CB3);

1CB2:

    #1CB2
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1CB3);

1CB3:

    #1CB3
    #instruction: NOP
    advance (4)
    jump (1CB4);

1CB4:

    #1CB4
    #instruction: LD   BC,040B
    advance (10)
    B := 04;
    C := 0B;
    jump (1CB7);

1CB5:

    #1CB5
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1CB6);

1CB6:

    #1CB6
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CB7);

1CB7:

    #1CB7
    #instruction: *NOP
    advance (4)
    jump (1CB8);

1CB8:

    #1CB8
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1CB9);

1CB9:

    #1CB9
    #instruction: *NOP
    advance (4)
    jump (1CBA);

1CBA:

    #1CBA
    #instruction: *NOP
    advance (4)
    jump (1CBB);

1CBB:

    #1CBB
    #instruction: *NOP
    advance (4)
    jump (1CBC);

1CBC:

    #1CBC
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1CBD);

1CBD:

    #1CBD
    #instruction: *NOP
    advance (4)
    jump (1CBE);

1CBE:

    #1CBE
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1CBF);

1CBF:

    #1CBF
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1CC0);

1CC0:

    #1CC0
    #instruction: NOP
    advance (4)
    jump (1CC1);

1CC1:

    #1CC1
    #instruction: *NOP
    advance (4)
    jump (1CC2);

1CC2:

    #1CC2
    #instruction: LD   C,C
    advance (5)
    jump (1CC3);

1CC3:

    #1CC3
    #instruction: LD   (8114),HL
    M[8114] := L;
    M[8115] := H;
    advance (16)
    jump (1CC6);

1CC4:

    #1CC4
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CC5);

1CC5:

    #1CC5
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CC6);

1CC6:

    #1CC6
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (1CC7);

1CC7:

    #1CC7
    #instruction: NOP
    advance (4)
    jump (1CC8);

1CC8:

    #1CC8
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (1CC9);

1CC9:

    #1CC9
    #instruction: ADD  C
    let:16 a1 = addWithCarry(false,C,A) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CCA);

1CCA:

    #1CCA
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CCB);

1CCB:

    #1CCB
    #instruction: LD   (0849),HL
    M[0849] := L;
    M[084A] := H;
    advance (16)
    jump (1CCE);

1CCC:

    #1CCC
    #instruction: LD   C,C
    advance (5)
    jump (1CCD);

1CCD:

    #1CCD
    #instruction: *NOP
    advance (4)
    jump (1CCE);

1CCE:

    #1CCE
    #instruction: NOP
    advance (4)
    jump (1CCF);

1CCF:

    #1CCF
    #instruction: NOP
    advance (4)
    jump (1CD0);

1CD0:

    #1CD0
    #instruction: LD   B,H
    advance (5)
    B := H;
    jump (1CD1);

1CD1:

    #1CD1
    #instruction: XOR  D
    let:8 a1 = (D ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1CD2);

1CD2:

    #1CD2
    #instruction: *NOP
    advance (4)
    jump (1CD3);

1CD3:

    #1CD3
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CD4);

1CD4:

    #1CD4
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (1CD5);

1CD5:

    #1CD5
    #instruction: LD   (AA10),HL
    M[AA10] := L;
    M[AA11] := H;
    advance (16)
    jump (1CD8);

1CD6:

    #1CD6
    #instruction: *NOP
    advance (4)
    jump (1CD7);

1CD7:

    #1CD7
    #instruction: XOR  D
    let:8 a1 = (D ^ A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1CD8);

1CD8:

    #1CD8
    #instruction: LD   B,H
    advance (5)
    B := H;
    jump (1CD9);

1CD9:

    #1CD9
    #instruction: LD   (8854),HL
    M[8854] := L;
    M[8855] := H;
    advance (16)
    jump (1CDC);

1CDA:

    #1CDA
    #instruction: LD   D,H
    advance (5)
    D := H;
    jump (1CDB);

1CDB:

    #1CDB
    #instruction: ADC  B
    let:16 a1 = addWithCarry(FlagCY,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CDC);

1CDC:

    #1CDC
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (1CDD);

1CDD:

    #1CDD
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CDE);

1CDE:

    #1CDE
    #instruction: CP   (HL)
    let:16 a1 = addWithCarry(!false,A,~M[(H,L)]) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~M[(H,L)] & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CDF);

1CDF:

    #1CDF
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (1CE0);

1CE0:

    #1CE0
    #instruction: LD   E,(HL)
    advance (7)
    E := M[(H,L)];
    jump (1CE1);

1CE1:

    #1CE1
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CE2);

1CE2:

    #1CE2
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CE3);

1CE3:

    #1CE3
    #instruction: CALL MI,1004
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := E6;
      #return-to: 1CE6
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (1004);
    } else {
      advance (11)
      jump (1CE6);
    }

1CE4:

    #1CE4
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CE5);

1CE5:

    #1CE5
    #instruction: *NOP
    advance (4)
    jump (1CE6);

1CE6:

    #1CE6
    #instruction: CALL MI,2010
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := E9;
      #return-to: 1CE9
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (2010);
    } else {
      advance (11)
      jump (1CE9);
    }

1CE7:

    #1CE7
    #instruction: *NOP
    advance (4)
    jump (1CE8);

1CE8:

    #1CE8
    #instruction: *NOP
    advance (4)
    jump (1CE9);

1CE9:

    #1CE9
    #instruction: CALL MI,8020
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := EC;
      #return-to: 1CEC
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (8020);
    } else {
      advance (11)
      jump (1CEC);
    }

1CEA:

    #1CEA
    #instruction: *NOP
    advance (4)
    jump (1CEB);

1CEB:

    #1CEB
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CEC);

1CEC:

    #1CEC
    #instruction: CALL MI,0080
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1C;
      let:16 a2 = (-1 + a1) in
      M[a2] := EF;
      #return-to: 1CEF
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (0080);
    } else {
      advance (11)
      jump (1CEF);
    }

1CED:

    #1CED
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1CEE);

1CEE:

    #1CEE
    #instruction: NOP
    advance (4)
    jump (1CEF);

1CEF:

    #1CEF
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CF1);

1CF0:

    #1CF0
    #instruction: NOP
    advance (4)
    jump (1CF1);

1CF1:

    #1CF1
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1CF2);

1CF2:

    #1CF2
    #instruction: CP   12
    let:16 a1 = addWithCarry(!false,A,~12) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~12 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CF4);

1CF3:

    #1CF3
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1CF4);

1CF4:

    #1CF4
    #instruction: NOP
    advance (4)
    jump (1CF5);

1CF5:

    #1CF5
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CF7);

1CF6:

    #1CF6
    #instruction: NOP
    advance (4)
    jump (1CF7);

1CF7:

    #1CF7
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1CF8);

1CF8:

    #1CF8
    #instruction: CP   90
    let:16 a1 = addWithCarry(!false,A,~90) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~90 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CFA);

1CF9:

    #1CF9
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1CFA);

1CFA:

    #1CFA
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1CFB);

1CFB:

    #1CFB
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1CFC);

1CFC:

    #1CFC
    #instruction: NOP
    advance (4)
    jump (1CFD);

1CFD:

    #1CFD
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1CFE);

1CFE:

    #1CFE
    #instruction: NOP
    advance (4)
    jump (1CFF);

1CFF:

    #1CFF
    #instruction: NOP
    advance (4)
    jump (1D00);

1D00:

    #1D00
    #instruction: LD   BC,0107
    advance (10)
    B := 01;
    C := 07;
    jump (1D03);

1D01:

    #1D01
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1D02);

1D02:

    #1D02
    #instruction: LD   BC,0101
    advance (10)
    B := 01;
    C := 01;
    jump (1D05);

1D03:

    #1D03
    #instruction: LD   BC,0401
    advance (10)
    B := 04;
    C := 01;
    jump (1D06);

1D04:

    #1D04
    #instruction: LD   BC,0B04
    advance (10)
    B := 0B;
    C := 04;
    jump (1D07);

1D05:

    #1D05
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D06);

1D06:

    #1D06
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1D07);

1D07:

    #1D07
    #instruction: LD   BC,0306
    advance (10)
    B := 03;
    C := 06;
    jump (1D0A);

1D08:

    #1D08
    #instruction: LD   B,03
    advance (7)
    B := 03;
    jump (1D0A);

1D09:

    #1D09
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1D0A);

1D0A:

    #1D0A
    #instruction: LD   BC,0B01
    advance (10)
    B := 0B;
    C := 01;
    jump (1D0D);

1D0B:

    #1D0B
    #instruction: LD   BC,090B
    advance (10)
    B := 09;
    C := 0B;
    jump (1D0E);

1D0C:

    #1D0C
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1D0D);

1D0D:

    #1D0D
    #instruction: ADD  HL,BC
    let:17 a1 = add17((B,C),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1D0E);

1D0E:

    #1D0E
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1D0F);

1D0F:

    #1D0F
    #instruction: *NOP
    advance (4)
    jump (1D10);

1D10:

    #1D10
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1D11);

1D11:

    #1D11
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1D12);

1D12:

    #1D12
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D13);

1D13:

    #1D13
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1D14);

1D14:

    #1D14
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1D15);

1D15:

    #1D15
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D16);

1D16:

    #1D16
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1D17);

1D17:

    #1D17
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D18);

1D18:

    #1D18
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D19);

1D19:

    #1D19
    #instruction: LD   B,07
    advance (7)
    B := 07;
    jump (1D1B);

1D1A:

    #1D1A
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1D1B);

1D1B:

    #1D1B
    #instruction: *NOP
    advance (4)
    jump (1D1C);

1D1C:

    #1D1C
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1D1D);

1D1D:

    #1D1D
    #instruction: LD   B,0A
    advance (7)
    B := 0A;
    jump (1D1F);

1D1E:

    #1D1E
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1D1F);

1D1F:

    #1D1F
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1D20);

1D20:

    #1D20
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 21;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D21:

    #1D21
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1D22);

1D22:

    #1D22
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 23;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D23:

    #1D23
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1D24);

1D24:

    #1D24
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 25;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D25:

    #1D25
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (1D26);

1D26:

    #1D26
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D27:

    #1D27
    #instruction: LD   A,A
    advance (5)
    jump (1D28);

1D28:

    #1D28
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 29;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D29:

    #1D29
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2A;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D2A:

    #1D2A
    #instruction: CALL MI,F8FF
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1D;
      let:16 a2 = (-1 + a1) in
      M[a2] := 2D;
      #return-to: 1D2D
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (F8FF);
    } else {
      advance (11)
      jump (1D2D);
    }

1D2B:

    #1D2B
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2C;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D2C:

    #1D2C
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D2D);
    }

1D2D:

    #1D2D
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2E;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D2E:

    #1D2E
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D2F);
    }

1D2F:

    #1D2F
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D30:

    #1D30
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D31);
    }

1D31:

    #1D31
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 32;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D32:

    #1D32
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D33);
    }

1D33:

    #1D33
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 34;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D34:

    #1D34
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D35);
    }

1D35:

    #1D35
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 36;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D36:

    #1D36
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D37);
    }

1D37:

    #1D37
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 38;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D38:

    #1D38
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D39);
    }

1D39:

    #1D39
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3A;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D3A:

    #1D3A
    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D3B);
    }

1D3B:

    #1D3B
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D3C:

    #1D3C
    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1D3D);
    }

1D3D:

    #1D3D
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3E;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D3E:

    #1D3E
    #instruction: CALL MI,FFFF
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1D;
      let:16 a2 = (-1 + a1) in
      M[a2] := 41;
      #return-to: 1D41
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (FFFF);
    } else {
      advance (11)
      jump (1D41);
    }

1D3F:

    #1D3F
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 40;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D40:

    #1D40
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 41;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D41:

    #1D41
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 42;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D42:

    #1D42
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 43;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D43:

    #1D43
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 44;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D44:

    #1D44
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 45;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D45:

    #1D45
    #instruction: LD   A,A
    advance (5)
    jump (1D46);

1D46:

    #1D46
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 47;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D47:

    #1D47
    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump (1D48);

1D48:

    #1D48
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 49;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D49:

    #1D49
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1D4A);

1D4A:

    #1D4A
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4B;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1D4B:

    #1D4B
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1D4C);

1D4C:

    #1D4C
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D4D);

1D4D:

    #1D4D
    #instruction: *NOP
    advance (4)
    jump (1D4E);

1D4E:

    #1D4E
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D4F);

1D4F:

    #1D4F
    #instruction: *NOP
    advance (4)
    jump (1D50);

1D50:

    #1D50
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D51);

1D51:

    #1D51
    #instruction: SUB  A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D52);

1D52:

    #1D52
    #instruction: SBC  D
    let:16 a1 = addWithCarry(!FlagCY,A,~D) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~D & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D53);

1D53:

    #1D53
    #instruction: SBC  L
    let:16 a1 = addWithCarry(!FlagCY,A,~L) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~L & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D54);

1D54:

    #1D54
    #instruction: *NOP
    advance (4)
    jump (1D55);

1D55:

    #1D55
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D56);

1D56:

    #1D56
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D57);

1D57:

    #1D57
    #instruction: *NOP
    advance (4)
    jump (1D58);

1D58:

    #1D58
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D59);

1D59:

    #1D59
    #instruction: *NOP
    advance (4)
    jump (1D5A);

1D5A:

    #1D5A
    #instruction: *NOP
    advance (4)
    jump (1D5B);

1D5B:

    #1D5B
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D5C);

1D5C:

    #1D5C
    #instruction: *NOP
    advance (4)
    jump (1D5D);

1D5D:

    #1D5D
    #instruction: *NOP
    advance (4)
    jump (1D5E);

1D5E:

    #1D5E
    #instruction: *NOP
    advance (4)
    jump (1D5F);

1D5F:

    #1D5F
    #instruction: *NOP
    advance (4)
    jump (1D60);

1D60:

    #1D60
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D61);

1D61:

    #1D61
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D62);

1D62:

    #1D62
    #instruction: *NOP
    advance (4)
    jump (1D63);

1D63:

    #1D63
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D64);

1D64:

    #1D64
    #instruction: NOP
    advance (4)
    jump (1D65);

1D65:

    #1D65
    #instruction: NOP
    advance (4)
    jump (1D66);

1D66:

    #1D66
    #instruction: NOP
    advance (4)
    jump (1D67);

1D67:

    #1D67
    #instruction: NOP
    advance (4)
    jump (1D68);

1D68:

    #1D68
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D69);

1D69:

    #1D69
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D6A);

1D6A:

    #1D6A
    #instruction: LD   E,37
    advance (7)
    E := 37;
    jump (1D6C);

1D6B:

    #1D6B
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (1D6C);

1D6C:

    #1D6C
    #instruction: LD   A,7C
    advance (7)
    A := 7C;
    jump (1D6E);

1D6D:

    #1D6D
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1D6E);

1D6E:

    #1D6E
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1D6F);

1D6F:

    #1D6F
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1D70);

1D70:

    #1D70
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1D71);

1D71:

    #1D71
    #instruction: LD   (HL),H
    M[(H,L)] := H;
    advance (7)
    jump (1D72);

1D72:

    #1D72
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1D73);

1D73:

    #1D73
    #instruction: LD   A,37
    advance (7)
    A := 37;
    jump (1D75);

1D74:

    #1D74
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (1D75);

1D75:

    #1D75
    #instruction: LD   E,0C
    advance (7)
    E := 0C;
    jump (1D77);

1D76:

    #1D76
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D77);

1D77:

    #1D77
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D78);

1D78:

    #1D78
    #instruction: NOP
    advance (4)
    jump (1D79);

1D79:

    #1D79
    #instruction: NOP
    advance (4)
    jump (1D7A);

1D7A:

    #1D7A
    #instruction: NOP
    advance (4)
    jump (1D7B);

1D7B:

    #1D7B
    #instruction: NOP
    advance (4)
    jump (1D7C);

1D7C:

    #1D7C
    #instruction: NOP
    advance (4)
    jump (1D7D);

1D7D:

    #1D7D
    #instruction: LD   (A500),HL
    M[A500] := L;
    M[A501] := H;
    advance (16)
    jump (1D80);

1D7E:

    #1D7E
    #instruction: NOP
    advance (4)
    jump (1D7F);

1D7F:

    #1D7F
    #instruction: AND  L
    let:8 a1 = (L & A) in
    let:8 a2 = (L | A) in
    advance (4)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump (1D80);

1D80:

    #1D80
    #instruction: LD   B,B
    advance (5)
    jump (1D81);

1D81:

    #1D81
    #instruction: *NOP
    advance (4)
    jump (1D82);

1D82:

    #1D82
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D83);

1D83:

    #1D83
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D84);

1D84:

    #1D84
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1D85);

1D85:

    #1D85
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D86);

1D86:

    #1D86
    #instruction: LD   (HL),1D
    M[(H,L)] := 1D;
    advance (10)
    jump (1D88);

1D87:

    #1D87
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D88);

1D88:

    #1D88
    #instruction: *NOP
    advance (4)
    jump (1D89);

1D89:

    #1D89
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1D8A);

1D8A:

    #1D8A
    #instruction: LD   H,D
    advance (5)
    H := D;
    jump (1D8B);

1D8B:

    #1D8B
    #instruction: OR   (HL)
    let:8 a1 = (M[(H,L)] | A) in
    advance (7)
    A := a1;
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump (1D8C);

1D8C:

    #1D8C
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D8D);

1D8D:

    #1D8D
    #instruction: SBC  B
    let:16 a1 = addWithCarry(!FlagCY,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D8E);

1D8E:

    #1D8E
    #instruction: *NOP
    advance (4)
    jump (1D8F);

1D8F:

    #1D8F
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (1D90);

1D90:

    #1D90
    #instruction: SUB  B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1D91);

1D91:

    #1D91
    #instruction: *NOP
    advance (4)
    jump (1D92);

1D92:

    #1D92
    #instruction: NOP
    advance (4)
    jump (1D93);

1D93:

    #1D93
    #instruction: NOP
    advance (4)
    jump (1D94);

1D94:

    #1D94
    #instruction: LD   H,1F
    advance (7)
    H := 1F;
    jump (1D96);

1D95:

    #1D95
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1D96);

1D96:

    #1D96
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1D97);

1D97:

    #1D97
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1D98);

1D98:

    #1D98
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1D99);

1D99:

    #1D99
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1D9A);

1D9A:

    #1D9A
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1D9B);

1D9B:

    #1D9B
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1D9C);

1D9C:

    #1D9C
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1D9D);

1D9D:

    #1D9D
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1D9E);

1D9E:

    #1D9E
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1D9F);

1D9F:

    #1D9F
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1DA0);

1DA0:

    #1DA0
    #instruction: *NOP
    advance (4)
    jump (1DA1);

1DA1:

    #1DA1
    #instruction: *NOP
    advance (4)
    jump (1DA2);

1DA2:

    #1DA2
    #instruction: *NOP
    advance (4)
    jump (1DA3);

1DA3:

    #1DA3
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1DA4);

1DA4:

    #1DA4
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1DA5);

1DA5:

    #1DA5
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1DA6);

1DA6:

    #1DA6
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1DA7);

1DA7:

    #1DA7
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1DA8);

1DA8:

    #1DA8
    #instruction: LD   B,B
    advance (5)
    jump (1DA9);

1DA9:

    #1DA9
    #instruction: LD   B,B
    advance (5)
    jump (1DAA);

1DAA:

    #1DAA
    #instruction: LD   B,B
    advance (5)
    jump (1DAB);

1DAB:

    #1DAB
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1DAC);

1DAC:

    #1DAC
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1DAD);

1DAD:

    #1DAD
    #instruction: NOP
    advance (4)
    jump (1DAE);

1DAE:

    #1DAE
    #instruction: *NOP
    advance (4)
    jump (1DAF);

1DAF:

    #1DAF
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1DB0);

1DB0:

    #1DB0
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1DB1);

1DB1:

    #1DB1
    #instruction: NOP
    advance (4)
    jump (1DB2);

1DB2:

    #1DB2
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1DB3);

1DB3:

    #1DB3
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DB4);

1DB4:

    #1DB4
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1DB6);

1DB5:

    #1DB5
    #instruction: LD   H,08
    advance (7)
    H := 08;
    jump (1DB7);

1DB6:

    #1DB6
    #instruction: *NOP
    advance (4)
    jump (1DB7);

1DB7:

    #1DB7
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DB8);

1DB8:

    #1DB8
    #instruction: DEC  D
    let:16 a1 = addWithCarry(!true,D,~00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DB9);

1DB9:

    #1DB9
    #instruction: NOP
    advance (4)
    jump (1DBA);

1DBA:

    #1DBA
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1DBB);

1DBB:

    #1DBB
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DBC);

1DBC:

    #1DBC
    #instruction: LD   DE,0E12
    advance (10)
    D := 0E;
    E := 12;
    jump (1DBF);

1DBD:

    #1DBD
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1DBE);

1DBE:

    #1DBE
    #instruction: LD   C,2C
    advance (7)
    C := 2C;
    jump (1DC0);

1DBF:

    #1DBF
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC0);

1DC0:

    #1DC0
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1DC1);

1DC1:

    #1DC1
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC2);

1DC2:

    #1DC2
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC3);

1DC3:

    #1DC3
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC4);

1DC4:

    #1DC4
    #instruction: *NOP
    advance (4)
    jump (1DC5);

1DC5:

    #1DC5
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC6);

1DC6:

    #1DC6
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1DC7);

1DC7:

    #1DC7
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DC8);

1DC8:

    #1DC8
    #instruction: LD   B,B
    advance (5)
    jump (1DC9);

1DC9:

    #1DC9
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DCA);

1DCA:

    #1DCA
    #instruction: *NOP
    advance (4)
    jump (1DCB);

1DCB:

    #1DCB
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,L,00) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    L := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DCC);

1DCC:

    #1DCC
    #instruction: NOP
    advance (4)
    jump (1DCD);

1DCD:

    #1DCD
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DCE);

1DCE:

    #1DCE
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := CF;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1DCF:

    #1DCF
    #instruction: LD   C,2E
    advance (7)
    C := 2E;
    jump (1DD1);

1DD0:

    #1DD0
    #instruction: LD   L,E0
    advance (7)
    L := E0;
    jump (1DD2);

1DD1:

    #1DD1
    #instruction: RET  PO
    if (!FlagP) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1DD2);
    }

1DD2:

    #1DD2
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DD3);

1DD3:

    #1DD3
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DD4);

1DD4:

    #1DD4
    #instruction: LD   L,EA
    advance (7)
    L := EA;
    jump (1DD6);

1DD5:

    #1DD5
    #instruction: JP   PE,0A1D
    if (FlagP) {
      advance (10)
      jump (0A1D);
    } else {
      advance (10)
      jump (1DD8);
    }

1DD6:

    #1DD6
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DD7);

1DD7:

    #1DD7
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1DD8);

1DD8:

    #1DD8
    #instruction: LD   L,F4
    advance (7)
    L := F4;
    jump (1DDA);

1DD9:

    #1DD9
    #instruction: CALL P,081D
    if (!FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1D;
      let:16 a2 = (-1 + a1) in
      M[a2] := DC;
      #return-to: 1DDC
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (081D);
    } else {
      advance (11)
      jump (1DDC);
    }

1DDA:

    #1DDA
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DDB);

1DDB:

    #1DDB
    #instruction: *NOP
    advance (4)
    jump (1DDC);

1DDC:

    #1DDC
    #instruction: LD   L,99
    advance (7)
    L := 99;
    jump (1DDE);

1DDD:

    #1DDD
    #instruction: SBC  C
    let:16 a1 = addWithCarry(!FlagCY,A,~C) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~C & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1DDE);

1DDE:

    #1DDE
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DDF);

1DDF:

    #1DDF
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E0;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1DE0:

    #1DE0
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1DE1);

1DE1:

    #1DE1
    #instruction: *NOP
    advance (4)
    jump (1DE2);

1DE2:

    #1DE2
    #instruction: LD   H,0C
    advance (7)
    H := 0C;
    jump (1DE4);

1DE3:

    #1DE3
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DE4);

1DE4:

    #1DE4
    #instruction: *NOP
    advance (4)
    jump (1DE5);

1DE5:

    #1DE5
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1DE6);

1DE6:

    #1DE6
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1DE7);

1DE7:

    #1DE7
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DE8);

1DE8:

    #1DE8
    #instruction: LD   DE,2718
    advance (10)
    D := 27;
    E := 18;
    jump (1DEB);

1DE9:

    #1DE9
    #instruction: *NOP
    advance (4)
    jump (1DEA);

1DEA:

    #1DEA
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1DEB);

1DEB:

    #1DEB
    #instruction: DEC  E
    let:16 a1 = addWithCarry(!true,E,~00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DEC);

1DEC:

    #1DEC
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1DED);

1DED:

    #1DED
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1DEF);

1DEE:

    #1DEE
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1DEF);

1DEF:

    #1DEF
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1DF1);

1DF0:

    #1DF0
    #instruction: *NOP
    advance (4)
    jump (1DF1);

1DF1:

    #1DF1
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DF2);

1DF2:

    #1DF2
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1DF3);

1DF3:

    #1DF3
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1DF4);

1DF4:

    #1DF4
    #instruction: DAA
    let:8 a1 = (A & 0F) in
    let:16 a2 = addWithCarry(false,a1,06) in
    let:16 a3 = addWithCarry(((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4],(A >> 04),00) in
    let:16 a4 = addWithCarry(false,a3[7:0],06) in
    let:8 a5 = (((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1) & 0F) in
    let:8 a6 = ((((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0]) << 04) | a5) in
    advance (4)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := ((((a1[1] || a1[2]) && a1[3]) || FlagA) ? a2[7:0] : a1)[4];
    FlagP := parity(a6);
    FlagCY := (((((a3[7:0][1] || a3[7:0][2]) && a3[7:0][3]) || FlagCY) ? a4[7:0] : a3[7:0])[4] || FlagCY);
    jump (1DF5);

1DF5:

    #1DF5
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DF6);

1DF6:

    #1DF6
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1DF7);

1DF7:

    #1DF7
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1DF9);

1DF8:

    #1DF8
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1DF9);

1DF9:

    #1DF9
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1DFB);

1DFA:

    #1DFA
    #instruction: *NOP
    advance (4)
    jump (1DFB);

1DFB:

    #1DFB
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1DFC);

1DFC:

    #1DFC
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1DFD);

1DFD:

    #1DFD
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1DFE);

1DFE:

    #1DFE
    #instruction: NOP
    advance (4)
    jump (1DFF);

1DFF:

    #1DFF
    #instruction: NOP
    advance (4)
    jump (1E00);

1E00:

    #1E00
    #instruction: NOP
    advance (4)
    jump (1E01);

1E01:

    #1E01
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1E02);

1E02:

    #1E02
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1E03);

1E03:

    #1E03
    #instruction: LD   B,H
    advance (5)
    B := H;
    jump (1E04);

1E04:

    #1E04
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1E05);

1E05:

    #1E05
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1E06);

1E06:

    #1E06
    #instruction: NOP
    advance (4)
    jump (1E07);

1E07:

    #1E07
    #instruction: NOP
    advance (4)
    jump (1E08);

1E08:

    #1E08
    #instruction: NOP
    advance (4)
    jump (1E09);

1E09:

    #1E09
    #instruction: LD   A,A
    advance (5)
    jump (1E0A);

1E0A:

    #1E0A
    #instruction: LD   C,C
    advance (5)
    jump (1E0B);

1E0B:

    #1E0B
    #instruction: LD   C,C
    advance (5)
    jump (1E0C);

1E0C:

    #1E0C
    #instruction: LD   C,C
    advance (5)
    jump (1E0D);

1E0D:

    #1E0D
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (1E0F);

1E0E:

    #1E0E
    #instruction: NOP
    advance (4)
    jump (1E0F);

1E0F:

    #1E0F
    #instruction: NOP
    advance (4)
    jump (1E10);

1E10:

    #1E10
    #instruction: NOP
    advance (4)
    jump (1E11);

1E11:

    #1E11
    #instruction: LD   A,41
    advance (7)
    A := 41;
    jump (1E13);

1E12:

    #1E12
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E13);

1E13:

    #1E13
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E14);

1E14:

    #1E14
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E15);

1E15:

    #1E15
    #instruction: LD   (0000),HL
    M[0000] := L;
    M[0001] := H;
    advance (16)
    jump (1E18);

1E16:

    #1E16
    #instruction: NOP
    advance (4)
    jump (1E17);

1E17:

    #1E17
    #instruction: NOP
    advance (4)
    jump (1E18);

1E18:

    #1E18
    #instruction: NOP
    advance (4)
    jump (1E19);

1E19:

    #1E19
    #instruction: LD   A,A
    advance (5)
    jump (1E1A);

1E1A:

    #1E1A
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E1B);

1E1B:

    #1E1B
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E1C);

1E1C:

    #1E1C
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E1D);

1E1D:

    #1E1D
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (1E1F);

1E1E:

    #1E1E
    #instruction: NOP
    advance (4)
    jump (1E1F);

1E1F:

    #1E1F
    #instruction: NOP
    advance (4)
    jump (1E20);

1E20:

    #1E20
    #instruction: NOP
    advance (4)
    jump (1E21);

1E21:

    #1E21
    #instruction: LD   A,A
    advance (5)
    jump (1E22);

1E22:

    #1E22
    #instruction: LD   C,C
    advance (5)
    jump (1E23);

1E23:

    #1E23
    #instruction: LD   C,C
    advance (5)
    jump (1E24);

1E24:

    #1E24
    #instruction: LD   C,C
    advance (5)
    jump (1E25);

1E25:

    #1E25
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E26);

1E26:

    #1E26
    #instruction: NOP
    advance (4)
    jump (1E27);

1E27:

    #1E27
    #instruction: NOP
    advance (4)
    jump (1E28);

1E28:

    #1E28
    #instruction: NOP
    advance (4)
    jump (1E29);

1E29:

    #1E29
    #instruction: LD   A,A
    advance (5)
    jump (1E2A);

1E2A:

    #1E2A
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E2B);

1E2B:

    #1E2B
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E2C);

1E2C:

    #1E2C
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E2D);

1E2D:

    #1E2D
    #instruction: LD   B,B
    advance (5)
    jump (1E2E);

1E2E:

    #1E2E
    #instruction: NOP
    advance (4)
    jump (1E2F);

1E2F:

    #1E2F
    #instruction: NOP
    advance (4)
    jump (1E30);

1E30:

    #1E30
    #instruction: NOP
    advance (4)
    jump (1E31);

1E31:

    #1E31
    #instruction: LD   A,41
    advance (7)
    A := 41;
    jump (1E33);

1E32:

    #1E32
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E33);

1E33:

    #1E33
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E34);

1E34:

    #1E34
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1E35);

1E35:

    #1E35
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (1E36);

1E36:

    #1E36
    #instruction: NOP
    advance (4)
    jump (1E37);

1E37:

    #1E37
    #instruction: NOP
    advance (4)
    jump (1E38);

1E38:

    #1E38
    #instruction: NOP
    advance (4)
    jump (1E39);

1E39:

    #1E39
    #instruction: LD   A,A
    advance (5)
    jump (1E3A);

1E3A:

    #1E3A
    #instruction: *NOP
    advance (4)
    jump (1E3B);

1E3B:

    #1E3B
    #instruction: *NOP
    advance (4)
    jump (1E3C);

1E3C:

    #1E3C
    #instruction: *NOP
    advance (4)
    jump (1E3D);

1E3D:

    #1E3D
    #instruction: LD   A,A
    advance (5)
    jump (1E3E);

1E3E:

    #1E3E
    #instruction: NOP
    advance (4)
    jump (1E3F);

1E3F:

    #1E3F
    #instruction: NOP
    advance (4)
    jump (1E40);

1E40:

    #1E40
    #instruction: NOP
    advance (4)
    jump (1E41);

1E41:

    #1E41
    #instruction: NOP
    advance (4)
    jump (1E42);

1E42:

    #1E42
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E43);

1E43:

    #1E43
    #instruction: LD   A,A
    advance (5)
    jump (1E44);

1E44:

    #1E44
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E45);

1E45:

    #1E45
    #instruction: NOP
    advance (4)
    jump (1E46);

1E46:

    #1E46
    #instruction: NOP
    advance (4)
    jump (1E47);

1E47:

    #1E47
    #instruction: NOP
    advance (4)
    jump (1E48);

1E48:

    #1E48
    #instruction: NOP
    advance (4)
    jump (1E49);

1E49:

    #1E49
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1E4A);

1E4A:

    #1E4A
    #instruction: LD   BC,0101
    advance (10)
    B := 01;
    C := 01;
    jump (1E4D);

1E4B:

    #1E4B
    #instruction: LD   BC,7E01
    advance (10)
    B := 7E;
    C := 01;
    jump (1E4E);

1E4C:

    #1E4C
    #instruction: LD   BC,007E
    advance (10)
    B := 00;
    C := 7E;
    jump (1E4F);

1E4D:

    #1E4D
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1E4E);

1E4E:

    #1E4E
    #instruction: NOP
    advance (4)
    jump (1E4F);

1E4F:

    #1E4F
    #instruction: NOP
    advance (4)
    jump (1E50);

1E50:

    #1E50
    #instruction: NOP
    advance (4)
    jump (1E51);

1E51:

    #1E51
    #instruction: LD   A,A
    advance (5)
    jump (1E52);

1E52:

    #1E52
    #instruction: *NOP
    advance (4)
    jump (1E53);

1E53:

    #1E53
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1E54);

1E54:

    #1E54
    #instruction: LD   (0041),HL
    M[0041] := L;
    M[0042] := H;
    advance (16)
    jump (1E57);

1E55:

    #1E55
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E56);

1E56:

    #1E56
    #instruction: NOP
    advance (4)
    jump (1E57);

1E57:

    #1E57
    #instruction: NOP
    advance (4)
    jump (1E58);

1E58:

    #1E58
    #instruction: NOP
    advance (4)
    jump (1E59);

1E59:

    #1E59
    #instruction: LD   A,A
    advance (5)
    jump (1E5A);

1E5A:

    #1E5A
    #instruction: LD   BC,0101
    advance (10)
    B := 01;
    C := 01;
    jump (1E5D);

1E5B:

    #1E5B
    #instruction: LD   BC,0101
    advance (10)
    B := 01;
    C := 01;
    jump (1E5E);

1E5C:

    #1E5C
    #instruction: LD   BC,0001
    advance (10)
    B := 00;
    C := 01;
    jump (1E5F);

1E5D:

    #1E5D
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1E60);

1E5E:

    #1E5E
    #instruction: NOP
    advance (4)
    jump (1E5F);

1E5F:

    #1E5F
    #instruction: NOP
    advance (4)
    jump (1E60);

1E60:

    #1E60
    #instruction: NOP
    advance (4)
    jump (1E61);

1E61:

    #1E61
    #instruction: LD   A,A
    advance (5)
    jump (1E62);

1E62:

    #1E62
    #instruction: *NOP
    advance (4)
    jump (1E63);

1E63:

    #1E63
    #instruction: *NOP
    advance (4)
    jump (1E64);

1E64:

    #1E64
    #instruction: *NOP
    advance (4)
    jump (1E65);

1E65:

    #1E65
    #instruction: LD   A,A
    advance (5)
    jump (1E66);

1E66:

    #1E66
    #instruction: NOP
    advance (4)
    jump (1E67);

1E67:

    #1E67
    #instruction: NOP
    advance (4)
    jump (1E68);

1E68:

    #1E68
    #instruction: NOP
    advance (4)
    jump (1E69);

1E69:

    #1E69
    #instruction: LD   A,A
    advance (5)
    jump (1E6A);

1E6A:

    #1E6A
    #instruction: *NOP
    advance (4)
    jump (1E6B);

1E6B:

    #1E6B
    #instruction: *NOP
    advance (4)
    jump (1E6C);

1E6C:

    #1E6C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1E6D);

1E6D:

    #1E6D
    #instruction: LD   A,A
    advance (5)
    jump (1E6E);

1E6E:

    #1E6E
    #instruction: NOP
    advance (4)
    jump (1E6F);

1E6F:

    #1E6F
    #instruction: NOP
    advance (4)
    jump (1E70);

1E70:

    #1E70
    #instruction: NOP
    advance (4)
    jump (1E71);

1E71:

    #1E71
    #instruction: LD   A,41
    advance (7)
    A := 41;
    jump (1E73);

1E72:

    #1E72
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E73);

1E73:

    #1E73
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E74);

1E74:

    #1E74
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E75);

1E75:

    #1E75
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (1E77);

1E76:

    #1E76
    #instruction: NOP
    advance (4)
    jump (1E77);

1E77:

    #1E77
    #instruction: NOP
    advance (4)
    jump (1E78);

1E78:

    #1E78
    #instruction: NOP
    advance (4)
    jump (1E79);

1E79:

    #1E79
    #instruction: LD   A,A
    advance (5)
    jump (1E7A);

1E7A:

    #1E7A
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E7B);

1E7B:

    #1E7B
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E7C);

1E7C:

    #1E7C
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E7D);

1E7D:

    #1E7D
    #instruction: *NOP
    advance (4)
    jump (1E7E);

1E7E:

    #1E7E
    #instruction: NOP
    advance (4)
    jump (1E7F);

1E7F:

    #1E7F
    #instruction: NOP
    advance (4)
    jump (1E80);

1E80:

    #1E80
    #instruction: NOP
    advance (4)
    jump (1E81);

1E81:

    #1E81
    #instruction: LD   A,41
    advance (7)
    A := 41;
    jump (1E83);

1E82:

    #1E82
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1E83);

1E83:

    #1E83
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1E84);

1E84:

    #1E84
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (1E85);

1E85:

    #1E85
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1E86);

1E86:

    #1E86
    #instruction: NOP
    advance (4)
    jump (1E87);

1E87:

    #1E87
    #instruction: NOP
    advance (4)
    jump (1E88);

1E88:

    #1E88
    #instruction: NOP
    advance (4)
    jump (1E89);

1E89:

    #1E89
    #instruction: LD   A,A
    advance (5)
    jump (1E8A);

1E8A:

    #1E8A
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1E8B);

1E8B:

    #1E8B
    #instruction: LD   C,H
    advance (5)
    C := H;
    jump (1E8C);

1E8C:

    #1E8C
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (1E8D);

1E8D:

    #1E8D
    #instruction: LD   SP,0000
    advance (10)
    SPH := 00;
    SPL := 00;
    jump (1E90);

1E8E:

    #1E8E
    #instruction: NOP
    advance (4)
    jump (1E8F);

1E8F:

    #1E8F
    #instruction: NOP
    advance (4)
    jump (1E90);

1E90:

    #1E90
    #instruction: NOP
    advance (4)
    jump (1E91);

1E91:

    #1E91
    #instruction: LD   (4949),A
    M[4949] := A;
    advance (13)
    jump (1E94);

1E92:

    #1E92
    #instruction: LD   C,C
    advance (5)
    jump (1E93);

1E93:

    #1E93
    #instruction: LD   C,C
    advance (5)
    jump (1E94);

1E94:

    #1E94
    #instruction: LD   C,C
    advance (5)
    jump (1E95);

1E95:

    #1E95
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (1E97);

1E96:

    #1E96
    #instruction: NOP
    advance (4)
    jump (1E97);

1E97:

    #1E97
    #instruction: NOP
    advance (4)
    jump (1E98);

1E98:

    #1E98
    #instruction: NOP
    advance (4)
    jump (1E99);

1E99:

    #1E99
    #instruction: LD   B,B
    advance (5)
    jump (1E9A);

1E9A:

    #1E9A
    #instruction: LD   B,B
    advance (5)
    jump (1E9B);

1E9B:

    #1E9B
    #instruction: LD   A,A
    advance (5)
    jump (1E9C);

1E9C:

    #1E9C
    #instruction: LD   B,B
    advance (5)
    jump (1E9D);

1E9D:

    #1E9D
    #instruction: LD   B,B
    advance (5)
    jump (1E9E);

1E9E:

    #1E9E
    #instruction: NOP
    advance (4)
    jump (1E9F);

1E9F:

    #1E9F
    #instruction: NOP
    advance (4)
    jump (1EA0);

1EA0:

    #1EA0
    #instruction: NOP
    advance (4)
    jump (1EA1);

1EA1:

    #1EA1
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1EA2);

1EA2:

    #1EA2
    #instruction: LD   BC,0101
    advance (10)
    B := 01;
    C := 01;
    jump (1EA5);

1EA3:

    #1EA3
    #instruction: LD   BC,7E01
    advance (10)
    B := 7E;
    C := 01;
    jump (1EA6);

1EA4:

    #1EA4
    #instruction: LD   BC,007E
    advance (10)
    B := 00;
    C := 7E;
    jump (1EA7);

1EA5:

    #1EA5
    #instruction: LD   A,(HL)
    advance (7)
    A := M[(H,L)];
    jump (1EA6);

1EA6:

    #1EA6
    #instruction: NOP
    advance (4)
    jump (1EA7);

1EA7:

    #1EA7
    #instruction: NOP
    advance (4)
    jump (1EA8);

1EA8:

    #1EA8
    #instruction: NOP
    advance (4)
    jump (1EA9);

1EA9:

    #1EA9
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1EAA);

1EAA:

    #1EAA
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1EAB);

1EAB:

    #1EAB
    #instruction: LD   BC,7C02
    advance (10)
    B := 7C;
    C := 02;
    jump (1EAE);

1EAC:

    #1EAC
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1EAD);

1EAD:

    #1EAD
    #instruction: LD   A,H
    advance (5)
    A := H;
    jump (1EAE);

1EAE:

    #1EAE
    #instruction: NOP
    advance (4)
    jump (1EAF);

1EAF:

    #1EAF
    #instruction: NOP
    advance (4)
    jump (1EB0);

1EB0:

    #1EB0
    #instruction: NOP
    advance (4)
    jump (1EB1);

1EB1:

    #1EB1
    #instruction: LD   A,A
    advance (5)
    jump (1EB2);

1EB2:

    #1EB2
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1EB3);

1EB3:

    #1EB3
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EB4);

1EB4:

    #1EB4
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1EB5);

1EB5:

    #1EB5
    #instruction: LD   A,A
    advance (5)
    jump (1EB6);

1EB6:

    #1EB6
    #instruction: NOP
    advance (4)
    jump (1EB7);

1EB7:

    #1EB7
    #instruction: NOP
    advance (4)
    jump (1EB8);

1EB8:

    #1EB8
    #instruction: NOP
    advance (4)
    jump (1EB9);

1EB9:

    #1EB9
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (1EBA);

1EBA:

    #1EBA
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EBB);

1EBB:

    #1EBB
    #instruction: *NOP
    advance (4)
    jump (1EBC);

1EBC:

    #1EBC
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EBD);

1EBD:

    #1EBD
    #instruction: LD   H,E
    advance (5)
    H := E;
    jump (1EBE);

1EBE:

    #1EBE
    #instruction: NOP
    advance (4)
    jump (1EBF);

1EBF:

    #1EBF
    #instruction: NOP
    advance (4)
    jump (1EC0);

1EC0:

    #1EC0
    #instruction: NOP
    advance (4)
    jump (1EC1);

1EC1:

    #1EC1
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1EC2);

1EC2:

    #1EC2
    #instruction: *NOP
    advance (4)
    jump (1EC3);

1EC3:

    #1EC3
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1EC4);

1EC4:

    #1EC4
    #instruction: *NOP
    advance (4)
    jump (1EC5);

1EC5:

    #1EC5
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1EC6);

1EC6:

    #1EC6
    #instruction: NOP
    advance (4)
    jump (1EC7);

1EC7:

    #1EC7
    #instruction: NOP
    advance (4)
    jump (1EC8);

1EC8:

    #1EC8
    #instruction: NOP
    advance (4)
    jump (1EC9);

1EC9:

    #1EC9
    #instruction: LD   B,E
    advance (5)
    B := E;
    jump (1ECA);

1ECA:

    #1ECA
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1ECB);

1ECB:

    #1ECB
    #instruction: LD   C,C
    advance (5)
    jump (1ECC);

1ECC:

    #1ECC
    #instruction: LD   D,C
    advance (5)
    D := C;
    jump (1ECD);

1ECD:

    #1ECD
    #instruction: LD   H,C
    advance (5)
    H := C;
    jump (1ECE);

1ECE:

    #1ECE
    #instruction: NOP
    advance (4)
    jump (1ECF);

1ECF:

    #1ECF
    #instruction: NOP
    advance (4)
    jump (1ED0);

1ED0:

    #1ED0
    #instruction: NOP
    advance (4)
    jump (1ED1);

1ED1:

    #1ED1
    #instruction: LD   A,45
    advance (7)
    A := 45;
    jump (1ED3);

1ED2:

    #1ED2
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1ED3);

1ED3:

    #1ED3
    #instruction: LD   C,C
    advance (5)
    jump (1ED4);

1ED4:

    #1ED4
    #instruction: LD   D,C
    advance (5)
    D := C;
    jump (1ED5);

1ED5:

    #1ED5
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (1ED7);

1ED6:

    #1ED6
    #instruction: NOP
    advance (4)
    jump (1ED7);

1ED7:

    #1ED7
    #instruction: NOP
    advance (4)
    jump (1ED8);

1ED8:

    #1ED8
    #instruction: NOP
    advance (4)
    jump (1ED9);

1ED9:

    #1ED9
    #instruction: NOP
    advance (4)
    jump (1EDA);

1EDA:

    #1EDA
    #instruction: LD   HL,017F
    advance (10)
    H := 01;
    L := 7F;
    jump (1EDD);

1EDB:

    #1EDB
    #instruction: LD   A,A
    advance (5)
    jump (1EDC);

1EDC:

    #1EDC
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1EDF);

1EDD:

    #1EDD
    #instruction: NOP
    advance (4)
    jump (1EDE);

1EDE:

    #1EDE
    #instruction: NOP
    advance (4)
    jump (1EDF);

1EDF:

    #1EDF
    #instruction: NOP
    advance (4)
    jump (1EE0);

1EE0:

    #1EE0
    #instruction: NOP
    advance (4)
    jump (1EE1);

1EE1:

    #1EE1
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    H := a1[15:8];
    L := a1[7:0];
    jump (1EE2);

1EE2:

    #1EE2
    #instruction: LD   B,L
    advance (5)
    B := L;
    jump (1EE3);

1EE3:

    #1EE3
    #instruction: LD   C,C
    advance (5)
    jump (1EE4);

1EE4:

    #1EE4
    #instruction: LD   C,C
    advance (5)
    jump (1EE5);

1EE5:

    #1EE5
    #instruction: LD   SP,0000
    advance (10)
    SPH := 00;
    SPL := 00;
    jump (1EE8);

1EE6:

    #1EE6
    #instruction: NOP
    advance (4)
    jump (1EE7);

1EE7:

    #1EE7
    #instruction: NOP
    advance (4)
    jump (1EE8);

1EE8:

    #1EE8
    #instruction: NOP
    advance (4)
    jump (1EE9);

1EE9:

    #1EE9
    #instruction: LD   B,D
    advance (5)
    B := D;
    jump (1EEA);

1EEA:

    #1EEA
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1EEB);

1EEB:

    #1EEB
    #instruction: LD   C,C
    advance (5)
    jump (1EEC);

1EEC:

    #1EEC
    #instruction: LD   E,C
    advance (5)
    E := C;
    jump (1EED);

1EED:

    #1EED
    #instruction: LD   H,(HL)
    advance (7)
    H := M[(H,L)];
    jump (1EEE);

1EEE:

    #1EEE
    #instruction: NOP
    advance (4)
    jump (1EEF);

1EEF:

    #1EEF
    #instruction: NOP
    advance (4)
    jump (1EF0);

1EF0:

    #1EF0
    #instruction: NOP
    advance (4)
    jump (1EF1);

1EF1:

    #1EF1
    #instruction: INC  C
    let:16 a1 = addWithCarry(true,C,00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EF2);

1EF2:

    #1EF2
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EF3);

1EF3:

    #1EF3
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EF4);

1EF4:

    #1EF4
    #instruction: LD   A,A
    advance (5)
    jump (1EF5);

1EF5:

    #1EF5
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1EF6);

1EF6:

    #1EF6
    #instruction: NOP
    advance (4)
    jump (1EF7);

1EF7:

    #1EF7
    #instruction: NOP
    advance (4)
    jump (1EF8);

1EF8:

    #1EF8
    #instruction: NOP
    advance (4)
    jump (1EF9);

1EF9:

    #1EF9
    #instruction: LD   (HL),D
    M[(H,L)] := D;
    advance (7)
    jump (1EFA);

1EFA:

    #1EFA
    #instruction: LD   D,C
    advance (5)
    D := C;
    jump (1EFB);

1EFB:

    #1EFB
    #instruction: LD   D,C
    advance (5)
    D := C;
    jump (1EFC);

1EFC:

    #1EFC
    #instruction: LD   D,C
    advance (5)
    D := C;
    jump (1EFD);

1EFD:

    #1EFD
    #instruction: LD   C,(HL)
    advance (7)
    C := M[(H,L)];
    jump (1EFE);

1EFE:

    #1EFE
    #instruction: NOP
    advance (4)
    jump (1EFF);

1EFF:

    #1EFF
    #instruction: NOP
    advance (4)
    jump (1F00);

1F00:

    #1F00
    #instruction: NOP
    advance (4)
    jump (1F01);

1F01:

    #1F01
    #instruction: LD   E,29
    advance (7)
    E := 29;
    jump (1F03);

1F02:

    #1F02
    #instruction: ADD  HL,HL
    let:17 a1 = add17((H,L),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1F03);

1F03:

    #1F03
    #instruction: LD   C,C
    advance (5)
    jump (1F04);

1F04:

    #1F04
    #instruction: LD   C,C
    advance (5)
    jump (1F05);

1F05:

    #1F05
    #instruction: LD   B,(HL)
    advance (7)
    B := M[(H,L)];
    jump (1F06);

1F06:

    #1F06
    #instruction: NOP
    advance (4)
    jump (1F07);

1F07:

    #1F07
    #instruction: NOP
    advance (4)
    jump (1F08);

1F08:

    #1F08
    #instruction: NOP
    advance (4)
    jump (1F09);

1F09:

    #1F09
    #instruction: LD   B,B
    advance (5)
    jump (1F0A);

1F0A:

    #1F0A
    #instruction: LD   B,A
    advance (5)
    B := A;
    jump (1F0B);

1F0B:

    #1F0B
    #instruction: LD   C,B
    advance (5)
    C := B;
    jump (1F0C);

1F0C:

    #1F0C
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1F0D);

1F0D:

    #1F0D
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1F0E);

1F0E:

    #1F0E
    #instruction: NOP
    advance (4)
    jump (1F0F);

1F0F:

    #1F0F
    #instruction: NOP
    advance (4)
    jump (1F10);

1F10:

    #1F10
    #instruction: NOP
    advance (4)
    jump (1F11);

1F11:

    #1F11
    #instruction: LD   (HL),49
    M[(H,L)] := 49;
    advance (10)
    jump (1F13);

1F12:

    #1F12
    #instruction: LD   C,C
    advance (5)
    jump (1F13);

1F13:

    #1F13
    #instruction: LD   C,C
    advance (5)
    jump (1F14);

1F14:

    #1F14
    #instruction: LD   C,C
    advance (5)
    jump (1F15);

1F15:

    #1F15
    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    jump (1F17);

1F16:

    #1F16
    #instruction: NOP
    advance (4)
    jump (1F17);

1F17:

    #1F17
    #instruction: NOP
    advance (4)
    jump (1F18);

1F18:

    #1F18
    #instruction: NOP
    advance (4)
    jump (1F19);

1F19:

    #1F19
    #instruction: LD   SP,4949
    advance (10)
    SPH := 49;
    SPL := 49;
    jump (1F1C);

1F1A:

    #1F1A
    #instruction: LD   C,C
    advance (5)
    jump (1F1B);

1F1B:

    #1F1B
    #instruction: LD   C,C
    advance (5)
    jump (1F1C);

1F1C:

    #1F1C
    #instruction: LD   C,D
    advance (5)
    C := D;
    jump (1F1D);

1F1D:

    #1F1D
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,A,00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F1E);

1F1E:

    #1F1E
    #instruction: NOP
    advance (4)
    jump (1F1F);

1F1F:

    #1F1F
    #instruction: NOP
    advance (4)
    jump (1F20);

1F20:

    #1F20
    #instruction: NOP
    advance (4)
    jump (1F21);

1F21:

    #1F21
    #instruction: *NOP
    advance (4)
    jump (1F22);

1F22:

    #1F22
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F23);

1F23:

    #1F23
    #instruction: LD   (0041),HL
    M[0041] := L;
    M[0042] := H;
    advance (16)
    jump (1F26);

1F24:

    #1F24
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1F25);

1F25:

    #1F25
    #instruction: NOP
    advance (4)
    jump (1F26);

1F26:

    #1F26
    #instruction: NOP
    advance (4)
    jump (1F27);

1F27:

    #1F27
    #instruction: NOP
    advance (4)
    jump (1F28);

1F28:

    #1F28
    #instruction: NOP
    advance (4)
    jump (1F29);

1F29:

    #1F29
    #instruction: NOP
    advance (4)
    jump (1F2A);

1F2A:

    #1F2A
    #instruction: LD   B,C
    advance (5)
    B := C;
    jump (1F2B);

1F2B:

    #1F2B
    #instruction: LD   (0814),HL
    M[0814] := L;
    M[0815] := H;
    advance (16)
    jump (1F2E);

1F2C:

    #1F2C
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F2D);

1F2D:

    #1F2D
    #instruction: *NOP
    advance (4)
    jump (1F2E);

1F2E:

    #1F2E
    #instruction: NOP
    advance (4)
    jump (1F2F);

1F2F:

    #1F2F
    #instruction: NOP
    advance (4)
    jump (1F30);

1F30:

    #1F30
    #instruction: NOP
    advance (4)
    jump (1F31);

1F31:

    #1F31
    #instruction: NOP
    advance (4)
    jump (1F32);

1F32:

    #1F32
    #instruction: NOP
    advance (4)
    jump (1F33);

1F33:

    #1F33
    #instruction: NOP
    advance (4)
    jump (1F34);

1F34:

    #1F34
    #instruction: NOP
    advance (4)
    jump (1F35);

1F35:

    #1F35
    #instruction: NOP
    advance (4)
    jump (1F36);

1F36:

    #1F36
    #instruction: NOP
    advance (4)
    jump (1F37);

1F37:

    #1F37
    #instruction: NOP
    advance (4)
    jump (1F38);

1F38:

    #1F38
    #instruction: NOP
    advance (4)
    jump (1F39);

1F39:

    #1F39
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F3A);

1F3A:

    #1F3A
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F3B);

1F3B:

    #1F3B
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F3C);

1F3C:

    #1F3C
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F3D);

1F3D:

    #1F3D
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F3E);

1F3E:

    #1F3E
    #instruction: NOP
    advance (4)
    jump (1F3F);

1F3F:

    #1F3F
    #instruction: NOP
    advance (4)
    jump (1F40);

1F40:

    #1F40
    #instruction: NOP
    advance (4)
    jump (1F41);

1F41:

    #1F41
    #instruction: LD   (7F14),HL
    M[7F14] := L;
    M[7F15] := H;
    advance (16)
    jump (1F44);

1F42:

    #1F42
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F43);

1F43:

    #1F43
    #instruction: LD   A,A
    advance (5)
    jump (1F44);

1F44:

    #1F44
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F45);

1F45:

    #1F45
    #instruction: LD   (0000),HL
    M[0000] := L;
    M[0001] := H;
    advance (16)
    jump (1F48);

1F46:

    #1F46
    #instruction: NOP
    advance (4)
    jump (1F47);

1F47:

    #1F47
    #instruction: NOP
    advance (4)
    jump (1F48);

1F48:

    #1F48
    #instruction: NOP
    advance (4)
    jump (1F49);

1F49:

    #1F49
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1F4A);

1F4A:

    #1F4A
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F4B);

1F4B:

    #1F4B
    #instruction: LD   A,B
    advance (5)
    A := B;
    jump (1F4C);

1F4C:

    #1F4C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F4D);

1F4D:

    #1F4D
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1F4E);

1F4E:

    #1F4E
    #instruction: NOP
    advance (4)
    jump (1F4F);

1F4F:

    #1F4F
    #instruction: NOP
    advance (4)
    jump (1F50);

1F50:

    #1F50
    #instruction: INC  H
    let:16 a1 = addWithCarry(true,H,00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F51);

1F51:

    #1F51
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1F52);

1F52:

    #1F52
    #instruction: LD   H,0E
    advance (7)
    H := 0E;
    jump (1F54);

1F53:

    #1F53
    #instruction: LD   C,11
    advance (7)
    C := 11;
    jump (1F55);

1F54:

    #1F54
    #instruction: LD   DE,1C26
    advance (10)
    D := 1C;
    E := 26;
    jump (1F57);

1F55:

    #1F55
    #instruction: LD   H,1C
    advance (7)
    H := 1C;
    jump (1F57);

1F56:

    #1F56
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F57);

1F57:

    #1F57
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1F59);

1F58:

    #1F58
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1F59);

1F59:

    #1F59
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1F5A);

1F5A:

    #1F5A
    #instruction: NOP
    advance (4)
    jump (1F5B);

1F5B:

    #1F5B
    #instruction: *NOP
    advance (4)
    jump (1F5C);

1F5C:

    #1F5C
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F5D);

1F5D:

    #1F5D
    #instruction: LD   DE,2512
    advance (10)
    D := 25;
    E := 12;
    jump (1F60);

1F5E:

    #1F5E
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1F5F);

1F5F:

    #1F5F
    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    H := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F60);

1F60:

    #1F60
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1F62);

1F61:

    #1F61
    #instruction: LD   H,28
    advance (7)
    H := 28;
    jump (1F63);

1F62:

    #1F62
    #instruction: *NOP
    advance (4)
    jump (1F63);

1F63:

    #1F63
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1F64);

1F64:

    #1F64
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1F66);

1F65:

    #1F65
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1F66);

1F66:

    #1F66
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1F67);

1F67:

    #1F67
    #instruction: NOP
    advance (4)
    jump (1F68);

1F68:

    #1F68
    #instruction: *NOP
    advance (4)
    jump (1F69);

1F69:

    #1F69
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F6A);

1F6A:

    #1F6A
    #instruction: LD   DE,2626
    advance (10)
    D := 26;
    E := 26;
    jump (1F6D);

1F6B:

    #1F6B
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1F6D);

1F6C:

    #1F6C
    #instruction: LD   H,1B
    advance (7)
    H := 1B;
    jump (1F6E);

1F6D:

    #1F6D
    #instruction: DEC  DE
    let:16 a1 = (-1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1F6E);

1F6E:

    #1F6E
    #instruction: LD   H,02
    advance (7)
    H := 02;
    jump (1F70);

1F6F:

    #1F6F
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1F70);

1F70:

    #1F70
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1F72);

1F71:

    #1F71
    #instruction: *NOP
    advance (4)
    jump (1F72);

1F72:

    #1F72
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F73);

1F73:

    #1F73
    #instruction: LD   H,01
    advance (7)
    H := 01;
    jump (1F75);

1F74:

    #1F74
    #instruction: LD   BC,0001
    advance (10)
    B := 00;
    C := 01;
    jump (1F77);

1F75:

    #1F75
    #instruction: LD   BC,0000
    advance (10)
    B := 00;
    C := 00;
    jump (1F78);

1F76:

    #1F76
    #instruction: NOP
    advance (4)
    jump (1F77);

1F77:

    #1F77
    #instruction: NOP
    advance (4)
    jump (1F78);

1F78:

    #1F78
    #instruction: LD   BC,0200
    advance (10)
    B := 02;
    C := 00;
    jump (1F7B);

1F79:

    #1F79
    #instruction: NOP
    advance (4)
    jump (1F7A);

1F7A:

    #1F7A
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1F7B);

1F7B:

    #1F7B
    #instruction: LD   BC,0200
    advance (10)
    B := 02;
    C := 00;
    jump (1F7E);

1F7C:

    #1F7C
    #instruction: NOP
    advance (4)
    jump (1F7D);

1F7D:

    #1F7D
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1F7E);

1F7E:

    #1F7E
    #instruction: LD   BC,6000
    advance (10)
    B := 60;
    C := 00;
    jump (1F81);

1F7F:

    #1F7F
    #instruction: NOP
    advance (4)
    jump (1F80);

1F80:

    #1F80
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1F81);

1F81:

    #1F81
    #instruction: *NOP
    advance (4)
    jump (1F82);

1F82:

    #1F82
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1F83);

1F83:

    #1F83
    #instruction: *NOP
    advance (4)
    jump (1F84);

1F84:

    #1F84
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1F85);

1F85:

    #1F85
    #instruction: *NOP
    advance (4)
    jump (1F86);

1F86:

    #1F86
    #instruction: *NOP
    advance (4)
    jump (1F87);

1F87:

    #1F87
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1F88);

1F88:

    #1F88
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F89);

1F89:

    #1F89
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1F8A);

1F8A:

    #1F8A
    #instruction: CALL MI,68FC
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1F;
      let:16 a2 = (-1 + a1) in
      M[a2] := 8D;
      #return-to: 1F8D
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (68FC);
    } else {
      advance (11)
      jump (1F8D);
    }

1F8B:

    #1F8B
    #instruction: CALL MI,3D68
    if (FlagS) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 1F;
      let:16 a2 = (-1 + a1) in
      M[a2] := 8E;
      #return-to: 1F8E
      advance (17)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump (3D68);
    } else {
      advance (11)
      jump (1F8E);
    }

1F8C:

    #1F8C
    #instruction: LD   L,B
    advance (5)
    L := B;
    jump (1F8D);

1F8D:

    #1F8D
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,A,~00) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F8E);

1F8E:

    #1F8E
    #instruction: LD   A,(DE)
    advance (7)
    A := M[(D,E)];
    jump (1F8F);

1F8F:

    #1F8F
    #instruction: NOP
    advance (4)
    jump (1F90);

1F90:

    #1F90
    #instruction: *NOP
    advance (4)
    jump (1F91);

1F91:

    #1F91
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F92);

1F92:

    #1F92
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1F93);

1F93:

    #1F93
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F94);

1F94:

    #1F94
    #instruction: LD   DE,2613
    advance (10)
    D := 26;
    E := 13;
    jump (1F97);

1F95:

    #1F95
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1F96);

1F96:

    #1F96
    #instruction: LD   H,26
    advance (7)
    H := 26;
    jump (1F98);

1F97:

    #1F97
    #instruction: LD   H,02
    advance (7)
    H := 02;
    jump (1F99);

1F98:

    #1F98
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1F99);

1F99:

    #1F99
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1F9B);

1F9A:

    #1F9A
    #instruction: *NOP
    advance (4)
    jump (1F9B);

1F9B:

    #1F9B
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F9C);

1F9C:

    #1F9C
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1F9D);

1F9D:

    #1F9D
    #instruction: LD   HL,(1F50)
    advance (16)
    H := 1B;
    L := 24;
    jump (1FA0);

1F9E:

    #1F9E
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1F9F);

1F9F:

    #1F9F
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1FA0);

1FA0:

    #1FA0
    #instruction: LD   A,(BC)
    advance (7)
    A := M[(B,C)];
    jump (1FA1);

1FA1:

    #1FA1
    #instruction: LD   HL,(1F62)
    advance (16)
    H := 1B;
    L := 28;
    jump (1FA4);

1FA2:

    #1FA2
    #instruction: LD   H,D
    advance (5)
    H := D;
    jump (1FA3);

1FA3:

    #1FA3
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1FA4);

1FA4:

    #1FA4
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1FA5);

1FA5:

    #1FA5
    #instruction: LD   HL,(1FE1)
    advance (16)
    H := 1C;
    L := 28;
    jump (1FA8);

1FA6:

    #1FA6
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (1FA7);

1FA7:

    #1FA7
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1FA8);

1FA8:

    #1FA8
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1F;
    let:16 a2 = (-1 + a1) in
    M[a2] := A9;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1FA9:

    #1FA9
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1FAA);

1FAA:

    #1FAA
    #instruction: LD   DE,0304
    advance (10)
    D := 03;
    E := 04;
    jump (1FAD);

1FAB:

    #1FAB
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FAC);

1FAC:

    #1FAC
    #instruction: INC  BC
    let:16 a1 = (1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1FAD);

1FAD:

    #1FAD
    #instruction: *NOP
    advance (4)
    jump (1FAE);

1FAE:

    #1FAE
    #instruction: INC  DE
    let:16 a1 = (1 + (D,E)) in
    advance (5)
    D := a1[15:8];
    E := a1[7:0];
    jump (1FAF);

1FAF:

    #1FAF
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (1FB1);

1FB0:

    #1FB0
    #instruction: NOP
    advance (4)
    jump (1FB1);

1FB1:

    #1FB1
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1FB2);

1FB2:

    #1FB2
    #instruction: *NOP
    advance (4)
    jump (1FB3);

1FB3:

    #1FB3
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1FB4);

1FB4:

    #1FB4
    #instruction: *NOP
    advance (4)
    jump (1FB5);

1FB5:

    #1FB5
    #instruction: LD   H,B
    advance (5)
    H := B;
    jump (1FB6);

1FB6:

    #1FB6
    #instruction: *NOP
    advance (4)
    jump (1FB7);

1FB7:

    #1FB7
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1FB8);

1FB8:

    #1FB8
    #instruction: LD   A,(FA6D)
    advance (13)
    A := M[FA6D];
    jump (1FBB);

1FB9:

    #1FB9
    #instruction: LD   L,L
    advance (5)
    jump (1FBA);

1FBA:

    #1FBA
    #instruction: JP   MI,6DFA
    if (FlagS) {
      advance (10)
      jump (6DFA);
    } else {
      advance (10)
      jump (1FBD);
    }

1FBB:

    #1FBB
    #instruction: JP   MI,3A6D
    if (FlagS) {
      advance (10)
      jump (3A6D);
    } else {
      advance (10)
      jump (1FBE);
    }

1FBC:

    #1FBC
    #instruction: LD   L,L
    advance (5)
    jump (1FBD);

1FBD:

    #1FBD
    #instruction: LD   A,(0019)
    advance (13)
    A := 21;
    jump (1FC0);

1FBE:

    #1FBE
    #instruction: ADD  HL,DE
    let:17 a1 = add17((D,E),(H,L)) in
    advance (10)
    H := a1[15:0][15:8];
    L := a1[15:0][7:0];
    FlagCY := a1[16];
    jump (1FBF);

1FBF:

    #1FBF
    #instruction: NOP
    advance (4)
    jump (1FC0);

1FC0:

    #1FC0
    #instruction: NOP
    advance (4)
    jump (1FC1);

1FC1:

    #1FC1
    #instruction: *NOP
    advance (4)
    jump (1FC2);

1FC2:

    #1FC2
    #instruction: LD   B,B
    advance (5)
    jump (1FC3);

1FC3:

    #1FC3
    #instruction: LD   C,L
    advance (5)
    C := L;
    jump (1FC4);

1FC4:

    #1FC4
    #instruction: LD   D,B
    advance (5)
    D := B;
    jump (1FC5);

1FC5:

    #1FC5
    #instruction: *NOP
    advance (4)
    jump (1FC6);

1FC6:

    #1FC6
    #instruction: NOP
    advance (4)
    jump (1FC7);

1FC7:

    #1FC7
    #instruction: NOP
    advance (4)
    jump (1FC8);

1FC8:

    #1FC8
    #instruction: NOP
    advance (4)
    jump (1FC9);

1FC9:

    #1FC9
    #instruction: NOP
    advance (4)
    jump (1FCA);

1FCA:

    #1FCA
    #instruction: NOP
    advance (4)
    jump (1FCB);

1FCB:

    #1FCB
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1F;
    let:16 a2 = (-1 + a1) in
    M[a2] := CC;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1FCC:

    #1FCC
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,A,~B) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~B & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1FCD);

1FCD:

    #1FCD
    #instruction: RST  7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1F;
    let:16 a2 = (-1 + a1) in
    M[a2] := CE;
    advance (4)
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump (0038);

1FCE:

    #1FCE
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1FCF);

1FCF:

    #1FCF
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1FD0);

1FD0:

    #1FD0
    #instruction: *NOP
    advance (4)
    jump (1FD1);

1FD1:

    #1FD1
    #instruction: SUB  A
    let:16 a1 = addWithCarry(!false,A,~A) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1FD2);

1FD2:

    #1FD2
    #instruction: NOP
    advance (4)
    jump (1FD3);

1FD3:

    #1FD3
    #instruction: ADD  B
    let:16 a1 = addWithCarry(false,B,A) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (A & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := a1[15:8][0];
    jump (1FD4);

1FD4:

    #1FD4
    #instruction: RAR
    advance (4)
    A := updateBit((A >> 01),7,FlagCY);
    FlagCY := A[0];
    jump (1FD5);

1FD5:

    #1FD5
    #instruction: NOP
    advance (4)
    jump (1FD6);

1FD6:

    #1FD6
    #instruction: NOP
    advance (4)
    jump (1FD7);

1FD7:

    #1FD7
    #instruction: LD   BC,22D0
    advance (10)
    B := 22;
    C := D0;
    jump (1FDA);

1FD8:

    #1FD8
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      jump (1FD9);
    }

1FD9:

    #1FD9
    #instruction: LD   (1C20),HL
    M[1C20] := L;
    M[1C21] := H;
    advance (16)
    jump (1FDC);

1FDA:

    #1FDA
    #instruction: *NOP
    advance (4)
    jump (1FDB);

1FDB:

    #1FDB
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FDC);

1FDC:

    #1FDC
    #instruction: *NOP
    advance (4)
    jump (1FDD);

1FDD:

    #1FDD
    #instruction: SUB  H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    A := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump (1FDE);

1FDE:

    #1FDE
    #instruction: NOP
    advance (4)
    jump (1FDF);

1FDF:

    #1FDF
    #instruction: *NOP
    advance (4)
    jump (1FE0);

1FE0:

    #1FE0
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FE1);

1FE1:

    #1FE1
    #instruction: *NOP
    advance (4)
    jump (1FE2);

1FE2:

    #1FE2
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FE3);

1FE3:

    #1FE3
    #instruction: LD   H,0F
    advance (7)
    H := 0F;
    jump (1FE5);

1FE4:

    #1FE4
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1FE5);

1FE5:

    #1FE5
    #instruction: DEC  BC
    let:16 a1 = (-1 + (B,C)) in
    advance (5)
    B := a1[15:8];
    C := a1[7:0];
    jump (1FE6);

1FE6:

    #1FE6
    #instruction: NOP
    advance (4)
    jump (1FE7);

1FE7:

    #1FE7
    #instruction: *NOP
    advance (4)
    jump (1FE8);

1FE8:

    #1FE8
    #instruction: INC  B
    let:16 a1 = addWithCarry(true,B,00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    B := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FE9);

1FE9:

    #1FE9
    #instruction: LD   DE,2612
    advance (10)
    D := 26;
    E := 12;
    jump (1FEC);

1FEA:

    #1FEA
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1FEB);

1FEB:

    #1FEB
    #instruction: LD   H,1C
    advance (7)
    H := 1C;
    jump (1FED);

1FEC:

    #1FEC
    #instruction: INC  E
    let:16 a1 = addWithCarry(true,E,00) in
    let:8 a2 = (E & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    E := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FED);

1FED:

    #1FED
    #instruction: LD   H,02
    advance (7)
    H := 02;
    jump (1FEF);

1FEE:

    #1FEE
    #instruction: LD   (BC),A
    M[(B,C)] := A;
    advance (7)
    jump (1FEF);

1FEF:

    #1FEF
    #instruction: LD   C,08
    advance (7)
    C := 08;
    jump (1FF1);

1FF0:

    #1FF0
    #instruction: *NOP
    advance (4)
    jump (1FF1);

1FF1:

    #1FF1
    #instruction: DEC  C
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    C := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FF2);

1FF2:

    #1FF2
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1FF3);

1FF3:

    #1FF3
    #instruction: RRCA
    advance (4)
    A := updateBit((A >> 01),7,A[0]);
    FlagCY := A[0];
    jump (1FF4);

1FF4:

    #1FF4
    #instruction: INC  D
    let:16 a1 = addWithCarry(true,D,00) in
    let:8 a2 = (D & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    D := a1[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    jump (1FF5);

1FF5:

    #1FF5
    #instruction: LD   (DE),A
    M[(D,E)] := A;
    advance (7)
    jump (1FF6);

1FF6:

    #1FF6
    #instruction: RLCA
    advance (4)
    A := updateBit((A << 01),0,A[7]);
    FlagCY := A[7];
    jump (1FF7);

1FF7:

    #1FF7
    #instruction: LD   H,00
    advance (7)
    H := 00;
    jump (1FF9);

1FF8:

    #1FF8
    #instruction: NOP
    advance (4)
    jump (1FF9);

1FF9:

    #1FF9
    #instruction: *NOP
    advance (4)
    jump (1FFA);

1FFA:

    #1FFA
    #instruction: *NOP
    advance (4)
    jump (1FFB);

1FFB:

    #1FFB
    #instruction: *NOP
    advance (4)
    jump (1FFC);

1FFC:

    #1FFC
    #instruction: *NOP
    advance (4)
    jump (1FFD);

1FFD:

    #1FFD
    #instruction: *NOP
    advance (4)
    jump (1FFE);

1FFE:

    #1FFE
    #instruction: NOP
    advance (4)
    jump (1FFF);

1FFF:

    #1FFF
    #instruction: NOP
    advance (4)
    jump (2000);
