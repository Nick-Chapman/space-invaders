
0000:

    #instruction: NOP
    advance (4)
    #0001
    #instruction: NOP
    advance (4)
    #0002
    #instruction: NOP
    advance (4)
    #0003
    #instruction: JP   18D4
    advance (10)
    #18D4
    #instruction: LD   SP,2400
    advance (10)
    #18D7
    #instruction: LD   B,00
    advance (7)
    #18D9
    #instruction: CALL 01E6
    M[23FF] := 18;
    M[23FE] := DC;
    #return-to: 18DC
    advance (17)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,00,~00) in
    let:8 a2 = (00 & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a1[7:0])) {
      advance (10)
      A := 01;
      B := a1[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := 23;
      SPL := FE;
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      advance (10)
      A := 01;
      B := a1[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := 24;
      SPL := 00;
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump ((M[23FF],M[23FE]));
    }

0008:

    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0009
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #000A
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := D;
    let:16 a6 = (-1 + a5) in
    M[a6] := E;
    advance (11)
    #000B
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := H;
    let:16 a8 = (-1 + a7) in
    M[a8] := L;
    advance (11)
    #000C
    #instruction: JP   008C
    advance (10)
    #008C
    #instruction: XOR  A
    let:8 a9 = (A ^ A) in
    advance (4)
    #008D
    #instruction: LD   (2072),A
    M[2072] := a9;
    advance (13)
    #0090
    #instruction: LD   A,(20E9)
    advance (13)
    #0093
    #instruction: AND  A
    let:8 a10 = (M[20E9] & M[20E9]) in
    let:8 a11 = (M[20E9] | M[20E9]) in
    advance (4)
    #0094
    #instruction: JP   Z,0082
    if (is_zero(a10)) {
      advance (10)
      #0082
      #instruction: POP  HL
      let:16 a12 = (1 + a8) in
      let:16 a13 = (1 + a12) in
      advance (10)
      #0083
      #instruction: POP  DE
      let:16 a14 = (1 + a13) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #0084
      #instruction: POP  BC
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      #0085
      #instruction: POP  PSW
      let:16 a18 = (1 + a17) in
      let:16 a19 = (1 + a18) in
      advance (10)
      #0086
      #instruction: EI
      enable_interrupts()
      advance (4)
      #0087
      #instruction: RET
      let:16 a20 = (1 + a19) in
      let:16 a21 = (1 + a20) in
      advance (10)
      A := M[a18];
      B := M[a16];
      C := M[a15];
      D := M[a14];
      E := M[a13];
      H := M[a12];
      L := M[a8];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := M[a17][7];
      FlagZ := M[a17][6];
      FlagA := M[a17][4];
      FlagP := M[a17][2];
      FlagCY := M[a17][0];
      jump ((M[a20],M[a19]));
    } else {
      advance (10)
      #0097
      #instruction: LD   A,(20EF)
      advance (13)
      #009A
      #instruction: AND  A
      let:8 a22 = (M[20EF] & M[20EF]) in
      let:8 a23 = (M[20EF] | M[20EF]) in
      advance (4)
      #009B
      #instruction: JP   NZ,00A5
      if (!is_zero(a22)) {
        advance (10)
        #00A5
        #instruction: LD   HL,2020
        advance (10)
        #00A8
        #instruction: CALL 024B
        let:16 a24 = (-1 + a8) in
        M[a24] := 00;
        let:16 a25 = (-1 + a24) in
        M[a25] := AB;
        #return-to: 00AB
        advance (17)
        #024B
        #instruction: LD   A,(HL)
        advance (7)
        #024C
        #instruction: CP   FF
        let:16 a26 = addWithCarry(!false,M[2020],~FF) in
        let:8 a27 = (M[2020] & 0F) in
        let:8 a28 = (~FF & 0F) in
        let:16 a29 = addWithCarry(!false,a27,a28) in
        advance (7)
        #024E
        #instruction: RET  Z
        if (is_zero(a26[7:0])) {
          let:16 a30 = (1 + a25) in
          let:16 a31 = (1 + a30) in
          advance (11)
          A := M[2020];
          H := 20;
          L := 20;
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a26[7:0][7];
          FlagZ := is_zero(a26[7:0]);
          FlagA := a29[7:0][4];
          FlagP := parity(a26[7:0]);
          FlagCY := !a26[15:8][0];
          jump ((M[a30],M[a25]));
        } else {
          advance (5)
          #024F
          #instruction: CP   FE
          let:16 a32 = addWithCarry(!false,M[2020],~FE) in
          let:8 a33 = (M[2020] & 0F) in
          let:8 a34 = (~FE & 0F) in
          let:16 a35 = addWithCarry(!false,a33,a34) in
          advance (7)
          #0251
          #instruction: JP   Z,0281
          if (is_zero(a32[7:0])) {
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a36 = add17(0010,2020) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := M[2020];
            D := 00;
            E := 10;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a25[15:8];
            SPL := a25[7:0];
            FlagS := a32[7:0][7];
            FlagZ := is_zero(a32[7:0]);
            FlagA := a35[7:0][4];
            FlagP := parity(a32[7:0]);
            FlagCY := a36[16];
            jump (024B);
          } else {
            advance (10)
            #0254
            #instruction: INC  HL
            advance (5)
            #0255
            #instruction: LD   B,(HL)
            advance (7)
            #0256
            #instruction: LD   C,A
            advance (5)
            #0257
            #instruction: OR   B
            let:8 a37 = (M[2021] | M[2020]) in
            advance (4)
            #0258
            #instruction: LD   A,C
            advance (5)
            #0259
            #instruction: JP   NZ,0277
            if (!is_zero(a37)) {
              advance (10)
              #0277
              #instruction: DEC  B
              let:16 a38 = addWithCarry(!true,M[2021],~00) in
              let:8 a39 = (M[2021] & 0F) in
              let:8 a40 = (~00 & 0F) in
              let:16 a41 = addWithCarry(!true,a39,a40) in
              advance (5)
              #0278
              #instruction: INC  B
              let:16 a42 = addWithCarry(true,a38[7:0],00) in
              let:8 a43 = (a38[7:0] & 0F) in
              let:8 a44 = (00 & 0F) in
              let:16 a45 = addWithCarry(true,a43,a44) in
              advance (5)
              #0279
              #instruction: JP   NZ,027D
              if (!is_zero(a42[7:0])) {
                advance (10)
                #027D
                #instruction: DEC  B
                let:16 a46 = addWithCarry(!true,a42[7:0],~00) in
                let:8 a47 = (a42[7:0] & 0F) in
                let:8 a48 = (~00 & 0F) in
                let:16 a49 = addWithCarry(!true,a47,a48) in
                advance (5)
                #027E
                #instruction: LD   (HL),B
                M[2021] := a46[7:0];
                advance (7)
                #027F
                #instruction: DEC  HL
                advance (5)
                #0280
                #instruction: LD   (HL),A
                M[2020] := M[2020];
                advance (7)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a50 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := M[2020];
                B := a46[7:0];
                C := M[2020];
                D := 00;
                E := 10;
                H := a50[15:0][15:8];
                L := a50[15:0][7:0];
                SPH := a25[15:8];
                SPL := a25[7:0];
                FlagS := a46[7:0][7];
                FlagZ := is_zero(a46[7:0]);
                FlagA := a49[7:0][4];
                FlagP := parity(a46[7:0]);
                FlagCY := a50[16];
                jump (024B);
              } else {
                advance (10)
                #027C
                #instruction: DEC  A
                let:16 a51 = addWithCarry(!true,M[2020],~00) in
                let:8 a52 = (M[2020] & 0F) in
                let:8 a53 = (~00 & 0F) in
                let:16 a54 = addWithCarry(!true,a52,a53) in
                advance (5)
                #027D
                #instruction: DEC  B
                let:16 a55 = addWithCarry(!true,a42[7:0],~00) in
                let:8 a56 = (a42[7:0] & 0F) in
                let:8 a57 = (~00 & 0F) in
                let:16 a58 = addWithCarry(!true,a56,a57) in
                advance (5)
                #027E
                #instruction: LD   (HL),B
                M[2021] := a55[7:0];
                advance (7)
                #027F
                #instruction: DEC  HL
                advance (5)
                #0280
                #instruction: LD   (HL),A
                M[2020] := a51[7:0];
                advance (7)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a59 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := a51[7:0];
                B := a55[7:0];
                C := M[2020];
                D := 00;
                E := 10;
                H := a59[15:0][15:8];
                L := a59[15:0][7:0];
                SPH := a25[15:8];
                SPL := a25[7:0];
                FlagS := a55[7:0][7];
                FlagZ := is_zero(a55[7:0]);
                FlagA := a58[7:0][4];
                FlagP := parity(a55[7:0]);
                FlagCY := a59[16];
                jump (024B);
              }
            } else {
              advance (10)
              #025C
              #instruction: INC  HL
              advance (5)
              #025D
              #instruction: LD   A,(HL)
              advance (7)
              #025E
              #instruction: AND  A
              let:8 a60 = (M[2022] & M[2022]) in
              let:8 a61 = (M[2022] | M[2022]) in
              advance (4)
              #025F
              #instruction: JP   NZ,0288
              if (!is_zero(a60)) {
                advance (10)
                #0288
                #instruction: DEC  (HL)
                let:16 a62 = addWithCarry(!true,M[2022],~00) in
                let:8 a63 = (M[2022] & 0F) in
                let:8 a64 = (~00 & 0F) in
                let:16 a65 = addWithCarry(!true,a63,a64) in
                M[2022] := a62[7:0];
                advance (10)
                #0289
                #instruction: DEC  HL
                advance (5)
                #028A
                #instruction: DEC  HL
                advance (5)
                #028B
                #instruction: JP   0281
                advance (10)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a66 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := a60;
                B := M[2021];
                C := M[2020];
                D := 00;
                E := 10;
                H := a66[15:0][15:8];
                L := a66[15:0][7:0];
                SPH := a25[15:8];
                SPL := a25[7:0];
                FlagS := a62[7:0][7];
                FlagZ := is_zero(a62[7:0]);
                FlagA := a65[7:0][4];
                FlagP := parity(a62[7:0]);
                FlagCY := a66[16];
                jump (024B);
              } else {
                advance (10)
                #0262
                #instruction: INC  HL
                advance (5)
                #0263
                #instruction: LD   E,(HL)
                advance (7)
                #0264
                #instruction: INC  HL
                advance (5)
                #0265
                #instruction: LD   D,(HL)
                advance (7)
                #0266
                #instruction: PUSH HL
                let:16 a67 = (-1 + a25) in
                M[a67] := 20;
                let:16 a68 = (-1 + a67) in
                M[a68] := 24;
                advance (11)
                #0267
                #instruction: EX   DE,HL
                advance (4)
                #0268
                #instruction: PUSH HL
                let:16 a69 = (-1 + a68) in
                M[a69] := M[2024];
                let:16 a70 = (-1 + a69) in
                M[a70] := M[2023];
                advance (11)
                #0269
                #instruction: LD   HL,026F
                advance (10)
                #026C
                #instruction: EX   (SP),HL
                let:16 a71 = (1 + a70) in
                M[a70] := 6F;
                M[a71] := 02;
                advance (18)
                #026D
                #instruction: PUSH DE
                let:16 a72 = (-1 + a70) in
                M[a72] := 20;
                let:16 a73 = (-1 + a72) in
                M[a73] := 24;
                advance (11)
                #026E
                #instruction: JP   (HL)
                advance (5)
                A := a60;
                B := M[2021];
                C := M[2020];
                D := 20;
                E := 24;
                H := M[a71];
                L := M[a70];
                SPH := a73[15:8];
                SPL := a73[7:0];
                FlagS := a60[7];
                FlagZ := is_zero(a60);
                FlagA := a61[3];
                FlagP := parity(a60);
                FlagCY := false;
                jump ((M[a71],M[a70]));
              }
            }
          }
        }
      } else {
        advance (10)
        #009E
        #instruction: LD   A,(20C1)
        advance (13)
        #00A1
        #instruction: RRCA 
        advance (4)
        #00A2
        #instruction: JP   NC,0082
        if (!M[20C1][0]) {
          advance (10)
          #0082
          #instruction: POP  HL
          let:16 a74 = (1 + a8) in
          let:16 a75 = (1 + a74) in
          advance (10)
          #0083
          #instruction: POP  DE
          let:16 a76 = (1 + a75) in
          let:16 a77 = (1 + a76) in
          advance (10)
          #0084
          #instruction: POP  BC
          let:16 a78 = (1 + a77) in
          let:16 a79 = (1 + a78) in
          advance (10)
          #0085
          #instruction: POP  PSW
          let:16 a80 = (1 + a79) in
          let:16 a81 = (1 + a80) in
          advance (10)
          #0086
          #instruction: EI
          enable_interrupts()
          advance (4)
          #0087
          #instruction: RET
          let:16 a82 = (1 + a81) in
          let:16 a83 = (1 + a82) in
          advance (10)
          A := M[a80];
          B := M[a78];
          C := M[a77];
          D := M[a76];
          E := M[a75];
          H := M[a74];
          L := M[a8];
          SPH := a83[15:8];
          SPL := a83[7:0];
          FlagS := M[a79][7];
          FlagZ := M[a79][6];
          FlagA := M[a79][4];
          FlagP := M[a79][2];
          FlagCY := M[a79][0];
          jump ((M[a82],M[a81]));
        } else {
          advance (10)
          #00A5
          #instruction: LD   HL,2020
          advance (10)
          #00A8
          #instruction: CALL 024B
          let:16 a84 = (-1 + a8) in
          M[a84] := 00;
          let:16 a85 = (-1 + a84) in
          M[a85] := AB;
          #return-to: 00AB
          advance (17)
          #024B
          #instruction: LD   A,(HL)
          advance (7)
          #024C
          #instruction: CP   FF
          let:16 a86 = addWithCarry(!false,M[2020],~FF) in
          let:8 a87 = (M[2020] & 0F) in
          let:8 a88 = (~FF & 0F) in
          let:16 a89 = addWithCarry(!false,a87,a88) in
          advance (7)
          #024E
          #instruction: RET  Z
          if (is_zero(a86[7:0])) {
            let:16 a90 = (1 + a85) in
            let:16 a91 = (1 + a90) in
            advance (11)
            A := M[2020];
            H := 20;
            L := 20;
            SPH := a91[15:8];
            SPL := a91[7:0];
            FlagS := a86[7:0][7];
            FlagZ := is_zero(a86[7:0]);
            FlagA := a89[7:0][4];
            FlagP := parity(a86[7:0]);
            FlagCY := !a86[15:8][0];
            jump ((M[a90],M[a85]));
          } else {
            advance (5)
            #024F
            #instruction: CP   FE
            let:16 a92 = addWithCarry(!false,M[2020],~FE) in
            let:8 a93 = (M[2020] & 0F) in
            let:8 a94 = (~FE & 0F) in
            let:16 a95 = addWithCarry(!false,a93,a94) in
            advance (7)
            #0251
            #instruction: JP   Z,0281
            if (is_zero(a92[7:0])) {
              advance (10)
              #0281
              #instruction: LD   DE,0010
              advance (10)
              #0284
              #instruction: ADD  HL,DE
              let:17 a96 = add17(0010,2020) in
              advance (10)
              #0285
              #instruction: JP   024B
              advance (10)
              A := M[2020];
              D := 00;
              E := 10;
              H := a96[15:0][15:8];
              L := a96[15:0][7:0];
              SPH := a85[15:8];
              SPL := a85[7:0];
              FlagS := a92[7:0][7];
              FlagZ := is_zero(a92[7:0]);
              FlagA := a95[7:0][4];
              FlagP := parity(a92[7:0]);
              FlagCY := a96[16];
              jump (024B);
            } else {
              advance (10)
              #0254
              #instruction: INC  HL
              advance (5)
              #0255
              #instruction: LD   B,(HL)
              advance (7)
              #0256
              #instruction: LD   C,A
              advance (5)
              #0257
              #instruction: OR   B
              let:8 a97 = (M[2021] | M[2020]) in
              advance (4)
              #0258
              #instruction: LD   A,C
              advance (5)
              #0259
              #instruction: JP   NZ,0277
              if (!is_zero(a97)) {
                advance (10)
                #0277
                #instruction: DEC  B
                let:16 a98 = addWithCarry(!true,M[2021],~00) in
                let:8 a99 = (M[2021] & 0F) in
                let:8 a100 = (~00 & 0F) in
                let:16 a101 = addWithCarry(!true,a99,a100) in
                advance (5)
                #0278
                #instruction: INC  B
                let:16 a102 = addWithCarry(true,a98[7:0],00) in
                let:8 a103 = (a98[7:0] & 0F) in
                let:8 a104 = (00 & 0F) in
                let:16 a105 = addWithCarry(true,a103,a104) in
                advance (5)
                #0279
                #instruction: JP   NZ,027D
                if (!is_zero(a102[7:0])) {
                  advance (10)
                  #027D
                  #instruction: DEC  B
                  let:16 a106 = addWithCarry(!true,a102[7:0],~00) in
                  let:8 a107 = (a102[7:0] & 0F) in
                  let:8 a108 = (~00 & 0F) in
                  let:16 a109 = addWithCarry(!true,a107,a108) in
                  advance (5)
                  #027E
                  #instruction: LD   (HL),B
                  M[2021] := a106[7:0];
                  advance (7)
                  #027F
                  #instruction: DEC  HL
                  advance (5)
                  #0280
                  #instruction: LD   (HL),A
                  M[2020] := M[2020];
                  advance (7)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a110 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := M[2020];
                  B := a106[7:0];
                  C := M[2020];
                  D := 00;
                  E := 10;
                  H := a110[15:0][15:8];
                  L := a110[15:0][7:0];
                  SPH := a85[15:8];
                  SPL := a85[7:0];
                  FlagS := a106[7:0][7];
                  FlagZ := is_zero(a106[7:0]);
                  FlagA := a109[7:0][4];
                  FlagP := parity(a106[7:0]);
                  FlagCY := a110[16];
                  jump (024B);
                } else {
                  advance (10)
                  #027C
                  #instruction: DEC  A
                  let:16 a111 = addWithCarry(!true,M[2020],~00) in
                  let:8 a112 = (M[2020] & 0F) in
                  let:8 a113 = (~00 & 0F) in
                  let:16 a114 = addWithCarry(!true,a112,a113) in
                  advance (5)
                  #027D
                  #instruction: DEC  B
                  let:16 a115 = addWithCarry(!true,a102[7:0],~00) in
                  let:8 a116 = (a102[7:0] & 0F) in
                  let:8 a117 = (~00 & 0F) in
                  let:16 a118 = addWithCarry(!true,a116,a117) in
                  advance (5)
                  #027E
                  #instruction: LD   (HL),B
                  M[2021] := a115[7:0];
                  advance (7)
                  #027F
                  #instruction: DEC  HL
                  advance (5)
                  #0280
                  #instruction: LD   (HL),A
                  M[2020] := a111[7:0];
                  advance (7)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a119 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := a111[7:0];
                  B := a115[7:0];
                  C := M[2020];
                  D := 00;
                  E := 10;
                  H := a119[15:0][15:8];
                  L := a119[15:0][7:0];
                  SPH := a85[15:8];
                  SPL := a85[7:0];
                  FlagS := a115[7:0][7];
                  FlagZ := is_zero(a115[7:0]);
                  FlagA := a118[7:0][4];
                  FlagP := parity(a115[7:0]);
                  FlagCY := a119[16];
                  jump (024B);
                }
              } else {
                advance (10)
                #025C
                #instruction: INC  HL
                advance (5)
                #025D
                #instruction: LD   A,(HL)
                advance (7)
                #025E
                #instruction: AND  A
                let:8 a120 = (M[2022] & M[2022]) in
                let:8 a121 = (M[2022] | M[2022]) in
                advance (4)
                #025F
                #instruction: JP   NZ,0288
                if (!is_zero(a120)) {
                  advance (10)
                  #0288
                  #instruction: DEC  (HL)
                  let:16 a122 = addWithCarry(!true,M[2022],~00) in
                  let:8 a123 = (M[2022] & 0F) in
                  let:8 a124 = (~00 & 0F) in
                  let:16 a125 = addWithCarry(!true,a123,a124) in
                  M[2022] := a122[7:0];
                  advance (10)
                  #0289
                  #instruction: DEC  HL
                  advance (5)
                  #028A
                  #instruction: DEC  HL
                  advance (5)
                  #028B
                  #instruction: JP   0281
                  advance (10)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a126 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := a120;
                  B := M[2021];
                  C := M[2020];
                  D := 00;
                  E := 10;
                  H := a126[15:0][15:8];
                  L := a126[15:0][7:0];
                  SPH := a85[15:8];
                  SPL := a85[7:0];
                  FlagS := a122[7:0][7];
                  FlagZ := is_zero(a122[7:0]);
                  FlagA := a125[7:0][4];
                  FlagP := parity(a122[7:0]);
                  FlagCY := a126[16];
                  jump (024B);
                } else {
                  advance (10)
                  #0262
                  #instruction: INC  HL
                  advance (5)
                  #0263
                  #instruction: LD   E,(HL)
                  advance (7)
                  #0264
                  #instruction: INC  HL
                  advance (5)
                  #0265
                  #instruction: LD   D,(HL)
                  advance (7)
                  #0266
                  #instruction: PUSH HL
                  let:16 a127 = (-1 + a85) in
                  M[a127] := 20;
                  let:16 a128 = (-1 + a127) in
                  M[a128] := 24;
                  advance (11)
                  #0267
                  #instruction: EX   DE,HL
                  advance (4)
                  #0268
                  #instruction: PUSH HL
                  let:16 a129 = (-1 + a128) in
                  M[a129] := M[2024];
                  let:16 a130 = (-1 + a129) in
                  M[a130] := M[2023];
                  advance (11)
                  #0269
                  #instruction: LD   HL,026F
                  advance (10)
                  #026C
                  #instruction: EX   (SP),HL
                  let:16 a131 = (1 + a130) in
                  M[a130] := 6F;
                  M[a131] := 02;
                  advance (18)
                  #026D
                  #instruction: PUSH DE
                  let:16 a132 = (-1 + a130) in
                  M[a132] := 20;
                  let:16 a133 = (-1 + a132) in
                  M[a133] := 24;
                  advance (11)
                  #026E
                  #instruction: JP   (HL)
                  advance (5)
                  A := a120;
                  B := M[2021];
                  C := M[2020];
                  D := 20;
                  E := 24;
                  H := M[a131];
                  L := M[a130];
                  SPH := a133[15:8];
                  SPL := a133[7:0];
                  FlagS := a120[7];
                  FlagZ := is_zero(a120);
                  FlagA := a121[3];
                  FlagP := parity(a120);
                  FlagCY := false;
                  jump ((M[a131],M[a130]));
                }
              }
            }
          }
        }
      }
    }

0010:

    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := A;
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0011
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #0012
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := D;
    let:16 a6 = (-1 + a5) in
    M[a6] := E;
    advance (11)
    #0013
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := H;
    let:16 a8 = (-1 + a7) in
    M[a8] := L;
    advance (11)
    #0014
    #instruction: LD   A,80
    advance (7)
    #0016
    #instruction: LD   (2072),A
    M[2072] := 80;
    advance (13)
    #0019
    #instruction: LD   HL,20C0
    advance (10)
    #001C
    #instruction: DEC  (HL)
    let:16 a9 = addWithCarry(!true,M[20C0],~00) in
    let:8 a10 = (M[20C0] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    M[20C0] := a9[7:0];
    advance (10)
    #001D
    #instruction: CALL 17CD
    let:16 a13 = (-1 + a8) in
    M[a13] := 00;
    let:16 a14 = (-1 + a13) in
    M[a14] := 20;
    #return-to: 0020
    advance (17)
    #17CD
    #instruction: IN   02
    advance (10)
    #17CF
    #instruction: AND  04
    let:8 a15 = (04 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
    let:8 a16 = (04 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
    advance (7)
    #17D1
    #instruction: RET  Z
    if (is_zero(a15)) {
      let:16 a17 = (1 + a14) in
      let:16 a18 = (1 + a17) in
      advance (11)
      A := a15;
      H := 20;
      L := C0;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := a16[3];
      FlagP := parity(a15);
      FlagCY := false;
      jump ((M[a17],M[a14]));
    } else {
      advance (5)
      #17D2
      #instruction: LD   A,(209A)
      advance (13)
      #17D5
      #instruction: AND  A
      let:8 a19 = (M[209A] & M[209A]) in
      let:8 a20 = (M[209A] | M[209A]) in
      advance (4)
      #17D6
      #instruction: RET  NZ
      if (!is_zero(a19)) {
        let:16 a21 = (1 + a14) in
        let:16 a22 = (1 + a21) in
        advance (11)
        A := a19;
        H := 20;
        L := C0;
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump ((M[a21],M[a14]));
      } else {
        advance (5)
        #17D7
        #instruction: LD   SP,2400
        advance (10)
        #17DA
        #instruction: LD   B,04
        advance (7)
        #17DC
        #instruction: CALL 09D6
        M[23FF] := 17;
        M[23FE] := DF;
        #return-to: 17DF
        advance (17)
        #09D6
        #instruction: LD   HL,2402
        advance (10)
        #09D9
        #instruction: LD   (HL),00
        M[2402] := 00;
        advance (10)
        #09DB
        #instruction: INC  HL
        advance (5)
        #09DC
        #instruction: LD   A,L
        advance (5)
        #09DD
        #instruction: AND  1F
        let:8 a23 = (1F & 03) in
        let:8 a24 = (1F | 03) in
        advance (7)
        #09DF
        #instruction: CP   1C
        let:16 a25 = addWithCarry(!false,a23,~1C) in
        let:8 a26 = (a23 & 0F) in
        let:8 a27 = (~1C & 0F) in
        let:16 a28 = addWithCarry(!false,a26,a27) in
        advance (7)
        #09E1
        #instruction: JP   CY,09E8
        if (!a25[15:8][0]) {
          advance (10)
          #09E8
          #instruction: LD   A,H
          advance (5)
          #09E9
          #instruction: CP   40
          let:16 a29 = addWithCarry(!false,24,~40) in
          let:8 a30 = (24 & 0F) in
          let:8 a31 = (~40 & 0F) in
          let:16 a32 = addWithCarry(!false,a30,a31) in
          advance (7)
          #09EB
          #instruction: JP   CY,09D9
          if (!a29[15:8][0]) {
            advance (10)
            A := 24;
            B := 04;
            H := 24;
            L := 03;
            SPH := 23;
            SPL := FE;
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := !a29[15:8][0];
            jump (09D9);
          } else {
            advance (10)
            #09EE
            #instruction: RET
            advance (10)
            A := 24;
            B := 04;
            H := 24;
            L := 03;
            SPH := 24;
            SPL := 00;
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := !a29[15:8][0];
            jump ((M[23FF],M[23FE]));
          }
        } else {
          advance (10)
          #09E4
          #instruction: LD   DE,0006
          advance (10)
          #09E7
          #instruction: ADD  HL,DE
          let:17 a33 = add17(0006,2403) in
          advance (10)
          #09E8
          #instruction: LD   A,H
          advance (5)
          #09E9
          #instruction: CP   40
          let:16 a34 = addWithCarry(!false,a33[15:0][15:8],~40) in
          let:8 a35 = (a33[15:0][15:8] & 0F) in
          let:8 a36 = (~40 & 0F) in
          let:16 a37 = addWithCarry(!false,a35,a36) in
          advance (7)
          #09EB
          #instruction: JP   CY,09D9
          if (!a34[15:8][0]) {
            advance (10)
            A := a33[15:0][15:8];
            B := 04;
            D := 00;
            E := 06;
            H := a33[15:0][15:8];
            L := a33[15:0][7:0];
            SPH := 23;
            SPL := FE;
            FlagS := a34[7:0][7];
            FlagZ := is_zero(a34[7:0]);
            FlagA := a37[7:0][4];
            FlagP := parity(a34[7:0]);
            FlagCY := !a34[15:8][0];
            jump (09D9);
          } else {
            advance (10)
            #09EE
            #instruction: RET
            advance (10)
            A := a33[15:0][15:8];
            B := 04;
            D := 00;
            E := 06;
            H := a33[15:0][15:8];
            L := a33[15:0][7:0];
            SPH := 24;
            SPL := 00;
            FlagS := a34[7:0][7];
            FlagZ := is_zero(a34[7:0]);
            FlagA := a37[7:0][4];
            FlagP := parity(a34[7:0]);
            FlagCY := !a34[15:8][0];
            jump ((M[23FF],M[23FE]));
          }
        }
      }
    }

0020:

    #instruction: IN   01
    advance (10)
    #0022
    #instruction: RRCA 
    advance (4)
    #0023
    #instruction: JP   CY,0067
    if (updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) {
      advance (10)
      #0067
      #instruction: LD   A,01
      advance (7)
      #0069
      #instruction: LD   (20EA),A
      M[20EA] := 01;
      advance (13)
      #006C
      #instruction: JP   003F
      advance (10)
      #003F
      #instruction: LD   (20EA),A
      M[20EA] := 01;
      advance (13)
      #0042
      #instruction: LD   A,(20E9)
      advance (13)
      #0045
      #instruction: AND  A
      let:8 a1 = (M[20E9] & M[20E9]) in
      let:8 a2 = (M[20E9] | M[20E9]) in
      advance (4)
      #0046
      #instruction: JP   Z,0082
      if (is_zero(a1)) {
        advance (10)
        #0082
        #instruction: POP  HL
        let:16 a3 = (1 + (SPH,SPL)) in
        let:16 a4 = (1 + a3) in
        advance (10)
        #0083
        #instruction: POP  DE
        let:16 a5 = (1 + a4) in
        let:16 a6 = (1 + a5) in
        advance (10)
        #0084
        #instruction: POP  BC
        let:16 a7 = (1 + a6) in
        let:16 a8 = (1 + a7) in
        advance (10)
        #0085
        #instruction: POP  PSW
        let:16 a9 = (1 + a8) in
        let:16 a10 = (1 + a9) in
        advance (10)
        #0086
        #instruction: EI
        enable_interrupts()
        advance (4)
        #0087
        #instruction: RET
        let:16 a11 = (1 + a10) in
        let:16 a12 = (1 + a11) in
        advance (10)
        A := M[a9];
        B := M[a7];
        C := M[a6];
        D := M[a5];
        E := M[a4];
        H := M[a3];
        L := M[(SPH,SPL)];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := M[a8][7];
        FlagZ := M[a8][6];
        FlagA := M[a8][4];
        FlagP := M[a8][2];
        FlagCY := M[a8][0];
        jump ((M[a11],M[a10]));
      } else {
        advance (10)
        #0049
        #instruction: LD   A,(20EF)
        advance (13)
        #004C
        #instruction: AND  A
        let:8 a13 = (M[20EF] & M[20EF]) in
        let:8 a14 = (M[20EF] | M[20EF]) in
        advance (4)
        #004D
        #instruction: JP   NZ,006F
        if (!is_zero(a13)) {
          advance (10)
          #006F
          #instruction: CALL 1740
          let:16 a15 = (-1 + (SPH,SPL)) in
          M[a15] := 00;
          let:16 a16 = (-1 + a15) in
          M[a16] := 72;
          #return-to: 0072
          advance (17)
          #1740
          #instruction: LD   HL,209B
          advance (10)
          #1743
          #instruction: DEC  (HL)
          let:16 a17 = addWithCarry(!true,M[209B],~00) in
          let:8 a18 = (M[209B] & 0F) in
          let:8 a19 = (~00 & 0F) in
          let:16 a20 = addWithCarry(!true,a18,a19) in
          M[209B] := a17[7:0];
          advance (10)
          #1744
          #instruction: CALL Z,176D
          if (is_zero(a17[7:0])) {
            let:16 a21 = (-1 + a16) in
            M[a21] := 17;
            let:16 a22 = (-1 + a21) in
            M[a22] := 47;
            #return-to: 1747
            advance (17)
            #176D
            #instruction: LD   A,(2098)
            advance (13)
            #1770
            #instruction: AND  30
            let:8 a23 = (30 & M[2098]) in
            let:8 a24 = (30 | M[2098]) in
            advance (7)
            #1772
            #instruction: OUT  05
            sound_control(FleetMovement1,a23[0]);
            sound_control(FleetMovement2,a23[1]);
            sound_control(FleetMovement3,a23[2]);
            sound_control(FleetMovement4,a23[3]);
            sound_control(UfoHit,a23[4]);
            advance (10)
            #1774
            #instruction: RET
            let:16 a25 = (1 + a22) in
            let:16 a26 = (1 + a25) in
            advance (10)
            A := a23;
            H := 20;
            L := 9B;
            SPH := a26[15:8];
            SPL := a26[7:0];
            FlagS := a23[7];
            FlagZ := is_zero(a23);
            FlagA := a24[3];
            FlagP := parity(a23);
            FlagCY := false;
            jump ((M[a25],M[a22]));
          } else {
            advance (11)
            A := a13;
            H := 20;
            L := 9B;
            SPH := a16[15:8];
            SPL := a16[7:0];
            FlagS := a17[7:0][7];
            FlagZ := is_zero(a17[7:0]);
            FlagA := a20[7:0][4];
            FlagP := parity(a17[7:0]);
            FlagCY := false;
            jump (1747);
          }
        } else {
          advance (10)
          #0050
          #instruction: LD   A,(20EB)
          advance (13)
          #0053
          #instruction: AND  A
          let:8 a27 = (M[20EB] & M[20EB]) in
          let:8 a28 = (M[20EB] | M[20EB]) in
          advance (4)
          #0054
          #instruction: JP   NZ,005D
          if (!is_zero(a27)) {
            advance (10)
            #005D
            #instruction: LD   A,(2093)
            advance (13)
            #0060
            #instruction: AND  A
            let:8 a29 = (M[2093] & M[2093]) in
            let:8 a30 = (M[2093] | M[2093]) in
            advance (4)
            #0061
            #instruction: JP   NZ,0082
            if (!is_zero(a29)) {
              advance (10)
              #0082
              #instruction: POP  HL
              let:16 a31 = (1 + (SPH,SPL)) in
              let:16 a32 = (1 + a31) in
              advance (10)
              #0083
              #instruction: POP  DE
              let:16 a33 = (1 + a32) in
              let:16 a34 = (1 + a33) in
              advance (10)
              #0084
              #instruction: POP  BC
              let:16 a35 = (1 + a34) in
              let:16 a36 = (1 + a35) in
              advance (10)
              #0085
              #instruction: POP  PSW
              let:16 a37 = (1 + a36) in
              let:16 a38 = (1 + a37) in
              advance (10)
              #0086
              #instruction: EI
              enable_interrupts()
              advance (4)
              #0087
              #instruction: RET
              let:16 a39 = (1 + a38) in
              let:16 a40 = (1 + a39) in
              advance (10)
              A := M[a37];
              B := M[a35];
              C := M[a34];
              D := M[a33];
              E := M[a32];
              H := M[a31];
              L := M[(SPH,SPL)];
              SPH := a40[15:8];
              SPL := a40[7:0];
              FlagS := M[a36][7];
              FlagZ := M[a36][6];
              FlagA := M[a36][4];
              FlagP := M[a36][2];
              FlagCY := M[a36][0];
              jump ((M[a39],M[a38]));
            } else {
              advance (10)
              #0064
              #instruction: JP   0765
              advance (10)
              #0765
              #instruction: LD   A,01
              advance (7)
              #0767
              #instruction: LD   (2093),A
              M[2093] := 01;
              advance (13)
              #076A
              #instruction: LD   SP,2400
              advance (10)
              #076D
              #instruction: EI
              enable_interrupts()
              advance (4)
              #076E
              #instruction: CALL 1979
              M[23FF] := 07;
              M[23FE] := 71;
              #return-to: 0771
              advance (17)
              #1979
              #instruction: CALL 19D7
              M[23FD] := 19;
              M[23FC] := 7C;
              #return-to: 197C
              advance (17)
              #19D7
              #instruction: XOR  A
              let:8 a41 = (01 ^ 01) in
              advance (4)
              #19D8
              #instruction: JP   19D3
              advance (10)
              #19D3
              #instruction: LD   (20E9),A
              M[20E9] := a41;
              advance (13)
              #19D6
              #instruction: RET
              advance (10)
              A := a41;
              SPH := 23;
              SPL := FE;
              FlagS := a41[7];
              FlagZ := is_zero(a41);
              FlagA := false;
              FlagP := parity(a41);
              FlagCY := false;
              jump ((M[23FD],M[23FC]));
            }
          } else {
            advance (10)
            #0057
            #instruction: CALL 0ABF
            let:16 a42 = (-1 + (SPH,SPL)) in
            M[a42] := 00;
            let:16 a43 = (-1 + a42) in
            M[a43] := 5A;
            #return-to: 005A
            advance (17)
            #0ABF
            #instruction: LD   A,(20C1)
            advance (13)
            #0AC2
            #instruction: RRCA 
            advance (4)
            #0AC3
            #instruction: JP   CY,0ABB
            if (M[20C1][0]) {
              advance (10)
              #0ABB
              #instruction: POP  HL
              let:16 a44 = (1 + a43) in
              let:16 a45 = (1 + a44) in
              advance (10)
              #0ABC
              #instruction: JP   0072
              advance (10)
              A := updateBit((M[20C1] >> 01),7,M[20C1][0]);
              H := M[a44];
              L := M[a43];
              SPH := a45[15:8];
              SPL := a45[7:0];
              FlagS := a27[7];
              FlagZ := is_zero(a27);
              FlagA := a28[3];
              FlagP := parity(a27);
              FlagCY := M[20C1][0];
              jump (0072);
            } else {
              advance (10)
              #0AC6
              #instruction: RRCA 
              advance (4)
              #0AC7
              #instruction: JP   CY,1868
              if (updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) {
                advance (10)
                #1868
                #instruction: LD   HL,20C2
                advance (10)
                #186B
                #instruction: INC  (HL)
                let:16 a46 = addWithCarry(true,M[20C2],00) in
                let:8 a47 = (M[20C2] & 0F) in
                let:8 a48 = (00 & 0F) in
                let:16 a49 = addWithCarry(true,a47,a48) in
                M[20C2] := a46[7:0];
                advance (10)
                #186C
                #instruction: INC  HL
                advance (5)
                #186D
                #instruction: LD   C,(HL)
                advance (7)
                #186E
                #instruction: CALL 01D9
                let:16 a50 = (-1 + a43) in
                M[a50] := 18;
                let:16 a51 = (-1 + a50) in
                M[a51] := 71;
                #return-to: 1871
                advance (17)
                #01D9
                #instruction: INC  HL
                advance (5)
                #01DA
                #instruction: LD   B,(HL)
                advance (7)
                #01DB
                #instruction: INC  HL
                advance (5)
                #01DC
                #instruction: LD   A,C
                advance (5)
                #01DD
                #instruction: ADD  (HL)
                let:16 a52 = addWithCarry(false,M[20C5],M[20C3]) in
                let:8 a53 = (M[20C5] & 0F) in
                let:8 a54 = (M[20C3] & 0F) in
                let:16 a55 = addWithCarry(false,a53,a54) in
                advance (7)
                #01DE
                #instruction: LD   (HL),A
                M[20C5] := a52[7:0];
                advance (7)
                #01DF
                #instruction: INC  HL
                advance (5)
                #01E0
                #instruction: LD   A,B
                advance (5)
                #01E1
                #instruction: ADD  (HL)
                let:16 a56 = addWithCarry(false,M[20C6],M[20C4]) in
                let:8 a57 = (M[20C6] & 0F) in
                let:8 a58 = (M[20C4] & 0F) in
                let:16 a59 = addWithCarry(false,a57,a58) in
                advance (7)
                #01E2
                #instruction: LD   (HL),A
                M[20C6] := a56[7:0];
                advance (7)
                #01E3
                #instruction: RET
                let:16 a60 = (1 + a51) in
                let:16 a61 = (1 + a60) in
                advance (10)
                A := a56[7:0];
                B := M[20C4];
                C := M[20C3];
                H := 20;
                L := C6;
                SPH := a61[15:8];
                SPL := a61[7:0];
                FlagS := a56[7:0][7];
                FlagZ := is_zero(a56[7:0]);
                FlagA := a59[7:0][4];
                FlagP := parity(a56[7:0]);
                FlagCY := a56[15:8][0];
                jump ((M[a60],M[a51]));
              } else {
                advance (10)
                #0ACA
                #instruction: RRCA 
                advance (4)
                #0ACB
                #instruction: JP   CY,0AAB
                if (updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]) {
                  advance (10)
                  #0AAB
                  #instruction: LD   HL,2050
                  advance (10)
                  #0AAE
                  #instruction: JP   024B
                  advance (10)
                  #024B
                  #instruction: LD   A,(HL)
                  advance (7)
                  #024C
                  #instruction: CP   FF
                  let:16 a62 = addWithCarry(!false,M[2050],~FF) in
                  let:8 a63 = (M[2050] & 0F) in
                  let:8 a64 = (~FF & 0F) in
                  let:16 a65 = addWithCarry(!false,a63,a64) in
                  advance (7)
                  #024E
                  #instruction: RET  Z
                  if (is_zero(a62[7:0])) {
                    let:16 a66 = (1 + a43) in
                    let:16 a67 = (1 + a66) in
                    advance (11)
                    A := M[2050];
                    H := 20;
                    L := 50;
                    SPH := a67[15:8];
                    SPL := a67[7:0];
                    FlagS := a62[7:0][7];
                    FlagZ := is_zero(a62[7:0]);
                    FlagA := a65[7:0][4];
                    FlagP := parity(a62[7:0]);
                    FlagCY := !a62[15:8][0];
                    jump ((M[a66],M[a43]));
                  } else {
                    advance (5)
                    #024F
                    #instruction: CP   FE
                    let:16 a68 = addWithCarry(!false,M[2050],~FE) in
                    let:8 a69 = (M[2050] & 0F) in
                    let:8 a70 = (~FE & 0F) in
                    let:16 a71 = addWithCarry(!false,a69,a70) in
                    advance (7)
                    #0251
                    #instruction: JP   Z,0281
                    if (is_zero(a68[7:0])) {
                      advance (10)
                      #0281
                      #instruction: LD   DE,0010
                      advance (10)
                      #0284
                      #instruction: ADD  HL,DE
                      let:17 a72 = add17(0010,2050) in
                      advance (10)
                      #0285
                      #instruction: JP   024B
                      advance (10)
                      A := M[2050];
                      D := 00;
                      E := 10;
                      H := a72[15:0][15:8];
                      L := a72[15:0][7:0];
                      SPH := a43[15:8];
                      SPL := a43[7:0];
                      FlagS := a68[7:0][7];
                      FlagZ := is_zero(a68[7:0]);
                      FlagA := a71[7:0][4];
                      FlagP := parity(a68[7:0]);
                      FlagCY := a72[16];
                      jump (024B);
                    } else {
                      advance (10)
                      #0254
                      #instruction: INC  HL
                      advance (5)
                      #0255
                      #instruction: LD   B,(HL)
                      advance (7)
                      #0256
                      #instruction: LD   C,A
                      advance (5)
                      #0257
                      #instruction: OR   B
                      let:8 a73 = (M[2051] | M[2050]) in
                      advance (4)
                      #0258
                      #instruction: LD   A,C
                      advance (5)
                      #0259
                      #instruction: JP   NZ,0277
                      if (!is_zero(a73)) {
                        advance (10)
                        #0277
                        #instruction: DEC  B
                        let:16 a74 = addWithCarry(!true,M[2051],~00) in
                        let:8 a75 = (M[2051] & 0F) in
                        let:8 a76 = (~00 & 0F) in
                        let:16 a77 = addWithCarry(!true,a75,a76) in
                        advance (5)
                        #0278
                        #instruction: INC  B
                        let:16 a78 = addWithCarry(true,a74[7:0],00) in
                        let:8 a79 = (a74[7:0] & 0F) in
                        let:8 a80 = (00 & 0F) in
                        let:16 a81 = addWithCarry(true,a79,a80) in
                        advance (5)
                        #0279
                        #instruction: JP   NZ,027D
                        if (!is_zero(a78[7:0])) {
                          advance (10)
                          #027D
                          #instruction: DEC  B
                          let:16 a82 = addWithCarry(!true,a78[7:0],~00) in
                          let:8 a83 = (a78[7:0] & 0F) in
                          let:8 a84 = (~00 & 0F) in
                          let:16 a85 = addWithCarry(!true,a83,a84) in
                          advance (5)
                          #027E
                          #instruction: LD   (HL),B
                          M[2051] := a82[7:0];
                          advance (7)
                          #027F
                          #instruction: DEC  HL
                          advance (5)
                          #0280
                          #instruction: LD   (HL),A
                          M[2050] := M[2050];
                          advance (7)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a86 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := M[2050];
                          B := a82[7:0];
                          C := M[2050];
                          D := 00;
                          E := 10;
                          H := a86[15:0][15:8];
                          L := a86[15:0][7:0];
                          SPH := a43[15:8];
                          SPL := a43[7:0];
                          FlagS := a82[7:0][7];
                          FlagZ := is_zero(a82[7:0]);
                          FlagA := a85[7:0][4];
                          FlagP := parity(a82[7:0]);
                          FlagCY := a86[16];
                          jump (024B);
                        } else {
                          advance (10)
                          #027C
                          #instruction: DEC  A
                          let:16 a87 = addWithCarry(!true,M[2050],~00) in
                          let:8 a88 = (M[2050] & 0F) in
                          let:8 a89 = (~00 & 0F) in
                          let:16 a90 = addWithCarry(!true,a88,a89) in
                          advance (5)
                          #027D
                          #instruction: DEC  B
                          let:16 a91 = addWithCarry(!true,a78[7:0],~00) in
                          let:8 a92 = (a78[7:0] & 0F) in
                          let:8 a93 = (~00 & 0F) in
                          let:16 a94 = addWithCarry(!true,a92,a93) in
                          advance (5)
                          #027E
                          #instruction: LD   (HL),B
                          M[2051] := a91[7:0];
                          advance (7)
                          #027F
                          #instruction: DEC  HL
                          advance (5)
                          #0280
                          #instruction: LD   (HL),A
                          M[2050] := a87[7:0];
                          advance (7)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a95 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := a87[7:0];
                          B := a91[7:0];
                          C := M[2050];
                          D := 00;
                          E := 10;
                          H := a95[15:0][15:8];
                          L := a95[15:0][7:0];
                          SPH := a43[15:8];
                          SPL := a43[7:0];
                          FlagS := a91[7:0][7];
                          FlagZ := is_zero(a91[7:0]);
                          FlagA := a94[7:0][4];
                          FlagP := parity(a91[7:0]);
                          FlagCY := a95[16];
                          jump (024B);
                        }
                      } else {
                        advance (10)
                        #025C
                        #instruction: INC  HL
                        advance (5)
                        #025D
                        #instruction: LD   A,(HL)
                        advance (7)
                        #025E
                        #instruction: AND  A
                        let:8 a96 = (M[2052] & M[2052]) in
                        let:8 a97 = (M[2052] | M[2052]) in
                        advance (4)
                        #025F
                        #instruction: JP   NZ,0288
                        if (!is_zero(a96)) {
                          advance (10)
                          #0288
                          #instruction: DEC  (HL)
                          let:16 a98 = addWithCarry(!true,M[2052],~00) in
                          let:8 a99 = (M[2052] & 0F) in
                          let:8 a100 = (~00 & 0F) in
                          let:16 a101 = addWithCarry(!true,a99,a100) in
                          M[2052] := a98[7:0];
                          advance (10)
                          #0289
                          #instruction: DEC  HL
                          advance (5)
                          #028A
                          #instruction: DEC  HL
                          advance (5)
                          #028B
                          #instruction: JP   0281
                          advance (10)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a102 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := a96;
                          B := M[2051];
                          C := M[2050];
                          D := 00;
                          E := 10;
                          H := a102[15:0][15:8];
                          L := a102[15:0][7:0];
                          SPH := a43[15:8];
                          SPL := a43[7:0];
                          FlagS := a98[7:0][7];
                          FlagZ := is_zero(a98[7:0]);
                          FlagA := a101[7:0][4];
                          FlagP := parity(a98[7:0]);
                          FlagCY := a102[16];
                          jump (024B);
                        } else {
                          advance (10)
                          #0262
                          #instruction: INC  HL
                          advance (5)
                          #0263
                          #instruction: LD   E,(HL)
                          advance (7)
                          #0264
                          #instruction: INC  HL
                          advance (5)
                          #0265
                          #instruction: LD   D,(HL)
                          advance (7)
                          #0266
                          #instruction: PUSH HL
                          let:16 a103 = (-1 + a43) in
                          M[a103] := 20;
                          let:16 a104 = (-1 + a103) in
                          M[a104] := 54;
                          advance (11)
                          #0267
                          #instruction: EX   DE,HL
                          advance (4)
                          #0268
                          #instruction: PUSH HL
                          let:16 a105 = (-1 + a104) in
                          M[a105] := M[2054];
                          let:16 a106 = (-1 + a105) in
                          M[a106] := M[2053];
                          advance (11)
                          #0269
                          #instruction: LD   HL,026F
                          advance (10)
                          #026C
                          #instruction: EX   (SP),HL
                          let:16 a107 = (1 + a106) in
                          M[a106] := 6F;
                          M[a107] := 02;
                          advance (18)
                          #026D
                          #instruction: PUSH DE
                          let:16 a108 = (-1 + a106) in
                          M[a108] := 20;
                          let:16 a109 = (-1 + a108) in
                          M[a109] := 54;
                          advance (11)
                          #026E
                          #instruction: JP   (HL)
                          advance (5)
                          A := a96;
                          B := M[2051];
                          C := M[2050];
                          D := 20;
                          E := 54;
                          H := M[a107];
                          L := M[a106];
                          SPH := a109[15:8];
                          SPL := a109[7:0];
                          FlagS := a96[7];
                          FlagZ := is_zero(a96);
                          FlagA := a97[3];
                          FlagP := parity(a96);
                          FlagCY := false;
                          jump ((M[a107],M[a106]));
                        }
                      }
                    }
                  }
                } else {
                  advance (10)
                  #0ACE
                  #instruction: RET
                  let:16 a110 = (1 + a43) in
                  let:16 a111 = (1 + a110) in
                  advance (10)
                  A := updateBit((updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) >> 01),7,updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]);
                  SPH := a111[15:8];
                  SPL := a111[7:0];
                  FlagS := a27[7];
                  FlagZ := is_zero(a27);
                  FlagA := a28[3];
                  FlagP := parity(a27);
                  FlagCY := updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0];
                  jump ((M[a110],M[a43]));
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0026
      #instruction: LD   A,(20EA)
      advance (13)
      #0029
      #instruction: AND  A
      let:8 a112 = (M[20EA] & M[20EA]) in
      let:8 a113 = (M[20EA] | M[20EA]) in
      advance (4)
      #002A
      #instruction: JP   Z,0042
      if (is_zero(a112)) {
        advance (10)
        #0042
        #instruction: LD   A,(20E9)
        advance (13)
        #0045
        #instruction: AND  A
        let:8 a114 = (M[20E9] & M[20E9]) in
        let:8 a115 = (M[20E9] | M[20E9]) in
        advance (4)
        #0046
        #instruction: JP   Z,0082
        if (is_zero(a114)) {
          advance (10)
          #0082
          #instruction: POP  HL
          let:16 a116 = (1 + (SPH,SPL)) in
          let:16 a117 = (1 + a116) in
          advance (10)
          #0083
          #instruction: POP  DE
          let:16 a118 = (1 + a117) in
          let:16 a119 = (1 + a118) in
          advance (10)
          #0084
          #instruction: POP  BC
          let:16 a120 = (1 + a119) in
          let:16 a121 = (1 + a120) in
          advance (10)
          #0085
          #instruction: POP  PSW
          let:16 a122 = (1 + a121) in
          let:16 a123 = (1 + a122) in
          advance (10)
          #0086
          #instruction: EI
          enable_interrupts()
          advance (4)
          #0087
          #instruction: RET
          let:16 a124 = (1 + a123) in
          let:16 a125 = (1 + a124) in
          advance (10)
          A := M[a122];
          B := M[a120];
          C := M[a119];
          D := M[a118];
          E := M[a117];
          H := M[a116];
          L := M[(SPH,SPL)];
          SPH := a125[15:8];
          SPL := a125[7:0];
          FlagS := M[a121][7];
          FlagZ := M[a121][6];
          FlagA := M[a121][4];
          FlagP := M[a121][2];
          FlagCY := M[a121][0];
          jump ((M[a124],M[a123]));
        } else {
          advance (10)
          #0049
          #instruction: LD   A,(20EF)
          advance (13)
          #004C
          #instruction: AND  A
          let:8 a126 = (M[20EF] & M[20EF]) in
          let:8 a127 = (M[20EF] | M[20EF]) in
          advance (4)
          #004D
          #instruction: JP   NZ,006F
          if (!is_zero(a126)) {
            advance (10)
            #006F
            #instruction: CALL 1740
            let:16 a128 = (-1 + (SPH,SPL)) in
            M[a128] := 00;
            let:16 a129 = (-1 + a128) in
            M[a129] := 72;
            #return-to: 0072
            advance (17)
            #1740
            #instruction: LD   HL,209B
            advance (10)
            #1743
            #instruction: DEC  (HL)
            let:16 a130 = addWithCarry(!true,M[209B],~00) in
            let:8 a131 = (M[209B] & 0F) in
            let:8 a132 = (~00 & 0F) in
            let:16 a133 = addWithCarry(!true,a131,a132) in
            M[209B] := a130[7:0];
            advance (10)
            #1744
            #instruction: CALL Z,176D
            if (is_zero(a130[7:0])) {
              let:16 a134 = (-1 + a129) in
              M[a134] := 17;
              let:16 a135 = (-1 + a134) in
              M[a135] := 47;
              #return-to: 1747
              advance (17)
              #176D
              #instruction: LD   A,(2098)
              advance (13)
              #1770
              #instruction: AND  30
              let:8 a136 = (30 & M[2098]) in
              let:8 a137 = (30 | M[2098]) in
              advance (7)
              #1772
              #instruction: OUT  05
              sound_control(FleetMovement1,a136[0]);
              sound_control(FleetMovement2,a136[1]);
              sound_control(FleetMovement3,a136[2]);
              sound_control(FleetMovement4,a136[3]);
              sound_control(UfoHit,a136[4]);
              advance (10)
              #1774
              #instruction: RET
              let:16 a138 = (1 + a135) in
              let:16 a139 = (1 + a138) in
              advance (10)
              A := a136;
              H := 20;
              L := 9B;
              SPH := a139[15:8];
              SPL := a139[7:0];
              FlagS := a136[7];
              FlagZ := is_zero(a136);
              FlagA := a137[3];
              FlagP := parity(a136);
              FlagCY := false;
              jump ((M[a138],M[a135]));
            } else {
              advance (11)
              A := a126;
              H := 20;
              L := 9B;
              SPH := a129[15:8];
              SPL := a129[7:0];
              FlagS := a130[7:0][7];
              FlagZ := is_zero(a130[7:0]);
              FlagA := a133[7:0][4];
              FlagP := parity(a130[7:0]);
              FlagCY := false;
              jump (1747);
            }
          } else {
            advance (10)
            #0050
            #instruction: LD   A,(20EB)
            advance (13)
            #0053
            #instruction: AND  A
            let:8 a140 = (M[20EB] & M[20EB]) in
            let:8 a141 = (M[20EB] | M[20EB]) in
            advance (4)
            #0054
            #instruction: JP   NZ,005D
            if (!is_zero(a140)) {
              advance (10)
              #005D
              #instruction: LD   A,(2093)
              advance (13)
              #0060
              #instruction: AND  A
              let:8 a142 = (M[2093] & M[2093]) in
              let:8 a143 = (M[2093] | M[2093]) in
              advance (4)
              #0061
              #instruction: JP   NZ,0082
              if (!is_zero(a142)) {
                advance (10)
                #0082
                #instruction: POP  HL
                let:16 a144 = (1 + (SPH,SPL)) in
                let:16 a145 = (1 + a144) in
                advance (10)
                #0083
                #instruction: POP  DE
                let:16 a146 = (1 + a145) in
                let:16 a147 = (1 + a146) in
                advance (10)
                #0084
                #instruction: POP  BC
                let:16 a148 = (1 + a147) in
                let:16 a149 = (1 + a148) in
                advance (10)
                #0085
                #instruction: POP  PSW
                let:16 a150 = (1 + a149) in
                let:16 a151 = (1 + a150) in
                advance (10)
                #0086
                #instruction: EI
                enable_interrupts()
                advance (4)
                #0087
                #instruction: RET
                let:16 a152 = (1 + a151) in
                let:16 a153 = (1 + a152) in
                advance (10)
                A := M[a150];
                B := M[a148];
                C := M[a147];
                D := M[a146];
                E := M[a145];
                H := M[a144];
                L := M[(SPH,SPL)];
                SPH := a153[15:8];
                SPL := a153[7:0];
                FlagS := M[a149][7];
                FlagZ := M[a149][6];
                FlagA := M[a149][4];
                FlagP := M[a149][2];
                FlagCY := M[a149][0];
                jump ((M[a152],M[a151]));
              } else {
                advance (10)
                #0064
                #instruction: JP   0765
                advance (10)
                #0765
                #instruction: LD   A,01
                advance (7)
                #0767
                #instruction: LD   (2093),A
                M[2093] := 01;
                advance (13)
                #076A
                #instruction: LD   SP,2400
                advance (10)
                #076D
                #instruction: EI
                enable_interrupts()
                advance (4)
                #076E
                #instruction: CALL 1979
                M[23FF] := 07;
                M[23FE] := 71;
                #return-to: 0771
                advance (17)
                #1979
                #instruction: CALL 19D7
                M[23FD] := 19;
                M[23FC] := 7C;
                #return-to: 197C
                advance (17)
                #19D7
                #instruction: XOR  A
                let:8 a154 = (01 ^ 01) in
                advance (4)
                #19D8
                #instruction: JP   19D3
                advance (10)
                #19D3
                #instruction: LD   (20E9),A
                M[20E9] := a154;
                advance (13)
                #19D6
                #instruction: RET
                advance (10)
                A := a154;
                SPH := 23;
                SPL := FE;
                FlagS := a154[7];
                FlagZ := is_zero(a154);
                FlagA := false;
                FlagP := parity(a154);
                FlagCY := false;
                jump ((M[23FD],M[23FC]));
              }
            } else {
              advance (10)
              #0057
              #instruction: CALL 0ABF
              let:16 a155 = (-1 + (SPH,SPL)) in
              M[a155] := 00;
              let:16 a156 = (-1 + a155) in
              M[a156] := 5A;
              #return-to: 005A
              advance (17)
              #0ABF
              #instruction: LD   A,(20C1)
              advance (13)
              #0AC2
              #instruction: RRCA 
              advance (4)
              #0AC3
              #instruction: JP   CY,0ABB
              if (M[20C1][0]) {
                advance (10)
                #0ABB
                #instruction: POP  HL
                let:16 a157 = (1 + a156) in
                let:16 a158 = (1 + a157) in
                advance (10)
                #0ABC
                #instruction: JP   0072
                advance (10)
                A := updateBit((M[20C1] >> 01),7,M[20C1][0]);
                H := M[a157];
                L := M[a156];
                SPH := a158[15:8];
                SPL := a158[7:0];
                FlagS := a140[7];
                FlagZ := is_zero(a140);
                FlagA := a141[3];
                FlagP := parity(a140);
                FlagCY := M[20C1][0];
                jump (0072);
              } else {
                advance (10)
                #0AC6
                #instruction: RRCA 
                advance (4)
                #0AC7
                #instruction: JP   CY,1868
                if (updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) {
                  advance (10)
                  #1868
                  #instruction: LD   HL,20C2
                  advance (10)
                  #186B
                  #instruction: INC  (HL)
                  let:16 a159 = addWithCarry(true,M[20C2],00) in
                  let:8 a160 = (M[20C2] & 0F) in
                  let:8 a161 = (00 & 0F) in
                  let:16 a162 = addWithCarry(true,a160,a161) in
                  M[20C2] := a159[7:0];
                  advance (10)
                  #186C
                  #instruction: INC  HL
                  advance (5)
                  #186D
                  #instruction: LD   C,(HL)
                  advance (7)
                  #186E
                  #instruction: CALL 01D9
                  let:16 a163 = (-1 + a156) in
                  M[a163] := 18;
                  let:16 a164 = (-1 + a163) in
                  M[a164] := 71;
                  #return-to: 1871
                  advance (17)
                  #01D9
                  #instruction: INC  HL
                  advance (5)
                  #01DA
                  #instruction: LD   B,(HL)
                  advance (7)
                  #01DB
                  #instruction: INC  HL
                  advance (5)
                  #01DC
                  #instruction: LD   A,C
                  advance (5)
                  #01DD
                  #instruction: ADD  (HL)
                  let:16 a165 = addWithCarry(false,M[20C5],M[20C3]) in
                  let:8 a166 = (M[20C5] & 0F) in
                  let:8 a167 = (M[20C3] & 0F) in
                  let:16 a168 = addWithCarry(false,a166,a167) in
                  advance (7)
                  #01DE
                  #instruction: LD   (HL),A
                  M[20C5] := a165[7:0];
                  advance (7)
                  #01DF
                  #instruction: INC  HL
                  advance (5)
                  #01E0
                  #instruction: LD   A,B
                  advance (5)
                  #01E1
                  #instruction: ADD  (HL)
                  let:16 a169 = addWithCarry(false,M[20C6],M[20C4]) in
                  let:8 a170 = (M[20C6] & 0F) in
                  let:8 a171 = (M[20C4] & 0F) in
                  let:16 a172 = addWithCarry(false,a170,a171) in
                  advance (7)
                  #01E2
                  #instruction: LD   (HL),A
                  M[20C6] := a169[7:0];
                  advance (7)
                  #01E3
                  #instruction: RET
                  let:16 a173 = (1 + a164) in
                  let:16 a174 = (1 + a173) in
                  advance (10)
                  A := a169[7:0];
                  B := M[20C4];
                  C := M[20C3];
                  H := 20;
                  L := C6;
                  SPH := a174[15:8];
                  SPL := a174[7:0];
                  FlagS := a169[7:0][7];
                  FlagZ := is_zero(a169[7:0]);
                  FlagA := a172[7:0][4];
                  FlagP := parity(a169[7:0]);
                  FlagCY := a169[15:8][0];
                  jump ((M[a173],M[a164]));
                } else {
                  advance (10)
                  #0ACA
                  #instruction: RRCA 
                  advance (4)
                  #0ACB
                  #instruction: JP   CY,0AAB
                  if (updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]) {
                    advance (10)
                    #0AAB
                    #instruction: LD   HL,2050
                    advance (10)
                    #0AAE
                    #instruction: JP   024B
                    advance (10)
                    #024B
                    #instruction: LD   A,(HL)
                    advance (7)
                    #024C
                    #instruction: CP   FF
                    let:16 a175 = addWithCarry(!false,M[2050],~FF) in
                    let:8 a176 = (M[2050] & 0F) in
                    let:8 a177 = (~FF & 0F) in
                    let:16 a178 = addWithCarry(!false,a176,a177) in
                    advance (7)
                    #024E
                    #instruction: RET  Z
                    if (is_zero(a175[7:0])) {
                      let:16 a179 = (1 + a156) in
                      let:16 a180 = (1 + a179) in
                      advance (11)
                      A := M[2050];
                      H := 20;
                      L := 50;
                      SPH := a180[15:8];
                      SPL := a180[7:0];
                      FlagS := a175[7:0][7];
                      FlagZ := is_zero(a175[7:0]);
                      FlagA := a178[7:0][4];
                      FlagP := parity(a175[7:0]);
                      FlagCY := !a175[15:8][0];
                      jump ((M[a179],M[a156]));
                    } else {
                      advance (5)
                      #024F
                      #instruction: CP   FE
                      let:16 a181 = addWithCarry(!false,M[2050],~FE) in
                      let:8 a182 = (M[2050] & 0F) in
                      let:8 a183 = (~FE & 0F) in
                      let:16 a184 = addWithCarry(!false,a182,a183) in
                      advance (7)
                      #0251
                      #instruction: JP   Z,0281
                      if (is_zero(a181[7:0])) {
                        advance (10)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a185 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := M[2050];
                        D := 00;
                        E := 10;
                        H := a185[15:0][15:8];
                        L := a185[15:0][7:0];
                        SPH := a156[15:8];
                        SPL := a156[7:0];
                        FlagS := a181[7:0][7];
                        FlagZ := is_zero(a181[7:0]);
                        FlagA := a184[7:0][4];
                        FlagP := parity(a181[7:0]);
                        FlagCY := a185[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #0254
                        #instruction: INC  HL
                        advance (5)
                        #0255
                        #instruction: LD   B,(HL)
                        advance (7)
                        #0256
                        #instruction: LD   C,A
                        advance (5)
                        #0257
                        #instruction: OR   B
                        let:8 a186 = (M[2051] | M[2050]) in
                        advance (4)
                        #0258
                        #instruction: LD   A,C
                        advance (5)
                        #0259
                        #instruction: JP   NZ,0277
                        if (!is_zero(a186)) {
                          advance (10)
                          #0277
                          #instruction: DEC  B
                          let:16 a187 = addWithCarry(!true,M[2051],~00) in
                          let:8 a188 = (M[2051] & 0F) in
                          let:8 a189 = (~00 & 0F) in
                          let:16 a190 = addWithCarry(!true,a188,a189) in
                          advance (5)
                          #0278
                          #instruction: INC  B
                          let:16 a191 = addWithCarry(true,a187[7:0],00) in
                          let:8 a192 = (a187[7:0] & 0F) in
                          let:8 a193 = (00 & 0F) in
                          let:16 a194 = addWithCarry(true,a192,a193) in
                          advance (5)
                          #0279
                          #instruction: JP   NZ,027D
                          if (!is_zero(a191[7:0])) {
                            advance (10)
                            #027D
                            #instruction: DEC  B
                            let:16 a195 = addWithCarry(!true,a191[7:0],~00) in
                            let:8 a196 = (a191[7:0] & 0F) in
                            let:8 a197 = (~00 & 0F) in
                            let:16 a198 = addWithCarry(!true,a196,a197) in
                            advance (5)
                            #027E
                            #instruction: LD   (HL),B
                            M[2051] := a195[7:0];
                            advance (7)
                            #027F
                            #instruction: DEC  HL
                            advance (5)
                            #0280
                            #instruction: LD   (HL),A
                            M[2050] := M[2050];
                            advance (7)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a199 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := M[2050];
                            B := a195[7:0];
                            C := M[2050];
                            D := 00;
                            E := 10;
                            H := a199[15:0][15:8];
                            L := a199[15:0][7:0];
                            SPH := a156[15:8];
                            SPL := a156[7:0];
                            FlagS := a195[7:0][7];
                            FlagZ := is_zero(a195[7:0]);
                            FlagA := a198[7:0][4];
                            FlagP := parity(a195[7:0]);
                            FlagCY := a199[16];
                            jump (024B);
                          } else {
                            advance (10)
                            #027C
                            #instruction: DEC  A
                            let:16 a200 = addWithCarry(!true,M[2050],~00) in
                            let:8 a201 = (M[2050] & 0F) in
                            let:8 a202 = (~00 & 0F) in
                            let:16 a203 = addWithCarry(!true,a201,a202) in
                            advance (5)
                            #027D
                            #instruction: DEC  B
                            let:16 a204 = addWithCarry(!true,a191[7:0],~00) in
                            let:8 a205 = (a191[7:0] & 0F) in
                            let:8 a206 = (~00 & 0F) in
                            let:16 a207 = addWithCarry(!true,a205,a206) in
                            advance (5)
                            #027E
                            #instruction: LD   (HL),B
                            M[2051] := a204[7:0];
                            advance (7)
                            #027F
                            #instruction: DEC  HL
                            advance (5)
                            #0280
                            #instruction: LD   (HL),A
                            M[2050] := a200[7:0];
                            advance (7)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a208 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := a200[7:0];
                            B := a204[7:0];
                            C := M[2050];
                            D := 00;
                            E := 10;
                            H := a208[15:0][15:8];
                            L := a208[15:0][7:0];
                            SPH := a156[15:8];
                            SPL := a156[7:0];
                            FlagS := a204[7:0][7];
                            FlagZ := is_zero(a204[7:0]);
                            FlagA := a207[7:0][4];
                            FlagP := parity(a204[7:0]);
                            FlagCY := a208[16];
                            jump (024B);
                          }
                        } else {
                          advance (10)
                          #025C
                          #instruction: INC  HL
                          advance (5)
                          #025D
                          #instruction: LD   A,(HL)
                          advance (7)
                          #025E
                          #instruction: AND  A
                          let:8 a209 = (M[2052] & M[2052]) in
                          let:8 a210 = (M[2052] | M[2052]) in
                          advance (4)
                          #025F
                          #instruction: JP   NZ,0288
                          if (!is_zero(a209)) {
                            advance (10)
                            #0288
                            #instruction: DEC  (HL)
                            let:16 a211 = addWithCarry(!true,M[2052],~00) in
                            let:8 a212 = (M[2052] & 0F) in
                            let:8 a213 = (~00 & 0F) in
                            let:16 a214 = addWithCarry(!true,a212,a213) in
                            M[2052] := a211[7:0];
                            advance (10)
                            #0289
                            #instruction: DEC  HL
                            advance (5)
                            #028A
                            #instruction: DEC  HL
                            advance (5)
                            #028B
                            #instruction: JP   0281
                            advance (10)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a215 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := a209;
                            B := M[2051];
                            C := M[2050];
                            D := 00;
                            E := 10;
                            H := a215[15:0][15:8];
                            L := a215[15:0][7:0];
                            SPH := a156[15:8];
                            SPL := a156[7:0];
                            FlagS := a211[7:0][7];
                            FlagZ := is_zero(a211[7:0]);
                            FlagA := a214[7:0][4];
                            FlagP := parity(a211[7:0]);
                            FlagCY := a215[16];
                            jump (024B);
                          } else {
                            advance (10)
                            #0262
                            #instruction: INC  HL
                            advance (5)
                            #0263
                            #instruction: LD   E,(HL)
                            advance (7)
                            #0264
                            #instruction: INC  HL
                            advance (5)
                            #0265
                            #instruction: LD   D,(HL)
                            advance (7)
                            #0266
                            #instruction: PUSH HL
                            let:16 a216 = (-1 + a156) in
                            M[a216] := 20;
                            let:16 a217 = (-1 + a216) in
                            M[a217] := 54;
                            advance (11)
                            #0267
                            #instruction: EX   DE,HL
                            advance (4)
                            #0268
                            #instruction: PUSH HL
                            let:16 a218 = (-1 + a217) in
                            M[a218] := M[2054];
                            let:16 a219 = (-1 + a218) in
                            M[a219] := M[2053];
                            advance (11)
                            #0269
                            #instruction: LD   HL,026F
                            advance (10)
                            #026C
                            #instruction: EX   (SP),HL
                            let:16 a220 = (1 + a219) in
                            M[a219] := 6F;
                            M[a220] := 02;
                            advance (18)
                            #026D
                            #instruction: PUSH DE
                            let:16 a221 = (-1 + a219) in
                            M[a221] := 20;
                            let:16 a222 = (-1 + a221) in
                            M[a222] := 54;
                            advance (11)
                            #026E
                            #instruction: JP   (HL)
                            advance (5)
                            A := a209;
                            B := M[2051];
                            C := M[2050];
                            D := 20;
                            E := 54;
                            H := M[a220];
                            L := M[a219];
                            SPH := a222[15:8];
                            SPL := a222[7:0];
                            FlagS := a209[7];
                            FlagZ := is_zero(a209);
                            FlagA := a210[3];
                            FlagP := parity(a209);
                            FlagCY := false;
                            jump ((M[a220],M[a219]));
                          }
                        }
                      }
                    }
                  } else {
                    advance (10)
                    #0ACE
                    #instruction: RET
                    let:16 a223 = (1 + a156) in
                    let:16 a224 = (1 + a223) in
                    advance (10)
                    A := updateBit((updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) >> 01),7,updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]);
                    SPH := a224[15:8];
                    SPL := a224[7:0];
                    FlagS := a140[7];
                    FlagZ := is_zero(a140);
                    FlagA := a141[3];
                    FlagP := parity(a140);
                    FlagCY := updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0];
                    jump ((M[a223],M[a156]));
                  }
                }
              }
            }
          }
        }
      } else {
        advance (10)
        #002D
        #instruction: LD   A,(20EB)
        advance (13)
        #0030
        #instruction: CP   99
        let:16 a225 = addWithCarry(!false,M[20EB],~99) in
        let:8 a226 = (M[20EB] & 0F) in
        let:8 a227 = (~99 & 0F) in
        let:16 a228 = addWithCarry(!false,a226,a227) in
        advance (7)
        #0032
        #instruction: JP   Z,003E
        if (is_zero(a225[7:0])) {
          advance (10)
          A := M[20EB];
          FlagS := a225[7:0][7];
          FlagZ := is_zero(a225[7:0]);
          FlagA := a228[7:0][4];
          FlagP := parity(a225[7:0]);
          FlagCY := !a225[15:8][0];
          jump (003E);
        } else {
          advance (10)
          #0035
          #instruction: ADD  01
          let:16 a229 = addWithCarry(false,01,M[20EB]) in
          let:8 a230 = (01 & 0F) in
          let:8 a231 = (M[20EB] & 0F) in
          let:16 a232 = addWithCarry(false,a230,a231) in
          advance (7)
          #0037
          #instruction: DAA
          let:8 a233 = (a229[7:0] & 0F) in
          let:16 a234 = addWithCarry(false,a233,06) in
          let:16 a235 = addWithCarry(((((a233[1] || a233[2]) && a233[3]) || a232[7:0][4]) ? a234[7:0] : a233)[4],(a229[7:0] >> 04),00) in
          let:16 a236 = addWithCarry(false,a235[7:0],06) in
          let:8 a237 = (((((a233[1] || a233[2]) && a233[3]) || a232[7:0][4]) ? a234[7:0] : a233) & 0F) in
          let:8 a238 = ((((((a235[7:0][1] || a235[7:0][2]) && a235[7:0][3]) || a229[15:8][0]) ? a236[7:0] : a235[7:0]) << 04) | a237) in
          advance (4)
          #0038
          #instruction: LD   (20EB),A
          M[20EB] := a238;
          advance (13)
          #003B
          #instruction: CALL 1947
          let:16 a239 = (-1 + (SPH,SPL)) in
          M[a239] := 00;
          let:16 a240 = (-1 + a239) in
          M[a240] := 3E;
          #return-to: 003E
          advance (17)
          #1947
          #instruction: LD   A,(20EB)
          advance (13)
          #194A
          #instruction: LD   HL,3C01
          advance (10)
          #194D
          #instruction: JP   09B2
          advance (10)
          #09B2
          #instruction: PUSH DE
          let:16 a241 = (-1 + a240) in
          M[a241] := D;
          let:16 a242 = (-1 + a241) in
          M[a242] := E;
          advance (11)
          #09B3
          #instruction: PUSH PSW
          let:16 a243 = (-1 + a242) in
          M[a243] := M[20EB];
          let:16 a244 = (-1 + a243) in
          M[a244] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a238[7]),6,is_zero(a238)),4,((((a233[1] || a233[2]) && a233[3]) || a232[7:0][4]) ? a234[7:0] : a233)[4]),2,parity(a238)),0,(((((a235[7:0][1] || a235[7:0][2]) && a235[7:0][3]) || a229[15:8][0]) ? a236[7:0] : a235[7:0])[4] || a229[15:8][0]));
          advance (11)
          #09B4
          #instruction: RRCA 
          advance (4)
          #09B5
          #instruction: RRCA 
          advance (4)
          #09B6
          #instruction: RRCA 
          advance (4)
          #09B7
          #instruction: RRCA 
          advance (4)
          #09B8
          #instruction: AND  0F
          let:8 a245 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
          let:8 a246 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
          advance (7)
          #09BA
          #instruction: CALL 09C5
          let:16 a247 = (-1 + a244) in
          M[a247] := 09;
          let:16 a248 = (-1 + a247) in
          M[a248] := BD;
          #return-to: 09BD
          advance (17)
          #09C5
          #instruction: ADD  1A
          let:16 a249 = addWithCarry(false,1A,a245) in
          let:8 a250 = (1A & 0F) in
          let:8 a251 = (a245 & 0F) in
          let:16 a252 = addWithCarry(false,a250,a251) in
          advance (7)
          #09C7
          #instruction: JP   08FF
          advance (10)
          #08FF
          #instruction: LD   DE,1E00
          advance (10)
          #0902
          #instruction: PUSH HL
          let:16 a253 = (-1 + a248) in
          M[a253] := 3C;
          let:16 a254 = (-1 + a253) in
          M[a254] := 01;
          advance (11)
          #0903
          #instruction: LD   H,00
          advance (7)
          #0905
          #instruction: LD   L,A
          advance (5)
          #0906
          #instruction: ADD  HL,HL
          let:17 a255 = add17((00,a249[7:0]),(00,a249[7:0])) in
          advance (10)
          #0907
          #instruction: ADD  HL,HL
          let:17 a256 = add17(a255[15:0],a255[15:0]) in
          advance (10)
          #0908
          #instruction: ADD  HL,HL
          let:17 a257 = add17(a256[15:0],a256[15:0]) in
          advance (10)
          #0909
          #instruction: ADD  HL,DE
          let:17 a258 = add17(1E00,a257[15:0]) in
          advance (10)
          #090A
          #instruction: EX   DE,HL
          advance (4)
          #090B
          #instruction: POP  HL
          let:16 a259 = (1 + a254) in
          let:16 a260 = (1 + a259) in
          advance (10)
          #090C
          #instruction: LD   B,08
          advance (7)
          #090E
          #instruction: OUT  06
          advance (10)
          #0910
          #instruction: JP   1439
          advance (10)
          #1439
          #instruction: PUSH BC
          let:16 a261 = (-1 + a260) in
          M[a261] := 08;
          let:16 a262 = (-1 + a261) in
          M[a262] := C;
          advance (11)
          #143A
          #instruction: LD   A,(DE)
          advance (7)
          #143B
          #instruction: LD   (HL),A
          M[(M[a259],M[a254])] := M[a258[15:0]];
          advance (7)
          #143C
          #instruction: INC  DE
          let:16 a263 = (1 + a258[15:0]) in
          advance (5)
          #143D
          #instruction: LD   BC,0020
          advance (10)
          #1440
          #instruction: ADD  HL,BC
          let:17 a264 = add17(0020,(M[a259],M[a254])) in
          advance (10)
          #1441
          #instruction: POP  BC
          let:16 a265 = (1 + a262) in
          let:16 a266 = (1 + a265) in
          advance (10)
          #1442
          #instruction: DEC  B
          let:16 a267 = addWithCarry(!true,M[a265],~00) in
          let:8 a268 = (M[a265] & 0F) in
          let:8 a269 = (~00 & 0F) in
          let:16 a270 = addWithCarry(!true,a268,a269) in
          advance (5)
          #1443
          #instruction: JP   NZ,1439
          if (!is_zero(a267[7:0])) {
            advance (10)
            A := M[a258[15:0]];
            B := a267[7:0];
            C := M[a262];
            D := a263[15:8];
            E := a263[7:0];
            H := a264[15:0][15:8];
            L := a264[15:0][7:0];
            SPH := a266[15:8];
            SPL := a266[7:0];
            FlagS := a267[7:0][7];
            FlagZ := is_zero(a267[7:0]);
            FlagA := a270[7:0][4];
            FlagP := parity(a267[7:0]);
            FlagCY := a264[16];
            jump (1439);
          } else {
            advance (10)
            #1446
            #instruction: RET
            let:16 a271 = (1 + a266) in
            let:16 a272 = (1 + a271) in
            advance (10)
            A := M[a258[15:0]];
            B := a267[7:0];
            C := M[a262];
            D := a263[15:8];
            E := a263[7:0];
            H := a264[15:0][15:8];
            L := a264[15:0][7:0];
            SPH := a272[15:8];
            SPL := a272[7:0];
            FlagS := a267[7:0][7];
            FlagZ := is_zero(a267[7:0]);
            FlagA := a270[7:0][4];
            FlagP := parity(a267[7:0]);
            FlagCY := a264[16];
            jump ((M[a271],M[a266]));
          }
        }
      }
    }

003E:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #003F
    #instruction: LD   (20EA),A
    M[20EA] := a1;
    advance (13)
    #0042
    #instruction: LD   A,(20E9)
    advance (13)
    #0045
    #instruction: AND  A
    let:8 a2 = (M[20E9] & M[20E9]) in
    let:8 a3 = (M[20E9] | M[20E9]) in
    advance (4)
    #0046
    #instruction: JP   Z,0082
    if (is_zero(a2)) {
      advance (10)
      #0082
      #instruction: POP  HL
      let:16 a4 = (1 + (SPH,SPL)) in
      let:16 a5 = (1 + a4) in
      advance (10)
      #0083
      #instruction: POP  DE
      let:16 a6 = (1 + a5) in
      let:16 a7 = (1 + a6) in
      advance (10)
      #0084
      #instruction: POP  BC
      let:16 a8 = (1 + a7) in
      let:16 a9 = (1 + a8) in
      advance (10)
      #0085
      #instruction: POP  PSW
      let:16 a10 = (1 + a9) in
      let:16 a11 = (1 + a10) in
      advance (10)
      #0086
      #instruction: EI
      enable_interrupts()
      advance (4)
      #0087
      #instruction: RET
      let:16 a12 = (1 + a11) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := M[a10];
      B := M[a8];
      C := M[a7];
      D := M[a6];
      E := M[a5];
      H := M[a4];
      L := M[(SPH,SPL)];
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := M[a9][7];
      FlagZ := M[a9][6];
      FlagA := M[a9][4];
      FlagP := M[a9][2];
      FlagCY := M[a9][0];
      jump ((M[a12],M[a11]));
    } else {
      advance (10)
      #0049
      #instruction: LD   A,(20EF)
      advance (13)
      #004C
      #instruction: AND  A
      let:8 a14 = (M[20EF] & M[20EF]) in
      let:8 a15 = (M[20EF] | M[20EF]) in
      advance (4)
      #004D
      #instruction: JP   NZ,006F
      if (!is_zero(a14)) {
        advance (10)
        #006F
        #instruction: CALL 1740
        let:16 a16 = (-1 + (SPH,SPL)) in
        M[a16] := 00;
        let:16 a17 = (-1 + a16) in
        M[a17] := 72;
        #return-to: 0072
        advance (17)
        #1740
        #instruction: LD   HL,209B
        advance (10)
        #1743
        #instruction: DEC  (HL)
        let:16 a18 = addWithCarry(!true,M[209B],~00) in
        let:8 a19 = (M[209B] & 0F) in
        let:8 a20 = (~00 & 0F) in
        let:16 a21 = addWithCarry(!true,a19,a20) in
        M[209B] := a18[7:0];
        advance (10)
        #1744
        #instruction: CALL Z,176D
        if (is_zero(a18[7:0])) {
          let:16 a22 = (-1 + a17) in
          M[a22] := 17;
          let:16 a23 = (-1 + a22) in
          M[a23] := 47;
          #return-to: 1747
          advance (17)
          #176D
          #instruction: LD   A,(2098)
          advance (13)
          #1770
          #instruction: AND  30
          let:8 a24 = (30 & M[2098]) in
          let:8 a25 = (30 | M[2098]) in
          advance (7)
          #1772
          #instruction: OUT  05
          sound_control(FleetMovement1,a24[0]);
          sound_control(FleetMovement2,a24[1]);
          sound_control(FleetMovement3,a24[2]);
          sound_control(FleetMovement4,a24[3]);
          sound_control(UfoHit,a24[4]);
          advance (10)
          #1774
          #instruction: RET
          let:16 a26 = (1 + a23) in
          let:16 a27 = (1 + a26) in
          advance (10)
          A := a24;
          H := 20;
          L := 9B;
          SPH := a27[15:8];
          SPL := a27[7:0];
          FlagS := a24[7];
          FlagZ := is_zero(a24);
          FlagA := a25[3];
          FlagP := parity(a24);
          FlagCY := false;
          jump ((M[a26],M[a23]));
        } else {
          advance (11)
          A := a14;
          H := 20;
          L := 9B;
          SPH := a17[15:8];
          SPL := a17[7:0];
          FlagS := a18[7:0][7];
          FlagZ := is_zero(a18[7:0]);
          FlagA := a21[7:0][4];
          FlagP := parity(a18[7:0]);
          FlagCY := false;
          jump (1747);
        }
      } else {
        advance (10)
        #0050
        #instruction: LD   A,(20EB)
        advance (13)
        #0053
        #instruction: AND  A
        let:8 a28 = (M[20EB] & M[20EB]) in
        let:8 a29 = (M[20EB] | M[20EB]) in
        advance (4)
        #0054
        #instruction: JP   NZ,005D
        if (!is_zero(a28)) {
          advance (10)
          #005D
          #instruction: LD   A,(2093)
          advance (13)
          #0060
          #instruction: AND  A
          let:8 a30 = (M[2093] & M[2093]) in
          let:8 a31 = (M[2093] | M[2093]) in
          advance (4)
          #0061
          #instruction: JP   NZ,0082
          if (!is_zero(a30)) {
            advance (10)
            #0082
            #instruction: POP  HL
            let:16 a32 = (1 + (SPH,SPL)) in
            let:16 a33 = (1 + a32) in
            advance (10)
            #0083
            #instruction: POP  DE
            let:16 a34 = (1 + a33) in
            let:16 a35 = (1 + a34) in
            advance (10)
            #0084
            #instruction: POP  BC
            let:16 a36 = (1 + a35) in
            let:16 a37 = (1 + a36) in
            advance (10)
            #0085
            #instruction: POP  PSW
            let:16 a38 = (1 + a37) in
            let:16 a39 = (1 + a38) in
            advance (10)
            #0086
            #instruction: EI
            enable_interrupts()
            advance (4)
            #0087
            #instruction: RET
            let:16 a40 = (1 + a39) in
            let:16 a41 = (1 + a40) in
            advance (10)
            A := M[a38];
            B := M[a36];
            C := M[a35];
            D := M[a34];
            E := M[a33];
            H := M[a32];
            L := M[(SPH,SPL)];
            SPH := a41[15:8];
            SPL := a41[7:0];
            FlagS := M[a37][7];
            FlagZ := M[a37][6];
            FlagA := M[a37][4];
            FlagP := M[a37][2];
            FlagCY := M[a37][0];
            jump ((M[a40],M[a39]));
          } else {
            advance (10)
            #0064
            #instruction: JP   0765
            advance (10)
            #0765
            #instruction: LD   A,01
            advance (7)
            #0767
            #instruction: LD   (2093),A
            M[2093] := 01;
            advance (13)
            #076A
            #instruction: LD   SP,2400
            advance (10)
            #076D
            #instruction: EI
            enable_interrupts()
            advance (4)
            #076E
            #instruction: CALL 1979
            M[23FF] := 07;
            M[23FE] := 71;
            #return-to: 0771
            advance (17)
            #1979
            #instruction: CALL 19D7
            M[23FD] := 19;
            M[23FC] := 7C;
            #return-to: 197C
            advance (17)
            #19D7
            #instruction: XOR  A
            let:8 a42 = (01 ^ 01) in
            advance (4)
            #19D8
            #instruction: JP   19D3
            advance (10)
            #19D3
            #instruction: LD   (20E9),A
            M[20E9] := a42;
            advance (13)
            #19D6
            #instruction: RET
            advance (10)
            A := a42;
            SPH := 23;
            SPL := FE;
            FlagS := a42[7];
            FlagZ := is_zero(a42);
            FlagA := false;
            FlagP := parity(a42);
            FlagCY := false;
            jump ((M[23FD],M[23FC]));
          }
        } else {
          advance (10)
          #0057
          #instruction: CALL 0ABF
          let:16 a43 = (-1 + (SPH,SPL)) in
          M[a43] := 00;
          let:16 a44 = (-1 + a43) in
          M[a44] := 5A;
          #return-to: 005A
          advance (17)
          #0ABF
          #instruction: LD   A,(20C1)
          advance (13)
          #0AC2
          #instruction: RRCA 
          advance (4)
          #0AC3
          #instruction: JP   CY,0ABB
          if (M[20C1][0]) {
            advance (10)
            #0ABB
            #instruction: POP  HL
            let:16 a45 = (1 + a44) in
            let:16 a46 = (1 + a45) in
            advance (10)
            #0ABC
            #instruction: JP   0072
            advance (10)
            A := updateBit((M[20C1] >> 01),7,M[20C1][0]);
            H := M[a45];
            L := M[a44];
            SPH := a46[15:8];
            SPL := a46[7:0];
            FlagS := a28[7];
            FlagZ := is_zero(a28);
            FlagA := a29[3];
            FlagP := parity(a28);
            FlagCY := M[20C1][0];
            jump (0072);
          } else {
            advance (10)
            #0AC6
            #instruction: RRCA 
            advance (4)
            #0AC7
            #instruction: JP   CY,1868
            if (updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) {
              advance (10)
              #1868
              #instruction: LD   HL,20C2
              advance (10)
              #186B
              #instruction: INC  (HL)
              let:16 a47 = addWithCarry(true,M[20C2],00) in
              let:8 a48 = (M[20C2] & 0F) in
              let:8 a49 = (00 & 0F) in
              let:16 a50 = addWithCarry(true,a48,a49) in
              M[20C2] := a47[7:0];
              advance (10)
              #186C
              #instruction: INC  HL
              advance (5)
              #186D
              #instruction: LD   C,(HL)
              advance (7)
              #186E
              #instruction: CALL 01D9
              let:16 a51 = (-1 + a44) in
              M[a51] := 18;
              let:16 a52 = (-1 + a51) in
              M[a52] := 71;
              #return-to: 1871
              advance (17)
              #01D9
              #instruction: INC  HL
              advance (5)
              #01DA
              #instruction: LD   B,(HL)
              advance (7)
              #01DB
              #instruction: INC  HL
              advance (5)
              #01DC
              #instruction: LD   A,C
              advance (5)
              #01DD
              #instruction: ADD  (HL)
              let:16 a53 = addWithCarry(false,M[20C5],M[20C3]) in
              let:8 a54 = (M[20C5] & 0F) in
              let:8 a55 = (M[20C3] & 0F) in
              let:16 a56 = addWithCarry(false,a54,a55) in
              advance (7)
              #01DE
              #instruction: LD   (HL),A
              M[20C5] := a53[7:0];
              advance (7)
              #01DF
              #instruction: INC  HL
              advance (5)
              #01E0
              #instruction: LD   A,B
              advance (5)
              #01E1
              #instruction: ADD  (HL)
              let:16 a57 = addWithCarry(false,M[20C6],M[20C4]) in
              let:8 a58 = (M[20C6] & 0F) in
              let:8 a59 = (M[20C4] & 0F) in
              let:16 a60 = addWithCarry(false,a58,a59) in
              advance (7)
              #01E2
              #instruction: LD   (HL),A
              M[20C6] := a57[7:0];
              advance (7)
              #01E3
              #instruction: RET
              let:16 a61 = (1 + a52) in
              let:16 a62 = (1 + a61) in
              advance (10)
              A := a57[7:0];
              B := M[20C4];
              C := M[20C3];
              H := 20;
              L := C6;
              SPH := a62[15:8];
              SPL := a62[7:0];
              FlagS := a57[7:0][7];
              FlagZ := is_zero(a57[7:0]);
              FlagA := a60[7:0][4];
              FlagP := parity(a57[7:0]);
              FlagCY := a57[15:8][0];
              jump ((M[a61],M[a52]));
            } else {
              advance (10)
              #0ACA
              #instruction: RRCA 
              advance (4)
              #0ACB
              #instruction: JP   CY,0AAB
              if (updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]) {
                advance (10)
                #0AAB
                #instruction: LD   HL,2050
                advance (10)
                #0AAE
                #instruction: JP   024B
                advance (10)
                #024B
                #instruction: LD   A,(HL)
                advance (7)
                #024C
                #instruction: CP   FF
                let:16 a63 = addWithCarry(!false,M[2050],~FF) in
                let:8 a64 = (M[2050] & 0F) in
                let:8 a65 = (~FF & 0F) in
                let:16 a66 = addWithCarry(!false,a64,a65) in
                advance (7)
                #024E
                #instruction: RET  Z
                if (is_zero(a63[7:0])) {
                  let:16 a67 = (1 + a44) in
                  let:16 a68 = (1 + a67) in
                  advance (11)
                  A := M[2050];
                  H := 20;
                  L := 50;
                  SPH := a68[15:8];
                  SPL := a68[7:0];
                  FlagS := a63[7:0][7];
                  FlagZ := is_zero(a63[7:0]);
                  FlagA := a66[7:0][4];
                  FlagP := parity(a63[7:0]);
                  FlagCY := !a63[15:8][0];
                  jump ((M[a67],M[a44]));
                } else {
                  advance (5)
                  #024F
                  #instruction: CP   FE
                  let:16 a69 = addWithCarry(!false,M[2050],~FE) in
                  let:8 a70 = (M[2050] & 0F) in
                  let:8 a71 = (~FE & 0F) in
                  let:16 a72 = addWithCarry(!false,a70,a71) in
                  advance (7)
                  #0251
                  #instruction: JP   Z,0281
                  if (is_zero(a69[7:0])) {
                    advance (10)
                    #0281
                    #instruction: LD   DE,0010
                    advance (10)
                    #0284
                    #instruction: ADD  HL,DE
                    let:17 a73 = add17(0010,2050) in
                    advance (10)
                    #0285
                    #instruction: JP   024B
                    advance (10)
                    A := M[2050];
                    D := 00;
                    E := 10;
                    H := a73[15:0][15:8];
                    L := a73[15:0][7:0];
                    SPH := a44[15:8];
                    SPL := a44[7:0];
                    FlagS := a69[7:0][7];
                    FlagZ := is_zero(a69[7:0]);
                    FlagA := a72[7:0][4];
                    FlagP := parity(a69[7:0]);
                    FlagCY := a73[16];
                    jump (024B);
                  } else {
                    advance (10)
                    #0254
                    #instruction: INC  HL
                    advance (5)
                    #0255
                    #instruction: LD   B,(HL)
                    advance (7)
                    #0256
                    #instruction: LD   C,A
                    advance (5)
                    #0257
                    #instruction: OR   B
                    let:8 a74 = (M[2051] | M[2050]) in
                    advance (4)
                    #0258
                    #instruction: LD   A,C
                    advance (5)
                    #0259
                    #instruction: JP   NZ,0277
                    if (!is_zero(a74)) {
                      advance (10)
                      #0277
                      #instruction: DEC  B
                      let:16 a75 = addWithCarry(!true,M[2051],~00) in
                      let:8 a76 = (M[2051] & 0F) in
                      let:8 a77 = (~00 & 0F) in
                      let:16 a78 = addWithCarry(!true,a76,a77) in
                      advance (5)
                      #0278
                      #instruction: INC  B
                      let:16 a79 = addWithCarry(true,a75[7:0],00) in
                      let:8 a80 = (a75[7:0] & 0F) in
                      let:8 a81 = (00 & 0F) in
                      let:16 a82 = addWithCarry(true,a80,a81) in
                      advance (5)
                      #0279
                      #instruction: JP   NZ,027D
                      if (!is_zero(a79[7:0])) {
                        advance (10)
                        #027D
                        #instruction: DEC  B
                        let:16 a83 = addWithCarry(!true,a79[7:0],~00) in
                        let:8 a84 = (a79[7:0] & 0F) in
                        let:8 a85 = (~00 & 0F) in
                        let:16 a86 = addWithCarry(!true,a84,a85) in
                        advance (5)
                        #027E
                        #instruction: LD   (HL),B
                        M[2051] := a83[7:0];
                        advance (7)
                        #027F
                        #instruction: DEC  HL
                        advance (5)
                        #0280
                        #instruction: LD   (HL),A
                        M[2050] := M[2050];
                        advance (7)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a87 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := M[2050];
                        B := a83[7:0];
                        C := M[2050];
                        D := 00;
                        E := 10;
                        H := a87[15:0][15:8];
                        L := a87[15:0][7:0];
                        SPH := a44[15:8];
                        SPL := a44[7:0];
                        FlagS := a83[7:0][7];
                        FlagZ := is_zero(a83[7:0]);
                        FlagA := a86[7:0][4];
                        FlagP := parity(a83[7:0]);
                        FlagCY := a87[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #027C
                        #instruction: DEC  A
                        let:16 a88 = addWithCarry(!true,M[2050],~00) in
                        let:8 a89 = (M[2050] & 0F) in
                        let:8 a90 = (~00 & 0F) in
                        let:16 a91 = addWithCarry(!true,a89,a90) in
                        advance (5)
                        #027D
                        #instruction: DEC  B
                        let:16 a92 = addWithCarry(!true,a79[7:0],~00) in
                        let:8 a93 = (a79[7:0] & 0F) in
                        let:8 a94 = (~00 & 0F) in
                        let:16 a95 = addWithCarry(!true,a93,a94) in
                        advance (5)
                        #027E
                        #instruction: LD   (HL),B
                        M[2051] := a92[7:0];
                        advance (7)
                        #027F
                        #instruction: DEC  HL
                        advance (5)
                        #0280
                        #instruction: LD   (HL),A
                        M[2050] := a88[7:0];
                        advance (7)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a96 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a88[7:0];
                        B := a92[7:0];
                        C := M[2050];
                        D := 00;
                        E := 10;
                        H := a96[15:0][15:8];
                        L := a96[15:0][7:0];
                        SPH := a44[15:8];
                        SPL := a44[7:0];
                        FlagS := a92[7:0][7];
                        FlagZ := is_zero(a92[7:0]);
                        FlagA := a95[7:0][4];
                        FlagP := parity(a92[7:0]);
                        FlagCY := a96[16];
                        jump (024B);
                      }
                    } else {
                      advance (10)
                      #025C
                      #instruction: INC  HL
                      advance (5)
                      #025D
                      #instruction: LD   A,(HL)
                      advance (7)
                      #025E
                      #instruction: AND  A
                      let:8 a97 = (M[2052] & M[2052]) in
                      let:8 a98 = (M[2052] | M[2052]) in
                      advance (4)
                      #025F
                      #instruction: JP   NZ,0288
                      if (!is_zero(a97)) {
                        advance (10)
                        #0288
                        #instruction: DEC  (HL)
                        let:16 a99 = addWithCarry(!true,M[2052],~00) in
                        let:8 a100 = (M[2052] & 0F) in
                        let:8 a101 = (~00 & 0F) in
                        let:16 a102 = addWithCarry(!true,a100,a101) in
                        M[2052] := a99[7:0];
                        advance (10)
                        #0289
                        #instruction: DEC  HL
                        advance (5)
                        #028A
                        #instruction: DEC  HL
                        advance (5)
                        #028B
                        #instruction: JP   0281
                        advance (10)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a103 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a97;
                        B := M[2051];
                        C := M[2050];
                        D := 00;
                        E := 10;
                        H := a103[15:0][15:8];
                        L := a103[15:0][7:0];
                        SPH := a44[15:8];
                        SPL := a44[7:0];
                        FlagS := a99[7:0][7];
                        FlagZ := is_zero(a99[7:0]);
                        FlagA := a102[7:0][4];
                        FlagP := parity(a99[7:0]);
                        FlagCY := a103[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #0262
                        #instruction: INC  HL
                        advance (5)
                        #0263
                        #instruction: LD   E,(HL)
                        advance (7)
                        #0264
                        #instruction: INC  HL
                        advance (5)
                        #0265
                        #instruction: LD   D,(HL)
                        advance (7)
                        #0266
                        #instruction: PUSH HL
                        let:16 a104 = (-1 + a44) in
                        M[a104] := 20;
                        let:16 a105 = (-1 + a104) in
                        M[a105] := 54;
                        advance (11)
                        #0267
                        #instruction: EX   DE,HL
                        advance (4)
                        #0268
                        #instruction: PUSH HL
                        let:16 a106 = (-1 + a105) in
                        M[a106] := M[2054];
                        let:16 a107 = (-1 + a106) in
                        M[a107] := M[2053];
                        advance (11)
                        #0269
                        #instruction: LD   HL,026F
                        advance (10)
                        #026C
                        #instruction: EX   (SP),HL
                        let:16 a108 = (1 + a107) in
                        M[a107] := 6F;
                        M[a108] := 02;
                        advance (18)
                        #026D
                        #instruction: PUSH DE
                        let:16 a109 = (-1 + a107) in
                        M[a109] := 20;
                        let:16 a110 = (-1 + a109) in
                        M[a110] := 54;
                        advance (11)
                        #026E
                        #instruction: JP   (HL)
                        advance (5)
                        A := a97;
                        B := M[2051];
                        C := M[2050];
                        D := 20;
                        E := 54;
                        H := M[a108];
                        L := M[a107];
                        SPH := a110[15:8];
                        SPL := a110[7:0];
                        FlagS := a97[7];
                        FlagZ := is_zero(a97);
                        FlagA := a98[3];
                        FlagP := parity(a97);
                        FlagCY := false;
                        jump ((M[a108],M[a107]));
                      }
                    }
                  }
                }
              } else {
                advance (10)
                #0ACE
                #instruction: RET
                let:16 a111 = (1 + a44) in
                let:16 a112 = (1 + a111) in
                advance (10)
                A := updateBit((updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0]) >> 01),7,updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0]);
                SPH := a112[15:8];
                SPL := a112[7:0];
                FlagS := a28[7];
                FlagZ := is_zero(a28);
                FlagA := a29[3];
                FlagP := parity(a28);
                FlagCY := updateBit((updateBit((M[20C1] >> 01),7,M[20C1][0]) >> 01),7,updateBit((M[20C1] >> 01),7,M[20C1][0])[0])[0];
                jump ((M[a111],M[a44]));
              }
            }
          }
        }
      }
    }

005A:

    #instruction: JP   0082
    advance (10)
    #0082
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0083
    #instruction: POP  DE
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    #0084
    #instruction: POP  BC
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:16 a9 = (1 + a8) in
    let:16 a10 = (1 + a9) in
    advance (10)
    A := M[a7];
    B := M[a5];
    C := M[a4];
    D := M[a3];
    E := M[a2];
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := M[a6][7];
    FlagZ := M[a6][6];
    FlagA := M[a6][4];
    FlagP := M[a6][2];
    FlagCY := M[a6][0];
    jump ((M[a9],M[a8]));

0072:

    #instruction: LD   A,(2032)
    advance (13)
    #0075
    #instruction: LD   (2080),A
    M[2080] := M[2032];
    advance (13)
    #0078
    #instruction: CALL 0100
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    #return-to: 007B
    advance (17)
    #0100
    #instruction: LD   HL,2002
    advance (10)
    #0103
    #instruction: LD   A,(HL)
    advance (7)
    #0104
    #instruction: AND  A
    let:8 a3 = (M[2002] & M[2002]) in
    let:8 a4 = (M[2002] | M[2002]) in
    advance (4)
    #0105
    #instruction: JP   NZ,1538
    if (!is_zero(a3)) {
      advance (10)
      #1538
      #instruction: LD   HL,2003
      advance (10)
      #153B
      #instruction: DEC  (HL)
      let:16 a5 = addWithCarry(!true,M[2003],~00) in
      let:8 a6 = (M[2003] & 0F) in
      let:8 a7 = (~00 & 0F) in
      let:16 a8 = addWithCarry(!true,a6,a7) in
      M[2003] := a5[7:0];
      advance (10)
      #153C
      #instruction: RET  NZ
      if (!is_zero(a5[7:0])) {
        let:16 a9 = (1 + a2) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := a3;
        H := 20;
        L := 03;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := false;
        jump ((M[a9],M[a2]));
      } else {
        advance (5)
        #153D
        #instruction: LD   HL,(2064)
        advance (16)
        #1540
        #instruction: LD   B,10
        advance (7)
        #1542
        #instruction: CALL 1424
        let:16 a11 = (-1 + a2) in
        M[a11] := 15;
        let:16 a12 = (-1 + a11) in
        M[a12] := 45;
        #return-to: 1545
        advance (17)
        #1424
        #instruction: CALL 1474
        let:16 a13 = (-1 + a12) in
        M[a13] := 14;
        let:16 a14 = (-1 + a13) in
        M[a14] := 27;
        #return-to: 1427
        advance (17)
        #1474
        #instruction: LD   A,L
        advance (5)
        #1475
        #instruction: AND  07
        let:8 a15 = (07 & M[2064]) in
        let:8 a16 = (07 | M[2064]) in
        advance (7)
        #1477
        #instruction: OUT  02
        advance (10)
        #1479
        #instruction: JP   1A47
        advance (10)
        #1A47
        #instruction: PUSH BC
        let:16 a17 = (-1 + a14) in
        M[a17] := 10;
        let:16 a18 = (-1 + a17) in
        M[a18] := C;
        advance (11)
        #1A48
        #instruction: LD   B,03
        advance (7)
        #1A4A
        #instruction: LD   A,H
        advance (5)
        #1A4B
        #instruction: RAR
        advance (4)
        #1A4C
        #instruction: LD   H,A
        advance (5)
        #1A4D
        #instruction: LD   A,L
        advance (5)
        #1A4E
        #instruction: RAR
        advance (4)
        #1A4F
        #instruction: LD   L,A
        advance (5)
        #1A50
        #instruction: DEC  B
        let:16 a19 = addWithCarry(!true,03,~00) in
        let:8 a20 = (03 & 0F) in
        let:8 a21 = (~00 & 0F) in
        let:16 a22 = addWithCarry(!true,a20,a21) in
        advance (5)
        #1A51
        #instruction: JP   NZ,1A4A
        if (!is_zero(a19[7:0])) {
          advance (10)
          A := updateBit((M[2064] >> 01),7,M[2065][0]);
          B := a19[7:0];
          H := updateBit((M[2065] >> 01),7,false);
          L := updateBit((M[2064] >> 01),7,M[2065][0]);
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a19[7:0][7];
          FlagZ := is_zero(a19[7:0]);
          FlagA := a22[7:0][4];
          FlagP := parity(a19[7:0]);
          FlagCY := M[2064][0];
          Shifter_OFF := a15;
          jump (1A4A);
        } else {
          advance (10)
          #1A54
          #instruction: LD   A,H
          advance (5)
          #1A55
          #instruction: AND  3F
          let:8 a23 = (3F & updateBit((M[2065] >> 01),7,false)) in
          let:8 a24 = (3F | updateBit((M[2065] >> 01),7,false)) in
          advance (7)
          #1A57
          #instruction: OR   20
          let:8 a25 = (20 | a23) in
          advance (7)
          #1A59
          #instruction: LD   H,A
          advance (5)
          #1A5A
          #instruction: POP  BC
          let:16 a26 = (1 + a18) in
          let:16 a27 = (1 + a26) in
          advance (10)
          #1A5B
          #instruction: RET
          let:16 a28 = (1 + a27) in
          let:16 a29 = (1 + a28) in
          advance (10)
          A := a25;
          B := M[a26];
          C := M[a18];
          H := a25;
          L := updateBit((M[2064] >> 01),7,M[2065][0]);
          SPH := a29[15:8];
          SPL := a29[7:0];
          FlagS := a25[7];
          FlagZ := is_zero(a25);
          FlagA := false;
          FlagP := parity(a25);
          FlagCY := false;
          Shifter_OFF := a15;
          jump ((M[a28],M[a27]));
        }
      }
    } else {
      advance (10)
      #0108
      #instruction: PUSH HL
      let:16 a30 = (-1 + a2) in
      M[a30] := 20;
      let:16 a31 = (-1 + a30) in
      M[a31] := 02;
      advance (11)
      #0109
      #instruction: LD   A,(2006)
      advance (13)
      #010C
      #instruction: LD   L,A
      advance (5)
      #010D
      #instruction: LD   A,(2067)
      advance (13)
      #0110
      #instruction: LD   H,A
      advance (5)
      #0111
      #instruction: LD   A,(HL)
      advance (7)
      #0112
      #instruction: AND  A
      let:8 a32 = (M[(M[2067],M[2006])] & M[(M[2067],M[2006])]) in
      let:8 a33 = (M[(M[2067],M[2006])] | M[(M[2067],M[2006])]) in
      advance (4)
      #0113
      #instruction: POP  HL
      let:16 a34 = (1 + a31) in
      let:16 a35 = (1 + a34) in
      advance (10)
      #0114
      #instruction: JP   Z,0136
      if (is_zero(a32)) {
        advance (10)
        A := a32;
        H := M[a34];
        L := M[a31];
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a32[7];
        FlagZ := is_zero(a32);
        FlagA := a33[3];
        FlagP := parity(a32);
        FlagCY := false;
        jump (0136);
      } else {
        advance (10)
        #0117
        #instruction: INC  HL
        let:16 a36 = (1 + (M[a34],M[a31])) in
        advance (5)
        #0118
        #instruction: INC  HL
        let:16 a37 = (1 + a36) in
        advance (5)
        #0119
        #instruction: LD   A,(HL)
        advance (7)
        #011A
        #instruction: INC  HL
        let:16 a38 = (1 + a37) in
        advance (5)
        #011B
        #instruction: LD   B,(HL)
        advance (7)
        #011C
        #instruction: AND  FE
        let:8 a39 = (FE & M[a37]) in
        let:8 a40 = (FE | M[a37]) in
        advance (7)
        #011E
        #instruction: RLCA 
        advance (4)
        #011F
        #instruction: RLCA 
        advance (4)
        #0120
        #instruction: RLCA 
        advance (4)
        #0121
        #instruction: LD   E,A
        advance (5)
        #0122
        #instruction: LD   D,00
        advance (7)
        #0124
        #instruction: LD   HL,1C00
        advance (10)
        #0127
        #instruction: ADD  HL,DE
        let:17 a41 = add17((00,updateBit((updateBit((updateBit((a39 << 01),0,a39[7]) << 01),0,updateBit((a39 << 01),0,a39[7])[7]) << 01),0,updateBit((updateBit((a39 << 01),0,a39[7]) << 01),0,updateBit((a39 << 01),0,a39[7])[7])[7])),1C00) in
        advance (10)
        #0128
        #instruction: EX   DE,HL
        advance (4)
        #0129
        #instruction: LD   A,B
        advance (5)
        #012A
        #instruction: AND  A
        let:8 a42 = (M[a38] & M[a38]) in
        let:8 a43 = (M[a38] | M[a38]) in
        advance (4)
        #012B
        #instruction: CALL NZ,013B
        if (!is_zero(a42)) {
          let:16 a44 = (-1 + a35) in
          M[a44] := 01;
          let:16 a45 = (-1 + a44) in
          M[a45] := 2E;
          #return-to: 012E
          advance (17)
          #013B
          #instruction: LD   HL,0030
          advance (10)
          #013E
          #instruction: ADD  HL,DE
          let:17 a46 = add17(a41[15:0],0030) in
          advance (10)
          #013F
          #instruction: EX   DE,HL
          advance (4)
          #0140
          #instruction: RET
          let:16 a47 = (1 + a45) in
          let:16 a48 = (1 + a47) in
          advance (10)
          A := a42;
          B := M[a38];
          D := a46[15:0][15:8];
          E := a46[15:0][7:0];
          H := a41[15:0][15:8];
          L := a41[15:0][7:0];
          SPH := a48[15:8];
          SPL := a48[7:0];
          FlagS := a42[7];
          FlagZ := is_zero(a42);
          FlagA := a43[3];
          FlagP := parity(a42);
          FlagCY := a46[16];
          jump ((M[a47],M[a45]));
        } else {
          advance (11)
          A := a42;
          B := M[a38];
          D := a41[15:0][15:8];
          E := a41[15:0][7:0];
          H := 00;
          L := updateBit((updateBit((updateBit((a39 << 01),0,a39[7]) << 01),0,updateBit((a39 << 01),0,a39[7])[7]) << 01),0,updateBit((updateBit((a39 << 01),0,a39[7]) << 01),0,updateBit((a39 << 01),0,a39[7])[7])[7]);
          SPH := a35[15:8];
          SPL := a35[7:0];
          FlagS := a42[7];
          FlagZ := is_zero(a42);
          FlagA := a43[3];
          FlagP := parity(a42);
          FlagCY := false;
          jump (012E);
        }
      }
    }

007B:

    #instruction: CALL 0248
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7E;
    #return-to: 007E
    advance (17)
    #0248
    #instruction: LD   HL,2010
    advance (10)
    #024B
    #instruction: LD   A,(HL)
    advance (7)
    #024C
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2010],~FF) in
    let:8 a4 = (M[2010] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #024E
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2010];
      H := 20;
      L := 10;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #024F
      #instruction: CP   FE
      let:16 a9 = addWithCarry(!false,M[2010],~FE) in
      let:8 a10 = (M[2010] & 0F) in
      let:8 a11 = (~FE & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0251
      #instruction: JP   Z,0281
      if (is_zero(a9[7:0])) {
        advance (10)
        #0281
        #instruction: LD   DE,0010
        advance (10)
        #0284
        #instruction: ADD  HL,DE
        let:17 a13 = add17(0010,2010) in
        advance (10)
        #0285
        #instruction: JP   024B
        advance (10)
        A := M[2010];
        D := 00;
        E := 10;
        H := a13[15:0][15:8];
        L := a13[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := a13[16];
        jump (024B);
      } else {
        advance (10)
        #0254
        #instruction: INC  HL
        advance (5)
        #0255
        #instruction: LD   B,(HL)
        advance (7)
        #0256
        #instruction: LD   C,A
        advance (5)
        #0257
        #instruction: OR   B
        let:8 a14 = (M[2011] | M[2010]) in
        advance (4)
        #0258
        #instruction: LD   A,C
        advance (5)
        #0259
        #instruction: JP   NZ,0277
        if (!is_zero(a14)) {
          advance (10)
          #0277
          #instruction: DEC  B
          let:16 a15 = addWithCarry(!true,M[2011],~00) in
          let:8 a16 = (M[2011] & 0F) in
          let:8 a17 = (~00 & 0F) in
          let:16 a18 = addWithCarry(!true,a16,a17) in
          advance (5)
          #0278
          #instruction: INC  B
          let:16 a19 = addWithCarry(true,a15[7:0],00) in
          let:8 a20 = (a15[7:0] & 0F) in
          let:8 a21 = (00 & 0F) in
          let:16 a22 = addWithCarry(true,a20,a21) in
          advance (5)
          #0279
          #instruction: JP   NZ,027D
          if (!is_zero(a19[7:0])) {
            advance (10)
            #027D
            #instruction: DEC  B
            let:16 a23 = addWithCarry(!true,a19[7:0],~00) in
            let:8 a24 = (a19[7:0] & 0F) in
            let:8 a25 = (~00 & 0F) in
            let:16 a26 = addWithCarry(!true,a24,a25) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            M[2011] := a23[7:0];
            advance (7)
            #027F
            #instruction: DEC  HL
            advance (5)
            #0280
            #instruction: LD   (HL),A
            M[2010] := M[2010];
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a27 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := M[2010];
            B := a23[7:0];
            C := M[2010];
            D := 00;
            E := 10;
            H := a27[15:0][15:8];
            L := a27[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a23[7:0][7];
            FlagZ := is_zero(a23[7:0]);
            FlagA := a26[7:0][4];
            FlagP := parity(a23[7:0]);
            FlagCY := a27[16];
            jump (024B);
          } else {
            advance (10)
            #027C
            #instruction: DEC  A
            let:16 a28 = addWithCarry(!true,M[2010],~00) in
            let:8 a29 = (M[2010] & 0F) in
            let:8 a30 = (~00 & 0F) in
            let:16 a31 = addWithCarry(!true,a29,a30) in
            advance (5)
            #027D
            #instruction: DEC  B
            let:16 a32 = addWithCarry(!true,a19[7:0],~00) in
            let:8 a33 = (a19[7:0] & 0F) in
            let:8 a34 = (~00 & 0F) in
            let:16 a35 = addWithCarry(!true,a33,a34) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            M[2011] := a32[7:0];
            advance (7)
            #027F
            #instruction: DEC  HL
            advance (5)
            #0280
            #instruction: LD   (HL),A
            M[2010] := a28[7:0];
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a36 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a28[7:0];
            B := a32[7:0];
            C := M[2010];
            D := 00;
            E := 10;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a32[7:0][7];
            FlagZ := is_zero(a32[7:0]);
            FlagA := a35[7:0][4];
            FlagP := parity(a32[7:0]);
            FlagCY := a36[16];
            jump (024B);
          }
        } else {
          advance (10)
          #025C
          #instruction: INC  HL
          advance (5)
          #025D
          #instruction: LD   A,(HL)
          advance (7)
          #025E
          #instruction: AND  A
          let:8 a37 = (M[2012] & M[2012]) in
          let:8 a38 = (M[2012] | M[2012]) in
          advance (4)
          #025F
          #instruction: JP   NZ,0288
          if (!is_zero(a37)) {
            advance (10)
            #0288
            #instruction: DEC  (HL)
            let:16 a39 = addWithCarry(!true,M[2012],~00) in
            let:8 a40 = (M[2012] & 0F) in
            let:8 a41 = (~00 & 0F) in
            let:16 a42 = addWithCarry(!true,a40,a41) in
            M[2012] := a39[7:0];
            advance (10)
            #0289
            #instruction: DEC  HL
            advance (5)
            #028A
            #instruction: DEC  HL
            advance (5)
            #028B
            #instruction: JP   0281
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a43 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a37;
            B := M[2011];
            C := M[2010];
            D := 00;
            E := 10;
            H := a43[15:0][15:8];
            L := a43[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a39[7:0][7];
            FlagZ := is_zero(a39[7:0]);
            FlagA := a42[7:0][4];
            FlagP := parity(a39[7:0]);
            FlagCY := a43[16];
            jump (024B);
          } else {
            advance (10)
            #0262
            #instruction: INC  HL
            advance (5)
            #0263
            #instruction: LD   E,(HL)
            advance (7)
            #0264
            #instruction: INC  HL
            advance (5)
            #0265
            #instruction: LD   D,(HL)
            advance (7)
            #0266
            #instruction: PUSH HL
            let:16 a44 = (-1 + a2) in
            M[a44] := 20;
            let:16 a45 = (-1 + a44) in
            M[a45] := 14;
            advance (11)
            #0267
            #instruction: EX   DE,HL
            advance (4)
            #0268
            #instruction: PUSH HL
            let:16 a46 = (-1 + a45) in
            M[a46] := M[2014];
            let:16 a47 = (-1 + a46) in
            M[a47] := M[2013];
            advance (11)
            #0269
            #instruction: LD   HL,026F
            advance (10)
            #026C
            #instruction: EX   (SP),HL
            let:16 a48 = (1 + a47) in
            M[a47] := 6F;
            M[a48] := 02;
            advance (18)
            #026D
            #instruction: PUSH DE
            let:16 a49 = (-1 + a47) in
            M[a49] := 20;
            let:16 a50 = (-1 + a49) in
            M[a50] := 14;
            advance (11)
            #026E
            #instruction: JP   (HL)
            advance (5)
            A := a37;
            B := M[2011];
            C := M[2010];
            D := 20;
            E := 14;
            H := M[a48];
            L := M[a47];
            SPH := a50[15:8];
            SPL := a50[7:0];
            FlagS := a37[7];
            FlagZ := is_zero(a37);
            FlagA := a38[3];
            FlagP := parity(a37);
            FlagCY := false;
            jump ((M[a48],M[a47]));
          }
        }
      }
    }

007E:

    #instruction: CALL 0913
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := 81;
    #return-to: 0081
    advance (17)
    #0913
    #instruction: LD   A,(2009)
    advance (13)
    #0916
    #instruction: CP   78
    let:16 a3 = addWithCarry(!false,M[2009],~78) in
    let:8 a4 = (M[2009] & 0F) in
    let:8 a5 = (~78 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0918
    #instruction: RET  NC
    if (!!a3[15:8][0]) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2009];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #0919
      #instruction: LD   HL,(2091)
      advance (16)
      #091C
      #instruction: LD   A,L
      advance (5)
      #091D
      #instruction: OR   H
      let:8 a9 = (M[2092] | M[2091]) in
      advance (4)
      #091E
      #instruction: JP   NZ,0929
      if (!is_zero(a9)) {
        advance (10)
        #0929
        #instruction: DEC  HL
        let:16 a10 = (-1 + (M[2092],M[2091])) in
        advance (5)
        #092A
        #instruction: LD   (2091),HL
        M[2091] := a10[7:0];
        M[2092] := a10[15:8];
        advance (16)
        #092D
        #instruction: RET
        let:16 a11 = (1 + a2) in
        let:16 a12 = (1 + a11) in
        advance (10)
        A := a9;
        H := a10[15:8];
        L := a10[7:0];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a11],M[a2]));
      } else {
        advance (10)
        #0921
        #instruction: LD   HL,0600
        advance (10)
        #0924
        #instruction: LD   A,01
        advance (7)
        #0926
        #instruction: LD   (2083),A
        M[2083] := 01;
        advance (13)
        #0929
        #instruction: DEC  HL
        advance (5)
        #092A
        #instruction: LD   (2091),HL
        M[2091] := FF;
        M[2092] := 05;
        advance (16)
        #092D
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 01;
        H := 05;
        L := FF;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a13],M[a2]));
      }
    }

0081:

    #instruction: NOP
    advance (4)
    #0082
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0083
    #instruction: POP  DE
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    #0084
    #instruction: POP  BC
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:16 a9 = (1 + a8) in
    let:16 a10 = (1 + a9) in
    advance (10)
    A := M[a7];
    B := M[a5];
    C := M[a4];
    D := M[a3];
    E := M[a2];
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := M[a6][7];
    FlagZ := M[a6][6];
    FlagA := M[a6][4];
    FlagP := M[a6][2];
    FlagCY := M[a6][0];
    jump ((M[a9],M[a8]));

00AB:

    #instruction: CALL 0141
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 00;
    let:16 a2 = (-1 + a1) in
    M[a2] := AE;
    #return-to: 00AE
    advance (17)
    #0141
    #instruction: LD   A,(2068)
    advance (13)
    #0144
    #instruction: AND  A
    let:8 a3 = (M[2068] & M[2068]) in
    let:8 a4 = (M[2068] | M[2068]) in
    advance (4)
    #0145
    #instruction: RET  Z
    if (is_zero(a3)) {
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    } else {
      advance (5)
      #0146
      #instruction: LD   A,(2000)
      advance (13)
      #0149
      #instruction: AND  A
      let:8 a7 = (M[2000] & M[2000]) in
      let:8 a8 = (M[2000] | M[2000]) in
      advance (4)
      #014A
      #instruction: RET  NZ
      if (!is_zero(a7)) {
        let:16 a9 = (1 + a2) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := a7;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a7[7];
        FlagZ := is_zero(a7);
        FlagA := a8[3];
        FlagP := parity(a7);
        FlagCY := false;
        jump ((M[a9],M[a2]));
      } else {
        advance (5)
        #014B
        #instruction: LD   A,(2067)
        advance (13)
        #014E
        #instruction: LD   H,A
        advance (5)
        #014F
        #instruction: LD   A,(2006)
        advance (13)
        #0152
        #instruction: LD   D,02
        advance (7)
        #0154
        #instruction: INC  A
        let:16 a11 = addWithCarry(true,M[2006],00) in
        let:8 a12 = (M[2006] & 0F) in
        let:8 a13 = (00 & 0F) in
        let:16 a14 = addWithCarry(true,a12,a13) in
        advance (5)
        #0155
        #instruction: CP   37
        let:16 a15 = addWithCarry(!false,a11[7:0],~37) in
        let:8 a16 = (a11[7:0] & 0F) in
        let:8 a17 = (~37 & 0F) in
        let:16 a18 = addWithCarry(!false,a16,a17) in
        advance (7)
        #0157
        #instruction: CALL Z,01A1
        if (is_zero(a15[7:0])) {
          let:16 a19 = (-1 + a2) in
          M[a19] := 01;
          let:16 a20 = (-1 + a19) in
          M[a20] := 5A;
          #return-to: 015A
          advance (17)
          #01A1
          #instruction: DEC  D
          let:16 a21 = addWithCarry(!true,02,~00) in
          let:8 a22 = (02 & 0F) in
          let:8 a23 = (~00 & 0F) in
          let:16 a24 = addWithCarry(!true,a22,a23) in
          advance (5)
          #01A2
          #instruction: JP   Z,01CD
          if (is_zero(a21[7:0])) {
            advance (10)
            #01CD
            #instruction: POP  HL
            let:16 a25 = (1 + a20) in
            let:16 a26 = (1 + a25) in
            advance (10)
            #01CE
            #instruction: RET
            let:16 a27 = (1 + a26) in
            let:16 a28 = (1 + a27) in
            advance (10)
            A := a11[7:0];
            D := a21[7:0];
            H := M[a25];
            L := M[a20];
            SPH := a28[15:8];
            SPL := a28[7:0];
            FlagS := a21[7:0][7];
            FlagZ := is_zero(a21[7:0]);
            FlagA := a24[7:0][4];
            FlagP := parity(a21[7:0]);
            FlagCY := !a15[15:8][0];
            jump ((M[a27],M[a26]));
          } else {
            advance (10)
            #01A5
            #instruction: LD   HL,2006
            advance (10)
            #01A8
            #instruction: LD   (HL),00
            M[2006] := 00;
            advance (10)
            #01AA
            #instruction: INC  HL
            advance (5)
            #01AB
            #instruction: LD   C,(HL)
            advance (7)
            #01AC
            #instruction: LD   (HL),00
            M[2007] := 00;
            advance (10)
            #01AE
            #instruction: CALL 01D9
            let:16 a29 = (-1 + a20) in
            M[a29] := 01;
            let:16 a30 = (-1 + a29) in
            M[a30] := B1;
            #return-to: 01B1
            advance (17)
            #01D9
            #instruction: INC  HL
            advance (5)
            #01DA
            #instruction: LD   B,(HL)
            advance (7)
            #01DB
            #instruction: INC  HL
            advance (5)
            #01DC
            #instruction: LD   A,C
            advance (5)
            #01DD
            #instruction: ADD  (HL)
            let:16 a31 = addWithCarry(false,M[2009],M[2007]) in
            let:8 a32 = (M[2009] & 0F) in
            let:8 a33 = (M[2007] & 0F) in
            let:16 a34 = addWithCarry(false,a32,a33) in
            advance (7)
            #01DE
            #instruction: LD   (HL),A
            M[2009] := a31[7:0];
            advance (7)
            #01DF
            #instruction: INC  HL
            advance (5)
            #01E0
            #instruction: LD   A,B
            advance (5)
            #01E1
            #instruction: ADD  (HL)
            let:16 a35 = addWithCarry(false,M[200A],M[2008]) in
            let:8 a36 = (M[200A] & 0F) in
            let:8 a37 = (M[2008] & 0F) in
            let:16 a38 = addWithCarry(false,a36,a37) in
            advance (7)
            #01E2
            #instruction: LD   (HL),A
            M[200A] := a35[7:0];
            advance (7)
            #01E3
            #instruction: RET
            let:16 a39 = (1 + a30) in
            let:16 a40 = (1 + a39) in
            advance (10)
            A := a35[7:0];
            B := M[2008];
            C := M[2007];
            D := a21[7:0];
            H := 20;
            L := 0A;
            SPH := a40[15:8];
            SPL := a40[7:0];
            FlagS := a35[7:0][7];
            FlagZ := is_zero(a35[7:0]);
            FlagA := a38[7:0][4];
            FlagP := parity(a35[7:0]);
            FlagCY := a35[15:8][0];
            jump ((M[a39],M[a30]));
          }
        } else {
          advance (11)
          A := a11[7:0];
          D := 02;
          H := M[2067];
          SPH := a2[15:8];
          SPL := a2[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a15[15:8][0];
          jump (015A);
        }
      }
    }

00AE:

    #instruction: JP   0082
    advance (10)
    #0082
    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0083
    #instruction: POP  DE
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    #0084
    #instruction: POP  BC
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:16 a9 = (1 + a8) in
    let:16 a10 = (1 + a9) in
    advance (10)
    A := M[a7];
    B := M[a5];
    C := M[a4];
    D := M[a3];
    E := M[a2];
    H := M[a1];
    L := M[(SPH,SPL)];
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := M[a6][7];
    FlagZ := M[a6][6];
    FlagA := M[a6][4];
    FlagP := M[a6][2];
    FlagCY := M[a6][0];
    jump ((M[a9],M[a8]));

00B4:

    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    #00B5
    #instruction: LD   A,(HL)
    advance (7)
    #00B6
    #instruction: INC  HL
    let:16 a3 = (1 + (H,L)) in
    advance (5)
    #00B7
    #instruction: LD   H,(HL)
    advance (7)
    #00B8
    #instruction: LD   L,A
    advance (5)
    #00B9
    #instruction: LD   (2009),HL
    M[2009] := M[(H,L)];
    M[200A] := M[a3];
    advance (16)
    #00BC
    #instruction: LD   (200B),HL
    M[200B] := M[(H,L)];
    M[200C] := M[a3];
    advance (16)
    #00BF
    #instruction: POP  HL
    let:16 a4 = (1 + a2) in
    let:16 a5 = (1 + a4) in
    advance (10)
    #00C0
    #instruction: DEC  HL
    let:16 a6 = (-1 + (M[a4],M[a2])) in
    advance (5)
    #00C1
    #instruction: LD   A,(HL)
    advance (7)
    #00C2
    #instruction: CP   03
    let:16 a7 = addWithCarry(!false,M[a6],~03) in
    let:8 a8 = (M[a6] & 0F) in
    let:8 a9 = (~03 & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #00C4
    #instruction: JP   NZ,00C8
    if (!is_zero(a7[7:0])) {
      advance (10)
      #00C8
      #instruction: LD   (2008),A
      M[2008] := M[a6];
      advance (13)
      #00CB
      #instruction: CP   FE
      let:16 a11 = addWithCarry(!false,M[a6],~FE) in
      let:8 a12 = (M[a6] & 0F) in
      let:8 a13 = (~FE & 0F) in
      let:16 a14 = addWithCarry(!false,a12,a13) in
      advance (7)
      #00CD
      #instruction: LD   A,00
      advance (7)
      #00CF
      #instruction: JP   NZ,00D3
      if (!is_zero(a11[7:0])) {
        advance (10)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := 00;
        advance (13)
        #00D6
        #instruction: RET
        let:16 a15 = (1 + a5) in
        let:16 a16 = (1 + a15) in
        advance (10)
        A := 00;
        H := a6[15:8];
        L := a6[7:0];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := !a11[15:8][0];
        jump ((M[a15],M[a5]));
      } else {
        advance (10)
        #00D2
        #instruction: INC  A
        let:16 a17 = addWithCarry(true,00,00) in
        let:8 a18 = (00 & 0F) in
        let:8 a19 = (00 & 0F) in
        let:16 a20 = addWithCarry(true,a18,a19) in
        advance (5)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := a17[7:0];
        advance (13)
        #00D6
        #instruction: RET
        let:16 a21 = (1 + a5) in
        let:16 a22 = (1 + a21) in
        advance (10)
        A := a17[7:0];
        H := a6[15:8];
        L := a6[7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a11[15:8][0];
        jump ((M[a21],M[a5]));
      }
    } else {
      advance (10)
      #00C7
      #instruction: DEC  A
      let:16 a23 = addWithCarry(!true,M[a6],~00) in
      let:8 a24 = (M[a6] & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #00C8
      #instruction: LD   (2008),A
      M[2008] := a23[7:0];
      advance (13)
      #00CB
      #instruction: CP   FE
      let:16 a27 = addWithCarry(!false,a23[7:0],~FE) in
      let:8 a28 = (a23[7:0] & 0F) in
      let:8 a29 = (~FE & 0F) in
      let:16 a30 = addWithCarry(!false,a28,a29) in
      advance (7)
      #00CD
      #instruction: LD   A,00
      advance (7)
      #00CF
      #instruction: JP   NZ,00D3
      if (!is_zero(a27[7:0])) {
        advance (10)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := 00;
        advance (13)
        #00D6
        #instruction: RET
        let:16 a31 = (1 + a5) in
        let:16 a32 = (1 + a31) in
        advance (10)
        A := 00;
        H := a6[15:8];
        L := a6[7:0];
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a27[7:0][7];
        FlagZ := is_zero(a27[7:0]);
        FlagA := a30[7:0][4];
        FlagP := parity(a27[7:0]);
        FlagCY := !a27[15:8][0];
        jump ((M[a31],M[a5]));
      } else {
        advance (10)
        #00D2
        #instruction: INC  A
        let:16 a33 = addWithCarry(true,00,00) in
        let:8 a34 = (00 & 0F) in
        let:8 a35 = (00 & 0F) in
        let:16 a36 = addWithCarry(true,a34,a35) in
        advance (5)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := a33[7:0];
        advance (13)
        #00D6
        #instruction: RET
        let:16 a37 = (1 + a5) in
        let:16 a38 = (1 + a37) in
        advance (10)
        A := a33[7:0];
        H := a6[15:8];
        L := a6[7:0];
        SPH := a38[15:8];
        SPL := a38[7:0];
        FlagS := a33[7:0][7];
        FlagZ := is_zero(a33[7:0]);
        FlagA := a36[7:0][4];
        FlagP := parity(a33[7:0]);
        FlagCY := !a27[15:8][0];
        jump ((M[a37],M[a5]));
      }
    }

012E:

    #instruction: LD   HL,(200B)
    advance (16)
    #0131
    #instruction: LD   B,10
    advance (7)
    #0133
    #instruction: CALL 15D3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 01;
    let:16 a2 = (-1 + a1) in
    M[a2] := 36;
    #return-to: 0136
    advance (17)
    #15D3
    #instruction: CALL 1474
    let:16 a3 = (-1 + a2) in
    M[a3] := 15;
    let:16 a4 = (-1 + a3) in
    M[a4] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a5 = (07 & M[200B]) in
    let:8 a6 = (07 | M[200B]) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a7 = (-1 + a4) in
    M[a7] := 10;
    let:16 a8 = (-1 + a7) in
    M[a8] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,03,~00) in
    let:8 a10 = (03 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := updateBit((M[200B] >> 01),7,M[200C][0]);
      B := a9[7:0];
      H := updateBit((M[200C] >> 01),7,false);
      L := updateBit((M[200B] >> 01),7,M[200C][0]);
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := M[200B][0];
      Shifter_OFF := a5;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a13 = (3F & updateBit((M[200C] >> 01),7,false)) in
      let:8 a14 = (3F | updateBit((M[200C] >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a15 = (20 | a13) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a16 = (1 + a8) in
      let:16 a17 = (1 + a16) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a18 = (1 + a17) in
      let:16 a19 = (1 + a18) in
      advance (10)
      A := a15;
      B := M[a16];
      C := M[a8];
      H := a15;
      L := updateBit((M[200B] >> 01),7,M[200C][0]);
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := false;
      FlagP := parity(a15);
      FlagCY := false;
      Shifter_OFF := a5;
      jump ((M[a18],M[a17]));
    }

0136:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #0137
    #instruction: LD   (2000),A
    M[2000] := a1;
    advance (13)
    #013A
    #instruction: RET
    let:16 a2 = (1 + (SPH,SPL)) in
    let:16 a3 = (1 + a2) in
    advance (10)
    A := a1;
    SPH := a3[15:8];
    SPL := a3[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a2],M[(SPH,SPL)]));

015A:

    #instruction: LD   L,A
    advance (5)
    #015B
    #instruction: LD   B,(HL)
    advance (7)
    #015C
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,M[(H,A)],~00) in
    let:8 a2 = (M[(H,A)] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #015D
    #instruction: JP   NZ,0154
    if (!is_zero(a1[7:0])) {
      advance (10)
      #0154
      #instruction: INC  A
      let:16 a5 = addWithCarry(true,A,00) in
      let:8 a6 = (A & 0F) in
      let:8 a7 = (00 & 0F) in
      let:16 a8 = addWithCarry(true,a6,a7) in
      advance (5)
      #0155
      #instruction: CP   37
      let:16 a9 = addWithCarry(!false,a5[7:0],~37) in
      let:8 a10 = (a5[7:0] & 0F) in
      let:8 a11 = (~37 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0157
      #instruction: CALL Z,01A1
      if (is_zero(a9[7:0])) {
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 01;
        let:16 a14 = (-1 + a13) in
        M[a14] := 5A;
        #return-to: 015A
        advance (17)
        #01A1
        #instruction: DEC  D
        let:16 a15 = addWithCarry(!true,D,~00) in
        let:8 a16 = (D & 0F) in
        let:8 a17 = (~00 & 0F) in
        let:16 a18 = addWithCarry(!true,a16,a17) in
        advance (5)
        #01A2
        #instruction: JP   Z,01CD
        if (is_zero(a15[7:0])) {
          advance (10)
          #01CD
          #instruction: POP  HL
          let:16 a19 = (1 + a14) in
          let:16 a20 = (1 + a19) in
          advance (10)
          #01CE
          #instruction: RET
          let:16 a21 = (1 + a20) in
          let:16 a22 = (1 + a21) in
          advance (10)
          A := a5[7:0];
          B := a1[7:0];
          D := a15[7:0];
          H := M[a19];
          L := M[a14];
          SPH := a22[15:8];
          SPL := a22[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a9[15:8][0];
          jump ((M[a21],M[a20]));
        } else {
          advance (10)
          #01A5
          #instruction: LD   HL,2006
          advance (10)
          #01A8
          #instruction: LD   (HL),00
          M[2006] := 00;
          advance (10)
          #01AA
          #instruction: INC  HL
          advance (5)
          #01AB
          #instruction: LD   C,(HL)
          advance (7)
          #01AC
          #instruction: LD   (HL),00
          M[2007] := 00;
          advance (10)
          #01AE
          #instruction: CALL 01D9
          let:16 a23 = (-1 + a14) in
          M[a23] := 01;
          let:16 a24 = (-1 + a23) in
          M[a24] := B1;
          #return-to: 01B1
          advance (17)
          #01D9
          #instruction: INC  HL
          advance (5)
          #01DA
          #instruction: LD   B,(HL)
          advance (7)
          #01DB
          #instruction: INC  HL
          advance (5)
          #01DC
          #instruction: LD   A,C
          advance (5)
          #01DD
          #instruction: ADD  (HL)
          let:16 a25 = addWithCarry(false,M[2009],M[2007]) in
          let:8 a26 = (M[2009] & 0F) in
          let:8 a27 = (M[2007] & 0F) in
          let:16 a28 = addWithCarry(false,a26,a27) in
          advance (7)
          #01DE
          #instruction: LD   (HL),A
          M[2009] := a25[7:0];
          advance (7)
          #01DF
          #instruction: INC  HL
          advance (5)
          #01E0
          #instruction: LD   A,B
          advance (5)
          #01E1
          #instruction: ADD  (HL)
          let:16 a29 = addWithCarry(false,M[200A],M[2008]) in
          let:8 a30 = (M[200A] & 0F) in
          let:8 a31 = (M[2008] & 0F) in
          let:16 a32 = addWithCarry(false,a30,a31) in
          advance (7)
          #01E2
          #instruction: LD   (HL),A
          M[200A] := a29[7:0];
          advance (7)
          #01E3
          #instruction: RET
          let:16 a33 = (1 + a24) in
          let:16 a34 = (1 + a33) in
          advance (10)
          A := a29[7:0];
          B := M[2008];
          C := M[2007];
          D := a15[7:0];
          H := 20;
          L := 0A;
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a29[7:0][7];
          FlagZ := is_zero(a29[7:0]);
          FlagA := a32[7:0][4];
          FlagP := parity(a29[7:0]);
          FlagCY := a29[15:8][0];
          jump ((M[a33],M[a24]));
        }
      } else {
        advance (11)
        A := a5[7:0];
        B := a1[7:0];
        L := A;
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (015A);
      }
    } else {
      advance (10)
      #0160
      #instruction: LD   (2006),A
      M[2006] := A;
      advance (13)
      #0163
      #instruction: CALL 017A
      let:16 a35 = (-1 + (SPH,SPL)) in
      M[a35] := 01;
      let:16 a36 = (-1 + a35) in
      M[a36] := 66;
      #return-to: 0166
      advance (17)
      #017A
      #instruction: LD   D,00
      advance (7)
      #017C
      #instruction: LD   A,L
      advance (5)
      #017D
      #instruction: LD   HL,2009
      advance (10)
      #0180
      #instruction: LD   B,(HL)
      advance (7)
      #0181
      #instruction: INC  HL
      advance (5)
      #0182
      #instruction: LD   C,(HL)
      advance (7)
      #0183
      #instruction: CP   0B
      let:16 a37 = addWithCarry(!false,A,~0B) in
      let:8 a38 = (A & 0F) in
      let:8 a39 = (~0B & 0F) in
      let:16 a40 = addWithCarry(!false,a38,a39) in
      advance (7)
      #0185
      #instruction: JP   MI,0194
      if (a37[7:0][7]) {
        advance (10)
        #0194
        #instruction: LD   L,B
        advance (5)
        #0195
        #instruction: AND  A
        let:8 a41 = (A & A) in
        let:8 a42 = (A | A) in
        advance (4)
        #0196
        #instruction: RET  Z
        if (is_zero(a41)) {
          let:16 a43 = (1 + a36) in
          let:16 a44 = (1 + a43) in
          advance (11)
          A := a41;
          B := M[2009];
          C := M[200A];
          D := 00;
          H := 20;
          L := M[2009];
          SPH := a44[15:8];
          SPL := a44[7:0];
          FlagS := a41[7];
          FlagZ := is_zero(a41);
          FlagA := a42[3];
          FlagP := parity(a41);
          FlagCY := false;
          jump ((M[a43],M[a36]));
        } else {
          advance (5)
          #0197
          #instruction: LD   E,A
          advance (5)
          #0198
          #instruction: LD   A,C
          advance (5)
          #0199
          #instruction: ADD  10
          let:16 a45 = addWithCarry(false,10,M[200A]) in
          let:8 a46 = (10 & 0F) in
          let:8 a47 = (M[200A] & 0F) in
          let:16 a48 = addWithCarry(false,a46,a47) in
          advance (7)
          #019B
          #instruction: LD   C,A
          advance (5)
          #019C
          #instruction: LD   A,E
          advance (5)
          #019D
          #instruction: DEC  A
          let:16 a49 = addWithCarry(!true,a41,~00) in
          let:8 a50 = (a41 & 0F) in
          let:8 a51 = (~00 & 0F) in
          let:16 a52 = addWithCarry(!true,a50,a51) in
          advance (5)
          #019E
          #instruction: JP   0195
          advance (10)
          A := a49[7:0];
          B := M[2009];
          C := a45[7:0];
          D := 00;
          E := a41;
          H := 20;
          L := M[2009];
          SPH := a36[15:8];
          SPL := a36[7:0];
          FlagS := a49[7:0][7];
          FlagZ := is_zero(a49[7:0]);
          FlagA := a52[7:0][4];
          FlagP := parity(a49[7:0]);
          FlagCY := a45[15:8][0];
          jump (0195);
        }
      } else {
        advance (10)
        #0188
        #instruction: SBC  0B
        let:16 a53 = addWithCarry(!!a37[15:8][0],A,~0B) in
        let:8 a54 = (A & 0F) in
        let:8 a55 = (~0B & 0F) in
        let:16 a56 = addWithCarry(!!a37[15:8][0],a54,a55) in
        advance (7)
        #018A
        #instruction: LD   E,A
        advance (5)
        #018B
        #instruction: LD   A,B
        advance (5)
        #018C
        #instruction: ADD  10
        let:16 a57 = addWithCarry(false,10,M[2009]) in
        let:8 a58 = (10 & 0F) in
        let:8 a59 = (M[2009] & 0F) in
        let:16 a60 = addWithCarry(false,a58,a59) in
        advance (7)
        #018E
        #instruction: LD   B,A
        advance (5)
        #018F
        #instruction: LD   A,E
        advance (5)
        #0190
        #instruction: INC  D
        let:16 a61 = addWithCarry(true,00,00) in
        let:8 a62 = (00 & 0F) in
        let:8 a63 = (00 & 0F) in
        let:16 a64 = addWithCarry(true,a62,a63) in
        advance (5)
        #0191
        #instruction: JP   0183
        advance (10)
        A := a53[7:0];
        B := a57[7:0];
        C := M[200A];
        D := a61[7:0];
        E := a53[7:0];
        H := 20;
        L := 0A;
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagS := a61[7:0][7];
        FlagZ := is_zero(a61[7:0]);
        FlagA := a64[7:0][4];
        FlagP := parity(a61[7:0]);
        FlagCY := a57[15:8][0];
        jump (0183);
      }
    }

0166:

    #instruction: LD   H,C
    advance (5)
    #0167
    #instruction: LD   (200B),HL
    M[200B] := L;
    M[200C] := C;
    advance (16)
    #016A
    #instruction: LD   A,L
    advance (5)
    #016B
    #instruction: CP   28
    let:16 a1 = addWithCarry(!false,L,~28) in
    let:8 a2 = (L & 0F) in
    let:8 a3 = (~28 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #016D
    #instruction: JP   CY,1971
    if (!a1[15:8][0]) {
      advance (10)
      #1971
      #instruction: LD   A,01
      advance (7)
      #1973
      #instruction: LD   (206D),A
      M[206D] := 01;
      advance (13)
      #1976
      #instruction: JP   16E6
      advance (10)
      #16E6
      #instruction: LD   SP,2400
      advance (10)
      #16E9
      #instruction: EI
      enable_interrupts()
      advance (4)
      #16EA
      #instruction: XOR  A
      let:8 a5 = (01 ^ 01) in
      advance (4)
      #16EB
      #instruction: LD   (2015),A
      M[2015] := a5;
      advance (13)
      #16EE
      #instruction: CALL 14D8
      M[23FF] := 16;
      M[23FE] := F1;
      #return-to: 16F1
      advance (17)
      #14D8
      #instruction: LD   A,(2025)
      advance (13)
      #14DB
      #instruction: CP   05
      let:16 a6 = addWithCarry(!false,M[2025],~05) in
      let:8 a7 = (M[2025] & 0F) in
      let:8 a8 = (~05 & 0F) in
      let:16 a9 = addWithCarry(!false,a7,a8) in
      advance (7)
      #14DD
      #instruction: RET  Z
      if (is_zero(a6[7:0])) {
        advance (11)
        A := M[2025];
        H := C;
        SPH := 24;
        SPL := 00;
        FlagS := a6[7:0][7];
        FlagZ := is_zero(a6[7:0]);
        FlagA := a9[7:0][4];
        FlagP := parity(a6[7:0]);
        FlagCY := !a6[15:8][0];
        jump ((M[23FF],M[23FE]));
      } else {
        advance (5)
        #14DE
        #instruction: CP   02
        let:16 a10 = addWithCarry(!false,M[2025],~02) in
        let:8 a11 = (M[2025] & 0F) in
        let:8 a12 = (~02 & 0F) in
        let:16 a13 = addWithCarry(!false,a11,a12) in
        advance (7)
        #14E0
        #instruction: RET  NZ
        if (!is_zero(a10[7:0])) {
          advance (11)
          A := M[2025];
          H := C;
          SPH := 24;
          SPL := 00;
          FlagS := a10[7:0][7];
          FlagZ := is_zero(a10[7:0]);
          FlagA := a13[7:0][4];
          FlagP := parity(a10[7:0]);
          FlagCY := !a10[15:8][0];
          jump ((M[23FF],M[23FE]));
        } else {
          advance (5)
          #14E1
          #instruction: LD   A,(2029)
          advance (13)
          #14E4
          #instruction: CP   D8
          let:16 a14 = addWithCarry(!false,M[2029],~D8) in
          let:8 a15 = (M[2029] & 0F) in
          let:8 a16 = (~D8 & 0F) in
          let:16 a17 = addWithCarry(!false,a15,a16) in
          advance (7)
          #14E6
          #instruction: LD   B,A
          advance (5)
          #14E7
          #instruction: JP   NC,1530
          if (!!a14[15:8][0]) {
            advance (10)
            #1530
            #instruction: LD   A,03
            advance (7)
            #1532
            #instruction: LD   (2025),A
            M[2025] := 03;
            advance (13)
            #1535
            #instruction: JP   154A
            advance (10)
            #154A
            #instruction: XOR  A
            let:8 a18 = (03 ^ 03) in
            advance (4)
            #154B
            #instruction: LD   (2002),A
            M[2002] := a18;
            advance (13)
            #154E
            #instruction: LD   B,F7
            advance (7)
            #1550
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a19 = (F7 & M[2094]) in
            let:8 a20 = (F7 | M[2094]) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            M[2094] := a19;
            advance (13)
            #19E3
            #instruction: OUT  03
            sound_control(Ufo,a19[0]);
            sound_control(Shot,a19[1]);
            sound_control(PlayerDie,a19[2]);
            sound_control(InvaderDie,a19[3]);
            sound_control(ExtraLife,a19[4]);
            advance (10)
            #19E5
            #instruction: RET
            advance (10)
            A := a19;
            B := F7;
            H := C;
            SPH := 24;
            SPL := 00;
            FlagS := a19[7];
            FlagZ := is_zero(a19);
            FlagA := a20[3];
            FlagP := parity(a19);
            FlagCY := false;
            jump ((M[23FF],M[23FE]));
          } else {
            advance (10)
            #14EA
            #instruction: LD   A,(2002)
            advance (13)
            #14ED
            #instruction: AND  A
            let:8 a21 = (M[2002] & M[2002]) in
            let:8 a22 = (M[2002] | M[2002]) in
            advance (4)
            #14EE
            #instruction: RET  Z
            if (is_zero(a21)) {
              advance (11)
              A := a21;
              B := M[2029];
              H := C;
              SPH := 24;
              SPL := 00;
              FlagS := a21[7];
              FlagZ := is_zero(a21);
              FlagA := a22[3];
              FlagP := parity(a21);
              FlagCY := false;
              jump ((M[23FF],M[23FE]));
            } else {
              advance (5)
              #14EF
              #instruction: LD   A,B
              advance (5)
              #14F0
              #instruction: CP   CE
              let:16 a23 = addWithCarry(!false,M[2029],~CE) in
              let:8 a24 = (M[2029] & 0F) in
              let:8 a25 = (~CE & 0F) in
              let:16 a26 = addWithCarry(!false,a24,a25) in
              advance (7)
              #14F2
              #instruction: JP   NC,1579
              if (!!a23[15:8][0]) {
                advance (10)
                #1579
                #instruction: LD   A,01
                advance (7)
                #157B
                #instruction: LD   (2085),A
                M[2085] := 01;
                advance (13)
                #157E
                #instruction: JP   1545
                advance (10)
                A := 01;
                B := M[2029];
                H := C;
                SPH := 23;
                SPL := FE;
                FlagS := a23[7:0][7];
                FlagZ := is_zero(a23[7:0]);
                FlagA := a26[7:0][4];
                FlagP := parity(a23[7:0]);
                FlagCY := !a23[15:8][0];
                jump (1545);
              } else {
                advance (10)
                #14F5
                #instruction: ADD  06
                let:16 a27 = addWithCarry(false,06,M[2029]) in
                let:8 a28 = (06 & 0F) in
                let:8 a29 = (M[2029] & 0F) in
                let:16 a30 = addWithCarry(false,a28,a29) in
                advance (7)
                #14F7
                #instruction: LD   B,A
                advance (5)
                #14F8
                #instruction: LD   A,(2009)
                advance (13)
                #14FB
                #instruction: CP   90
                let:16 a31 = addWithCarry(!false,M[2009],~90) in
                let:8 a32 = (M[2009] & 0F) in
                let:8 a33 = (~90 & 0F) in
                let:16 a34 = addWithCarry(!false,a32,a33) in
                advance (7)
                #14FD
                #instruction: JP   NC,1504
                if (!!a31[15:8][0]) {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  M[23FD] := 15;
                  M[23FC] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  M[23FB] := 15;
                  M[23FA] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a35 = addWithCarry(!false,M[2009],~a27[7:0]) in
                  let:8 a36 = (M[2009] & 0F) in
                  let:8 a37 = (~a27[7:0] & 0F) in
                  let:16 a38 = addWithCarry(!false,a36,a37) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a35[15:8][0]) {
                    M[23F9] := 15;
                    M[23F8] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a39 = addWithCarry(true,00,00) in
                    let:8 a40 = (00 & 0F) in
                    let:8 a41 = (00 & 0F) in
                    let:16 a42 = addWithCarry(true,a40,a41) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a43 = addWithCarry(false,10,M[2009]) in
                    let:8 a44 = (10 & 0F) in
                    let:8 a45 = (M[2009] & 0F) in
                    let:16 a46 = addWithCarry(false,a44,a45) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a43[7:0][7]) {
                      advance (10)
                      A := a43[7:0];
                      B := a27[7:0];
                      C := a39[7:0];
                      H := a27[7:0];
                      L := a27[7:0];
                      SPH := 23;
                      SPL := F8;
                      FlagS := a43[7:0][7];
                      FlagZ := is_zero(a43[7:0]);
                      FlagA := a46[7:0][4];
                      FlagP := parity(a43[7:0]);
                      FlagCY := a43[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      advance (10)
                      A := a43[7:0];
                      B := a27[7:0];
                      C := a39[7:0];
                      H := a27[7:0];
                      L := a27[7:0];
                      SPH := 23;
                      SPL := FA;
                      FlagS := a43[7:0][7];
                      FlagZ := is_zero(a43[7:0]);
                      FlagA := a46[7:0][4];
                      FlagP := parity(a43[7:0]);
                      FlagCY := a43[15:8][0];
                      jump ((M[23F9],M[23F8]));
                    }
                  } else {
                    advance (11)
                    A := M[2009];
                    B := a27[7:0];
                    C := 00;
                    H := a27[7:0];
                    L := a27[7:0];
                    SPH := 23;
                    SPL := FA;
                    FlagS := a35[7:0][7];
                    FlagZ := is_zero(a35[7:0]);
                    FlagA := a38[7:0][4];
                    FlagP := parity(a35[7:0]);
                    FlagCY := !a35[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #1500
                  #instruction: CP   B
                  let:16 a47 = addWithCarry(!false,M[2009],~a27[7:0]) in
                  let:8 a48 = (M[2009] & 0F) in
                  let:8 a49 = (~a27[7:0] & 0F) in
                  let:16 a50 = addWithCarry(!false,a48,a49) in
                  advance (4)
                  #1501
                  #instruction: JP   NC,1530
                  if (!!a47[15:8][0]) {
                    advance (10)
                    #1530
                    #instruction: LD   A,03
                    advance (7)
                    #1532
                    #instruction: LD   (2025),A
                    M[2025] := 03;
                    advance (13)
                    #1535
                    #instruction: JP   154A
                    advance (10)
                    #154A
                    #instruction: XOR  A
                    let:8 a51 = (03 ^ 03) in
                    advance (4)
                    #154B
                    #instruction: LD   (2002),A
                    M[2002] := a51;
                    advance (13)
                    #154E
                    #instruction: LD   B,F7
                    advance (7)
                    #1550
                    #instruction: JP   19DC
                    advance (10)
                    #19DC
                    #instruction: LD   A,(2094)
                    advance (13)
                    #19DF
                    #instruction: AND  B
                    let:8 a52 = (F7 & M[2094]) in
                    let:8 a53 = (F7 | M[2094]) in
                    advance (4)
                    #19E0
                    #instruction: LD   (2094),A
                    M[2094] := a52;
                    advance (13)
                    #19E3
                    #instruction: OUT  03
                    sound_control(Ufo,a52[0]);
                    sound_control(Shot,a52[1]);
                    sound_control(PlayerDie,a52[2]);
                    sound_control(InvaderDie,a52[3]);
                    sound_control(ExtraLife,a52[4]);
                    advance (10)
                    #19E5
                    #instruction: RET
                    advance (10)
                    A := a52;
                    B := F7;
                    H := C;
                    SPH := 24;
                    SPL := 00;
                    FlagS := a52[7];
                    FlagZ := is_zero(a52);
                    FlagA := a53[3];
                    FlagP := parity(a52);
                    FlagCY := false;
                    jump ((M[23FF],M[23FE]));
                  } else {
                    advance (10)
                    #1504
                    #instruction: LD   L,B
                    advance (5)
                    #1505
                    #instruction: CALL 1562
                    M[23FD] := 15;
                    M[23FC] := 08;
                    #return-to: 1508
                    advance (17)
                    #1562
                    #instruction: LD   A,(2009)
                    advance (13)
                    #1565
                    #instruction: LD   H,L
                    advance (5)
                    #1566
                    #instruction: CALL 1554
                    M[23FB] := 15;
                    M[23FA] := 69;
                    #return-to: 1569
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:16 a54 = addWithCarry(!false,M[2009],~a27[7:0]) in
                    let:8 a55 = (M[2009] & 0F) in
                    let:8 a56 = (~a27[7:0] & 0F) in
                    let:16 a57 = addWithCarry(!false,a55,a56) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a54[15:8][0]) {
                      M[23F9] := 15;
                      M[23F8] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a58 = addWithCarry(true,00,00) in
                      let:8 a59 = (00 & 0F) in
                      let:8 a60 = (00 & 0F) in
                      let:16 a61 = addWithCarry(true,a59,a60) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:16 a62 = addWithCarry(false,10,M[2009]) in
                      let:8 a63 = (10 & 0F) in
                      let:8 a64 = (M[2009] & 0F) in
                      let:16 a65 = addWithCarry(false,a63,a64) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a62[7:0][7]) {
                        advance (10)
                        A := a62[7:0];
                        B := a27[7:0];
                        C := a58[7:0];
                        H := a27[7:0];
                        L := a27[7:0];
                        SPH := 23;
                        SPL := F8;
                        FlagS := a62[7:0][7];
                        FlagZ := is_zero(a62[7:0]);
                        FlagA := a65[7:0][4];
                        FlagP := parity(a62[7:0]);
                        FlagCY := a62[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        advance (10)
                        A := a62[7:0];
                        B := a27[7:0];
                        C := a58[7:0];
                        H := a27[7:0];
                        L := a27[7:0];
                        SPH := 23;
                        SPL := FA;
                        FlagS := a62[7:0][7];
                        FlagZ := is_zero(a62[7:0]);
                        FlagA := a65[7:0][4];
                        FlagP := parity(a62[7:0]);
                        FlagCY := a62[15:8][0];
                        jump ((M[23F9],M[23F8]));
                      }
                    } else {
                      advance (11)
                      A := M[2009];
                      B := a27[7:0];
                      C := 00;
                      H := a27[7:0];
                      L := a27[7:0];
                      SPH := 23;
                      SPL := FA;
                      FlagS := a54[7:0][7];
                      FlagZ := is_zero(a54[7:0]);
                      FlagA := a57[7:0][4];
                      FlagP := parity(a54[7:0]);
                      FlagCY := !a54[15:8][0];
                      jump (155A);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0170
      #instruction: LD   A,D
      advance (5)
      #0171
      #instruction: LD   (2004),A
      M[2004] := D;
      advance (13)
      #0174
      #instruction: LD   A,01
      advance (7)
      #0176
      #instruction: LD   (2000),A
      M[2000] := 01;
      advance (13)
      #0179
      #instruction: RET
      let:16 a66 = (1 + (SPH,SPL)) in
      let:16 a67 = (1 + a66) in
      advance (10)
      A := 01;
      H := C;
      SPH := a67[15:8];
      SPL := a67[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump ((M[a66],M[(SPH,SPL)]));
    }

01B1:

    #instruction: LD   HL,2005
    advance (10)
    #01B4
    #instruction: LD   A,(HL)
    advance (7)
    #01B5
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,M[2005],00) in
    let:8 a2 = (M[2005] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    #01B6
    #instruction: AND  01
    let:8 a5 = (01 & a1[7:0]) in
    let:8 a6 = (01 | a1[7:0]) in
    advance (7)
    #01B8
    #instruction: LD   (HL),A
    M[2005] := a5;
    advance (7)
    #01B9
    #instruction: XOR  A
    let:8 a7 = (a5 ^ a5) in
    advance (4)
    #01BA
    #instruction: LD   HL,2067
    advance (10)
    #01BD
    #instruction: LD   H,(HL)
    advance (7)
    #01BE
    #instruction: RET
    let:16 a8 = (1 + (SPH,SPL)) in
    let:16 a9 = (1 + a8) in
    advance (10)
    A := a7;
    H := M[2067];
    L := 67;
    SPH := a9[15:8];
    SPL := a9[7:0];
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := false;
    FlagP := parity(a7);
    FlagCY := false;
    jump ((M[a8],M[(SPH,SPL)]));

0203:

    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0204
    #instruction: DEC  C
    let:16 a3 = addWithCarry(!true,C,~00) in
    let:8 a4 = (C & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0205
    #instruction: JP   NZ,01FD
    if (!is_zero(a3[7:0])) {
      advance (10)
      #01FD
      #instruction: PUSH DE
      let:16 a7 = (-1 + a2) in
      M[a7] := M[a1];
      let:16 a8 = (-1 + a7) in
      M[a8] := M[(SPH,SPL)];
      advance (11)
      #01FE
      #instruction: LD   B,2C
      advance (7)
      #0200
      #instruction: CALL 1A32
      let:16 a9 = (-1 + a8) in
      M[a9] := 02;
      let:16 a10 = (-1 + a9) in
      M[a10] := 03;
      #return-to: 0203
      advance (17)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[(H,L)] := M[(M[a1],M[(SPH,SPL)])];
      advance (7)
      #1A34
      #instruction: INC  HL
      let:16 a11 = (1 + (H,L)) in
      advance (5)
      #1A35
      #instruction: INC  DE
      let:16 a12 = (1 + (M[a1],M[(SPH,SPL)])) in
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a13 = addWithCarry(!true,2C,~00) in
      let:8 a14 = (2C & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a13[7:0])) {
        advance (10)
        A := M[(M[a1],M[(SPH,SPL)])];
        B := a13[7:0];
        C := a3[7:0];
        D := a12[15:8];
        E := a12[7:0];
        H := a11[15:8];
        L := a11[7:0];
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a17 = (1 + a10) in
        let:16 a18 = (1 + a17) in
        advance (10)
        A := M[(M[a1],M[(SPH,SPL)])];
        B := a13[7:0];
        C := a3[7:0];
        D := a12[15:8];
        E := a12[7:0];
        H := a11[15:8];
        L := a11[7:0];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        jump ((M[a17],M[a10]));
      }
    } else {
      advance (10)
      #0208
      #instruction: RET
      let:16 a19 = (1 + a2) in
      let:16 a20 = (1 + a19) in
      advance (10)
      C := a3[7:0];
      D := M[a1];
      E := M[(SPH,SPL)];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a19],M[a2]));
    }

0235:

    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0236
    #instruction: POP  PSW
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    #0237
    #instruction: DEC  A
    let:16 a5 = addWithCarry(!true,M[a3],~00) in
    let:8 a6 = (M[a3] & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #0238
    #instruction: RET  Z
    if (is_zero(a5[7:0])) {
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (11)
      A := a5[7:0];
      B := M[a1];
      C := M[(SPH,SPL)];
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := M[a2][0];
      jump ((M[a9],M[a4]));
    } else {
      advance (5)
      #0239
      #instruction: PUSH DE
      let:16 a11 = (-1 + a4) in
      M[a11] := D;
      let:16 a12 = (-1 + a11) in
      M[a12] := E;
      advance (11)
      #023A
      #instruction: LD   DE,02E0
      advance (10)
      #023D
      #instruction: ADD  HL,DE
      let:17 a13 = add17(02E0,(H,L)) in
      advance (10)
      #023E
      #instruction: POP  DE
      let:16 a14 = (1 + a12) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #023F
      #instruction: JP   0229
      advance (10)
      #0229
      #instruction: PUSH PSW
      let:16 a16 = (-1 + a15) in
      M[a16] := a5[7:0];
      let:16 a17 = (-1 + a16) in
      M[a17] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a5[7:0][7]),6,is_zero(a5[7:0])),4,a8[7:0][4]),2,parity(a5[7:0])),0,a13[16]);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:16 a18 = (-1 + a17) in
      M[a18] := M[a1];
      let:16 a19 = (-1 + a18) in
      M[a19] := M[(SPH,SPL)];
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a20 = (M[2081] & M[2081]) in
      let:8 a21 = (M[2081] | M[2081]) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a20)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:16 a22 = (-1 + a19) in
        M[a22] := 02;
        let:16 a23 = (-1 + a22) in
        M[a23] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:16 a24 = (-1 + a23) in
        M[a24] := M[a1];
        let:16 a25 = (-1 + a24) in
        M[a25] := M[(SPH,SPL)];
        advance (11)
        #147D
        #instruction: PUSH HL
        let:16 a26 = (-1 + a25) in
        M[a26] := a13[15:0][15:8];
        let:16 a27 = (-1 + a26) in
        M[a27] := a13[15:0][7:0];
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        advance (7)
        #147F
        #instruction: LD   (DE),A
        M[(M[a14],M[a12])] := M[a13[15:0]];
        advance (7)
        #1480
        #instruction: INC  DE
        let:16 a28 = (1 + (M[a14],M[a12])) in
        advance (5)
        #1481
        #instruction: INC  HL
        let:16 a29 = (1 + a13[15:0]) in
        advance (5)
        #1482
        #instruction: DEC  C
        let:16 a30 = addWithCarry(!true,M[(SPH,SPL)],~00) in
        let:8 a31 = (M[(SPH,SPL)] & 0F) in
        let:8 a32 = (~00 & 0F) in
        let:16 a33 = addWithCarry(!true,a31,a32) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a30[7:0])) {
          advance (10)
          A := M[a13[15:0]];
          B := M[a1];
          C := a30[7:0];
          D := a28[15:8];
          E := a28[7:0];
          H := a29[15:8];
          L := a29[7:0];
          SPH := a27[15:8];
          SPL := a27[7:0];
          FlagS := a30[7:0][7];
          FlagZ := is_zero(a30[7:0]);
          FlagA := a33[7:0][4];
          FlagP := parity(a30[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:16 a34 = (1 + a27) in
          let:16 a35 = (1 + a34) in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:17 a36 = add17(0020,(M[a34],M[a27])) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:16 a37 = (1 + a35) in
          let:16 a38 = (1 + a37) in
          advance (10)
          #148C
          #instruction: DEC  B
          let:16 a39 = addWithCarry(!true,M[a37],~00) in
          let:8 a40 = (M[a37] & 0F) in
          let:8 a41 = (~00 & 0F) in
          let:16 a42 = addWithCarry(!true,a40,a41) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a39[7:0])) {
            advance (10)
            A := M[a13[15:0]];
            B := a39[7:0];
            C := M[a35];
            D := a28[15:8];
            E := a28[7:0];
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a38[15:8];
            SPL := a38[7:0];
            FlagS := a39[7:0][7];
            FlagZ := is_zero(a39[7:0]);
            FlagA := a42[7:0][4];
            FlagP := parity(a39[7:0]);
            FlagCY := a36[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:16 a43 = (1 + a38) in
            let:16 a44 = (1 + a43) in
            advance (10)
            A := M[a13[15:0]];
            B := a39[7:0];
            C := M[a35];
            D := a28[15:8];
            E := a28[7:0];
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a44[15:8];
            SPL := a44[7:0];
            FlagS := a39[7:0][7];
            FlagZ := is_zero(a39[7:0]);
            FlagA := a42[7:0][4];
            FlagP := parity(a39[7:0]);
            FlagCY := a36[16];
            jump ((M[a43],M[a38]));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:16 a45 = (-1 + a19) in
        M[a45] := 02;
        let:16 a46 = (-1 + a45) in
        M[a46] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:16 a47 = (-1 + a46) in
        M[a47] := M[a1];
        let:16 a48 = (-1 + a47) in
        M[a48] := M[(SPH,SPL)];
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:16 a49 = (-1 + a48) in
        M[a49] := a13[15:0][15:8];
        let:16 a50 = (-1 + a49) in
        M[a50] := a13[15:0][7:0];
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a51 = (M[a13[15:0]] | M[(M[a14],M[a12])]) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        M[a13[15:0]] := a51;
        advance (7)
        #1A6E
        #instruction: INC  DE
        let:16 a52 = (1 + (M[a14],M[a12])) in
        advance (5)
        #1A6F
        #instruction: INC  HL
        let:16 a53 = (1 + a13[15:0]) in
        advance (5)
        #1A70
        #instruction: DEC  C
        let:16 a54 = addWithCarry(!true,M[(SPH,SPL)],~00) in
        let:8 a55 = (M[(SPH,SPL)] & 0F) in
        let:8 a56 = (~00 & 0F) in
        let:16 a57 = addWithCarry(!true,a55,a56) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a54[7:0])) {
          advance (10)
          A := a51;
          B := M[a1];
          C := a54[7:0];
          D := a52[15:8];
          E := a52[7:0];
          H := a53[15:8];
          L := a53[7:0];
          SPH := a50[15:8];
          SPL := a50[7:0];
          FlagS := a54[7:0][7];
          FlagZ := is_zero(a54[7:0]);
          FlagA := a57[7:0][4];
          FlagP := parity(a54[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:16 a58 = (1 + a50) in
          let:16 a59 = (1 + a58) in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:17 a60 = add17(0020,(M[a58],M[a50])) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:16 a61 = (1 + a59) in
          let:16 a62 = (1 + a61) in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:16 a63 = addWithCarry(!true,M[a61],~00) in
          let:8 a64 = (M[a61] & 0F) in
          let:8 a65 = (~00 & 0F) in
          let:16 a66 = addWithCarry(!true,a64,a65) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a63[7:0])) {
            advance (10)
            A := a51;
            B := a63[7:0];
            C := M[a59];
            D := a52[15:8];
            E := a52[7:0];
            H := a60[15:0][15:8];
            L := a60[15:0][7:0];
            SPH := a62[15:8];
            SPL := a62[7:0];
            FlagS := a63[7:0][7];
            FlagZ := is_zero(a63[7:0]);
            FlagA := a66[7:0][4];
            FlagP := parity(a63[7:0]);
            FlagCY := a60[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:16 a67 = (1 + a62) in
            let:16 a68 = (1 + a67) in
            advance (10)
            A := a51;
            B := a63[7:0];
            C := M[a59];
            D := a52[15:8];
            E := a52[7:0];
            H := a60[15:0][15:8];
            L := a60[15:0][7:0];
            SPH := a68[15:8];
            SPL := a68[7:0];
            FlagS := a63[7:0][7];
            FlagZ := is_zero(a63[7:0]);
            FlagA := a66[7:0][4];
            FlagP := parity(a63[7:0]);
            FlagCY := a60[16];
            jump ((M[a67],M[a62]));
          }
        }
      }
    }

0245:

    #instruction: JP   0235
    advance (10)
    jump (0235);

026F:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0270
    #instruction: LD   DE,000C
    advance (10)
    #0273
    #instruction: ADD  HL,DE
    let:17 a3 = add17(000C,(M[a1],M[(SPH,SPL)])) in
    advance (10)
    #0274
    #instruction: JP   024B
    advance (10)
    #024B
    #instruction: LD   A,(HL)
    advance (7)
    #024C
    #instruction: CP   FF
    let:16 a4 = addWithCarry(!false,M[a3[15:0]],~FF) in
    let:8 a5 = (M[a3[15:0]] & 0F) in
    let:8 a6 = (~FF & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    #024E
    #instruction: RET  Z
    if (is_zero(a4[7:0])) {
      let:16 a8 = (1 + a2) in
      let:16 a9 = (1 + a8) in
      advance (11)
      A := M[a3[15:0]];
      D := 00;
      E := 0C;
      H := a3[15:0][15:8];
      L := a3[15:0][7:0];
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a4[7:0][7];
      FlagZ := is_zero(a4[7:0]);
      FlagA := a7[7:0][4];
      FlagP := parity(a4[7:0]);
      FlagCY := !a4[15:8][0];
      jump ((M[a8],M[a2]));
    } else {
      advance (5)
      #024F
      #instruction: CP   FE
      let:16 a10 = addWithCarry(!false,M[a3[15:0]],~FE) in
      let:8 a11 = (M[a3[15:0]] & 0F) in
      let:8 a12 = (~FE & 0F) in
      let:16 a13 = addWithCarry(!false,a11,a12) in
      advance (7)
      #0251
      #instruction: JP   Z,0281
      if (is_zero(a10[7:0])) {
        advance (10)
        #0281
        #instruction: LD   DE,0010
        advance (10)
        #0284
        #instruction: ADD  HL,DE
        let:17 a14 = add17(0010,a3[15:0]) in
        advance (10)
        #0285
        #instruction: JP   024B
        advance (10)
        A := M[a3[15:0]];
        D := 00;
        E := 10;
        H := a14[15:0][15:8];
        L := a14[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := a14[16];
        jump (024B);
      } else {
        advance (10)
        #0254
        #instruction: INC  HL
        let:16 a15 = (1 + a3[15:0]) in
        advance (5)
        #0255
        #instruction: LD   B,(HL)
        advance (7)
        #0256
        #instruction: LD   C,A
        advance (5)
        #0257
        #instruction: OR   B
        let:8 a16 = (M[a15] | M[a3[15:0]]) in
        advance (4)
        #0258
        #instruction: LD   A,C
        advance (5)
        #0259
        #instruction: JP   NZ,0277
        if (!is_zero(a16)) {
          advance (10)
          #0277
          #instruction: DEC  B
          let:16 a17 = addWithCarry(!true,M[a15],~00) in
          let:8 a18 = (M[a15] & 0F) in
          let:8 a19 = (~00 & 0F) in
          let:16 a20 = addWithCarry(!true,a18,a19) in
          advance (5)
          #0278
          #instruction: INC  B
          let:16 a21 = addWithCarry(true,a17[7:0],00) in
          let:8 a22 = (a17[7:0] & 0F) in
          let:8 a23 = (00 & 0F) in
          let:16 a24 = addWithCarry(true,a22,a23) in
          advance (5)
          #0279
          #instruction: JP   NZ,027D
          if (!is_zero(a21[7:0])) {
            advance (10)
            #027D
            #instruction: DEC  B
            let:16 a25 = addWithCarry(!true,a21[7:0],~00) in
            let:8 a26 = (a21[7:0] & 0F) in
            let:8 a27 = (~00 & 0F) in
            let:16 a28 = addWithCarry(!true,a26,a27) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            M[a15] := a25[7:0];
            advance (7)
            #027F
            #instruction: DEC  HL
            let:16 a29 = (-1 + a15) in
            advance (5)
            #0280
            #instruction: LD   (HL),A
            M[a29] := M[a3[15:0]];
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a30 = add17(0010,a29) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := M[a3[15:0]];
            B := a25[7:0];
            C := M[a3[15:0]];
            D := 00;
            E := 10;
            H := a30[15:0][15:8];
            L := a30[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a25[7:0][7];
            FlagZ := is_zero(a25[7:0]);
            FlagA := a28[7:0][4];
            FlagP := parity(a25[7:0]);
            FlagCY := a30[16];
            jump (024B);
          } else {
            advance (10)
            #027C
            #instruction: DEC  A
            let:16 a31 = addWithCarry(!true,M[a3[15:0]],~00) in
            let:8 a32 = (M[a3[15:0]] & 0F) in
            let:8 a33 = (~00 & 0F) in
            let:16 a34 = addWithCarry(!true,a32,a33) in
            advance (5)
            #027D
            #instruction: DEC  B
            let:16 a35 = addWithCarry(!true,a21[7:0],~00) in
            let:8 a36 = (a21[7:0] & 0F) in
            let:8 a37 = (~00 & 0F) in
            let:16 a38 = addWithCarry(!true,a36,a37) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            M[a15] := a35[7:0];
            advance (7)
            #027F
            #instruction: DEC  HL
            let:16 a39 = (-1 + a15) in
            advance (5)
            #0280
            #instruction: LD   (HL),A
            M[a39] := a31[7:0];
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a40 = add17(0010,a39) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a31[7:0];
            B := a35[7:0];
            C := M[a3[15:0]];
            D := 00;
            E := 10;
            H := a40[15:0][15:8];
            L := a40[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a35[7:0][7];
            FlagZ := is_zero(a35[7:0]);
            FlagA := a38[7:0][4];
            FlagP := parity(a35[7:0]);
            FlagCY := a40[16];
            jump (024B);
          }
        } else {
          advance (10)
          #025C
          #instruction: INC  HL
          let:16 a41 = (1 + a15) in
          advance (5)
          #025D
          #instruction: LD   A,(HL)
          advance (7)
          #025E
          #instruction: AND  A
          let:8 a42 = (M[a41] & M[a41]) in
          let:8 a43 = (M[a41] | M[a41]) in
          advance (4)
          #025F
          #instruction: JP   NZ,0288
          if (!is_zero(a42)) {
            advance (10)
            #0288
            #instruction: DEC  (HL)
            let:16 a44 = addWithCarry(!true,M[a41],~00) in
            let:8 a45 = (M[a41] & 0F) in
            let:8 a46 = (~00 & 0F) in
            let:16 a47 = addWithCarry(!true,a45,a46) in
            M[a41] := a44[7:0];
            advance (10)
            #0289
            #instruction: DEC  HL
            let:16 a48 = (-1 + a41) in
            advance (5)
            #028A
            #instruction: DEC  HL
            let:16 a49 = (-1 + a48) in
            advance (5)
            #028B
            #instruction: JP   0281
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a50 = add17(0010,a49) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a42;
            B := M[a15];
            C := M[a3[15:0]];
            D := 00;
            E := 10;
            H := a50[15:0][15:8];
            L := a50[15:0][7:0];
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a44[7:0][7];
            FlagZ := is_zero(a44[7:0]);
            FlagA := a47[7:0][4];
            FlagP := parity(a44[7:0]);
            FlagCY := a50[16];
            jump (024B);
          } else {
            advance (10)
            #0262
            #instruction: INC  HL
            let:16 a51 = (1 + a41) in
            advance (5)
            #0263
            #instruction: LD   E,(HL)
            advance (7)
            #0264
            #instruction: INC  HL
            let:16 a52 = (1 + a51) in
            advance (5)
            #0265
            #instruction: LD   D,(HL)
            advance (7)
            #0266
            #instruction: PUSH HL
            let:16 a53 = (-1 + a2) in
            M[a53] := a52[15:8];
            let:16 a54 = (-1 + a53) in
            M[a54] := a52[7:0];
            advance (11)
            #0267
            #instruction: EX   DE,HL
            advance (4)
            #0268
            #instruction: PUSH HL
            let:16 a55 = (-1 + a54) in
            M[a55] := M[a52];
            let:16 a56 = (-1 + a55) in
            M[a56] := M[a51];
            advance (11)
            #0269
            #instruction: LD   HL,026F
            advance (10)
            #026C
            #instruction: EX   (SP),HL
            let:16 a57 = (1 + a56) in
            M[a56] := 6F;
            M[a57] := 02;
            advance (18)
            #026D
            #instruction: PUSH DE
            let:16 a58 = (-1 + a56) in
            M[a58] := a52[15:8];
            let:16 a59 = (-1 + a58) in
            M[a59] := a52[7:0];
            advance (11)
            #026E
            #instruction: JP   (HL)
            advance (5)
            A := a42;
            B := M[a15];
            C := M[a3[15:0]];
            D := a52[15:8];
            E := a52[7:0];
            H := M[a57];
            L := M[a56];
            SPH := a59[15:8];
            SPL := a59[7:0];
            FlagS := a42[7];
            FlagZ := is_zero(a42);
            FlagA := a43[3];
            FlagP := parity(a42);
            FlagCY := false;
            jump ((M[a57],M[a56]));
          }
        }
      }
    }

028E:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #028F
    #instruction: INC  HL
    let:16 a3 = (1 + (M[a1],M[(SPH,SPL)])) in
    advance (5)
    #0290
    #instruction: LD   A,(HL)
    advance (7)
    #0291
    #instruction: CP   FF
    let:16 a4 = addWithCarry(!false,M[a3],~FF) in
    let:8 a5 = (M[a3] & 0F) in
    let:8 a6 = (~FF & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    #0293
    #instruction: JP   Z,033B
    if (is_zero(a4[7:0])) {
      advance (10)
      #033B
      #instruction: LD   HL,2068
      advance (10)
      #033E
      #instruction: LD   (HL),01
      M[2068] := 01;
      advance (10)
      #0340
      #instruction: INC  HL
      advance (5)
      #0341
      #instruction: LD   A,(HL)
      advance (7)
      #0342
      #instruction: AND  A
      let:8 a8 = (M[2069] & M[2069]) in
      let:8 a9 = (M[2069] | M[2069]) in
      advance (4)
      #0343
      #instruction: JP   03B0
      advance (10)
      #03B0
      #instruction: JP   NZ,034A
      if (!is_zero(a8)) {
        advance (10)
        #034A
        #instruction: LD   A,(201B)
        advance (13)
        #034D
        #instruction: LD   B,A
        advance (5)
        #034E
        #instruction: LD   A,(20EF)
        advance (13)
        #0351
        #instruction: AND  A
        let:8 a10 = (M[20EF] & M[20EF]) in
        let:8 a11 = (M[20EF] | M[20EF]) in
        advance (4)
        #0352
        #instruction: JP   NZ,0363
        if (!is_zero(a10)) {
          advance (10)
          #0363
          #instruction: CALL 17C0
          let:16 a12 = (-1 + a2) in
          M[a12] := 03;
          let:16 a13 = (-1 + a12) in
          M[a13] := 66;
          #return-to: 0366
          advance (17)
          #17C0
          #instruction: LD   A,(2067)
          advance (13)
          #17C3
          #instruction: RRCA 
          advance (4)
          #17C4
          #instruction: JP   NC,17CA
          if (!M[2067][0]) {
            advance (10)
            #17CA
            #instruction: IN   02
            advance (10)
            #17CC
            #instruction: RET
            let:16 a14 = (1 + a13) in
            let:16 a15 = (1 + a14) in
            advance (10)
            A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
            B := M[201B];
            H := 20;
            L := 69;
            SPH := a15[15:8];
            SPL := a15[7:0];
            FlagS := a10[7];
            FlagZ := is_zero(a10);
            FlagA := a11[3];
            FlagP := parity(a10);
            FlagCY := M[2067][0];
            jump ((M[a14],M[a13]));
          } else {
            advance (10)
            #17C7
            #instruction: IN   01
            advance (10)
            #17C9
            #instruction: RET
            let:16 a16 = (1 + a13) in
            let:16 a17 = (1 + a16) in
            advance (10)
            A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
            B := M[201B];
            H := 20;
            L := 69;
            SPH := a17[15:8];
            SPL := a17[7:0];
            FlagS := a10[7];
            FlagZ := is_zero(a10);
            FlagA := a11[3];
            FlagP := parity(a10);
            FlagCY := M[2067][0];
            jump ((M[a16],M[a13]));
          }
        } else {
          advance (10)
          #0355
          #instruction: LD   A,(201D)
          advance (13)
          #0358
          #instruction: RRCA 
          advance (4)
          #0359
          #instruction: JP   CY,0381
          if (M[201D][0]) {
            advance (10)
            #0381
            #instruction: LD   A,B
            advance (5)
            #0382
            #instruction: CP   D9
            let:16 a18 = addWithCarry(!false,M[201B],~D9) in
            let:8 a19 = (M[201B] & 0F) in
            let:8 a20 = (~D9 & 0F) in
            let:16 a21 = addWithCarry(!false,a19,a20) in
            advance (7)
            #0384
            #instruction: JP   Z,036F
            if (is_zero(a18[7:0])) {
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:16 a22 = (-1 + a2) in
              M[a22] := 03;
              let:16 a23 = (-1 + a22) in
              M[a23] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              advance (7)
              #1A44
              #instruction: LD   H,C
              advance (5)
              #1A45
              #instruction: LD   L,A
              advance (5)
              #1A46
              #instruction: RET
              let:16 a24 = (1 + a23) in
              let:16 a25 = (1 + a24) in
              advance (10)
              A := M[201A];
              B := M[201C];
              C := M[201B];
              D := M[2019];
              E := M[2018];
              H := M[201B];
              L := M[201A];
              SPH := a25[15:8];
              SPL := a25[7:0];
              FlagS := a18[7:0][7];
              FlagZ := is_zero(a18[7:0]);
              FlagA := a21[7:0][4];
              FlagP := parity(a18[7:0]);
              FlagCY := !a18[15:8][0];
              jump ((M[a24],M[a23]));
            } else {
              advance (10)
              #0387
              #instruction: INC  A
              let:16 a26 = addWithCarry(true,M[201B],00) in
              let:8 a27 = (M[201B] & 0F) in
              let:8 a28 = (00 & 0F) in
              let:16 a29 = addWithCarry(true,a27,a28) in
              advance (5)
              #0388
              #instruction: LD   (201B),A
              M[201B] := a26[7:0];
              advance (13)
              #038B
              #instruction: JP   036F
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:16 a30 = (-1 + a2) in
              M[a30] := 03;
              let:16 a31 = (-1 + a30) in
              M[a31] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              advance (7)
              #1A44
              #instruction: LD   H,C
              advance (5)
              #1A45
              #instruction: LD   L,A
              advance (5)
              #1A46
              #instruction: RET
              let:16 a32 = (1 + a31) in
              let:16 a33 = (1 + a32) in
              advance (10)
              A := M[201A];
              B := M[201C];
              C := M[201B];
              D := M[2019];
              E := M[2018];
              H := M[201B];
              L := M[201A];
              SPH := a33[15:8];
              SPL := a33[7:0];
              FlagS := a26[7:0][7];
              FlagZ := is_zero(a26[7:0]);
              FlagA := a29[7:0][4];
              FlagP := parity(a26[7:0]);
              FlagCY := !a18[15:8][0];
              jump ((M[a32],M[a31]));
            }
          } else {
            advance (10)
            #035C
            #instruction: RRCA 
            advance (4)
            #035D
            #instruction: JP   CY,038E
            if (updateBit((M[201D] >> 01),7,M[201D][0])[0]) {
              advance (10)
              #038E
              #instruction: LD   A,B
              advance (5)
              #038F
              #instruction: CP   30
              let:16 a34 = addWithCarry(!false,M[201B],~30) in
              let:8 a35 = (M[201B] & 0F) in
              let:8 a36 = (~30 & 0F) in
              let:16 a37 = addWithCarry(!false,a35,a36) in
              advance (7)
              #0391
              #instruction: JP   Z,036F
              if (is_zero(a34[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a38 = (-1 + a2) in
                M[a38] := 03;
                let:16 a39 = (-1 + a38) in
                M[a39] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a40 = (1 + a39) in
                let:16 a41 = (1 + a40) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a41[15:8];
                SPL := a41[7:0];
                FlagS := a34[7:0][7];
                FlagZ := is_zero(a34[7:0]);
                FlagA := a37[7:0][4];
                FlagP := parity(a34[7:0]);
                FlagCY := !a34[15:8][0];
                jump ((M[a40],M[a39]));
              } else {
                advance (10)
                #0394
                #instruction: DEC  A
                let:16 a42 = addWithCarry(!true,M[201B],~00) in
                let:8 a43 = (M[201B] & 0F) in
                let:8 a44 = (~00 & 0F) in
                let:16 a45 = addWithCarry(!true,a43,a44) in
                advance (5)
                #0395
                #instruction: LD   (201B),A
                M[201B] := a42[7:0];
                advance (13)
                #0398
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a46 = (-1 + a2) in
                M[a46] := 03;
                let:16 a47 = (-1 + a46) in
                M[a47] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a48 = (1 + a47) in
                let:16 a49 = (1 + a48) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a49[15:8];
                SPL := a49[7:0];
                FlagS := a42[7:0][7];
                FlagZ := is_zero(a42[7:0]);
                FlagA := a45[7:0][4];
                FlagP := parity(a42[7:0]);
                FlagCY := !a34[15:8][0];
                jump ((M[a48],M[a47]));
              }
            } else {
              advance (10)
              #0360
              #instruction: JP   036F
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:16 a50 = (-1 + a2) in
              M[a50] := 03;
              let:16 a51 = (-1 + a50) in
              M[a51] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              advance (7)
              #1A44
              #instruction: LD   H,C
              advance (5)
              #1A45
              #instruction: LD   L,A
              advance (5)
              #1A46
              #instruction: RET
              let:16 a52 = (1 + a51) in
              let:16 a53 = (1 + a52) in
              advance (10)
              A := M[201A];
              B := M[201C];
              C := M[201B];
              D := M[2019];
              E := M[2018];
              H := M[201B];
              L := M[201A];
              SPH := a53[15:8];
              SPL := a53[7:0];
              FlagS := a10[7];
              FlagZ := is_zero(a10);
              FlagA := a11[3];
              FlagP := parity(a10);
              FlagCY := updateBit((M[201D] >> 01),7,M[201D][0])[0];
              jump ((M[a52],M[a51]));
            }
          }
        }
      } else {
        advance (10)
        #03B3
        #instruction: INC  HL
        advance (5)
        #03B4
        #instruction: DEC  (HL)
        let:16 a54 = addWithCarry(!true,M[206A],~00) in
        let:8 a55 = (M[206A] & 0F) in
        let:8 a56 = (~00 & 0F) in
        let:16 a57 = addWithCarry(!true,a55,a56) in
        M[206A] := a54[7:0];
        advance (10)
        #03B5
        #instruction: JP   NZ,034A
        if (!is_zero(a54[7:0])) {
          advance (10)
          #034A
          #instruction: LD   A,(201B)
          advance (13)
          #034D
          #instruction: LD   B,A
          advance (5)
          #034E
          #instruction: LD   A,(20EF)
          advance (13)
          #0351
          #instruction: AND  A
          let:8 a58 = (M[20EF] & M[20EF]) in
          let:8 a59 = (M[20EF] | M[20EF]) in
          advance (4)
          #0352
          #instruction: JP   NZ,0363
          if (!is_zero(a58)) {
            advance (10)
            #0363
            #instruction: CALL 17C0
            let:16 a60 = (-1 + a2) in
            M[a60] := 03;
            let:16 a61 = (-1 + a60) in
            M[a61] := 66;
            #return-to: 0366
            advance (17)
            #17C0
            #instruction: LD   A,(2067)
            advance (13)
            #17C3
            #instruction: RRCA 
            advance (4)
            #17C4
            #instruction: JP   NC,17CA
            if (!M[2067][0]) {
              advance (10)
              #17CA
              #instruction: IN   02
              advance (10)
              #17CC
              #instruction: RET
              let:16 a62 = (1 + a61) in
              let:16 a63 = (1 + a62) in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
              B := M[201B];
              H := 20;
              L := 6A;
              SPH := a63[15:8];
              SPL := a63[7:0];
              FlagS := a58[7];
              FlagZ := is_zero(a58);
              FlagA := a59[3];
              FlagP := parity(a58);
              FlagCY := M[2067][0];
              jump ((M[a62],M[a61]));
            } else {
              advance (10)
              #17C7
              #instruction: IN   01
              advance (10)
              #17C9
              #instruction: RET
              let:16 a64 = (1 + a61) in
              let:16 a65 = (1 + a64) in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
              B := M[201B];
              H := 20;
              L := 6A;
              SPH := a65[15:8];
              SPL := a65[7:0];
              FlagS := a58[7];
              FlagZ := is_zero(a58);
              FlagA := a59[3];
              FlagP := parity(a58);
              FlagCY := M[2067][0];
              jump ((M[a64],M[a61]));
            }
          } else {
            advance (10)
            #0355
            #instruction: LD   A,(201D)
            advance (13)
            #0358
            #instruction: RRCA 
            advance (4)
            #0359
            #instruction: JP   CY,0381
            if (M[201D][0]) {
              advance (10)
              #0381
              #instruction: LD   A,B
              advance (5)
              #0382
              #instruction: CP   D9
              let:16 a66 = addWithCarry(!false,M[201B],~D9) in
              let:8 a67 = (M[201B] & 0F) in
              let:8 a68 = (~D9 & 0F) in
              let:16 a69 = addWithCarry(!false,a67,a68) in
              advance (7)
              #0384
              #instruction: JP   Z,036F
              if (is_zero(a66[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a70 = (-1 + a2) in
                M[a70] := 03;
                let:16 a71 = (-1 + a70) in
                M[a71] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a72 = (1 + a71) in
                let:16 a73 = (1 + a72) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a73[15:8];
                SPL := a73[7:0];
                FlagS := a66[7:0][7];
                FlagZ := is_zero(a66[7:0]);
                FlagA := a69[7:0][4];
                FlagP := parity(a66[7:0]);
                FlagCY := !a66[15:8][0];
                jump ((M[a72],M[a71]));
              } else {
                advance (10)
                #0387
                #instruction: INC  A
                let:16 a74 = addWithCarry(true,M[201B],00) in
                let:8 a75 = (M[201B] & 0F) in
                let:8 a76 = (00 & 0F) in
                let:16 a77 = addWithCarry(true,a75,a76) in
                advance (5)
                #0388
                #instruction: LD   (201B),A
                M[201B] := a74[7:0];
                advance (13)
                #038B
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a78 = (-1 + a2) in
                M[a78] := 03;
                let:16 a79 = (-1 + a78) in
                M[a79] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a80 = (1 + a79) in
                let:16 a81 = (1 + a80) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a81[15:8];
                SPL := a81[7:0];
                FlagS := a74[7:0][7];
                FlagZ := is_zero(a74[7:0]);
                FlagA := a77[7:0][4];
                FlagP := parity(a74[7:0]);
                FlagCY := !a66[15:8][0];
                jump ((M[a80],M[a79]));
              }
            } else {
              advance (10)
              #035C
              #instruction: RRCA 
              advance (4)
              #035D
              #instruction: JP   CY,038E
              if (updateBit((M[201D] >> 01),7,M[201D][0])[0]) {
                advance (10)
                #038E
                #instruction: LD   A,B
                advance (5)
                #038F
                #instruction: CP   30
                let:16 a82 = addWithCarry(!false,M[201B],~30) in
                let:8 a83 = (M[201B] & 0F) in
                let:8 a84 = (~30 & 0F) in
                let:16 a85 = addWithCarry(!false,a83,a84) in
                advance (7)
                #0391
                #instruction: JP   Z,036F
                if (is_zero(a82[7:0])) {
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:16 a86 = (-1 + a2) in
                  M[a86] := 03;
                  let:16 a87 = (-1 + a86) in
                  M[a87] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:16 a88 = (1 + a87) in
                  let:16 a89 = (1 + a88) in
                  advance (10)
                  A := M[201A];
                  B := M[201C];
                  C := M[201B];
                  D := M[2019];
                  E := M[2018];
                  H := M[201B];
                  L := M[201A];
                  SPH := a89[15:8];
                  SPL := a89[7:0];
                  FlagS := a82[7:0][7];
                  FlagZ := is_zero(a82[7:0]);
                  FlagA := a85[7:0][4];
                  FlagP := parity(a82[7:0]);
                  FlagCY := !a82[15:8][0];
                  jump ((M[a88],M[a87]));
                } else {
                  advance (10)
                  #0394
                  #instruction: DEC  A
                  let:16 a90 = addWithCarry(!true,M[201B],~00) in
                  let:8 a91 = (M[201B] & 0F) in
                  let:8 a92 = (~00 & 0F) in
                  let:16 a93 = addWithCarry(!true,a91,a92) in
                  advance (5)
                  #0395
                  #instruction: LD   (201B),A
                  M[201B] := a90[7:0];
                  advance (13)
                  #0398
                  #instruction: JP   036F
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:16 a94 = (-1 + a2) in
                  M[a94] := 03;
                  let:16 a95 = (-1 + a94) in
                  M[a95] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:16 a96 = (1 + a95) in
                  let:16 a97 = (1 + a96) in
                  advance (10)
                  A := M[201A];
                  B := M[201C];
                  C := M[201B];
                  D := M[2019];
                  E := M[2018];
                  H := M[201B];
                  L := M[201A];
                  SPH := a97[15:8];
                  SPL := a97[7:0];
                  FlagS := a90[7:0][7];
                  FlagZ := is_zero(a90[7:0]);
                  FlagA := a93[7:0][4];
                  FlagP := parity(a90[7:0]);
                  FlagCY := !a82[15:8][0];
                  jump ((M[a96],M[a95]));
                }
              } else {
                advance (10)
                #0360
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a98 = (-1 + a2) in
                M[a98] := 03;
                let:16 a99 = (-1 + a98) in
                M[a99] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a100 = (1 + a99) in
                let:16 a101 = (1 + a100) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a101[15:8];
                SPL := a101[7:0];
                FlagS := a58[7];
                FlagZ := is_zero(a58);
                FlagA := a59[3];
                FlagP := parity(a58);
                FlagCY := updateBit((M[201D] >> 01),7,M[201D][0])[0];
                jump ((M[a100],M[a99]));
              }
            }
          }
        } else {
          advance (10)
          #03B8
          #instruction: JP   0346
          advance (10)
          #0346
          #instruction: NOP
          advance (4)
          #0347
          #instruction: DEC  HL
          advance (5)
          #0348
          #instruction: LD   (HL),01
          M[2069] := 01;
          advance (10)
          #034A
          #instruction: LD   A,(201B)
          advance (13)
          #034D
          #instruction: LD   B,A
          advance (5)
          #034E
          #instruction: LD   A,(20EF)
          advance (13)
          #0351
          #instruction: AND  A
          let:8 a102 = (M[20EF] & M[20EF]) in
          let:8 a103 = (M[20EF] | M[20EF]) in
          advance (4)
          #0352
          #instruction: JP   NZ,0363
          if (!is_zero(a102)) {
            advance (10)
            #0363
            #instruction: CALL 17C0
            let:16 a104 = (-1 + a2) in
            M[a104] := 03;
            let:16 a105 = (-1 + a104) in
            M[a105] := 66;
            #return-to: 0366
            advance (17)
            #17C0
            #instruction: LD   A,(2067)
            advance (13)
            #17C3
            #instruction: RRCA 
            advance (4)
            #17C4
            #instruction: JP   NC,17CA
            if (!M[2067][0]) {
              advance (10)
              #17CA
              #instruction: IN   02
              advance (10)
              #17CC
              #instruction: RET
              let:16 a106 = (1 + a105) in
              let:16 a107 = (1 + a106) in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
              B := M[201B];
              H := 20;
              L := 69;
              SPH := a107[15:8];
              SPL := a107[7:0];
              FlagS := a102[7];
              FlagZ := is_zero(a102);
              FlagA := a103[3];
              FlagP := parity(a102);
              FlagCY := M[2067][0];
              jump ((M[a106],M[a105]));
            } else {
              advance (10)
              #17C7
              #instruction: IN   01
              advance (10)
              #17C9
              #instruction: RET
              let:16 a108 = (1 + a105) in
              let:16 a109 = (1 + a108) in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
              B := M[201B];
              H := 20;
              L := 69;
              SPH := a109[15:8];
              SPL := a109[7:0];
              FlagS := a102[7];
              FlagZ := is_zero(a102);
              FlagA := a103[3];
              FlagP := parity(a102);
              FlagCY := M[2067][0];
              jump ((M[a108],M[a105]));
            }
          } else {
            advance (10)
            #0355
            #instruction: LD   A,(201D)
            advance (13)
            #0358
            #instruction: RRCA 
            advance (4)
            #0359
            #instruction: JP   CY,0381
            if (M[201D][0]) {
              advance (10)
              #0381
              #instruction: LD   A,B
              advance (5)
              #0382
              #instruction: CP   D9
              let:16 a110 = addWithCarry(!false,M[201B],~D9) in
              let:8 a111 = (M[201B] & 0F) in
              let:8 a112 = (~D9 & 0F) in
              let:16 a113 = addWithCarry(!false,a111,a112) in
              advance (7)
              #0384
              #instruction: JP   Z,036F
              if (is_zero(a110[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a114 = (-1 + a2) in
                M[a114] := 03;
                let:16 a115 = (-1 + a114) in
                M[a115] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a116 = (1 + a115) in
                let:16 a117 = (1 + a116) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a117[15:8];
                SPL := a117[7:0];
                FlagS := a110[7:0][7];
                FlagZ := is_zero(a110[7:0]);
                FlagA := a113[7:0][4];
                FlagP := parity(a110[7:0]);
                FlagCY := !a110[15:8][0];
                jump ((M[a116],M[a115]));
              } else {
                advance (10)
                #0387
                #instruction: INC  A
                let:16 a118 = addWithCarry(true,M[201B],00) in
                let:8 a119 = (M[201B] & 0F) in
                let:8 a120 = (00 & 0F) in
                let:16 a121 = addWithCarry(true,a119,a120) in
                advance (5)
                #0388
                #instruction: LD   (201B),A
                M[201B] := a118[7:0];
                advance (13)
                #038B
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a122 = (-1 + a2) in
                M[a122] := 03;
                let:16 a123 = (-1 + a122) in
                M[a123] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a124 = (1 + a123) in
                let:16 a125 = (1 + a124) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a125[15:8];
                SPL := a125[7:0];
                FlagS := a118[7:0][7];
                FlagZ := is_zero(a118[7:0]);
                FlagA := a121[7:0][4];
                FlagP := parity(a118[7:0]);
                FlagCY := !a110[15:8][0];
                jump ((M[a124],M[a123]));
              }
            } else {
              advance (10)
              #035C
              #instruction: RRCA 
              advance (4)
              #035D
              #instruction: JP   CY,038E
              if (updateBit((M[201D] >> 01),7,M[201D][0])[0]) {
                advance (10)
                #038E
                #instruction: LD   A,B
                advance (5)
                #038F
                #instruction: CP   30
                let:16 a126 = addWithCarry(!false,M[201B],~30) in
                let:8 a127 = (M[201B] & 0F) in
                let:8 a128 = (~30 & 0F) in
                let:16 a129 = addWithCarry(!false,a127,a128) in
                advance (7)
                #0391
                #instruction: JP   Z,036F
                if (is_zero(a126[7:0])) {
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:16 a130 = (-1 + a2) in
                  M[a130] := 03;
                  let:16 a131 = (-1 + a130) in
                  M[a131] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:16 a132 = (1 + a131) in
                  let:16 a133 = (1 + a132) in
                  advance (10)
                  A := M[201A];
                  B := M[201C];
                  C := M[201B];
                  D := M[2019];
                  E := M[2018];
                  H := M[201B];
                  L := M[201A];
                  SPH := a133[15:8];
                  SPL := a133[7:0];
                  FlagS := a126[7:0][7];
                  FlagZ := is_zero(a126[7:0]);
                  FlagA := a129[7:0][4];
                  FlagP := parity(a126[7:0]);
                  FlagCY := !a126[15:8][0];
                  jump ((M[a132],M[a131]));
                } else {
                  advance (10)
                  #0394
                  #instruction: DEC  A
                  let:16 a134 = addWithCarry(!true,M[201B],~00) in
                  let:8 a135 = (M[201B] & 0F) in
                  let:8 a136 = (~00 & 0F) in
                  let:16 a137 = addWithCarry(!true,a135,a136) in
                  advance (5)
                  #0395
                  #instruction: LD   (201B),A
                  M[201B] := a134[7:0];
                  advance (13)
                  #0398
                  #instruction: JP   036F
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:16 a138 = (-1 + a2) in
                  M[a138] := 03;
                  let:16 a139 = (-1 + a138) in
                  M[a139] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:16 a140 = (1 + a139) in
                  let:16 a141 = (1 + a140) in
                  advance (10)
                  A := M[201A];
                  B := M[201C];
                  C := M[201B];
                  D := M[2019];
                  E := M[2018];
                  H := M[201B];
                  L := M[201A];
                  SPH := a141[15:8];
                  SPL := a141[7:0];
                  FlagS := a134[7:0][7];
                  FlagZ := is_zero(a134[7:0]);
                  FlagA := a137[7:0][4];
                  FlagP := parity(a134[7:0]);
                  FlagCY := !a126[15:8][0];
                  jump ((M[a140],M[a139]));
                }
              } else {
                advance (10)
                #0360
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:16 a142 = (-1 + a2) in
                M[a142] := 03;
                let:16 a143 = (-1 + a142) in
                M[a143] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a144 = (1 + a143) in
                let:16 a145 = (1 + a144) in
                advance (10)
                A := M[201A];
                B := M[201C];
                C := M[201B];
                D := M[2019];
                E := M[2018];
                H := M[201B];
                L := M[201A];
                SPH := a145[15:8];
                SPL := a145[7:0];
                FlagS := a102[7];
                FlagZ := is_zero(a102);
                FlagA := a103[3];
                FlagP := parity(a102);
                FlagCY := updateBit((M[201D] >> 01),7,M[201D][0])[0];
                jump ((M[a144],M[a143]));
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0296
      #instruction: INC  HL
      let:16 a146 = (1 + a3) in
      advance (5)
      #0297
      #instruction: DEC  (HL)
      let:16 a147 = addWithCarry(!true,M[a146],~00) in
      let:8 a148 = (M[a146] & 0F) in
      let:8 a149 = (~00 & 0F) in
      let:16 a150 = addWithCarry(!true,a148,a149) in
      M[a146] := a147[7:0];
      advance (10)
      #0298
      #instruction: RET  NZ
      if (!is_zero(a147[7:0])) {
        let:16 a151 = (1 + a2) in
        let:16 a152 = (1 + a151) in
        advance (11)
        A := M[a3];
        H := a146[15:8];
        L := a146[7:0];
        SPH := a152[15:8];
        SPL := a152[7:0];
        FlagS := a147[7:0][7];
        FlagZ := is_zero(a147[7:0]);
        FlagA := a150[7:0][4];
        FlagP := parity(a147[7:0]);
        FlagCY := !a4[15:8][0];
        jump ((M[a151],M[a2]));
      } else {
        advance (5)
        #0299
        #instruction: LD   B,A
        advance (5)
        #029A
        #instruction: XOR  A
        let:8 a153 = (M[a3] ^ M[a3]) in
        advance (4)
        #029B
        #instruction: LD   (2068),A
        M[2068] := a153;
        advance (13)
        #029E
        #instruction: LD   (2069),A
        M[2069] := a153;
        advance (13)
        #02A1
        #instruction: LD   A,30
        advance (7)
        #02A3
        #instruction: LD   (206A),A
        M[206A] := 30;
        advance (13)
        #02A6
        #instruction: LD   A,B
        advance (5)
        #02A7
        #instruction: LD   (HL),05
        M[a146] := 05;
        advance (10)
        #02A9
        #instruction: INC  HL
        let:16 a154 = (1 + a146) in
        advance (5)
        #02AA
        #instruction: DEC  (HL)
        let:16 a155 = addWithCarry(!true,M[a154],~00) in
        let:8 a156 = (M[a154] & 0F) in
        let:8 a157 = (~00 & 0F) in
        let:16 a158 = addWithCarry(!true,a156,a157) in
        M[a154] := a155[7:0];
        advance (10)
        #02AB
        #instruction: JP   NZ,039B
        if (!is_zero(a155[7:0])) {
          advance (10)
          #039B
          #instruction: INC  A
          let:16 a159 = addWithCarry(true,M[a3],00) in
          let:8 a160 = (M[a3] & 0F) in
          let:8 a161 = (00 & 0F) in
          let:16 a162 = addWithCarry(true,a160,a161) in
          advance (5)
          #039C
          #instruction: AND  01
          let:8 a163 = (01 & a159[7:0]) in
          let:8 a164 = (01 | a159[7:0]) in
          advance (7)
          #039E
          #instruction: LD   (2015),A
          M[2015] := a163;
          advance (13)
          #03A1
          #instruction: RLCA 
          advance (4)
          #03A2
          #instruction: RLCA 
          advance (4)
          #03A3
          #instruction: RLCA 
          advance (4)
          #03A4
          #instruction: RLCA 
          advance (4)
          #03A5
          #instruction: LD   HL,1C70
          advance (10)
          #03A8
          #instruction: ADD  L
          let:16 a165 = addWithCarry(false,70,updateBit((updateBit((updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7]) << 01),0,updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7])[7]) << 01),0,updateBit((updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7]) << 01),0,updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7])[7])[7])) in
          let:8 a166 = (70 & 0F) in
          let:8 a167 = (updateBit((updateBit((updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7]) << 01),0,updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7])[7]) << 01),0,updateBit((updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7]) << 01),0,updateBit((updateBit((a163 << 01),0,a163[7]) << 01),0,updateBit((a163 << 01),0,a163[7])[7])[7])[7]) & 0F) in
          let:16 a168 = addWithCarry(false,a166,a167) in
          advance (4)
          #03A9
          #instruction: LD   L,A
          advance (5)
          #03AA
          #instruction: LD   (2018),HL
          M[2018] := a165[7:0];
          M[2019] := 1C;
          advance (16)
          #03AD
          #instruction: JP   036F
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:16 a169 = (-1 + a2) in
          M[a169] := 03;
          let:16 a170 = (-1 + a169) in
          M[a170] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a171 = (1 + a170) in
          let:16 a172 = (1 + a171) in
          advance (10)
          A := M[201A];
          B := M[201C];
          C := M[201B];
          D := M[2019];
          E := M[2018];
          H := M[201B];
          L := M[201A];
          SPH := a172[15:8];
          SPL := a172[7:0];
          FlagS := a165[7:0][7];
          FlagZ := is_zero(a165[7:0]);
          FlagA := a168[7:0][4];
          FlagP := parity(a165[7:0]);
          FlagCY := a165[15:8][0];
          jump ((M[a171],M[a170]));
        } else {
          advance (10)
          #02AE
          #instruction: LD   HL,(201A)
          advance (16)
          #02B1
          #instruction: LD   B,10
          advance (7)
          #02B3
          #instruction: CALL 1424
          let:16 a173 = (-1 + a2) in
          M[a173] := 02;
          let:16 a174 = (-1 + a173) in
          M[a174] := B6;
          #return-to: 02B6
          advance (17)
          #1424
          #instruction: CALL 1474
          let:16 a175 = (-1 + a174) in
          M[a175] := 14;
          let:16 a176 = (-1 + a175) in
          M[a176] := 27;
          #return-to: 1427
          advance (17)
          #1474
          #instruction: LD   A,L
          advance (5)
          #1475
          #instruction: AND  07
          let:8 a177 = (07 & M[201A]) in
          let:8 a178 = (07 | M[201A]) in
          advance (7)
          #1477
          #instruction: OUT  02
          advance (10)
          #1479
          #instruction: JP   1A47
          advance (10)
          #1A47
          #instruction: PUSH BC
          let:16 a179 = (-1 + a176) in
          M[a179] := 10;
          let:16 a180 = (-1 + a179) in
          M[a180] := C;
          advance (11)
          #1A48
          #instruction: LD   B,03
          advance (7)
          #1A4A
          #instruction: LD   A,H
          advance (5)
          #1A4B
          #instruction: RAR
          advance (4)
          #1A4C
          #instruction: LD   H,A
          advance (5)
          #1A4D
          #instruction: LD   A,L
          advance (5)
          #1A4E
          #instruction: RAR
          advance (4)
          #1A4F
          #instruction: LD   L,A
          advance (5)
          #1A50
          #instruction: DEC  B
          let:16 a181 = addWithCarry(!true,03,~00) in
          let:8 a182 = (03 & 0F) in
          let:8 a183 = (~00 & 0F) in
          let:16 a184 = addWithCarry(!true,a182,a183) in
          advance (5)
          #1A51
          #instruction: JP   NZ,1A4A
          if (!is_zero(a181[7:0])) {
            advance (10)
            A := updateBit((M[201A] >> 01),7,M[201B][0]);
            B := a181[7:0];
            H := updateBit((M[201B] >> 01),7,false);
            L := updateBit((M[201A] >> 01),7,M[201B][0]);
            SPH := a180[15:8];
            SPL := a180[7:0];
            FlagS := a181[7:0][7];
            FlagZ := is_zero(a181[7:0]);
            FlagA := a184[7:0][4];
            FlagP := parity(a181[7:0]);
            FlagCY := M[201A][0];
            Shifter_OFF := a177;
            jump (1A4A);
          } else {
            advance (10)
            #1A54
            #instruction: LD   A,H
            advance (5)
            #1A55
            #instruction: AND  3F
            let:8 a185 = (3F & updateBit((M[201B] >> 01),7,false)) in
            let:8 a186 = (3F | updateBit((M[201B] >> 01),7,false)) in
            advance (7)
            #1A57
            #instruction: OR   20
            let:8 a187 = (20 | a185) in
            advance (7)
            #1A59
            #instruction: LD   H,A
            advance (5)
            #1A5A
            #instruction: POP  BC
            let:16 a188 = (1 + a180) in
            let:16 a189 = (1 + a188) in
            advance (10)
            #1A5B
            #instruction: RET
            let:16 a190 = (1 + a189) in
            let:16 a191 = (1 + a190) in
            advance (10)
            A := a187;
            B := M[a188];
            C := M[a180];
            H := a187;
            L := updateBit((M[201A] >> 01),7,M[201B][0]);
            SPH := a191[15:8];
            SPL := a191[7:0];
            FlagS := a187[7];
            FlagZ := is_zero(a187);
            FlagA := false;
            FlagP := parity(a187);
            FlagCY := false;
            Shifter_OFF := a177;
            jump ((M[a190],M[a189]));
          }
        }
      }
    }

02B6:

    #instruction: LD   HL,2010
    advance (10)
    #02B9
    #instruction: LD   DE,1B10
    advance (10)
    #02BC
    #instruction: LD   B,10
    advance (7)
    #02BE
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 02C1
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2010] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,10,~00) in
    let:8 a4 = (10 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 11;
      H := 20;
      L := 11;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 11;
      H := 20;
      L := 11;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

02C1:

    #instruction: LD   B,00
    advance (7)
    #02C3
    #instruction: CALL 19DC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := C6;
    #return-to: 02C6
    advance (17)
    #19DC
    #instruction: LD   A,(2094)
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a3 = (00 & M[2094]) in
    let:8 a4 = (00 | M[2094]) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    M[2094] := a3;
    advance (13)
    #19E3
    #instruction: OUT  03
    sound_control(Ufo,a3[0]);
    sound_control(Shot,a3[1]);
    sound_control(PlayerDie,a3[2]);
    sound_control(InvaderDie,a3[3]);
    sound_control(ExtraLife,a3[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:16 a5 = (1 + a2) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := a3;
    B := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a5],M[a2]));

02C6:

    #instruction: LD   A,(206D)
    advance (13)
    #02C9
    #instruction: AND  A
    let:8 a1 = (M[206D] & M[206D]) in
    let:8 a2 = (M[206D] | M[206D]) in
    advance (4)
    #02CA
    #instruction: RET  NZ
    if (!is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #02CB
      #instruction: LD   A,(20EF)
      advance (13)
      #02CE
      #instruction: AND  A
      let:8 a5 = (M[20EF] & M[20EF]) in
      let:8 a6 = (M[20EF] | M[20EF]) in
      advance (4)
      #02CF
      #instruction: RET  Z
      if (is_zero(a5)) {
        let:16 a7 = (1 + (SPH,SPL)) in
        let:16 a8 = (1 + a7) in
        advance (11)
        A := a5;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := false;
        jump ((M[a7],M[(SPH,SPL)]));
      } else {
        advance (5)
        #02D0
        #instruction: LD   SP,2400
        advance (10)
        #02D3
        #instruction: EI
        enable_interrupts()
        advance (4)
        #02D4
        #instruction: CALL 19D7
        M[23FF] := 02;
        M[23FE] := D7;
        #return-to: 02D7
        advance (17)
        #19D7
        #instruction: XOR  A
        let:8 a9 = (a5 ^ a5) in
        advance (4)
        #19D8
        #instruction: JP   19D3
        advance (10)
        #19D3
        #instruction: LD   (20E9),A
        M[20E9] := a9;
        advance (13)
        #19D6
        #instruction: RET
        advance (10)
        A := a9;
        SPH := 24;
        SPL := 00;
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[23FF],M[23FE]));
      }
    }

02D7:

    #instruction: CALL 092E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 02DA
    advance (17)
    #092E
    #instruction: CALL 1611
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    advance (13)
    #1616
    #instruction: LD   H,A
    advance (5)
    #1617
    #instruction: RET
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump ((M[a5],M[a4]));

02DA:

    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    #02DB
    #instruction: JP   Z,166D
    if (is_zero(a1)) {
      advance (10)
      #166D
      #instruction: XOR  A
      let:8 a3 = (a1 ^ a1) in
      advance (4)
      #166E
      #instruction: CALL 1A8B
      let:16 a4 = (-1 + (SPH,SPL)) in
      M[a4] := 16;
      let:16 a5 = (-1 + a4) in
      M[a5] := 71;
      #return-to: 1671
      advance (17)
      #1A8B
      #instruction: LD   HL,2501
      advance (10)
      #1A8E
      #instruction: AND  0F
      let:8 a6 = (0F & a3) in
      let:8 a7 = (0F | a3) in
      advance (7)
      #1A90
      #instruction: JP   09C5
      advance (10)
      #09C5
      #instruction: ADD  1A
      let:16 a8 = addWithCarry(false,1A,a6) in
      let:8 a9 = (1A & 0F) in
      let:8 a10 = (a6 & 0F) in
      let:16 a11 = addWithCarry(false,a9,a10) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a12 = (-1 + a5) in
      M[a12] := 25;
      let:16 a13 = (-1 + a12) in
      M[a13] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a14 = add17((00,a8[7:0]),(00,a8[7:0])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a15 = add17(a14[15:0],a14[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a16 = add17(a15[15:0],a15[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a17 = add17(1E00,a16[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a18 = (1 + a13) in
      let:16 a19 = (1 + a18) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a20 = (-1 + a19) in
      M[a20] := 08;
      let:16 a21 = (-1 + a20) in
      M[a21] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a18],M[a13])] := M[a17[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a22 = (1 + a17[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a23 = add17(0020,(M[a18],M[a13])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a24 = (1 + a21) in
      let:16 a25 = (1 + a24) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a26 = addWithCarry(!true,M[a24],~00) in
      let:8 a27 = (M[a24] & 0F) in
      let:8 a28 = (~00 & 0F) in
      let:16 a29 = addWithCarry(!true,a27,a28) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a26[7:0])) {
        advance (10)
        A := M[a17[15:0]];
        B := a26[7:0];
        C := M[a21];
        D := a22[15:8];
        E := a22[7:0];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a30 = (1 + a25) in
        let:16 a31 = (1 + a30) in
        advance (10)
        A := M[a17[15:0]];
        B := a26[7:0];
        C := M[a21];
        D := a22[15:8];
        E := a22[7:0];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump ((M[a30],M[a25]));
      }
    } else {
      advance (10)
      #02DE
      #instruction: CALL 18E7
      let:16 a32 = (-1 + (SPH,SPL)) in
      M[a32] := 02;
      let:16 a33 = (-1 + a32) in
      M[a33] := E1;
      #return-to: 02E1
      advance (17)
      #18E7
      #instruction: LD   A,(2067)
      advance (13)
      #18EA
      #instruction: LD   HL,20E7
      advance (10)
      #18ED
      #instruction: RRCA 
      advance (4)
      #18EE
      #instruction: RET  NC
      if (!M[2067][0]) {
        let:16 a34 = (1 + a33) in
        let:16 a35 = (1 + a34) in
        advance (11)
        A := updateBit((M[2067] >> 01),7,M[2067][0]);
        H := 20;
        L := E7;
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a1[7];
        FlagZ := is_zero(a1);
        FlagA := a2[3];
        FlagP := parity(a1);
        FlagCY := M[2067][0];
        jump ((M[a34],M[a33]));
      } else {
        advance (5)
        #18EF
        #instruction: INC  HL
        advance (5)
        #18F0
        #instruction: RET
        let:16 a36 = (1 + a33) in
        let:16 a37 = (1 + a36) in
        advance (10)
        A := updateBit((M[2067] >> 01),7,M[2067][0]);
        H := 20;
        L := E8;
        SPH := a37[15:8];
        SPL := a37[7:0];
        FlagS := a1[7];
        FlagZ := is_zero(a1);
        FlagA := a2[3];
        FlagP := parity(a1);
        FlagCY := M[2067][0];
        jump ((M[a36],M[a33]));
      }
    }

02E1:

    #instruction: LD   A,(HL)
    advance (7)
    #02E2
    #instruction: AND  A
    let:8 a1 = (M[(H,L)] & M[(H,L)]) in
    let:8 a2 = (M[(H,L)] | M[(H,L)]) in
    advance (4)
    #02E3
    #instruction: JP   Z,032C
    if (is_zero(a1)) {
      advance (10)
      #032C
      #instruction: CALL 1A7F
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 03;
      let:16 a4 = (-1 + a3) in
      M[a4] := 2F;
      #return-to: 032F
      advance (17)
      #1A7F
      #instruction: CALL 092E
      let:16 a5 = (-1 + a4) in
      M[a5] := 1A;
      let:16 a6 = (-1 + a5) in
      M[a6] := 82;
      #return-to: 1A82
      advance (17)
      #092E
      #instruction: CALL 1611
      let:16 a7 = (-1 + a6) in
      M[a7] := 09;
      let:16 a8 = (-1 + a7) in
      M[a8] := 31;
      #return-to: 0931
      advance (17)
      #1611
      #instruction: LD   L,00
      advance (7)
      #1613
      #instruction: LD   A,(2067)
      advance (13)
      #1616
      #instruction: LD   H,A
      advance (5)
      #1617
      #instruction: RET
      let:16 a9 = (1 + a8) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := M[2067];
      H := M[2067];
      L := 00;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a9],M[a8]));
    } else {
      advance (10)
      #02E6
      #instruction: LD   A,(20CE)
      advance (13)
      #02E9
      #instruction: AND  A
      let:8 a11 = (M[20CE] & M[20CE]) in
      let:8 a12 = (M[20CE] | M[20CE]) in
      advance (4)
      #02EA
      #instruction: JP   Z,032C
      if (is_zero(a11)) {
        advance (10)
        #032C
        #instruction: CALL 1A7F
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 03;
        let:16 a14 = (-1 + a13) in
        M[a14] := 2F;
        #return-to: 032F
        advance (17)
        #1A7F
        #instruction: CALL 092E
        let:16 a15 = (-1 + a14) in
        M[a15] := 1A;
        let:16 a16 = (-1 + a15) in
        M[a16] := 82;
        #return-to: 1A82
        advance (17)
        #092E
        #instruction: CALL 1611
        let:16 a17 = (-1 + a16) in
        M[a17] := 09;
        let:16 a18 = (-1 + a17) in
        M[a18] := 31;
        #return-to: 0931
        advance (17)
        #1611
        #instruction: LD   L,00
        advance (7)
        #1613
        #instruction: LD   A,(2067)
        advance (13)
        #1616
        #instruction: LD   H,A
        advance (5)
        #1617
        #instruction: RET
        let:16 a19 = (1 + a18) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := M[2067];
        H := M[2067];
        L := 00;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump ((M[a19],M[a18]));
      } else {
        advance (10)
        #02ED
        #instruction: LD   A,(2067)
        advance (13)
        #02F0
        #instruction: PUSH PSW
        let:16 a21 = (-1 + (SPH,SPL)) in
        M[a21] := M[2067];
        let:16 a22 = (-1 + a21) in
        M[a22] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a11[7]),6,is_zero(a11)),4,a12[3]),2,parity(a11)),0,false);
        advance (11)
        #02F1
        #instruction: RRCA 
        advance (4)
        #02F2
        #instruction: JP   CY,0332
        if (M[2067][0]) {
          advance (10)
          #0332
          #instruction: CALL 0209
          let:16 a23 = (-1 + a22) in
          M[a23] := 03;
          let:16 a24 = (-1 + a23) in
          M[a24] := 35;
          #return-to: 0335
          advance (17)
          #0209
          #instruction: LD   A,01
          advance (7)
          #020B
          #instruction: JP   021B
          advance (10)
          #021B
          #instruction: LD   DE,2142
          advance (10)
          #021E
          #instruction: LD   (2081),A
          M[2081] := 01;
          advance (13)
          #0221
          #instruction: LD   BC,1602
          advance (10)
          #0224
          #instruction: LD   HL,2806
          advance (10)
          #0227
          #instruction: LD   A,04
          advance (7)
          #0229
          #instruction: PUSH PSW
          let:16 a25 = (-1 + a24) in
          M[a25] := 04;
          let:16 a26 = (-1 + a25) in
          M[a26] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a11[7]),6,is_zero(a11)),4,a12[3]),2,parity(a11)),0,M[2067][0]);
          advance (11)
          #022A
          #instruction: PUSH BC
          let:16 a27 = (-1 + a26) in
          M[a27] := 16;
          let:16 a28 = (-1 + a27) in
          M[a28] := 02;
          advance (11)
          #022B
          #instruction: LD   A,(2081)
          advance (13)
          #022E
          #instruction: AND  A
          let:8 a29 = (M[2081] & M[2081]) in
          let:8 a30 = (M[2081] | M[2081]) in
          advance (4)
          #022F
          #instruction: JP   NZ,0242
          if (!is_zero(a29)) {
            advance (10)
            #0242
            #instruction: CALL 147C
            let:16 a31 = (-1 + a28) in
            M[a31] := 02;
            let:16 a32 = (-1 + a31) in
            M[a32] := 45;
            #return-to: 0245
            advance (17)
            #147C
            #instruction: PUSH BC
            let:16 a33 = (-1 + a32) in
            M[a33] := 16;
            let:16 a34 = (-1 + a33) in
            M[a34] := 02;
            advance (11)
            #147D
            #instruction: PUSH HL
            let:16 a35 = (-1 + a34) in
            M[a35] := 28;
            let:16 a36 = (-1 + a35) in
            M[a36] := 06;
            advance (11)
            #147E
            #instruction: LD   A,(HL)
            advance (7)
            #147F
            #instruction: LD   (DE),A
            M[2142] := M[2806];
            advance (7)
            #1480
            #instruction: INC  DE
            advance (5)
            #1481
            #instruction: INC  HL
            advance (5)
            #1482
            #instruction: DEC  C
            let:16 a37 = addWithCarry(!true,02,~00) in
            let:8 a38 = (02 & 0F) in
            let:8 a39 = (~00 & 0F) in
            let:16 a40 = addWithCarry(!true,a38,a39) in
            advance (5)
            #1483
            #instruction: JP   NZ,147E
            if (!is_zero(a37[7:0])) {
              advance (10)
              A := M[2806];
              B := 16;
              C := a37[7:0];
              D := 21;
              E := 43;
              H := 28;
              L := 07;
              SPH := a36[15:8];
              SPL := a36[7:0];
              FlagS := a37[7:0][7];
              FlagZ := is_zero(a37[7:0]);
              FlagA := a40[7:0][4];
              FlagP := parity(a37[7:0]);
              FlagCY := false;
              jump (147E);
            } else {
              advance (10)
              #1486
              #instruction: POP  HL
              let:16 a41 = (1 + a36) in
              let:16 a42 = (1 + a41) in
              advance (10)
              #1487
              #instruction: LD   BC,0020
              advance (10)
              #148A
              #instruction: ADD  HL,BC
              let:17 a43 = add17(0020,(M[a41],M[a36])) in
              advance (10)
              #148B
              #instruction: POP  BC
              let:16 a44 = (1 + a42) in
              let:16 a45 = (1 + a44) in
              advance (10)
              #148C
              #instruction: DEC  B
              let:16 a46 = addWithCarry(!true,M[a44],~00) in
              let:8 a47 = (M[a44] & 0F) in
              let:8 a48 = (~00 & 0F) in
              let:16 a49 = addWithCarry(!true,a47,a48) in
              advance (5)
              #148D
              #instruction: JP   NZ,147C
              if (!is_zero(a46[7:0])) {
                advance (10)
                A := M[2806];
                B := a46[7:0];
                C := M[a42];
                D := 21;
                E := 43;
                H := a43[15:0][15:8];
                L := a43[15:0][7:0];
                SPH := a45[15:8];
                SPL := a45[7:0];
                FlagS := a46[7:0][7];
                FlagZ := is_zero(a46[7:0]);
                FlagA := a49[7:0][4];
                FlagP := parity(a46[7:0]);
                FlagCY := a43[16];
                jump (147C);
              } else {
                advance (10)
                #1490
                #instruction: RET
                let:16 a50 = (1 + a45) in
                let:16 a51 = (1 + a50) in
                advance (10)
                A := M[2806];
                B := a46[7:0];
                C := M[a42];
                D := 21;
                E := 43;
                H := a43[15:0][15:8];
                L := a43[15:0][7:0];
                SPH := a51[15:8];
                SPL := a51[7:0];
                FlagS := a46[7:0][7];
                FlagZ := is_zero(a46[7:0]);
                FlagA := a49[7:0][4];
                FlagP := parity(a46[7:0]);
                FlagCY := a43[16];
                jump ((M[a50],M[a45]));
              }
            }
          } else {
            advance (10)
            #0232
            #instruction: CALL 1A69
            let:16 a52 = (-1 + a28) in
            M[a52] := 02;
            let:16 a53 = (-1 + a52) in
            M[a53] := 35;
            #return-to: 0235
            advance (17)
            #1A69
            #instruction: PUSH BC
            let:16 a54 = (-1 + a53) in
            M[a54] := 16;
            let:16 a55 = (-1 + a54) in
            M[a55] := 02;
            advance (11)
            #1A6A
            #instruction: PUSH HL
            let:16 a56 = (-1 + a55) in
            M[a56] := 28;
            let:16 a57 = (-1 + a56) in
            M[a57] := 06;
            advance (11)
            #1A6B
            #instruction: LD   A,(DE)
            advance (7)
            #1A6C
            #instruction: OR   (HL)
            let:8 a58 = (M[2806] | M[2142]) in
            advance (7)
            #1A6D
            #instruction: LD   (HL),A
            M[2806] := a58;
            advance (7)
            #1A6E
            #instruction: INC  DE
            advance (5)
            #1A6F
            #instruction: INC  HL
            advance (5)
            #1A70
            #instruction: DEC  C
            let:16 a59 = addWithCarry(!true,02,~00) in
            let:8 a60 = (02 & 0F) in
            let:8 a61 = (~00 & 0F) in
            let:16 a62 = addWithCarry(!true,a60,a61) in
            advance (5)
            #1A71
            #instruction: JP   NZ,1A6B
            if (!is_zero(a59[7:0])) {
              advance (10)
              A := a58;
              B := 16;
              C := a59[7:0];
              D := 21;
              E := 43;
              H := 28;
              L := 07;
              SPH := a57[15:8];
              SPL := a57[7:0];
              FlagS := a59[7:0][7];
              FlagZ := is_zero(a59[7:0]);
              FlagA := a62[7:0][4];
              FlagP := parity(a59[7:0]);
              FlagCY := false;
              jump (1A6B);
            } else {
              advance (10)
              #1A74
              #instruction: POP  HL
              let:16 a63 = (1 + a57) in
              let:16 a64 = (1 + a63) in
              advance (10)
              #1A75
              #instruction: LD   BC,0020
              advance (10)
              #1A78
              #instruction: ADD  HL,BC
              let:17 a65 = add17(0020,(M[a63],M[a57])) in
              advance (10)
              #1A79
              #instruction: POP  BC
              let:16 a66 = (1 + a64) in
              let:16 a67 = (1 + a66) in
              advance (10)
              #1A7A
              #instruction: DEC  B
              let:16 a68 = addWithCarry(!true,M[a66],~00) in
              let:8 a69 = (M[a66] & 0F) in
              let:8 a70 = (~00 & 0F) in
              let:16 a71 = addWithCarry(!true,a69,a70) in
              advance (5)
              #1A7B
              #instruction: JP   NZ,1A69
              if (!is_zero(a68[7:0])) {
                advance (10)
                A := a58;
                B := a68[7:0];
                C := M[a64];
                D := 21;
                E := 43;
                H := a65[15:0][15:8];
                L := a65[15:0][7:0];
                SPH := a67[15:8];
                SPL := a67[7:0];
                FlagS := a68[7:0][7];
                FlagZ := is_zero(a68[7:0]);
                FlagA := a71[7:0][4];
                FlagP := parity(a68[7:0]);
                FlagCY := a65[16];
                jump (1A69);
              } else {
                advance (10)
                #1A7E
                #instruction: RET
                let:16 a72 = (1 + a67) in
                let:16 a73 = (1 + a72) in
                advance (10)
                A := a58;
                B := a68[7:0];
                C := M[a64];
                D := 21;
                E := 43;
                H := a65[15:0][15:8];
                L := a65[15:0][7:0];
                SPH := a73[15:8];
                SPL := a73[7:0];
                FlagS := a68[7:0][7];
                FlagZ := is_zero(a68[7:0]);
                FlagA := a71[7:0][4];
                FlagP := parity(a68[7:0]);
                FlagCY := a65[16];
                jump ((M[a72],M[a67]));
              }
            }
          }
        } else {
          advance (10)
          #02F5
          #instruction: CALL 020E
          let:16 a74 = (-1 + a22) in
          M[a74] := 02;
          let:16 a75 = (-1 + a74) in
          M[a75] := F8;
          #return-to: 02F8
          advance (17)
          #020E
          #instruction: LD   A,01
          advance (7)
          #0210
          #instruction: JP   0214
          advance (10)
          #0214
          #instruction: LD   DE,2242
          advance (10)
          #0217
          #instruction: JP   021E
          advance (10)
          #021E
          #instruction: LD   (2081),A
          M[2081] := 01;
          advance (13)
          #0221
          #instruction: LD   BC,1602
          advance (10)
          #0224
          #instruction: LD   HL,2806
          advance (10)
          #0227
          #instruction: LD   A,04
          advance (7)
          #0229
          #instruction: PUSH PSW
          let:16 a76 = (-1 + a75) in
          M[a76] := 04;
          let:16 a77 = (-1 + a76) in
          M[a77] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a11[7]),6,is_zero(a11)),4,a12[3]),2,parity(a11)),0,M[2067][0]);
          advance (11)
          #022A
          #instruction: PUSH BC
          let:16 a78 = (-1 + a77) in
          M[a78] := 16;
          let:16 a79 = (-1 + a78) in
          M[a79] := 02;
          advance (11)
          #022B
          #instruction: LD   A,(2081)
          advance (13)
          #022E
          #instruction: AND  A
          let:8 a80 = (M[2081] & M[2081]) in
          let:8 a81 = (M[2081] | M[2081]) in
          advance (4)
          #022F
          #instruction: JP   NZ,0242
          if (!is_zero(a80)) {
            advance (10)
            #0242
            #instruction: CALL 147C
            let:16 a82 = (-1 + a79) in
            M[a82] := 02;
            let:16 a83 = (-1 + a82) in
            M[a83] := 45;
            #return-to: 0245
            advance (17)
            #147C
            #instruction: PUSH BC
            let:16 a84 = (-1 + a83) in
            M[a84] := 16;
            let:16 a85 = (-1 + a84) in
            M[a85] := 02;
            advance (11)
            #147D
            #instruction: PUSH HL
            let:16 a86 = (-1 + a85) in
            M[a86] := 28;
            let:16 a87 = (-1 + a86) in
            M[a87] := 06;
            advance (11)
            #147E
            #instruction: LD   A,(HL)
            advance (7)
            #147F
            #instruction: LD   (DE),A
            M[2242] := M[2806];
            advance (7)
            #1480
            #instruction: INC  DE
            advance (5)
            #1481
            #instruction: INC  HL
            advance (5)
            #1482
            #instruction: DEC  C
            let:16 a88 = addWithCarry(!true,02,~00) in
            let:8 a89 = (02 & 0F) in
            let:8 a90 = (~00 & 0F) in
            let:16 a91 = addWithCarry(!true,a89,a90) in
            advance (5)
            #1483
            #instruction: JP   NZ,147E
            if (!is_zero(a88[7:0])) {
              advance (10)
              A := M[2806];
              B := 16;
              C := a88[7:0];
              D := 22;
              E := 43;
              H := 28;
              L := 07;
              SPH := a87[15:8];
              SPL := a87[7:0];
              FlagS := a88[7:0][7];
              FlagZ := is_zero(a88[7:0]);
              FlagA := a91[7:0][4];
              FlagP := parity(a88[7:0]);
              FlagCY := false;
              jump (147E);
            } else {
              advance (10)
              #1486
              #instruction: POP  HL
              let:16 a92 = (1 + a87) in
              let:16 a93 = (1 + a92) in
              advance (10)
              #1487
              #instruction: LD   BC,0020
              advance (10)
              #148A
              #instruction: ADD  HL,BC
              let:17 a94 = add17(0020,(M[a92],M[a87])) in
              advance (10)
              #148B
              #instruction: POP  BC
              let:16 a95 = (1 + a93) in
              let:16 a96 = (1 + a95) in
              advance (10)
              #148C
              #instruction: DEC  B
              let:16 a97 = addWithCarry(!true,M[a95],~00) in
              let:8 a98 = (M[a95] & 0F) in
              let:8 a99 = (~00 & 0F) in
              let:16 a100 = addWithCarry(!true,a98,a99) in
              advance (5)
              #148D
              #instruction: JP   NZ,147C
              if (!is_zero(a97[7:0])) {
                advance (10)
                A := M[2806];
                B := a97[7:0];
                C := M[a93];
                D := 22;
                E := 43;
                H := a94[15:0][15:8];
                L := a94[15:0][7:0];
                SPH := a96[15:8];
                SPL := a96[7:0];
                FlagS := a97[7:0][7];
                FlagZ := is_zero(a97[7:0]);
                FlagA := a100[7:0][4];
                FlagP := parity(a97[7:0]);
                FlagCY := a94[16];
                jump (147C);
              } else {
                advance (10)
                #1490
                #instruction: RET
                let:16 a101 = (1 + a96) in
                let:16 a102 = (1 + a101) in
                advance (10)
                A := M[2806];
                B := a97[7:0];
                C := M[a93];
                D := 22;
                E := 43;
                H := a94[15:0][15:8];
                L := a94[15:0][7:0];
                SPH := a102[15:8];
                SPL := a102[7:0];
                FlagS := a97[7:0][7];
                FlagZ := is_zero(a97[7:0]);
                FlagA := a100[7:0][4];
                FlagP := parity(a97[7:0]);
                FlagCY := a94[16];
                jump ((M[a101],M[a96]));
              }
            }
          } else {
            advance (10)
            #0232
            #instruction: CALL 1A69
            let:16 a103 = (-1 + a79) in
            M[a103] := 02;
            let:16 a104 = (-1 + a103) in
            M[a104] := 35;
            #return-to: 0235
            advance (17)
            #1A69
            #instruction: PUSH BC
            let:16 a105 = (-1 + a104) in
            M[a105] := 16;
            let:16 a106 = (-1 + a105) in
            M[a106] := 02;
            advance (11)
            #1A6A
            #instruction: PUSH HL
            let:16 a107 = (-1 + a106) in
            M[a107] := 28;
            let:16 a108 = (-1 + a107) in
            M[a108] := 06;
            advance (11)
            #1A6B
            #instruction: LD   A,(DE)
            advance (7)
            #1A6C
            #instruction: OR   (HL)
            let:8 a109 = (M[2806] | M[2242]) in
            advance (7)
            #1A6D
            #instruction: LD   (HL),A
            M[2806] := a109;
            advance (7)
            #1A6E
            #instruction: INC  DE
            advance (5)
            #1A6F
            #instruction: INC  HL
            advance (5)
            #1A70
            #instruction: DEC  C
            let:16 a110 = addWithCarry(!true,02,~00) in
            let:8 a111 = (02 & 0F) in
            let:8 a112 = (~00 & 0F) in
            let:16 a113 = addWithCarry(!true,a111,a112) in
            advance (5)
            #1A71
            #instruction: JP   NZ,1A6B
            if (!is_zero(a110[7:0])) {
              advance (10)
              A := a109;
              B := 16;
              C := a110[7:0];
              D := 22;
              E := 43;
              H := 28;
              L := 07;
              SPH := a108[15:8];
              SPL := a108[7:0];
              FlagS := a110[7:0][7];
              FlagZ := is_zero(a110[7:0]);
              FlagA := a113[7:0][4];
              FlagP := parity(a110[7:0]);
              FlagCY := false;
              jump (1A6B);
            } else {
              advance (10)
              #1A74
              #instruction: POP  HL
              let:16 a114 = (1 + a108) in
              let:16 a115 = (1 + a114) in
              advance (10)
              #1A75
              #instruction: LD   BC,0020
              advance (10)
              #1A78
              #instruction: ADD  HL,BC
              let:17 a116 = add17(0020,(M[a114],M[a108])) in
              advance (10)
              #1A79
              #instruction: POP  BC
              let:16 a117 = (1 + a115) in
              let:16 a118 = (1 + a117) in
              advance (10)
              #1A7A
              #instruction: DEC  B
              let:16 a119 = addWithCarry(!true,M[a117],~00) in
              let:8 a120 = (M[a117] & 0F) in
              let:8 a121 = (~00 & 0F) in
              let:16 a122 = addWithCarry(!true,a120,a121) in
              advance (5)
              #1A7B
              #instruction: JP   NZ,1A69
              if (!is_zero(a119[7:0])) {
                advance (10)
                A := a109;
                B := a119[7:0];
                C := M[a115];
                D := 22;
                E := 43;
                H := a116[15:0][15:8];
                L := a116[15:0][7:0];
                SPH := a118[15:8];
                SPL := a118[7:0];
                FlagS := a119[7:0][7];
                FlagZ := is_zero(a119[7:0]);
                FlagA := a122[7:0][4];
                FlagP := parity(a119[7:0]);
                FlagCY := a116[16];
                jump (1A69);
              } else {
                advance (10)
                #1A7E
                #instruction: RET
                let:16 a123 = (1 + a118) in
                let:16 a124 = (1 + a123) in
                advance (10)
                A := a109;
                B := a119[7:0];
                C := M[a115];
                D := 22;
                E := 43;
                H := a116[15:0][15:8];
                L := a116[15:0][7:0];
                SPH := a124[15:8];
                SPL := a124[7:0];
                FlagS := a119[7:0][7];
                FlagZ := is_zero(a119[7:0]);
                FlagA := a122[7:0][4];
                FlagP := parity(a119[7:0]);
                FlagCY := a116[16];
                jump ((M[a123],M[a118]));
              }
            }
          }
        }
      }
    }

02F8:

    #instruction: CALL 0878
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 02;
    let:16 a2 = (-1 + a1) in
    M[a2] := FB;
    #return-to: 02FB
    advance (17)
    #0878
    #instruction: LD   A,(2008)
    advance (13)
    #087B
    #instruction: LD   B,A
    advance (5)
    #087C
    #instruction: LD   HL,(2009)
    advance (16)
    #087F
    #instruction: EX   DE,HL
    advance (4)
    #0880
    #instruction: JP   0886
    advance (10)
    #0886
    #instruction: LD   A,(2067)
    advance (13)
    #0889
    #instruction: LD   H,A
    advance (5)
    #088A
    #instruction: LD   L,FC
    advance (7)
    #088C
    #instruction: RET
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    A := M[2067];
    B := M[2008];
    D := M[200A];
    E := M[2009];
    H := M[2067];
    L := FC;
    SPH := a4[15:8];
    SPL := a4[7:0];
    jump ((M[a3],M[a2]));

02FB:

    #instruction: LD   (HL),E
    M[(H,L)] := E;
    advance (7)
    #02FC
    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    #02FD
    #instruction: LD   (HL),D
    M[a1] := D;
    advance (7)
    #02FE
    #instruction: DEC  HL
    let:16 a2 = (-1 + a1) in
    advance (5)
    #02FF
    #instruction: DEC  HL
    let:16 a3 = (-1 + a2) in
    advance (5)
    #0300
    #instruction: LD   (HL),B
    M[a3] := B;
    advance (7)
    #0301
    #instruction: NOP
    advance (4)
    #0302
    #instruction: CALL 01E4
    let:16 a4 = (-1 + (SPH,SPL)) in
    M[a4] := 03;
    let:16 a5 = (-1 + a4) in
    M[a5] := 05;
    #return-to: 0305
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a6 = addWithCarry(!true,C0,~00) in
    let:8 a7 = (C0 & 0F) in
    let:8 a8 = (~00 & 0F) in
    let:16 a9 = addWithCarry(!true,a7,a8) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a6[7:0])) {
      advance (10)
      A := 01;
      B := a6[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a5[15:8];
      SPL := a5[7:0];
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a10 = (1 + a5) in
      let:16 a11 = (1 + a10) in
      advance (10)
      A := 01;
      B := a6[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      jump ((M[a10],M[a5]));
    }

0305:

    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0306
    #instruction: RRCA 
    advance (4)
    #0307
    #instruction: LD   A,21
    advance (7)
    #0309
    #instruction: LD   B,00
    advance (7)
    #030B
    #instruction: JP   NC,0312
    if (!M[a1][0]) {
      advance (10)
      #0312
      #instruction: LD   (2067),A
      M[2067] := 21;
      advance (13)
      #0315
      #instruction: CALL 0AB6
      let:16 a3 = (-1 + a2) in
      M[a3] := 03;
      let:16 a4 = (-1 + a3) in
      M[a4] := 18;
      #return-to: 0318
      advance (17)
      #0AB6
      #instruction: LD   A,80
      advance (7)
      #0AB8
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 80;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a5 = (M[20C0] & M[20C0]) in
      let:8 a6 = (M[20C0] | M[20C0]) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a5)) {
        advance (10)
        A := a5;
        B := 00;
        SPH := a4[15:8];
        SPL := a4[7:0];
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:16 a7 = (1 + a4) in
        let:16 a8 = (1 + a7) in
        advance (10)
        A := a5;
        B := 00;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := false;
        jump ((M[a7],M[a4]));
      }
    } else {
      advance (10)
      #030E
      #instruction: LD   B,20
      advance (7)
      #0310
      #instruction: LD   A,22
      advance (7)
      #0312
      #instruction: LD   (2067),A
      M[2067] := 22;
      advance (13)
      #0315
      #instruction: CALL 0AB6
      let:16 a9 = (-1 + a2) in
      M[a9] := 03;
      let:16 a10 = (-1 + a9) in
      M[a10] := 18;
      #return-to: 0318
      advance (17)
      #0AB6
      #instruction: LD   A,80
      advance (7)
      #0AB8
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 80;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a11 = (M[20C0] & M[20C0]) in
      let:8 a12 = (M[20C0] | M[20C0]) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a11)) {
        advance (10)
        A := a11;
        B := 20;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:16 a13 = (1 + a10) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := a11;
        B := 20;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump ((M[a13],M[a10]));
      }
    }

0318:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #0319
    #instruction: LD   (2011),A
    M[2011] := a1;
    advance (13)
    #031C
    #instruction: LD   A,B
    advance (5)
    #031D
    #instruction: OUT  05
    sound_control(FleetMovement1,B[0]);
    sound_control(FleetMovement2,B[1]);
    sound_control(FleetMovement3,B[2]);
    sound_control(FleetMovement4,B[3]);
    sound_control(UfoHit,B[4]);
    advance (10)
    #031F
    #instruction: INC  A
    let:16 a2 = addWithCarry(true,B,00) in
    let:8 a3 = (B & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    #0320
    #instruction: LD   (2098),A
    M[2098] := a2[7:0];
    advance (13)
    #0323
    #instruction: CALL 09D6
    let:16 a6 = (-1 + (SPH,SPL)) in
    M[a6] := 03;
    let:16 a7 = (-1 + a6) in
    M[a7] := 26;
    #return-to: 0326
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a8 = (1F & 03) in
    let:8 a9 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a10 = addWithCarry(!false,a8,~1C) in
    let:8 a11 = (a8 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a18 = (1 + a7) in
        let:16 a19 = (1 + a18) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a19[15:8];
        SPL := a19[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((M[a18],M[a7]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a20 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a21 = addWithCarry(!false,a20[15:0][15:8],~40) in
      let:8 a22 = (a20[15:0][15:8] & 0F) in
      let:8 a23 = (~40 & 0F) in
      let:16 a24 = addWithCarry(!false,a22,a23) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a21[15:8][0]) {
        advance (10)
        A := a20[15:0][15:8];
        D := 00;
        E := 06;
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a21[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a25 = (1 + a7) in
        let:16 a26 = (1 + a25) in
        advance (10)
        A := a20[15:0][15:8];
        D := 00;
        E := 06;
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a26[15:8];
        SPL := a26[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a21[15:8][0];
        jump ((M[a25],M[a7]));
      }
    }

0326:

    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 29;
    #return-to: 0329
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    let:16 a4 = (-1 + a3) in
    M[a4] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:16 a5 = (-1 + a4) in
    M[a5] := 09;
    let:16 a6 = (-1 + a5) in
    M[a6] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    advance (13)
    #1616
    #instruction: LD   H,A
    advance (5)
    #1617
    #instruction: RET
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := 00;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((M[a7],M[a6]));

0329:

    #instruction: JP   07F9
    advance (10)
    jump (07F9);

032F:

    #instruction: JP   0817
    advance (10)
    jump (0817);

0335:

    #instruction: JP   02F8
    advance (10)
    jump (02F8);

0366:

    #instruction: RLCA 
    advance (4)
    #0367
    #instruction: RLCA 
    advance (4)
    #0368
    #instruction: JP   CY,0381
    if (updateBit((A << 01),0,A[7])[7]) {
      advance (10)
      #0381
      #instruction: LD   A,B
      advance (5)
      #0382
      #instruction: CP   D9
      let:16 a1 = addWithCarry(!false,B,~D9) in
      let:8 a2 = (B & 0F) in
      let:8 a3 = (~D9 & 0F) in
      let:16 a4 = addWithCarry(!false,a2,a3) in
      advance (7)
      #0384
      #instruction: JP   Z,036F
      if (is_zero(a1[7:0])) {
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:16 a5 = (-1 + (SPH,SPL)) in
        M[a5] := 03;
        let:16 a6 = (-1 + a5) in
        M[a6] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a7 = (1 + a6) in
        let:16 a8 = (1 + a7) in
        advance (10)
        A := M[201A];
        B := M[201C];
        C := M[201B];
        D := M[2019];
        E := M[2018];
        H := M[201B];
        L := M[201A];
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a1[7:0][7];
        FlagZ := is_zero(a1[7:0]);
        FlagA := a4[7:0][4];
        FlagP := parity(a1[7:0]);
        FlagCY := !a1[15:8][0];
        jump ((M[a7],M[a6]));
      } else {
        advance (10)
        #0387
        #instruction: INC  A
        let:16 a9 = addWithCarry(true,B,00) in
        let:8 a10 = (B & 0F) in
        let:8 a11 = (00 & 0F) in
        let:16 a12 = addWithCarry(true,a10,a11) in
        advance (5)
        #0388
        #instruction: LD   (201B),A
        M[201B] := a9[7:0];
        advance (13)
        #038B
        #instruction: JP   036F
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 03;
        let:16 a14 = (-1 + a13) in
        M[a14] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a15 = (1 + a14) in
        let:16 a16 = (1 + a15) in
        advance (10)
        A := M[201A];
        B := M[201C];
        C := M[201B];
        D := M[2019];
        E := M[2018];
        H := M[201B];
        L := M[201A];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a1[15:8][0];
        jump ((M[a15],M[a14]));
      }
    } else {
      advance (10)
      #036B
      #instruction: RLCA 
      advance (4)
      #036C
      #instruction: JP   CY,038E
      if (updateBit((updateBit((A << 01),0,A[7]) << 01),0,updateBit((A << 01),0,A[7])[7])[7]) {
        advance (10)
        #038E
        #instruction: LD   A,B
        advance (5)
        #038F
        #instruction: CP   30
        let:16 a17 = addWithCarry(!false,B,~30) in
        let:8 a18 = (B & 0F) in
        let:8 a19 = (~30 & 0F) in
        let:16 a20 = addWithCarry(!false,a18,a19) in
        advance (7)
        #0391
        #instruction: JP   Z,036F
        if (is_zero(a17[7:0])) {
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:16 a21 = (-1 + (SPH,SPL)) in
          M[a21] := 03;
          let:16 a22 = (-1 + a21) in
          M[a22] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a23 = (1 + a22) in
          let:16 a24 = (1 + a23) in
          advance (10)
          A := M[201A];
          B := M[201C];
          C := M[201B];
          D := M[2019];
          E := M[2018];
          H := M[201B];
          L := M[201A];
          SPH := a24[15:8];
          SPL := a24[7:0];
          FlagS := a17[7:0][7];
          FlagZ := is_zero(a17[7:0]);
          FlagA := a20[7:0][4];
          FlagP := parity(a17[7:0]);
          FlagCY := !a17[15:8][0];
          jump ((M[a23],M[a22]));
        } else {
          advance (10)
          #0394
          #instruction: DEC  A
          let:16 a25 = addWithCarry(!true,B,~00) in
          let:8 a26 = (B & 0F) in
          let:8 a27 = (~00 & 0F) in
          let:16 a28 = addWithCarry(!true,a26,a27) in
          advance (5)
          #0395
          #instruction: LD   (201B),A
          M[201B] := a25[7:0];
          advance (13)
          #0398
          #instruction: JP   036F
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:16 a29 = (-1 + (SPH,SPL)) in
          M[a29] := 03;
          let:16 a30 = (-1 + a29) in
          M[a30] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a31 = (1 + a30) in
          let:16 a32 = (1 + a31) in
          advance (10)
          A := M[201A];
          B := M[201C];
          C := M[201B];
          D := M[2019];
          E := M[2018];
          H := M[201B];
          L := M[201A];
          SPH := a32[15:8];
          SPL := a32[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := !a17[15:8][0];
          jump ((M[a31],M[a30]));
        }
      } else {
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:16 a33 = (-1 + (SPH,SPL)) in
        M[a33] := 03;
        let:16 a34 = (-1 + a33) in
        M[a34] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a35 = (1 + a34) in
        let:16 a36 = (1 + a35) in
        advance (10)
        A := M[201A];
        B := M[201C];
        C := M[201B];
        D := M[2019];
        E := M[2018];
        H := M[201B];
        L := M[201A];
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagCY := updateBit((updateBit((A << 01),0,A[7]) << 01),0,updateBit((A << 01),0,A[7])[7])[7];
        jump ((M[a35],M[a34]));
      }
    }

0375:

    #instruction: CALL 1A47
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 78;
    #return-to: 0378
    advance (17)
    #1A47
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a5 = addWithCarry(!true,03,~00) in
    let:8 a6 = (03 & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a5[7:0];
      H := updateBit((H >> 01),7,FlagCY);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := L[0];
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a9 = (3F & updateBit((H >> 01),7,FlagCY)) in
      let:8 a10 = (3F | updateBit((H >> 01),7,FlagCY)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a11 = (20 | a9) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a12 = (1 + a4) in
      let:16 a13 = (1 + a12) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a14 = (1 + a13) in
      let:16 a15 = (1 + a14) in
      advance (10)
      A := a11;
      B := M[a12];
      C := M[a4];
      H := a11;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a11[7];
      FlagZ := is_zero(a11);
      FlagA := false;
      FlagP := parity(a11);
      FlagCY := false;
      jump ((M[a14],M[a13]));
    }

0378:

    #instruction: CALL 1439
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7B;
    #return-to: 037B
    advance (17)
    #1439
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(H,L)] := M[(D,E)];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a5 = (1 + (D,E)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a6 = add17(0020,(H,L)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a7 = (1 + a4) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,M[a7],~00) in
    let:8 a10 = (M[a7] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := M[(D,E)];
      B := a9[7:0];
      C := M[a4];
      D := a5[15:8];
      E := a5[7:0];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a13 = (1 + a8) in
      let:16 a14 = (1 + a13) in
      advance (10)
      A := M[(D,E)];
      B := a9[7:0];
      C := M[a4];
      D := a5[15:8];
      E := a5[7:0];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump ((M[a13],M[a8]));
    }

037B:

    #instruction: LD   A,00
    advance (7)
    #037D
    #instruction: LD   (2012),A
    M[2012] := 00;
    advance (13)
    #0380
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := 00;
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

03BB:

    #instruction: LD   DE,202A
    advance (10)
    #03BE
    #instruction: CALL 1A06
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 03C1
    advance (17)
    #1A06
    #instruction: LD   HL,2072
    advance (10)
    #1A09
    #instruction: LD   B,(HL)
    advance (7)
    #1A0A
    #instruction: LD   A,(DE)
    advance (7)
    #1A0B
    #instruction: AND  80
    let:8 a3 = (80 & M[202A]) in
    let:8 a4 = (80 | M[202A]) in
    advance (7)
    #1A0D
    #instruction: XOR  B
    let:8 a5 = (M[2072] ^ a3) in
    advance (4)
    #1A0E
    #instruction: RET  NZ
    if (!is_zero(a5)) {
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (11)
      A := a5;
      B := M[2072];
      D := 20;
      E := 2A;
      H := 20;
      L := 72;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    } else {
      advance (5)
      #1A0F
      #instruction: SCF
      advance (4)
      #1A10
      #instruction: RET
      let:16 a8 = (1 + a2) in
      let:16 a9 = (1 + a8) in
      advance (10)
      A := a5;
      B := M[2072];
      D := 20;
      E := 2A;
      H := 20;
      L := 72;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := true;
      jump ((M[a8],M[a2]));
    }

03C1:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #03C2
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a3 = (1 + a2) in
      let:16 a4 = (1 + a3) in
      advance (11)
      H := M[a1];
      L := M[(SPH,SPL)];
      SPH := a4[15:8];
      SPL := a4[7:0];
      jump ((M[a3],M[a2]));
    } else {
      advance (5)
      #03C3
      #instruction: INC  HL
      let:16 a5 = (1 + (M[a1],M[(SPH,SPL)])) in
      advance (5)
      #03C4
      #instruction: LD   A,(HL)
      advance (7)
      #03C5
      #instruction: AND  A
      let:8 a6 = (M[a5] & M[a5]) in
      let:8 a7 = (M[a5] | M[a5]) in
      advance (4)
      #03C6
      #instruction: RET  Z
      if (is_zero(a6)) {
        let:16 a8 = (1 + a2) in
        let:16 a9 = (1 + a8) in
        advance (11)
        A := a6;
        H := a5[15:8];
        L := a5[7:0];
        SPH := a9[15:8];
        SPL := a9[7:0];
        FlagS := a6[7];
        FlagZ := is_zero(a6);
        FlagA := a7[3];
        FlagP := parity(a6);
        FlagCY := false;
        jump ((M[a8],M[a2]));
      } else {
        advance (5)
        #03C7
        #instruction: CP   01
        let:16 a10 = addWithCarry(!false,a6,~01) in
        let:8 a11 = (a6 & 0F) in
        let:8 a12 = (~01 & 0F) in
        let:16 a13 = addWithCarry(!false,a11,a12) in
        advance (7)
        #03C9
        #instruction: JP   Z,03FA
        if (is_zero(a10[7:0])) {
          advance (10)
          #03FA
          #instruction: INC  A
          let:16 a14 = addWithCarry(true,a6,00) in
          let:8 a15 = (a6 & 0F) in
          let:8 a16 = (00 & 0F) in
          let:16 a17 = addWithCarry(true,a15,a16) in
          advance (5)
          #03FB
          #instruction: LD   (HL),A
          M[a5] := a14[7:0];
          advance (7)
          #03FC
          #instruction: LD   A,(201B)
          advance (13)
          #03FF
          #instruction: ADD  08
          let:16 a18 = addWithCarry(false,08,M[201B]) in
          let:8 a19 = (08 & 0F) in
          let:8 a20 = (M[201B] & 0F) in
          let:16 a21 = addWithCarry(false,a19,a20) in
          advance (7)
          #0401
          #instruction: LD   (202A),A
          M[202A] := a18[7:0];
          advance (13)
          #0404
          #instruction: CALL 0430
          let:16 a22 = (-1 + a2) in
          M[a22] := 04;
          let:16 a23 = (-1 + a22) in
          M[a23] := 07;
          #return-to: 0407
          advance (17)
          #0430
          #instruction: LD   HL,2027
          advance (10)
          #0433
          #instruction: JP   1A3B
          advance (10)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a24 = (1 + a23) in
          let:16 a25 = (1 + a24) in
          advance (10)
          A := M[2029];
          B := M[202B];
          C := M[202A];
          D := M[2028];
          E := M[2027];
          H := M[202A];
          L := M[2029];
          SPH := a25[15:8];
          SPL := a25[7:0];
          FlagS := a18[7:0][7];
          FlagZ := is_zero(a18[7:0]);
          FlagA := a21[7:0][4];
          FlagP := parity(a18[7:0]);
          FlagCY := a18[15:8][0];
          jump ((M[a24],M[a23]));
        } else {
          advance (10)
          #03CC
          #instruction: CP   02
          let:16 a26 = addWithCarry(!false,a6,~02) in
          let:8 a27 = (a6 & 0F) in
          let:8 a28 = (~02 & 0F) in
          let:16 a29 = addWithCarry(!false,a27,a28) in
          advance (7)
          #03CE
          #instruction: JP   Z,040A
          if (is_zero(a26[7:0])) {
            advance (10)
            #040A
            #instruction: CALL 0430
            let:16 a30 = (-1 + a2) in
            M[a30] := 04;
            let:16 a31 = (-1 + a30) in
            M[a31] := 0D;
            #return-to: 040D
            advance (17)
            #0430
            #instruction: LD   HL,2027
            advance (10)
            #0433
            #instruction: JP   1A3B
            advance (10)
            #1A3B
            #instruction: LD   E,(HL)
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            advance (7)
            #1A44
            #instruction: LD   H,C
            advance (5)
            #1A45
            #instruction: LD   L,A
            advance (5)
            #1A46
            #instruction: RET
            let:16 a32 = (1 + a31) in
            let:16 a33 = (1 + a32) in
            advance (10)
            A := M[2029];
            B := M[202B];
            C := M[202A];
            D := M[2028];
            E := M[2027];
            H := M[202A];
            L := M[2029];
            SPH := a33[15:8];
            SPL := a33[7:0];
            FlagS := a26[7:0][7];
            FlagZ := is_zero(a26[7:0]);
            FlagA := a29[7:0][4];
            FlagP := parity(a26[7:0]);
            FlagCY := !a26[15:8][0];
            jump ((M[a32],M[a31]));
          } else {
            advance (10)
            #03D1
            #instruction: INC  HL
            let:16 a34 = (1 + a5) in
            advance (5)
            #03D2
            #instruction: CP   03
            let:16 a35 = addWithCarry(!false,a6,~03) in
            let:8 a36 = (a6 & 0F) in
            let:8 a37 = (~03 & 0F) in
            let:16 a38 = addWithCarry(!false,a36,a37) in
            advance (7)
            #03D4
            #instruction: JP   NZ,042A
            if (!is_zero(a35[7:0])) {
              advance (10)
              #042A
              #instruction: CP   05
              let:16 a39 = addWithCarry(!false,a6,~05) in
              let:8 a40 = (a6 & 0F) in
              let:8 a41 = (~05 & 0F) in
              let:16 a42 = addWithCarry(!false,a40,a41) in
              advance (7)
              #042C
              #instruction: RET  Z
              if (is_zero(a39[7:0])) {
                let:16 a43 = (1 + a2) in
                let:16 a44 = (1 + a43) in
                advance (11)
                A := a6;
                H := a34[15:8];
                L := a34[7:0];
                SPH := a44[15:8];
                SPL := a44[7:0];
                FlagS := a39[7:0][7];
                FlagZ := is_zero(a39[7:0]);
                FlagA := a42[7:0][4];
                FlagP := parity(a39[7:0]);
                FlagCY := !a39[15:8][0];
                jump ((M[a43],M[a2]));
              } else {
                advance (5)
                #042D
                #instruction: JP   0436
                advance (10)
                #0436
                #instruction: CALL 0430
                let:16 a45 = (-1 + a2) in
                M[a45] := 04;
                let:16 a46 = (-1 + a45) in
                M[a46] := 39;
                #return-to: 0439
                advance (17)
                #0430
                #instruction: LD   HL,2027
                advance (10)
                #0433
                #instruction: JP   1A3B
                advance (10)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a47 = (1 + a46) in
                let:16 a48 = (1 + a47) in
                advance (10)
                A := M[2029];
                B := M[202B];
                C := M[202A];
                D := M[2028];
                E := M[2027];
                H := M[202A];
                L := M[2029];
                SPH := a48[15:8];
                SPL := a48[7:0];
                FlagS := a39[7:0][7];
                FlagZ := is_zero(a39[7:0]);
                FlagA := a42[7:0][4];
                FlagP := parity(a39[7:0]);
                FlagCY := !a39[15:8][0];
                jump ((M[a47],M[a46]));
              }
            } else {
              advance (10)
              #03D7
              #instruction: DEC  (HL)
              let:16 a49 = addWithCarry(!true,M[a34],~00) in
              let:8 a50 = (M[a34] & 0F) in
              let:8 a51 = (~00 & 0F) in
              let:16 a52 = addWithCarry(!true,a50,a51) in
              M[a34] := a49[7:0];
              advance (10)
              #03D8
              #instruction: JP   Z,0436
              if (is_zero(a49[7:0])) {
                advance (10)
                #0436
                #instruction: CALL 0430
                let:16 a53 = (-1 + a2) in
                M[a53] := 04;
                let:16 a54 = (-1 + a53) in
                M[a54] := 39;
                #return-to: 0439
                advance (17)
                #0430
                #instruction: LD   HL,2027
                advance (10)
                #0433
                #instruction: JP   1A3B
                advance (10)
                #1A3B
                #instruction: LD   E,(HL)
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                advance (7)
                #1A44
                #instruction: LD   H,C
                advance (5)
                #1A45
                #instruction: LD   L,A
                advance (5)
                #1A46
                #instruction: RET
                let:16 a55 = (1 + a54) in
                let:16 a56 = (1 + a55) in
                advance (10)
                A := M[2029];
                B := M[202B];
                C := M[202A];
                D := M[2028];
                E := M[2027];
                H := M[202A];
                L := M[2029];
                SPH := a56[15:8];
                SPL := a56[7:0];
                FlagS := a49[7:0][7];
                FlagZ := is_zero(a49[7:0]);
                FlagA := a52[7:0][4];
                FlagP := parity(a49[7:0]);
                FlagCY := !a35[15:8][0];
                jump ((M[a55],M[a54]));
              } else {
                advance (10)
                #03DB
                #instruction: LD   A,(HL)
                advance (7)
                #03DC
                #instruction: CP   0F
                let:16 a57 = addWithCarry(!false,M[a34],~0F) in
                let:8 a58 = (M[a34] & 0F) in
                let:8 a59 = (~0F & 0F) in
                let:16 a60 = addWithCarry(!false,a58,a59) in
                advance (7)
                #03DE
                #instruction: RET  NZ
                if (!is_zero(a57[7:0])) {
                  let:16 a61 = (1 + a2) in
                  let:16 a62 = (1 + a61) in
                  advance (11)
                  A := M[a34];
                  H := a34[15:8];
                  L := a34[7:0];
                  SPH := a62[15:8];
                  SPL := a62[7:0];
                  FlagS := a57[7:0][7];
                  FlagZ := is_zero(a57[7:0]);
                  FlagA := a60[7:0][4];
                  FlagP := parity(a57[7:0]);
                  FlagCY := !a57[15:8][0];
                  jump ((M[a61],M[a2]));
                } else {
                  advance (5)
                  #03DF
                  #instruction: PUSH HL
                  let:16 a63 = (-1 + a2) in
                  M[a63] := a34[15:8];
                  let:16 a64 = (-1 + a63) in
                  M[a64] := a34[7:0];
                  advance (11)
                  #03E0
                  #instruction: CALL 0430
                  let:16 a65 = (-1 + a64) in
                  M[a65] := 03;
                  let:16 a66 = (-1 + a65) in
                  M[a66] := E3;
                  #return-to: 03E3
                  advance (17)
                  #0430
                  #instruction: LD   HL,2027
                  advance (10)
                  #0433
                  #instruction: JP   1A3B
                  advance (10)
                  #1A3B
                  #instruction: LD   E,(HL)
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:16 a67 = (1 + a66) in
                  let:16 a68 = (1 + a67) in
                  advance (10)
                  A := M[2029];
                  B := M[202B];
                  C := M[202A];
                  D := M[2028];
                  E := M[2027];
                  H := M[202A];
                  L := M[2029];
                  SPH := a68[15:8];
                  SPL := a68[7:0];
                  FlagS := a57[7:0][7];
                  FlagZ := is_zero(a57[7:0]);
                  FlagA := a60[7:0][4];
                  FlagP := parity(a57[7:0]);
                  FlagCY := !a57[15:8][0];
                  jump ((M[a67],M[a66]));
                }
              }
            }
          }
        }
      }
    }

03E3:

    #instruction: CALL 1452
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 03;
    let:16 a2 = (-1 + a1) in
    M[a2] := E6;
    #return-to: 03E6
    advance (17)
    #1452
    #instruction: CALL 1474
    let:16 a3 = (-1 + a2) in
    M[a3] := 14;
    let:16 a4 = (-1 + a3) in
    M[a4] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a5 = (07 & L) in
    let:8 a6 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a7 = (-1 + a4) in
    M[a7] := B;
    let:16 a8 = (-1 + a7) in
    M[a8] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,03,~00) in
    let:8 a10 = (03 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a9[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a5;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a13 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a14 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a15 = (20 | a13) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a16 = (1 + a8) in
      let:16 a17 = (1 + a16) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a18 = (1 + a17) in
      let:16 a19 = (1 + a18) in
      advance (10)
      A := a15;
      B := M[a16];
      C := M[a8];
      H := a15;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := false;
      FlagP := parity(a15);
      FlagCY := false;
      Shifter_OFF := a5;
      jump ((M[a18],M[a17]));
    }

03E6:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #03E7
    #instruction: INC  HL
    let:16 a3 = (1 + (M[a1],M[(SPH,SPL)])) in
    advance (5)
    #03E8
    #instruction: INC  (HL)
    let:16 a4 = addWithCarry(true,M[a3],00) in
    let:8 a5 = (M[a3] & 0F) in
    let:8 a6 = (00 & 0F) in
    let:16 a7 = addWithCarry(true,a5,a6) in
    M[a3] := a4[7:0];
    advance (10)
    #03E9
    #instruction: INC  HL
    let:16 a8 = (1 + a3) in
    advance (5)
    #03EA
    #instruction: INC  HL
    let:16 a9 = (1 + a8) in
    advance (5)
    #03EB
    #instruction: DEC  (HL)
    let:16 a10 = addWithCarry(!true,M[a9],~00) in
    let:8 a11 = (M[a9] & 0F) in
    let:8 a12 = (~00 & 0F) in
    let:16 a13 = addWithCarry(!true,a11,a12) in
    M[a9] := a10[7:0];
    advance (10)
    #03EC
    #instruction: DEC  (HL)
    let:16 a14 = addWithCarry(!true,M[a9],~00) in
    let:8 a15 = (M[a9] & 0F) in
    let:8 a16 = (~00 & 0F) in
    let:16 a17 = addWithCarry(!true,a15,a16) in
    M[a9] := a14[7:0];
    advance (10)
    #03ED
    #instruction: INC  HL
    let:16 a18 = (1 + a9) in
    advance (5)
    #03EE
    #instruction: DEC  (HL)
    let:16 a19 = addWithCarry(!true,M[a18],~00) in
    let:8 a20 = (M[a18] & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    M[a18] := a19[7:0];
    advance (10)
    #03EF
    #instruction: DEC  (HL)
    let:16 a23 = addWithCarry(!true,M[a18],~00) in
    let:8 a24 = (M[a18] & 0F) in
    let:8 a25 = (~00 & 0F) in
    let:16 a26 = addWithCarry(!true,a24,a25) in
    M[a18] := a23[7:0];
    advance (10)
    #03F0
    #instruction: DEC  (HL)
    let:16 a27 = addWithCarry(!true,M[a18],~00) in
    let:8 a28 = (M[a18] & 0F) in
    let:8 a29 = (~00 & 0F) in
    let:16 a30 = addWithCarry(!true,a28,a29) in
    M[a18] := a27[7:0];
    advance (10)
    #03F1
    #instruction: INC  HL
    let:16 a31 = (1 + a18) in
    advance (5)
    #03F2
    #instruction: LD   (HL),08
    M[a31] := 08;
    advance (10)
    #03F4
    #instruction: CALL 0430
    let:16 a32 = (-1 + a2) in
    M[a32] := 03;
    let:16 a33 = (-1 + a32) in
    M[a33] := F7;
    #return-to: 03F7
    advance (17)
    #0430
    #instruction: LD   HL,2027
    advance (10)
    #0433
    #instruction: JP   1A3B
    advance (10)
    #1A3B
    #instruction: LD   E,(HL)
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    advance (7)
    #1A44
    #instruction: LD   H,C
    advance (5)
    #1A45
    #instruction: LD   L,A
    advance (5)
    #1A46
    #instruction: RET
    let:16 a34 = (1 + a33) in
    let:16 a35 = (1 + a34) in
    advance (10)
    A := M[2029];
    B := M[202B];
    C := M[202A];
    D := M[2028];
    E := M[2027];
    H := M[202A];
    L := M[2029];
    SPH := a35[15:8];
    SPL := a35[7:0];
    FlagS := a27[7:0][7];
    FlagZ := is_zero(a27[7:0]);
    FlagA := a30[7:0][4];
    FlagP := parity(a27[7:0]);
    jump ((M[a34],M[a33]));

03F7:

    #instruction: JP   1400
    advance (10)
    #1400
    #instruction: NOP
    advance (4)
    #1401
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    #return-to: 1404
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a3 = (07 & L) in
    let:8 a4 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a5 = (-1 + a2) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,03,~00) in
    let:8 a8 = (03 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a7[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a3;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a11 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a12 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a13 = (20 | a11) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a14 = (1 + a6) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      A := a13;
      B := M[a14];
      C := M[a6];
      H := a13;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := false;
      FlagP := parity(a13);
      FlagCY := false;
      Shifter_OFF := a3;
      jump ((M[a16],M[a15]));
    }

0407:

    #instruction: JP   1400
    advance (10)
    #1400
    #instruction: NOP
    advance (4)
    #1401
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    #return-to: 1404
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a3 = (07 & L) in
    let:8 a4 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a5 = (-1 + a2) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,03,~00) in
    let:8 a8 = (03 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a7[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a3;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a11 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a12 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a13 = (20 | a11) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a14 = (1 + a6) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      A := a13;
      B := M[a14];
      C := M[a6];
      H := a13;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := false;
      FlagP := parity(a13);
      FlagCY := false;
      Shifter_OFF := a3;
      jump ((M[a16],M[a15]));
    }

040D:

    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    #040E
    #instruction: PUSH HL
    let:16 a3 = (-1 + a2) in
    M[a3] := H;
    let:16 a4 = (-1 + a3) in
    M[a4] := L;
    advance (11)
    #040F
    #instruction: PUSH BC
    let:16 a5 = (-1 + a4) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #0410
    #instruction: CALL 1452
    let:16 a7 = (-1 + a6) in
    M[a7] := 04;
    let:16 a8 = (-1 + a7) in
    M[a8] := 13;
    #return-to: 0413
    advance (17)
    #1452
    #instruction: CALL 1474
    let:16 a9 = (-1 + a8) in
    M[a9] := 14;
    let:16 a10 = (-1 + a9) in
    M[a10] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a11 = (07 & L) in
    let:8 a12 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a13 = (-1 + a10) in
    M[a13] := B;
    let:16 a14 = (-1 + a13) in
    M[a14] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a15 = addWithCarry(!true,03,~00) in
    let:8 a16 = (03 & 0F) in
    let:8 a17 = (~00 & 0F) in
    let:16 a18 = addWithCarry(!true,a16,a17) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a15[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a15[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a11;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a19 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a20 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a21 = (20 | a19) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a22 = (1 + a14) in
      let:16 a23 = (1 + a22) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a24 = (1 + a23) in
      let:16 a25 = (1 + a24) in
      advance (10)
      A := a21;
      B := M[a22];
      C := M[a14];
      H := a21;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a21[7];
      FlagZ := is_zero(a21);
      FlagA := false;
      FlagP := parity(a21);
      FlagCY := false;
      Shifter_OFF := a11;
      jump ((M[a24],M[a23]));
    }

0413:

    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0414
    #instruction: POP  HL
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    #0415
    #instruction: POP  DE
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    #0416
    #instruction: LD   A,(202C)
    advance (13)
    #0419
    #instruction: ADD  L
    let:16 a7 = addWithCarry(false,M[a2],M[202C]) in
    let:8 a8 = (M[a2] & 0F) in
    let:8 a9 = (M[202C] & 0F) in
    let:16 a10 = addWithCarry(false,a8,a9) in
    advance (4)
    #041A
    #instruction: LD   L,A
    advance (5)
    #041B
    #instruction: LD   (2029),A
    M[2029] := a7[7:0];
    advance (13)
    #041E
    #instruction: CALL 1491
    let:16 a11 = (-1 + a6) in
    M[a11] := 04;
    let:16 a12 = (-1 + a11) in
    M[a12] := 21;
    #return-to: 0421
    advance (17)
    #1491
    #instruction: CALL 1474
    let:16 a13 = (-1 + a12) in
    M[a13] := 14;
    let:16 a14 = (-1 + a13) in
    M[a14] := 94;
    #return-to: 1494
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a15 = (07 & a7[7:0]) in
    let:8 a16 = (07 | a7[7:0]) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a17 = (-1 + a14) in
    M[a17] := M[a1];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[(SPH,SPL)];
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,03,~00) in
    let:8 a20 = (03 & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := updateBit((a7[7:0] >> 01),7,M[a3][0]);
      B := a19[7:0];
      C := M[(SPH,SPL)];
      D := M[a5];
      E := M[a4];
      H := updateBit((M[a3] >> 01),7,false);
      L := updateBit((a7[7:0] >> 01),7,M[a3][0]);
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a7[7:0][0];
      Shifter_OFF := a15;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a23 = (3F & updateBit((M[a3] >> 01),7,false)) in
      let:8 a24 = (3F | updateBit((M[a3] >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a25 = (20 | a23) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a26 = (1 + a18) in
      let:16 a27 = (1 + a26) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a28 = (1 + a27) in
      let:16 a29 = (1 + a28) in
      advance (10)
      A := a25;
      B := M[a26];
      C := M[a18];
      D := M[a5];
      E := M[a4];
      H := a25;
      L := updateBit((a7[7:0] >> 01),7,M[a3][0]);
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a25[7];
      FlagZ := is_zero(a25);
      FlagA := false;
      FlagP := parity(a25);
      FlagCY := false;
      Shifter_OFF := a15;
      jump ((M[a28],M[a27]));
    }

0421:

    #instruction: LD   A,(2061)
    advance (13)
    #0424
    #instruction: AND  A
    let:8 a1 = (M[2061] & M[2061]) in
    let:8 a2 = (M[2061] | M[2061]) in
    advance (4)
    #0425
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #0426
      #instruction: LD   (2002),A
      M[2002] := a1;
      advance (13)
      #0429
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a1;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a5],M[(SPH,SPL)]));
    }

0439:

    #instruction: CALL 1452
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    #return-to: 043C
    advance (17)
    #1452
    #instruction: CALL 1474
    let:16 a3 = (-1 + a2) in
    M[a3] := 14;
    let:16 a4 = (-1 + a3) in
    M[a4] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a5 = (07 & L) in
    let:8 a6 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a7 = (-1 + a4) in
    M[a7] := B;
    let:16 a8 = (-1 + a7) in
    M[a8] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,03,~00) in
    let:8 a10 = (03 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a9[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a5;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a13 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a14 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a15 = (20 | a13) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a16 = (1 + a8) in
      let:16 a17 = (1 + a16) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a18 = (1 + a17) in
      let:16 a19 = (1 + a18) in
      advance (10)
      A := a15;
      B := M[a16];
      C := M[a8];
      H := a15;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := false;
      FlagP := parity(a15);
      FlagCY := false;
      Shifter_OFF := a5;
      jump ((M[a18],M[a17]));
    }

043C:

    #instruction: LD   HL,2025
    advance (10)
    #043F
    #instruction: LD   DE,1B25
    advance (10)
    #0442
    #instruction: LD   B,07
    advance (7)
    #0444
    #instruction: CALL 1A32
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := 47;
    #return-to: 0447
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2025] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,07,~00) in
    let:8 a4 = (07 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 26;
      H := 20;
      L := 26;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 26;
      H := 20;
      L := 26;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0447:

    #instruction: LD   HL,(208D)
    advance (16)
    #044A
    #instruction: INC  L
    let:16 a1 = addWithCarry(true,M[208D],00) in
    let:8 a2 = (M[208D] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    #044B
    #instruction: LD   A,L
    advance (5)
    #044C
    #instruction: CP   63
    let:16 a5 = addWithCarry(!false,a1[7:0],~63) in
    let:8 a6 = (a1[7:0] & 0F) in
    let:8 a7 = (~63 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #044E
    #instruction: JP   CY,0453
    if (!a5[15:8][0]) {
      advance (10)
      #0453
      #instruction: LD   (208D),HL
      M[208D] := a1[7:0];
      M[208E] := M[208E];
      advance (16)
      #0456
      #instruction: LD   HL,(208F)
      advance (16)
      #0459
      #instruction: INC  L
      let:16 a9 = addWithCarry(true,M[208F],00) in
      let:8 a10 = (M[208F] & 0F) in
      let:8 a11 = (00 & 0F) in
      let:16 a12 = addWithCarry(true,a10,a11) in
      advance (5)
      #045A
      #instruction: LD   (208F),HL
      M[208F] := a9[7:0];
      M[2090] := M[2090];
      advance (16)
      #045D
      #instruction: LD   A,(2084)
      advance (13)
      #0460
      #instruction: AND  A
      let:8 a13 = (M[2084] & M[2084]) in
      let:8 a14 = (M[2084] | M[2084]) in
      advance (4)
      #0461
      #instruction: RET  NZ
      if (!is_zero(a13)) {
        let:16 a15 = (1 + (SPH,SPL)) in
        let:16 a16 = (1 + a15) in
        advance (11)
        A := a13;
        H := M[2090];
        L := a9[7:0];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a13[7];
        FlagZ := is_zero(a13);
        FlagA := a14[3];
        FlagP := parity(a13);
        FlagCY := false;
        jump ((M[a15],M[(SPH,SPL)]));
      } else {
        advance (5)
        #0462
        #instruction: LD   A,(HL)
        advance (7)
        #0463
        #instruction: AND  01
        let:8 a17 = (01 & M[(M[2090],a9[7:0])]) in
        let:8 a18 = (01 | M[(M[2090],a9[7:0])]) in
        advance (7)
        #0465
        #instruction: LD   BC,0229
        advance (10)
        #0468
        #instruction: JP   NZ,046E
        if (!is_zero(a17)) {
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := 29;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := 02;
          advance (7)
          #0475
          #instruction: RET
          let:16 a19 = (1 + (SPH,SPL)) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := a17;
          B := 02;
          C := 29;
          H := 20;
          L := 8C;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a17[7];
          FlagZ := is_zero(a17);
          FlagA := a18[3];
          FlagP := parity(a17);
          FlagCY := false;
          jump ((M[a19],M[(SPH,SPL)]));
        } else {
          advance (10)
          #046B
          #instruction: LD   BC,FEE0
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := E0;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := FE;
          advance (7)
          #0475
          #instruction: RET
          let:16 a21 = (1 + (SPH,SPL)) in
          let:16 a22 = (1 + a21) in
          advance (10)
          A := a17;
          B := FE;
          C := E0;
          H := 20;
          L := 8C;
          SPH := a22[15:8];
          SPL := a22[7:0];
          FlagS := a17[7];
          FlagZ := is_zero(a17);
          FlagA := a18[3];
          FlagP := parity(a17);
          FlagCY := false;
          jump ((M[a21],M[(SPH,SPL)]));
        }
      }
    } else {
      advance (10)
      #0451
      #instruction: LD   L,54
      advance (7)
      #0453
      #instruction: LD   (208D),HL
      M[208D] := 54;
      M[208E] := M[208E];
      advance (16)
      #0456
      #instruction: LD   HL,(208F)
      advance (16)
      #0459
      #instruction: INC  L
      let:16 a23 = addWithCarry(true,M[208F],00) in
      let:8 a24 = (M[208F] & 0F) in
      let:8 a25 = (00 & 0F) in
      let:16 a26 = addWithCarry(true,a24,a25) in
      advance (5)
      #045A
      #instruction: LD   (208F),HL
      M[208F] := a23[7:0];
      M[2090] := M[2090];
      advance (16)
      #045D
      #instruction: LD   A,(2084)
      advance (13)
      #0460
      #instruction: AND  A
      let:8 a27 = (M[2084] & M[2084]) in
      let:8 a28 = (M[2084] | M[2084]) in
      advance (4)
      #0461
      #instruction: RET  NZ
      if (!is_zero(a27)) {
        let:16 a29 = (1 + (SPH,SPL)) in
        let:16 a30 = (1 + a29) in
        advance (11)
        A := a27;
        H := M[2090];
        L := a23[7:0];
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a27[7];
        FlagZ := is_zero(a27);
        FlagA := a28[3];
        FlagP := parity(a27);
        FlagCY := false;
        jump ((M[a29],M[(SPH,SPL)]));
      } else {
        advance (5)
        #0462
        #instruction: LD   A,(HL)
        advance (7)
        #0463
        #instruction: AND  01
        let:8 a31 = (01 & M[(M[2090],a23[7:0])]) in
        let:8 a32 = (01 | M[(M[2090],a23[7:0])]) in
        advance (7)
        #0465
        #instruction: LD   BC,0229
        advance (10)
        #0468
        #instruction: JP   NZ,046E
        if (!is_zero(a31)) {
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := 29;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := 02;
          advance (7)
          #0475
          #instruction: RET
          let:16 a33 = (1 + (SPH,SPL)) in
          let:16 a34 = (1 + a33) in
          advance (10)
          A := a31;
          B := 02;
          C := 29;
          H := 20;
          L := 8C;
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a31[7];
          FlagZ := is_zero(a31);
          FlagA := a32[3];
          FlagP := parity(a31);
          FlagCY := false;
          jump ((M[a33],M[(SPH,SPL)]));
        } else {
          advance (10)
          #046B
          #instruction: LD   BC,FEE0
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := E0;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := FE;
          advance (7)
          #0475
          #instruction: RET
          let:16 a35 = (1 + (SPH,SPL)) in
          let:16 a36 = (1 + a35) in
          advance (10)
          A := a31;
          B := FE;
          C := E0;
          H := 20;
          L := 8C;
          SPH := a36[15:8];
          SPL := a36[7:0];
          FlagS := a31[7];
          FlagZ := is_zero(a31);
          FlagA := a32[3];
          FlagP := parity(a31);
          FlagCY := false;
          jump ((M[a35],M[(SPH,SPL)]));
        }
      }
    }

0476:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0477
    #instruction: LD   A,(1B32)
    advance (13)
    #047A
    #instruction: LD   (2032),A
    M[2032] := 02;
    advance (13)
    #047D
    #instruction: LD   HL,(2038)
    advance (16)
    #0480
    #instruction: LD   A,L
    advance (5)
    #0481
    #instruction: OR   H
    let:8 a3 = (M[2039] | M[2038]) in
    advance (4)
    #0482
    #instruction: JP   NZ,048A
    if (!is_zero(a3)) {
      advance (10)
      #048A
      #instruction: LD   DE,2035
      advance (10)
      #048D
      #instruction: LD   A,F9
      advance (7)
      #048F
      #instruction: CALL 0550
      let:16 a4 = (-1 + a2) in
      M[a4] := 04;
      let:16 a5 = (-1 + a4) in
      M[a5] := 92;
      #return-to: 0492
      advance (17)
      #0550
      #instruction: LD   (207F),A
      M[207F] := F9;
      advance (13)
      #0553
      #instruction: LD   HL,2073
      advance (10)
      #0556
      #instruction: LD   B,0B
      advance (7)
      #0558
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[2073] := M[2035];
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a6 = addWithCarry(!true,0B,~00) in
      let:8 a7 = (0B & 0F) in
      let:8 a8 = (~00 & 0F) in
      let:16 a9 = addWithCarry(!true,a7,a8) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a6[7:0])) {
        advance (10)
        A := M[2035];
        B := a6[7:0];
        D := 20;
        E := 36;
        H := 20;
        L := 74;
        SPH := a5[15:8];
        SPL := a5[7:0];
        FlagS := a6[7:0][7];
        FlagZ := is_zero(a6[7:0]);
        FlagA := a9[7:0][4];
        FlagP := parity(a6[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a10 = (1 + a5) in
        let:16 a11 = (1 + a10) in
        advance (10)
        A := M[2035];
        B := a6[7:0];
        D := 20;
        E := 36;
        H := 20;
        L := 74;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a6[7:0][7];
        FlagZ := is_zero(a6[7:0]);
        FlagA := a9[7:0][4];
        FlagP := parity(a6[7:0]);
        FlagCY := false;
        jump ((M[a10],M[a5]));
      }
    } else {
      advance (10)
      #0485
      #instruction: DEC  HL
      let:16 a12 = (-1 + (M[2039],M[2038])) in
      advance (5)
      #0486
      #instruction: LD   (2038),HL
      M[2038] := a12[7:0];
      M[2039] := a12[15:8];
      advance (16)
      #0489
      #instruction: RET
      let:16 a13 = (1 + a2) in
      let:16 a14 = (1 + a13) in
      advance (10)
      A := a3;
      H := a12[15:8];
      L := a12[7:0];
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := false;
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a13],M[a2]));
    }

0492:

    #instruction: LD   A,(2046)
    advance (13)
    #0495
    #instruction: LD   (2070),A
    M[2070] := M[2046];
    advance (13)
    #0498
    #instruction: LD   A,(2056)
    advance (13)
    #049B
    #instruction: LD   (2071),A
    M[2071] := M[2056];
    advance (13)
    #049E
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := A1;
    #return-to: 04A1
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a3 = (80 & M[2073]) in
    let:8 a4 = (80 | M[2073]) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a3)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:16 a5 = (-1 + a2) in
      M[a5] := 05;
      let:16 a6 = (-1 + a5) in
      M[a6] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a7 = (80 & M[207C]) in
      let:8 a8 = (80 | M[207C]) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a9 = (M[2072] ^ a7) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a9)) {
        let:16 a10 = (1 + a6) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a6]));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:16 a12 = (1 + a6) in
        let:16 a13 = (1 + a12) in
        advance (10)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a13[15:8];
        SPL := a13[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := true;
        jump ((M[a12],M[a6]));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      advance (13)
      #056F
      #instruction: CP   04
      let:16 a14 = addWithCarry(!false,M[20C1],~04) in
      let:8 a15 = (M[20C1] & 0F) in
      let:8 a16 = (~04 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a14[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a18 = (80 | M[2073]) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        M[2073] := a18;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:16 a19 = addWithCarry(true,M[2074],00) in
        let:8 a20 = (M[2074] & 0F) in
        let:8 a21 = (00 & 0F) in
        let:16 a22 = addWithCarry(true,a20,a21) in
        M[2074] := a19[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:16 a23 = (1 + a2) in
        let:16 a24 = (1 + a23) in
        advance (10)
        A := a18;
        H := 20;
        L := 74;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a19[7:0][7];
        FlagZ := is_zero(a19[7:0]);
        FlagA := a22[7:0][4];
        FlagP := parity(a19[7:0]);
        FlagCY := false;
        jump ((M[a23],M[a2]));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a25 = (M[2069] & M[2069]) in
        let:8 a26 = (M[2069] | M[2069]) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a25)) {
          let:16 a27 = (1 + a2) in
          let:16 a28 = (1 + a27) in
          advance (11)
          A := a25;
          H := 20;
          L := 73;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a25[7];
          FlagZ := is_zero(a25);
          FlagA := a26[3];
          FlagP := parity(a25);
          FlagCY := false;
          jump ((M[a27],M[a2]));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a29 = (M[2070] & M[2070]) in
          let:8 a30 = (M[2070] | M[2070]) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a29)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a31 = (M[2071] & M[2071]) in
            let:8 a32 = (M[2071] | M[2071]) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a31)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a33 = (M[2075] & M[2075]) in
              let:8 a34 = (M[2075] | M[2075]) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a33)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                advance (13)
                #061E
                #instruction: ADD  08
                let:16 a35 = addWithCarry(false,08,M[201B]) in
                let:8 a36 = (08 & 0F) in
                let:8 a37 = (M[201B] & 0F) in
                let:16 a38 = addWithCarry(false,a36,a37) in
                advance (7)
                #0620
                #instruction: LD   H,A
                advance (5)
                #0621
                #instruction: CALL 156F
                let:16 a39 = (-1 + a2) in
                M[a39] := 06;
                let:16 a40 = (-1 + a39) in
                M[a40] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                advance (13)
                #1572
                #instruction: CALL 1554
                let:16 a41 = (-1 + a40) in
                M[a41] := 15;
                let:16 a42 = (-1 + a41) in
                M[a42] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:16 a43 = addWithCarry(!false,M[200A],~a35[7:0]) in
                let:8 a44 = (M[200A] & 0F) in
                let:8 a45 = (~a35[7:0] & 0F) in
                let:16 a46 = addWithCarry(!false,a44,a45) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a43[15:8][0]) {
                  let:16 a47 = (-1 + a42) in
                  M[a47] := 15;
                  let:16 a48 = (-1 + a47) in
                  M[a48] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a49 = addWithCarry(true,00,00) in
                  let:8 a50 = (00 & 0F) in
                  let:8 a51 = (00 & 0F) in
                  let:16 a52 = addWithCarry(true,a50,a51) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:16 a53 = addWithCarry(false,10,M[200A]) in
                  let:8 a54 = (10 & 0F) in
                  let:8 a55 = (M[200A] & 0F) in
                  let:16 a56 = addWithCarry(false,a54,a55) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a53[7:0][7]) {
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a48[15:8];
                    SPL := a48[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:16 a57 = (1 + a48) in
                    let:16 a58 = (1 + a57) in
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a58[15:8];
                    SPL := a58[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump ((M[a57],M[a48]));
                  }
                } else {
                  advance (11)
                  A := M[200A];
                  C := 00;
                  H := a35[7:0];
                  L := 75;
                  SPH := a42[15:8];
                  SPL := a42[7:0];
                  FlagS := a43[7:0][7];
                  FlagZ := is_zero(a43[7:0]);
                  FlagA := a46[7:0][4];
                  FlagP := parity(a43[7:0]);
                  FlagCY := !a43[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                advance (7)
                #05A0
                #instruction: INC  HL
                let:16 a59 = (1 + (M[2077],M[2076])) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                M[2076] := a59[7:0];
                M[2077] := a59[15:8];
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:16 a60 = (-1 + a2) in
                M[a60] := 05;
                let:16 a61 = (-1 + a60) in
                M[a61] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:16 a62 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                let:8 a63 = (M[(M[2077],M[2076])] & 0F) in
                let:8 a64 = (~00 & 0F) in
                let:16 a65 = addWithCarry(!true,a63,a64) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                advance (13)
                #0633
                #instruction: LD   H,A
                advance (5)
                #0634
                #instruction: LD   L,C
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a66 = (M[(M[2067],a62[7:0])] & M[(M[2067],a62[7:0])]) in
                let:8 a67 = (M[(M[2067],a62[7:0])] | M[(M[2067],a62[7:0])]) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a66)) {
                  let:16 a68 = (1 + a61) in
                  let:16 a69 = (1 + a68) in
                  advance (11)
                  A := a66;
                  C := a62[7:0];
                  D := 05;
                  H := M[2067];
                  L := a62[7:0];
                  SPH := a69[15:8];
                  SPL := a69[7:0];
                  FlagS := a66[7];
                  FlagZ := is_zero(a66);
                  FlagA := a67[3];
                  FlagP := parity(a66);
                  FlagCY := true;
                  jump ((M[a68],M[a61]));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:16 a70 = addWithCarry(false,0B,a62[7:0]) in
                  let:8 a71 = (0B & 0F) in
                  let:8 a72 = (a62[7:0] & 0F) in
                  let:16 a73 = addWithCarry(false,a71,a72) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a74 = addWithCarry(!true,05,~00) in
                  let:8 a75 = (05 & 0F) in
                  let:8 a76 = (~00 & 0F) in
                  let:16 a77 = addWithCarry(!true,a75,a76) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a74[7:0])) {
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a61[15:8];
                    SPL := a61[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:16 a78 = (1 + a61) in
                    let:16 a79 = (1 + a78) in
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a79[15:8];
                    SPL := a79[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump ((M[a78],M[a61]));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              advance (13)
              #0594
              #instruction: CP   B
              let:16 a80 = addWithCarry(!false,M[20CF],~a31) in
              let:8 a81 = (M[20CF] & 0F) in
              let:8 a82 = (~a31 & 0F) in
              let:16 a83 = addWithCarry(!false,a81,a82) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a80[15:8][0]) {
                let:16 a84 = (1 + a2) in
                let:16 a85 = (1 + a84) in
                advance (11)
                A := M[20CF];
                B := a31;
                H := 20;
                L := 74;
                SPH := a85[15:8];
                SPL := a85[7:0];
                FlagS := a80[7:0][7];
                FlagZ := is_zero(a80[7:0]);
                FlagA := a83[7:0][4];
                FlagP := parity(a80[7:0]);
                FlagCY := !a80[15:8][0];
                jump ((M[a84],M[a2]));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a86 = (M[2075] & M[2075]) in
                let:8 a87 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a86)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a88 = addWithCarry(false,08,M[201B]) in
                  let:8 a89 = (08 & 0F) in
                  let:8 a90 = (M[201B] & 0F) in
                  let:16 a91 = addWithCarry(false,a89,a90) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a92 = (-1 + a2) in
                  M[a92] := 06;
                  let:16 a93 = (-1 + a92) in
                  M[a93] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a94 = (-1 + a93) in
                  M[a94] := 15;
                  let:16 a95 = (-1 + a94) in
                  M[a95] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a96 = addWithCarry(!false,M[200A],~a88[7:0]) in
                  let:8 a97 = (M[200A] & 0F) in
                  let:8 a98 = (~a88[7:0] & 0F) in
                  let:16 a99 = addWithCarry(!false,a97,a98) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a96[15:8][0]) {
                    let:16 a100 = (-1 + a95) in
                    M[a100] := 15;
                    let:16 a101 = (-1 + a100) in
                    M[a101] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a102 = addWithCarry(true,00,00) in
                    let:8 a103 = (00 & 0F) in
                    let:8 a104 = (00 & 0F) in
                    let:16 a105 = addWithCarry(true,a103,a104) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a106 = addWithCarry(false,10,M[200A]) in
                    let:8 a107 = (10 & 0F) in
                    let:8 a108 = (M[200A] & 0F) in
                    let:16 a109 = addWithCarry(false,a107,a108) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a106[7:0][7]) {
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a101[15:8];
                      SPL := a101[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a110 = (1 + a101) in
                      let:16 a111 = (1 + a110) in
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a111[15:8];
                      SPL := a111[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump ((M[a110],M[a101]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a31;
                    C := 00;
                    H := a88[7:0];
                    L := 75;
                    SPH := a95[15:8];
                    SPL := a95[7:0];
                    FlagS := a96[7:0][7];
                    FlagZ := is_zero(a96[7:0]);
                    FlagA := a99[7:0][4];
                    FlagP := parity(a96[7:0]);
                    FlagCY := !a96[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a112 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a112[7:0];
                  M[2077] := a112[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a113 = (-1 + a2) in
                  M[a113] := 05;
                  let:16 a114 = (-1 + a113) in
                  M[a114] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a115 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a116 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a117 = (~00 & 0F) in
                  let:16 a118 = addWithCarry(!true,a116,a117) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a119 = (M[(M[2067],a115[7:0])] & M[(M[2067],a115[7:0])]) in
                  let:8 a120 = (M[(M[2067],a115[7:0])] | M[(M[2067],a115[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a119)) {
                    let:16 a121 = (1 + a114) in
                    let:16 a122 = (1 + a121) in
                    advance (11)
                    A := a119;
                    B := a31;
                    C := a115[7:0];
                    D := 05;
                    H := M[2067];
                    L := a115[7:0];
                    SPH := a122[15:8];
                    SPL := a122[7:0];
                    FlagS := a119[7];
                    FlagZ := is_zero(a119);
                    FlagA := a120[3];
                    FlagP := parity(a119);
                    FlagCY := true;
                    jump ((M[a121],M[a114]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a123 = addWithCarry(false,0B,a115[7:0]) in
                    let:8 a124 = (0B & 0F) in
                    let:8 a125 = (a115[7:0] & 0F) in
                    let:16 a126 = addWithCarry(false,a124,a125) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a127 = addWithCarry(!true,05,~00) in
                    let:8 a128 = (05 & 0F) in
                    let:8 a129 = (~00 & 0F) in
                    let:16 a130 = addWithCarry(!true,a128,a129) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a127[7:0])) {
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a114[15:8];
                      SPL := a114[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a131 = (1 + a114) in
                      let:16 a132 = (1 + a131) in
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a132[15:8];
                      SPL := a132[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump ((M[a131],M[a114]));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            advance (13)
            #0587
            #instruction: CP   B
            let:16 a133 = addWithCarry(!false,M[20CF],~a29) in
            let:8 a134 = (M[20CF] & 0F) in
            let:8 a135 = (~a29 & 0F) in
            let:16 a136 = addWithCarry(!false,a134,a135) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a133[15:8][0]) {
              let:16 a137 = (1 + a2) in
              let:16 a138 = (1 + a137) in
              advance (11)
              A := M[20CF];
              B := a29;
              H := 20;
              L := 74;
              SPH := a138[15:8];
              SPL := a138[7:0];
              FlagS := a133[7:0][7];
              FlagZ := is_zero(a133[7:0]);
              FlagA := a136[7:0][4];
              FlagP := parity(a133[7:0]);
              FlagCY := !a133[15:8][0];
              jump ((M[a137],M[a2]));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a139 = (M[2071] & M[2071]) in
              let:8 a140 = (M[2071] | M[2071]) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a139)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a141 = (M[2075] & M[2075]) in
                let:8 a142 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a141)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a143 = addWithCarry(false,08,M[201B]) in
                  let:8 a144 = (08 & 0F) in
                  let:8 a145 = (M[201B] & 0F) in
                  let:16 a146 = addWithCarry(false,a144,a145) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a147 = (-1 + a2) in
                  M[a147] := 06;
                  let:16 a148 = (-1 + a147) in
                  M[a148] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a149 = (-1 + a148) in
                  M[a149] := 15;
                  let:16 a150 = (-1 + a149) in
                  M[a150] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a151 = addWithCarry(!false,M[200A],~a143[7:0]) in
                  let:8 a152 = (M[200A] & 0F) in
                  let:8 a153 = (~a143[7:0] & 0F) in
                  let:16 a154 = addWithCarry(!false,a152,a153) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a151[15:8][0]) {
                    let:16 a155 = (-1 + a150) in
                    M[a155] := 15;
                    let:16 a156 = (-1 + a155) in
                    M[a156] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a157 = addWithCarry(true,00,00) in
                    let:8 a158 = (00 & 0F) in
                    let:8 a159 = (00 & 0F) in
                    let:16 a160 = addWithCarry(true,a158,a159) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a161 = addWithCarry(false,10,M[200A]) in
                    let:8 a162 = (10 & 0F) in
                    let:8 a163 = (M[200A] & 0F) in
                    let:16 a164 = addWithCarry(false,a162,a163) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a161[7:0][7]) {
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a156[15:8];
                      SPL := a156[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a165 = (1 + a156) in
                      let:16 a166 = (1 + a165) in
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a166[15:8];
                      SPL := a166[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump ((M[a165],M[a156]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a29;
                    C := 00;
                    H := a143[7:0];
                    L := 75;
                    SPH := a150[15:8];
                    SPL := a150[7:0];
                    FlagS := a151[7:0][7];
                    FlagZ := is_zero(a151[7:0]);
                    FlagA := a154[7:0][4];
                    FlagP := parity(a151[7:0]);
                    FlagCY := !a151[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a167 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a167[7:0];
                  M[2077] := a167[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a168 = (-1 + a2) in
                  M[a168] := 05;
                  let:16 a169 = (-1 + a168) in
                  M[a169] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a170 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a171 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a172 = (~00 & 0F) in
                  let:16 a173 = addWithCarry(!true,a171,a172) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a174 = (M[(M[2067],a170[7:0])] & M[(M[2067],a170[7:0])]) in
                  let:8 a175 = (M[(M[2067],a170[7:0])] | M[(M[2067],a170[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a174)) {
                    let:16 a176 = (1 + a169) in
                    let:16 a177 = (1 + a176) in
                    advance (11)
                    A := a174;
                    B := a29;
                    C := a170[7:0];
                    D := 05;
                    H := M[2067];
                    L := a170[7:0];
                    SPH := a177[15:8];
                    SPL := a177[7:0];
                    FlagS := a174[7];
                    FlagZ := is_zero(a174);
                    FlagA := a175[3];
                    FlagP := parity(a174);
                    FlagCY := true;
                    jump ((M[a176],M[a169]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a178 = addWithCarry(false,0B,a170[7:0]) in
                    let:8 a179 = (0B & 0F) in
                    let:8 a180 = (a170[7:0] & 0F) in
                    let:16 a181 = addWithCarry(false,a179,a180) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a182 = addWithCarry(!true,05,~00) in
                    let:8 a183 = (05 & 0F) in
                    let:8 a184 = (~00 & 0F) in
                    let:16 a185 = addWithCarry(!true,a183,a184) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a182[7:0])) {
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a169[15:8];
                      SPL := a169[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a186 = (1 + a169) in
                      let:16 a187 = (1 + a186) in
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a187[15:8];
                      SPL := a187[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump ((M[a186],M[a169]));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                advance (13)
                #0594
                #instruction: CP   B
                let:16 a188 = addWithCarry(!false,M[20CF],~a139) in
                let:8 a189 = (M[20CF] & 0F) in
                let:8 a190 = (~a139 & 0F) in
                let:16 a191 = addWithCarry(!false,a189,a190) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a188[15:8][0]) {
                  let:16 a192 = (1 + a2) in
                  let:16 a193 = (1 + a192) in
                  advance (11)
                  A := M[20CF];
                  B := a139;
                  H := 20;
                  L := 74;
                  SPH := a193[15:8];
                  SPL := a193[7:0];
                  FlagS := a188[7:0][7];
                  FlagZ := is_zero(a188[7:0]);
                  FlagA := a191[7:0][4];
                  FlagP := parity(a188[7:0]);
                  FlagCY := !a188[15:8][0];
                  jump ((M[a192],M[a2]));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a194 = (M[2075] & M[2075]) in
                  let:8 a195 = (M[2075] | M[2075]) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a194)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:16 a196 = addWithCarry(false,08,M[201B]) in
                    let:8 a197 = (08 & 0F) in
                    let:8 a198 = (M[201B] & 0F) in
                    let:16 a199 = addWithCarry(false,a197,a198) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:16 a200 = (-1 + a2) in
                    M[a200] := 06;
                    let:16 a201 = (-1 + a200) in
                    M[a201] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:16 a202 = (-1 + a201) in
                    M[a202] := 15;
                    let:16 a203 = (-1 + a202) in
                    M[a203] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:16 a204 = addWithCarry(!false,M[200A],~a196[7:0]) in
                    let:8 a205 = (M[200A] & 0F) in
                    let:8 a206 = (~a196[7:0] & 0F) in
                    let:16 a207 = addWithCarry(!false,a205,a206) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a204[15:8][0]) {
                      let:16 a208 = (-1 + a203) in
                      M[a208] := 15;
                      let:16 a209 = (-1 + a208) in
                      M[a209] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a210 = addWithCarry(true,00,00) in
                      let:8 a211 = (00 & 0F) in
                      let:8 a212 = (00 & 0F) in
                      let:16 a213 = addWithCarry(true,a211,a212) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:16 a214 = addWithCarry(false,10,M[200A]) in
                      let:8 a215 = (10 & 0F) in
                      let:8 a216 = (M[200A] & 0F) in
                      let:16 a217 = addWithCarry(false,a215,a216) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a214[7:0][7]) {
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a209[15:8];
                        SPL := a209[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:16 a218 = (1 + a209) in
                        let:16 a219 = (1 + a218) in
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a219[15:8];
                        SPL := a219[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump ((M[a218],M[a209]));
                      }
                    } else {
                      advance (11)
                      A := M[200A];
                      B := a139;
                      C := 00;
                      H := a196[7:0];
                      L := 75;
                      SPH := a203[15:8];
                      SPL := a203[7:0];
                      FlagS := a204[7:0][7];
                      FlagZ := is_zero(a204[7:0]);
                      FlagA := a207[7:0][4];
                      FlagP := parity(a204[7:0]);
                      FlagCY := !a204[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:16 a220 = (1 + (M[2077],M[2076])) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    M[2076] := a220[7:0];
                    M[2077] := a220[15:8];
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:16 a221 = (-1 + a2) in
                    M[a221] := 05;
                    let:16 a222 = (-1 + a221) in
                    M[a222] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:16 a223 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                    let:8 a224 = (M[(M[2077],M[2076])] & 0F) in
                    let:8 a225 = (~00 & 0F) in
                    let:16 a226 = addWithCarry(!true,a224,a225) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a227 = (M[(M[2067],a223[7:0])] & M[(M[2067],a223[7:0])]) in
                    let:8 a228 = (M[(M[2067],a223[7:0])] | M[(M[2067],a223[7:0])]) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a227)) {
                      let:16 a229 = (1 + a222) in
                      let:16 a230 = (1 + a229) in
                      advance (11)
                      A := a227;
                      B := a139;
                      C := a223[7:0];
                      D := 05;
                      H := M[2067];
                      L := a223[7:0];
                      SPH := a230[15:8];
                      SPL := a230[7:0];
                      FlagS := a227[7];
                      FlagZ := is_zero(a227);
                      FlagA := a228[3];
                      FlagP := parity(a227);
                      FlagCY := true;
                      jump ((M[a229],M[a222]));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:16 a231 = addWithCarry(false,0B,a223[7:0]) in
                      let:8 a232 = (0B & 0F) in
                      let:8 a233 = (a223[7:0] & 0F) in
                      let:16 a234 = addWithCarry(false,a232,a233) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a235 = addWithCarry(!true,05,~00) in
                      let:8 a236 = (05 & 0F) in
                      let:8 a237 = (~00 & 0F) in
                      let:16 a238 = addWithCarry(!true,a236,a237) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a235[7:0])) {
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a222[15:8];
                        SPL := a222[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:16 a239 = (1 + a222) in
                        let:16 a240 = (1 + a239) in
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a240[15:8];
                        SPL := a240[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump ((M[a239],M[a222]));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

04A1:

    #instruction: LD   A,(2078)
    advance (13)
    #04A4
    #instruction: AND  A
    let:8 a1 = (M[2078] & M[2078]) in
    let:8 a2 = (M[2078] | M[2078]) in
    advance (4)
    #04A5
    #instruction: LD   HL,2035
    advance (10)
    #04A8
    #instruction: JP   NZ,055B
    if (!is_zero(a1)) {
      advance (10)
      #055B
      #instruction: LD   DE,2073
      advance (10)
      #055E
      #instruction: LD   B,0B
      advance (7)
      #0560
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[2035] := M[2073];
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a3 = addWithCarry(!true,0B,~00) in
      let:8 a4 = (0B & 0F) in
      let:8 a5 = (~00 & 0F) in
      let:16 a6 = addWithCarry(!true,a4,a5) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a3[7:0])) {
        advance (10)
        A := M[2073];
        B := a3[7:0];
        D := 20;
        E := 74;
        H := 20;
        L := 36;
        FlagS := a3[7:0][7];
        FlagZ := is_zero(a3[7:0]);
        FlagA := a6[7:0][4];
        FlagP := parity(a3[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a7 = (1 + (SPH,SPL)) in
        let:16 a8 = (1 + a7) in
        advance (10)
        A := M[2073];
        B := a3[7:0];
        D := 20;
        E := 74;
        H := 20;
        L := 36;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a3[7:0][7];
        FlagZ := is_zero(a3[7:0]);
        FlagA := a6[7:0][4];
        FlagP := parity(a3[7:0]);
        FlagCY := false;
        jump ((M[a7],M[(SPH,SPL)]));
      }
    } else {
      advance (10)
      #04AB
      #instruction: LD   DE,1B30
      advance (10)
      #04AE
      #instruction: LD   HL,2030
      advance (10)
      #04B1
      #instruction: LD   B,10
      advance (7)
      #04B3
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[2030] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a9 = addWithCarry(!true,10,~00) in
      let:8 a10 = (10 & 0F) in
      let:8 a11 = (~00 & 0F) in
      let:16 a12 = addWithCarry(!true,a10,a11) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a9[7:0])) {
        advance (10)
        A := 00;
        B := a9[7:0];
        D := 1B;
        E := 31;
        H := 20;
        L := 31;
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a13 = (1 + (SPH,SPL)) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 00;
        B := a9[7:0];
        D := 1B;
        E := 31;
        H := 20;
        L := 31;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := false;
        jump ((M[a13],M[(SPH,SPL)]));
      }
    }

04B6:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #04B7
    #instruction: LD   A,(206E)
    advance (13)
    #04BA
    #instruction: AND  A
    let:8 a3 = (M[206E] & M[206E]) in
    let:8 a4 = (M[206E] | M[206E]) in
    advance (4)
    #04BB
    #instruction: RET  NZ
    if (!is_zero(a3)) {
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := a3;
      H := M[a1];
      L := M[(SPH,SPL)];
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    } else {
      advance (5)
      #04BC
      #instruction: LD   A,(2080)
      advance (13)
      #04BF
      #instruction: CP   01
      let:16 a7 = addWithCarry(!false,M[2080],~01) in
      let:8 a8 = (M[2080] & 0F) in
      let:8 a9 = (~01 & 0F) in
      let:16 a10 = addWithCarry(!false,a8,a9) in
      advance (7)
      #04C1
      #instruction: RET  NZ
      if (!is_zero(a7[7:0])) {
        let:16 a11 = (1 + a2) in
        let:16 a12 = (1 + a11) in
        advance (11)
        A := M[2080];
        H := M[a1];
        L := M[(SPH,SPL)];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := !a7[15:8][0];
        jump ((M[a11],M[a2]));
      } else {
        advance (5)
        #04C2
        #instruction: LD   DE,2045
        advance (10)
        #04C5
        #instruction: LD   A,ED
        advance (7)
        #04C7
        #instruction: CALL 0550
        let:16 a13 = (-1 + a2) in
        M[a13] := 04;
        let:16 a14 = (-1 + a13) in
        M[a14] := CA;
        #return-to: 04CA
        advance (17)
        #0550
        #instruction: LD   (207F),A
        M[207F] := ED;
        advance (13)
        #0553
        #instruction: LD   HL,2073
        advance (10)
        #0556
        #instruction: LD   B,0B
        advance (7)
        #0558
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2073] := M[2045];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a15 = addWithCarry(!true,0B,~00) in
        let:8 a16 = (0B & 0F) in
        let:8 a17 = (~00 & 0F) in
        let:16 a18 = addWithCarry(!true,a16,a17) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a15[7:0])) {
          advance (10)
          A := M[2045];
          B := a15[7:0];
          D := 20;
          E := 46;
          H := 20;
          L := 74;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a7[15:8][0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a19 = (1 + a14) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := M[2045];
          B := a15[7:0];
          D := 20;
          E := 46;
          H := 20;
          L := 74;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a7[15:8][0];
          jump ((M[a19],M[a14]));
        }
      }
    }

04CA:

    #instruction: LD   A,(2036)
    advance (13)
    #04CD
    #instruction: LD   (2070),A
    M[2070] := M[2036];
    advance (13)
    #04D0
    #instruction: LD   A,(2056)
    advance (13)
    #04D3
    #instruction: LD   (2071),A
    M[2071] := M[2056];
    advance (13)
    #04D6
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 04;
    let:16 a2 = (-1 + a1) in
    M[a2] := D9;
    #return-to: 04D9
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a3 = (80 & M[2073]) in
    let:8 a4 = (80 | M[2073]) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a3)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:16 a5 = (-1 + a2) in
      M[a5] := 05;
      let:16 a6 = (-1 + a5) in
      M[a6] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a7 = (80 & M[207C]) in
      let:8 a8 = (80 | M[207C]) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a9 = (M[2072] ^ a7) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a9)) {
        let:16 a10 = (1 + a6) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a6]));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:16 a12 = (1 + a6) in
        let:16 a13 = (1 + a12) in
        advance (10)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a13[15:8];
        SPL := a13[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := true;
        jump ((M[a12],M[a6]));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      advance (13)
      #056F
      #instruction: CP   04
      let:16 a14 = addWithCarry(!false,M[20C1],~04) in
      let:8 a15 = (M[20C1] & 0F) in
      let:8 a16 = (~04 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a14[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a18 = (80 | M[2073]) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        M[2073] := a18;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:16 a19 = addWithCarry(true,M[2074],00) in
        let:8 a20 = (M[2074] & 0F) in
        let:8 a21 = (00 & 0F) in
        let:16 a22 = addWithCarry(true,a20,a21) in
        M[2074] := a19[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:16 a23 = (1 + a2) in
        let:16 a24 = (1 + a23) in
        advance (10)
        A := a18;
        H := 20;
        L := 74;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a19[7:0][7];
        FlagZ := is_zero(a19[7:0]);
        FlagA := a22[7:0][4];
        FlagP := parity(a19[7:0]);
        FlagCY := false;
        jump ((M[a23],M[a2]));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a25 = (M[2069] & M[2069]) in
        let:8 a26 = (M[2069] | M[2069]) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a25)) {
          let:16 a27 = (1 + a2) in
          let:16 a28 = (1 + a27) in
          advance (11)
          A := a25;
          H := 20;
          L := 73;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a25[7];
          FlagZ := is_zero(a25);
          FlagA := a26[3];
          FlagP := parity(a25);
          FlagCY := false;
          jump ((M[a27],M[a2]));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a29 = (M[2070] & M[2070]) in
          let:8 a30 = (M[2070] | M[2070]) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a29)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a31 = (M[2071] & M[2071]) in
            let:8 a32 = (M[2071] | M[2071]) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a31)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a33 = (M[2075] & M[2075]) in
              let:8 a34 = (M[2075] | M[2075]) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a33)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                advance (13)
                #061E
                #instruction: ADD  08
                let:16 a35 = addWithCarry(false,08,M[201B]) in
                let:8 a36 = (08 & 0F) in
                let:8 a37 = (M[201B] & 0F) in
                let:16 a38 = addWithCarry(false,a36,a37) in
                advance (7)
                #0620
                #instruction: LD   H,A
                advance (5)
                #0621
                #instruction: CALL 156F
                let:16 a39 = (-1 + a2) in
                M[a39] := 06;
                let:16 a40 = (-1 + a39) in
                M[a40] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                advance (13)
                #1572
                #instruction: CALL 1554
                let:16 a41 = (-1 + a40) in
                M[a41] := 15;
                let:16 a42 = (-1 + a41) in
                M[a42] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:16 a43 = addWithCarry(!false,M[200A],~a35[7:0]) in
                let:8 a44 = (M[200A] & 0F) in
                let:8 a45 = (~a35[7:0] & 0F) in
                let:16 a46 = addWithCarry(!false,a44,a45) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a43[15:8][0]) {
                  let:16 a47 = (-1 + a42) in
                  M[a47] := 15;
                  let:16 a48 = (-1 + a47) in
                  M[a48] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a49 = addWithCarry(true,00,00) in
                  let:8 a50 = (00 & 0F) in
                  let:8 a51 = (00 & 0F) in
                  let:16 a52 = addWithCarry(true,a50,a51) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:16 a53 = addWithCarry(false,10,M[200A]) in
                  let:8 a54 = (10 & 0F) in
                  let:8 a55 = (M[200A] & 0F) in
                  let:16 a56 = addWithCarry(false,a54,a55) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a53[7:0][7]) {
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a48[15:8];
                    SPL := a48[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:16 a57 = (1 + a48) in
                    let:16 a58 = (1 + a57) in
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a58[15:8];
                    SPL := a58[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump ((M[a57],M[a48]));
                  }
                } else {
                  advance (11)
                  A := M[200A];
                  C := 00;
                  H := a35[7:0];
                  L := 75;
                  SPH := a42[15:8];
                  SPL := a42[7:0];
                  FlagS := a43[7:0][7];
                  FlagZ := is_zero(a43[7:0]);
                  FlagA := a46[7:0][4];
                  FlagP := parity(a43[7:0]);
                  FlagCY := !a43[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                advance (7)
                #05A0
                #instruction: INC  HL
                let:16 a59 = (1 + (M[2077],M[2076])) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                M[2076] := a59[7:0];
                M[2077] := a59[15:8];
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:16 a60 = (-1 + a2) in
                M[a60] := 05;
                let:16 a61 = (-1 + a60) in
                M[a61] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:16 a62 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                let:8 a63 = (M[(M[2077],M[2076])] & 0F) in
                let:8 a64 = (~00 & 0F) in
                let:16 a65 = addWithCarry(!true,a63,a64) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                advance (13)
                #0633
                #instruction: LD   H,A
                advance (5)
                #0634
                #instruction: LD   L,C
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a66 = (M[(M[2067],a62[7:0])] & M[(M[2067],a62[7:0])]) in
                let:8 a67 = (M[(M[2067],a62[7:0])] | M[(M[2067],a62[7:0])]) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a66)) {
                  let:16 a68 = (1 + a61) in
                  let:16 a69 = (1 + a68) in
                  advance (11)
                  A := a66;
                  C := a62[7:0];
                  D := 05;
                  H := M[2067];
                  L := a62[7:0];
                  SPH := a69[15:8];
                  SPL := a69[7:0];
                  FlagS := a66[7];
                  FlagZ := is_zero(a66);
                  FlagA := a67[3];
                  FlagP := parity(a66);
                  FlagCY := true;
                  jump ((M[a68],M[a61]));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:16 a70 = addWithCarry(false,0B,a62[7:0]) in
                  let:8 a71 = (0B & 0F) in
                  let:8 a72 = (a62[7:0] & 0F) in
                  let:16 a73 = addWithCarry(false,a71,a72) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a74 = addWithCarry(!true,05,~00) in
                  let:8 a75 = (05 & 0F) in
                  let:8 a76 = (~00 & 0F) in
                  let:16 a77 = addWithCarry(!true,a75,a76) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a74[7:0])) {
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a61[15:8];
                    SPL := a61[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:16 a78 = (1 + a61) in
                    let:16 a79 = (1 + a78) in
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a79[15:8];
                    SPL := a79[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump ((M[a78],M[a61]));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              advance (13)
              #0594
              #instruction: CP   B
              let:16 a80 = addWithCarry(!false,M[20CF],~a31) in
              let:8 a81 = (M[20CF] & 0F) in
              let:8 a82 = (~a31 & 0F) in
              let:16 a83 = addWithCarry(!false,a81,a82) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a80[15:8][0]) {
                let:16 a84 = (1 + a2) in
                let:16 a85 = (1 + a84) in
                advance (11)
                A := M[20CF];
                B := a31;
                H := 20;
                L := 74;
                SPH := a85[15:8];
                SPL := a85[7:0];
                FlagS := a80[7:0][7];
                FlagZ := is_zero(a80[7:0]);
                FlagA := a83[7:0][4];
                FlagP := parity(a80[7:0]);
                FlagCY := !a80[15:8][0];
                jump ((M[a84],M[a2]));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a86 = (M[2075] & M[2075]) in
                let:8 a87 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a86)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a88 = addWithCarry(false,08,M[201B]) in
                  let:8 a89 = (08 & 0F) in
                  let:8 a90 = (M[201B] & 0F) in
                  let:16 a91 = addWithCarry(false,a89,a90) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a92 = (-1 + a2) in
                  M[a92] := 06;
                  let:16 a93 = (-1 + a92) in
                  M[a93] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a94 = (-1 + a93) in
                  M[a94] := 15;
                  let:16 a95 = (-1 + a94) in
                  M[a95] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a96 = addWithCarry(!false,M[200A],~a88[7:0]) in
                  let:8 a97 = (M[200A] & 0F) in
                  let:8 a98 = (~a88[7:0] & 0F) in
                  let:16 a99 = addWithCarry(!false,a97,a98) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a96[15:8][0]) {
                    let:16 a100 = (-1 + a95) in
                    M[a100] := 15;
                    let:16 a101 = (-1 + a100) in
                    M[a101] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a102 = addWithCarry(true,00,00) in
                    let:8 a103 = (00 & 0F) in
                    let:8 a104 = (00 & 0F) in
                    let:16 a105 = addWithCarry(true,a103,a104) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a106 = addWithCarry(false,10,M[200A]) in
                    let:8 a107 = (10 & 0F) in
                    let:8 a108 = (M[200A] & 0F) in
                    let:16 a109 = addWithCarry(false,a107,a108) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a106[7:0][7]) {
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a101[15:8];
                      SPL := a101[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a110 = (1 + a101) in
                      let:16 a111 = (1 + a110) in
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a111[15:8];
                      SPL := a111[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump ((M[a110],M[a101]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a31;
                    C := 00;
                    H := a88[7:0];
                    L := 75;
                    SPH := a95[15:8];
                    SPL := a95[7:0];
                    FlagS := a96[7:0][7];
                    FlagZ := is_zero(a96[7:0]);
                    FlagA := a99[7:0][4];
                    FlagP := parity(a96[7:0]);
                    FlagCY := !a96[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a112 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a112[7:0];
                  M[2077] := a112[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a113 = (-1 + a2) in
                  M[a113] := 05;
                  let:16 a114 = (-1 + a113) in
                  M[a114] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a115 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a116 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a117 = (~00 & 0F) in
                  let:16 a118 = addWithCarry(!true,a116,a117) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a119 = (M[(M[2067],a115[7:0])] & M[(M[2067],a115[7:0])]) in
                  let:8 a120 = (M[(M[2067],a115[7:0])] | M[(M[2067],a115[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a119)) {
                    let:16 a121 = (1 + a114) in
                    let:16 a122 = (1 + a121) in
                    advance (11)
                    A := a119;
                    B := a31;
                    C := a115[7:0];
                    D := 05;
                    H := M[2067];
                    L := a115[7:0];
                    SPH := a122[15:8];
                    SPL := a122[7:0];
                    FlagS := a119[7];
                    FlagZ := is_zero(a119);
                    FlagA := a120[3];
                    FlagP := parity(a119);
                    FlagCY := true;
                    jump ((M[a121],M[a114]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a123 = addWithCarry(false,0B,a115[7:0]) in
                    let:8 a124 = (0B & 0F) in
                    let:8 a125 = (a115[7:0] & 0F) in
                    let:16 a126 = addWithCarry(false,a124,a125) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a127 = addWithCarry(!true,05,~00) in
                    let:8 a128 = (05 & 0F) in
                    let:8 a129 = (~00 & 0F) in
                    let:16 a130 = addWithCarry(!true,a128,a129) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a127[7:0])) {
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a114[15:8];
                      SPL := a114[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a131 = (1 + a114) in
                      let:16 a132 = (1 + a131) in
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a132[15:8];
                      SPL := a132[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump ((M[a131],M[a114]));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            advance (13)
            #0587
            #instruction: CP   B
            let:16 a133 = addWithCarry(!false,M[20CF],~a29) in
            let:8 a134 = (M[20CF] & 0F) in
            let:8 a135 = (~a29 & 0F) in
            let:16 a136 = addWithCarry(!false,a134,a135) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a133[15:8][0]) {
              let:16 a137 = (1 + a2) in
              let:16 a138 = (1 + a137) in
              advance (11)
              A := M[20CF];
              B := a29;
              H := 20;
              L := 74;
              SPH := a138[15:8];
              SPL := a138[7:0];
              FlagS := a133[7:0][7];
              FlagZ := is_zero(a133[7:0]);
              FlagA := a136[7:0][4];
              FlagP := parity(a133[7:0]);
              FlagCY := !a133[15:8][0];
              jump ((M[a137],M[a2]));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a139 = (M[2071] & M[2071]) in
              let:8 a140 = (M[2071] | M[2071]) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a139)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a141 = (M[2075] & M[2075]) in
                let:8 a142 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a141)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a143 = addWithCarry(false,08,M[201B]) in
                  let:8 a144 = (08 & 0F) in
                  let:8 a145 = (M[201B] & 0F) in
                  let:16 a146 = addWithCarry(false,a144,a145) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a147 = (-1 + a2) in
                  M[a147] := 06;
                  let:16 a148 = (-1 + a147) in
                  M[a148] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a149 = (-1 + a148) in
                  M[a149] := 15;
                  let:16 a150 = (-1 + a149) in
                  M[a150] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a151 = addWithCarry(!false,M[200A],~a143[7:0]) in
                  let:8 a152 = (M[200A] & 0F) in
                  let:8 a153 = (~a143[7:0] & 0F) in
                  let:16 a154 = addWithCarry(!false,a152,a153) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a151[15:8][0]) {
                    let:16 a155 = (-1 + a150) in
                    M[a155] := 15;
                    let:16 a156 = (-1 + a155) in
                    M[a156] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a157 = addWithCarry(true,00,00) in
                    let:8 a158 = (00 & 0F) in
                    let:8 a159 = (00 & 0F) in
                    let:16 a160 = addWithCarry(true,a158,a159) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a161 = addWithCarry(false,10,M[200A]) in
                    let:8 a162 = (10 & 0F) in
                    let:8 a163 = (M[200A] & 0F) in
                    let:16 a164 = addWithCarry(false,a162,a163) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a161[7:0][7]) {
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a156[15:8];
                      SPL := a156[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a165 = (1 + a156) in
                      let:16 a166 = (1 + a165) in
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a166[15:8];
                      SPL := a166[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump ((M[a165],M[a156]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a29;
                    C := 00;
                    H := a143[7:0];
                    L := 75;
                    SPH := a150[15:8];
                    SPL := a150[7:0];
                    FlagS := a151[7:0][7];
                    FlagZ := is_zero(a151[7:0]);
                    FlagA := a154[7:0][4];
                    FlagP := parity(a151[7:0]);
                    FlagCY := !a151[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a167 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a167[7:0];
                  M[2077] := a167[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a168 = (-1 + a2) in
                  M[a168] := 05;
                  let:16 a169 = (-1 + a168) in
                  M[a169] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a170 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a171 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a172 = (~00 & 0F) in
                  let:16 a173 = addWithCarry(!true,a171,a172) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a174 = (M[(M[2067],a170[7:0])] & M[(M[2067],a170[7:0])]) in
                  let:8 a175 = (M[(M[2067],a170[7:0])] | M[(M[2067],a170[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a174)) {
                    let:16 a176 = (1 + a169) in
                    let:16 a177 = (1 + a176) in
                    advance (11)
                    A := a174;
                    B := a29;
                    C := a170[7:0];
                    D := 05;
                    H := M[2067];
                    L := a170[7:0];
                    SPH := a177[15:8];
                    SPL := a177[7:0];
                    FlagS := a174[7];
                    FlagZ := is_zero(a174);
                    FlagA := a175[3];
                    FlagP := parity(a174);
                    FlagCY := true;
                    jump ((M[a176],M[a169]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a178 = addWithCarry(false,0B,a170[7:0]) in
                    let:8 a179 = (0B & 0F) in
                    let:8 a180 = (a170[7:0] & 0F) in
                    let:16 a181 = addWithCarry(false,a179,a180) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a182 = addWithCarry(!true,05,~00) in
                    let:8 a183 = (05 & 0F) in
                    let:8 a184 = (~00 & 0F) in
                    let:16 a185 = addWithCarry(!true,a183,a184) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a182[7:0])) {
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a169[15:8];
                      SPL := a169[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a186 = (1 + a169) in
                      let:16 a187 = (1 + a186) in
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a187[15:8];
                      SPL := a187[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump ((M[a186],M[a169]));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                advance (13)
                #0594
                #instruction: CP   B
                let:16 a188 = addWithCarry(!false,M[20CF],~a139) in
                let:8 a189 = (M[20CF] & 0F) in
                let:8 a190 = (~a139 & 0F) in
                let:16 a191 = addWithCarry(!false,a189,a190) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a188[15:8][0]) {
                  let:16 a192 = (1 + a2) in
                  let:16 a193 = (1 + a192) in
                  advance (11)
                  A := M[20CF];
                  B := a139;
                  H := 20;
                  L := 74;
                  SPH := a193[15:8];
                  SPL := a193[7:0];
                  FlagS := a188[7:0][7];
                  FlagZ := is_zero(a188[7:0]);
                  FlagA := a191[7:0][4];
                  FlagP := parity(a188[7:0]);
                  FlagCY := !a188[15:8][0];
                  jump ((M[a192],M[a2]));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a194 = (M[2075] & M[2075]) in
                  let:8 a195 = (M[2075] | M[2075]) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a194)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:16 a196 = addWithCarry(false,08,M[201B]) in
                    let:8 a197 = (08 & 0F) in
                    let:8 a198 = (M[201B] & 0F) in
                    let:16 a199 = addWithCarry(false,a197,a198) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:16 a200 = (-1 + a2) in
                    M[a200] := 06;
                    let:16 a201 = (-1 + a200) in
                    M[a201] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:16 a202 = (-1 + a201) in
                    M[a202] := 15;
                    let:16 a203 = (-1 + a202) in
                    M[a203] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:16 a204 = addWithCarry(!false,M[200A],~a196[7:0]) in
                    let:8 a205 = (M[200A] & 0F) in
                    let:8 a206 = (~a196[7:0] & 0F) in
                    let:16 a207 = addWithCarry(!false,a205,a206) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a204[15:8][0]) {
                      let:16 a208 = (-1 + a203) in
                      M[a208] := 15;
                      let:16 a209 = (-1 + a208) in
                      M[a209] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a210 = addWithCarry(true,00,00) in
                      let:8 a211 = (00 & 0F) in
                      let:8 a212 = (00 & 0F) in
                      let:16 a213 = addWithCarry(true,a211,a212) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:16 a214 = addWithCarry(false,10,M[200A]) in
                      let:8 a215 = (10 & 0F) in
                      let:8 a216 = (M[200A] & 0F) in
                      let:16 a217 = addWithCarry(false,a215,a216) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a214[7:0][7]) {
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a209[15:8];
                        SPL := a209[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:16 a218 = (1 + a209) in
                        let:16 a219 = (1 + a218) in
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a219[15:8];
                        SPL := a219[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump ((M[a218],M[a209]));
                      }
                    } else {
                      advance (11)
                      A := M[200A];
                      B := a139;
                      C := 00;
                      H := a196[7:0];
                      L := 75;
                      SPH := a203[15:8];
                      SPL := a203[7:0];
                      FlagS := a204[7:0][7];
                      FlagZ := is_zero(a204[7:0]);
                      FlagA := a207[7:0][4];
                      FlagP := parity(a204[7:0]);
                      FlagCY := !a204[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:16 a220 = (1 + (M[2077],M[2076])) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    M[2076] := a220[7:0];
                    M[2077] := a220[15:8];
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:16 a221 = (-1 + a2) in
                    M[a221] := 05;
                    let:16 a222 = (-1 + a221) in
                    M[a222] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:16 a223 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                    let:8 a224 = (M[(M[2077],M[2076])] & 0F) in
                    let:8 a225 = (~00 & 0F) in
                    let:16 a226 = addWithCarry(!true,a224,a225) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a227 = (M[(M[2067],a223[7:0])] & M[(M[2067],a223[7:0])]) in
                    let:8 a228 = (M[(M[2067],a223[7:0])] | M[(M[2067],a223[7:0])]) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a227)) {
                      let:16 a229 = (1 + a222) in
                      let:16 a230 = (1 + a229) in
                      advance (11)
                      A := a227;
                      B := a139;
                      C := a223[7:0];
                      D := 05;
                      H := M[2067];
                      L := a223[7:0];
                      SPH := a230[15:8];
                      SPL := a230[7:0];
                      FlagS := a227[7];
                      FlagZ := is_zero(a227);
                      FlagA := a228[3];
                      FlagP := parity(a227);
                      FlagCY := true;
                      jump ((M[a229],M[a222]));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:16 a231 = addWithCarry(false,0B,a223[7:0]) in
                      let:8 a232 = (0B & 0F) in
                      let:8 a233 = (a223[7:0] & 0F) in
                      let:16 a234 = addWithCarry(false,a232,a233) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a235 = addWithCarry(!true,05,~00) in
                      let:8 a236 = (05 & 0F) in
                      let:8 a237 = (~00 & 0F) in
                      let:16 a238 = addWithCarry(!true,a236,a237) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a235[7:0])) {
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a222[15:8];
                        SPL := a222[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:16 a239 = (1 + a222) in
                        let:16 a240 = (1 + a239) in
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a240[15:8];
                        SPL := a240[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump ((M[a239],M[a222]));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

04D9:

    #instruction: LD   A,(2076)
    advance (13)
    #04DC
    #instruction: CP   10
    let:16 a1 = addWithCarry(!false,M[2076],~10) in
    let:8 a2 = (M[2076] & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #04DE
    #instruction: JP   CY,04E7
    if (!a1[15:8][0]) {
      advance (10)
      #04E7
      #instruction: LD   A,(2078)
      advance (13)
      #04EA
      #instruction: AND  A
      let:8 a5 = (M[2078] & M[2078]) in
      let:8 a6 = (M[2078] | M[2078]) in
      advance (4)
      #04EB
      #instruction: LD   HL,2045
      advance (10)
      #04EE
      #instruction: JP   NZ,055B
      if (!is_zero(a5)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2045] := M[2073];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a7 = addWithCarry(!true,0B,~00) in
        let:8 a8 = (0B & 0F) in
        let:8 a9 = (~00 & 0F) in
        let:16 a10 = addWithCarry(!true,a8,a9) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a7[7:0])) {
          advance (10)
          A := M[2073];
          B := a7[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          FlagS := a7[7:0][7];
          FlagZ := is_zero(a7[7:0]);
          FlagA := a10[7:0][4];
          FlagP := parity(a7[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a11 = (1 + (SPH,SPL)) in
          let:16 a12 = (1 + a11) in
          advance (10)
          A := M[2073];
          B := a7[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a7[7:0][7];
          FlagZ := is_zero(a7[7:0]);
          FlagA := a10[7:0][4];
          FlagP := parity(a7[7:0]);
          FlagCY := false;
          jump ((M[a11],M[(SPH,SPL)]));
        }
      } else {
        advance (10)
        #04F1
        #instruction: LD   DE,1B40
        advance (10)
        #04F4
        #instruction: LD   HL,2040
        advance (10)
        #04F7
        #instruction: LD   B,10
        advance (7)
        #04F9
        #instruction: CALL 1A32
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 04;
        let:16 a14 = (-1 + a13) in
        M[a14] := FC;
        #return-to: 04FC
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2040] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a15 = addWithCarry(!true,10,~00) in
        let:8 a16 = (10 & 0F) in
        let:8 a17 = (~00 & 0F) in
        let:16 a18 = addWithCarry(!true,a16,a17) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a15[7:0])) {
          advance (10)
          A := 00;
          B := a15[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a19 = (1 + a14) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := 00;
          B := a15[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := false;
          jump ((M[a19],M[a14]));
        }
      }
    } else {
      advance (10)
      #04E1
      #instruction: LD   A,(1B48)
      advance (13)
      #04E4
      #instruction: LD   (2076),A
      M[2076] := 00;
      advance (13)
      #04E7
      #instruction: LD   A,(2078)
      advance (13)
      #04EA
      #instruction: AND  A
      let:8 a21 = (M[2078] & M[2078]) in
      let:8 a22 = (M[2078] | M[2078]) in
      advance (4)
      #04EB
      #instruction: LD   HL,2045
      advance (10)
      #04EE
      #instruction: JP   NZ,055B
      if (!is_zero(a21)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2045] := M[2073];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a23 = addWithCarry(!true,0B,~00) in
        let:8 a24 = (0B & 0F) in
        let:8 a25 = (~00 & 0F) in
        let:16 a26 = addWithCarry(!true,a24,a25) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a23[7:0])) {
          advance (10)
          A := M[2073];
          B := a23[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          FlagS := a23[7:0][7];
          FlagZ := is_zero(a23[7:0]);
          FlagA := a26[7:0][4];
          FlagP := parity(a23[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a27 = (1 + (SPH,SPL)) in
          let:16 a28 = (1 + a27) in
          advance (10)
          A := M[2073];
          B := a23[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a23[7:0][7];
          FlagZ := is_zero(a23[7:0]);
          FlagA := a26[7:0][4];
          FlagP := parity(a23[7:0]);
          FlagCY := false;
          jump ((M[a27],M[(SPH,SPL)]));
        }
      } else {
        advance (10)
        #04F1
        #instruction: LD   DE,1B40
        advance (10)
        #04F4
        #instruction: LD   HL,2040
        advance (10)
        #04F7
        #instruction: LD   B,10
        advance (7)
        #04F9
        #instruction: CALL 1A32
        let:16 a29 = (-1 + (SPH,SPL)) in
        M[a29] := 04;
        let:16 a30 = (-1 + a29) in
        M[a30] := FC;
        #return-to: 04FC
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2040] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a31 = addWithCarry(!true,10,~00) in
        let:8 a32 = (10 & 0F) in
        let:8 a33 = (~00 & 0F) in
        let:16 a34 = addWithCarry(!true,a32,a33) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a31[7:0])) {
          advance (10)
          A := 00;
          B := a31[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a30[15:8];
          SPL := a30[7:0];
          FlagS := a31[7:0][7];
          FlagZ := is_zero(a31[7:0]);
          FlagA := a34[7:0][4];
          FlagP := parity(a31[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a35 = (1 + a30) in
          let:16 a36 = (1 + a35) in
          advance (10)
          A := 00;
          B := a31[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a36[15:8];
          SPL := a36[7:0];
          FlagS := a31[7:0][7];
          FlagZ := is_zero(a31[7:0]);
          FlagA := a34[7:0][4];
          FlagP := parity(a31[7:0]);
          FlagCY := false;
          jump ((M[a35],M[a30]));
        }
      }
    }

04FC:

    #instruction: LD   A,(2082)
    advance (13)
    #04FF
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,M[2082],~00) in
    let:8 a2 = (M[2082] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #0500
    #instruction: JP   NZ,0508
    if (!is_zero(a1[7:0])) {
      advance (10)
      #0508
      #instruction: LD   HL,(2076)
      advance (16)
      #050B
      #instruction: JP   067E
      advance (10)
      #067E
      #instruction: LD   (2048),HL
      M[2048] := M[2076];
      M[2049] := M[2077];
      advance (16)
      #0681
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a1[7:0];
      H := M[2077];
      L := M[2076];
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump ((M[a5],M[(SPH,SPL)]));
    } else {
      advance (10)
      #0503
      #instruction: LD   A,01
      advance (7)
      #0505
      #instruction: LD   (206E),A
      M[206E] := 01;
      advance (13)
      #0508
      #instruction: LD   HL,(2076)
      advance (16)
      #050B
      #instruction: JP   067E
      advance (10)
      #067E
      #instruction: LD   (2048),HL
      M[2048] := M[2076];
      M[2049] := M[2077];
      advance (16)
      #0681
      #instruction: RET
      let:16 a7 = (1 + (SPH,SPL)) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 01;
      H := M[2077];
      L := M[2076];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump ((M[a7],M[(SPH,SPL)]));
    }

050E:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #050F
    #instruction: LD   DE,2055
    advance (10)
    #0512
    #instruction: LD   A,DB
    advance (7)
    #0514
    #instruction: CALL 0550
    let:16 a3 = (-1 + a2) in
    M[a3] := 05;
    let:16 a4 = (-1 + a3) in
    M[a4] := 17;
    #return-to: 0517
    advance (17)
    #0550
    #instruction: LD   (207F),A
    M[207F] := DB;
    advance (13)
    #0553
    #instruction: LD   HL,2073
    advance (10)
    #0556
    #instruction: LD   B,0B
    advance (7)
    #0558
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2073] := M[2055];
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a5 = addWithCarry(!true,0B,~00) in
    let:8 a6 = (0B & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := M[2055];
      B := a5[7:0];
      D := 20;
      E := 56;
      H := 20;
      L := 74;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := M[2055];
      B := a5[7:0];
      D := 20;
      E := 56;
      H := 20;
      L := 74;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump ((M[a9],M[a4]));
    }

0517:

    #instruction: LD   A,(2046)
    advance (13)
    #051A
    #instruction: LD   (2070),A
    M[2070] := M[2046];
    advance (13)
    #051D
    #instruction: LD   A,(2036)
    advance (13)
    #0520
    #instruction: LD   (2071),A
    M[2071] := M[2036];
    advance (13)
    #0523
    #instruction: CALL 0563
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 05;
    let:16 a2 = (-1 + a1) in
    M[a2] := 26;
    #return-to: 0526
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a3 = (80 & M[2073]) in
    let:8 a4 = (80 | M[2073]) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a3)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:16 a5 = (-1 + a2) in
      M[a5] := 05;
      let:16 a6 = (-1 + a5) in
      M[a6] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a7 = (80 & M[207C]) in
      let:8 a8 = (80 | M[207C]) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a9 = (M[2072] ^ a7) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a9)) {
        let:16 a10 = (1 + a6) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a6]));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:16 a12 = (1 + a6) in
        let:16 a13 = (1 + a12) in
        advance (10)
        A := a9;
        B := M[2072];
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a13[15:8];
        SPL := a13[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := true;
        jump ((M[a12],M[a6]));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      advance (13)
      #056F
      #instruction: CP   04
      let:16 a14 = addWithCarry(!false,M[20C1],~04) in
      let:8 a15 = (M[20C1] & 0F) in
      let:8 a16 = (~04 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a14[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a18 = (80 | M[2073]) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        M[2073] := a18;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:16 a19 = addWithCarry(true,M[2074],00) in
        let:8 a20 = (M[2074] & 0F) in
        let:8 a21 = (00 & 0F) in
        let:16 a22 = addWithCarry(true,a20,a21) in
        M[2074] := a19[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:16 a23 = (1 + a2) in
        let:16 a24 = (1 + a23) in
        advance (10)
        A := a18;
        H := 20;
        L := 74;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a19[7:0][7];
        FlagZ := is_zero(a19[7:0]);
        FlagA := a22[7:0][4];
        FlagP := parity(a19[7:0]);
        FlagCY := false;
        jump ((M[a23],M[a2]));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a25 = (M[2069] & M[2069]) in
        let:8 a26 = (M[2069] | M[2069]) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a25)) {
          let:16 a27 = (1 + a2) in
          let:16 a28 = (1 + a27) in
          advance (11)
          A := a25;
          H := 20;
          L := 73;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a25[7];
          FlagZ := is_zero(a25);
          FlagA := a26[3];
          FlagP := parity(a25);
          FlagCY := false;
          jump ((M[a27],M[a2]));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a29 = (M[2070] & M[2070]) in
          let:8 a30 = (M[2070] | M[2070]) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a29)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a31 = (M[2071] & M[2071]) in
            let:8 a32 = (M[2071] | M[2071]) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a31)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a33 = (M[2075] & M[2075]) in
              let:8 a34 = (M[2075] | M[2075]) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a33)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                advance (13)
                #061E
                #instruction: ADD  08
                let:16 a35 = addWithCarry(false,08,M[201B]) in
                let:8 a36 = (08 & 0F) in
                let:8 a37 = (M[201B] & 0F) in
                let:16 a38 = addWithCarry(false,a36,a37) in
                advance (7)
                #0620
                #instruction: LD   H,A
                advance (5)
                #0621
                #instruction: CALL 156F
                let:16 a39 = (-1 + a2) in
                M[a39] := 06;
                let:16 a40 = (-1 + a39) in
                M[a40] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                advance (13)
                #1572
                #instruction: CALL 1554
                let:16 a41 = (-1 + a40) in
                M[a41] := 15;
                let:16 a42 = (-1 + a41) in
                M[a42] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:16 a43 = addWithCarry(!false,M[200A],~a35[7:0]) in
                let:8 a44 = (M[200A] & 0F) in
                let:8 a45 = (~a35[7:0] & 0F) in
                let:16 a46 = addWithCarry(!false,a44,a45) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a43[15:8][0]) {
                  let:16 a47 = (-1 + a42) in
                  M[a47] := 15;
                  let:16 a48 = (-1 + a47) in
                  M[a48] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a49 = addWithCarry(true,00,00) in
                  let:8 a50 = (00 & 0F) in
                  let:8 a51 = (00 & 0F) in
                  let:16 a52 = addWithCarry(true,a50,a51) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:16 a53 = addWithCarry(false,10,M[200A]) in
                  let:8 a54 = (10 & 0F) in
                  let:8 a55 = (M[200A] & 0F) in
                  let:16 a56 = addWithCarry(false,a54,a55) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a53[7:0][7]) {
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a48[15:8];
                    SPL := a48[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:16 a57 = (1 + a48) in
                    let:16 a58 = (1 + a57) in
                    advance (10)
                    A := a53[7:0];
                    C := a49[7:0];
                    H := a35[7:0];
                    L := 75;
                    SPH := a58[15:8];
                    SPL := a58[7:0];
                    FlagS := a53[7:0][7];
                    FlagZ := is_zero(a53[7:0]);
                    FlagA := a56[7:0][4];
                    FlagP := parity(a53[7:0]);
                    FlagCY := a53[15:8][0];
                    jump ((M[a57],M[a48]));
                  }
                } else {
                  advance (11)
                  A := M[200A];
                  C := 00;
                  H := a35[7:0];
                  L := 75;
                  SPH := a42[15:8];
                  SPL := a42[7:0];
                  FlagS := a43[7:0][7];
                  FlagZ := is_zero(a43[7:0]);
                  FlagA := a46[7:0][4];
                  FlagP := parity(a43[7:0]);
                  FlagCY := !a43[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                advance (7)
                #05A0
                #instruction: INC  HL
                let:16 a59 = (1 + (M[2077],M[2076])) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                M[2076] := a59[7:0];
                M[2077] := a59[15:8];
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:16 a60 = (-1 + a2) in
                M[a60] := 05;
                let:16 a61 = (-1 + a60) in
                M[a61] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:16 a62 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                let:8 a63 = (M[(M[2077],M[2076])] & 0F) in
                let:8 a64 = (~00 & 0F) in
                let:16 a65 = addWithCarry(!true,a63,a64) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                advance (13)
                #0633
                #instruction: LD   H,A
                advance (5)
                #0634
                #instruction: LD   L,C
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a66 = (M[(M[2067],a62[7:0])] & M[(M[2067],a62[7:0])]) in
                let:8 a67 = (M[(M[2067],a62[7:0])] | M[(M[2067],a62[7:0])]) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a66)) {
                  let:16 a68 = (1 + a61) in
                  let:16 a69 = (1 + a68) in
                  advance (11)
                  A := a66;
                  C := a62[7:0];
                  D := 05;
                  H := M[2067];
                  L := a62[7:0];
                  SPH := a69[15:8];
                  SPL := a69[7:0];
                  FlagS := a66[7];
                  FlagZ := is_zero(a66);
                  FlagA := a67[3];
                  FlagP := parity(a66);
                  FlagCY := true;
                  jump ((M[a68],M[a61]));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:16 a70 = addWithCarry(false,0B,a62[7:0]) in
                  let:8 a71 = (0B & 0F) in
                  let:8 a72 = (a62[7:0] & 0F) in
                  let:16 a73 = addWithCarry(false,a71,a72) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a74 = addWithCarry(!true,05,~00) in
                  let:8 a75 = (05 & 0F) in
                  let:8 a76 = (~00 & 0F) in
                  let:16 a77 = addWithCarry(!true,a75,a76) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a74[7:0])) {
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a61[15:8];
                    SPL := a61[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:16 a78 = (1 + a61) in
                    let:16 a79 = (1 + a78) in
                    advance (10)
                    A := a70[7:0];
                    C := a62[7:0];
                    D := a74[7:0];
                    H := M[2067];
                    L := a70[7:0];
                    SPH := a79[15:8];
                    SPL := a79[7:0];
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := a70[15:8][0];
                    jump ((M[a78],M[a61]));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              advance (13)
              #0594
              #instruction: CP   B
              let:16 a80 = addWithCarry(!false,M[20CF],~a31) in
              let:8 a81 = (M[20CF] & 0F) in
              let:8 a82 = (~a31 & 0F) in
              let:16 a83 = addWithCarry(!false,a81,a82) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a80[15:8][0]) {
                let:16 a84 = (1 + a2) in
                let:16 a85 = (1 + a84) in
                advance (11)
                A := M[20CF];
                B := a31;
                H := 20;
                L := 74;
                SPH := a85[15:8];
                SPL := a85[7:0];
                FlagS := a80[7:0][7];
                FlagZ := is_zero(a80[7:0]);
                FlagA := a83[7:0][4];
                FlagP := parity(a80[7:0]);
                FlagCY := !a80[15:8][0];
                jump ((M[a84],M[a2]));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a86 = (M[2075] & M[2075]) in
                let:8 a87 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a86)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a88 = addWithCarry(false,08,M[201B]) in
                  let:8 a89 = (08 & 0F) in
                  let:8 a90 = (M[201B] & 0F) in
                  let:16 a91 = addWithCarry(false,a89,a90) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a92 = (-1 + a2) in
                  M[a92] := 06;
                  let:16 a93 = (-1 + a92) in
                  M[a93] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a94 = (-1 + a93) in
                  M[a94] := 15;
                  let:16 a95 = (-1 + a94) in
                  M[a95] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a96 = addWithCarry(!false,M[200A],~a88[7:0]) in
                  let:8 a97 = (M[200A] & 0F) in
                  let:8 a98 = (~a88[7:0] & 0F) in
                  let:16 a99 = addWithCarry(!false,a97,a98) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a96[15:8][0]) {
                    let:16 a100 = (-1 + a95) in
                    M[a100] := 15;
                    let:16 a101 = (-1 + a100) in
                    M[a101] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a102 = addWithCarry(true,00,00) in
                    let:8 a103 = (00 & 0F) in
                    let:8 a104 = (00 & 0F) in
                    let:16 a105 = addWithCarry(true,a103,a104) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a106 = addWithCarry(false,10,M[200A]) in
                    let:8 a107 = (10 & 0F) in
                    let:8 a108 = (M[200A] & 0F) in
                    let:16 a109 = addWithCarry(false,a107,a108) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a106[7:0][7]) {
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a101[15:8];
                      SPL := a101[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a110 = (1 + a101) in
                      let:16 a111 = (1 + a110) in
                      advance (10)
                      A := a106[7:0];
                      B := a31;
                      C := a102[7:0];
                      H := a88[7:0];
                      L := 75;
                      SPH := a111[15:8];
                      SPL := a111[7:0];
                      FlagS := a106[7:0][7];
                      FlagZ := is_zero(a106[7:0]);
                      FlagA := a109[7:0][4];
                      FlagP := parity(a106[7:0]);
                      FlagCY := a106[15:8][0];
                      jump ((M[a110],M[a101]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a31;
                    C := 00;
                    H := a88[7:0];
                    L := 75;
                    SPH := a95[15:8];
                    SPL := a95[7:0];
                    FlagS := a96[7:0][7];
                    FlagZ := is_zero(a96[7:0]);
                    FlagA := a99[7:0][4];
                    FlagP := parity(a96[7:0]);
                    FlagCY := !a96[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a112 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a112[7:0];
                  M[2077] := a112[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a113 = (-1 + a2) in
                  M[a113] := 05;
                  let:16 a114 = (-1 + a113) in
                  M[a114] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a115 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a116 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a117 = (~00 & 0F) in
                  let:16 a118 = addWithCarry(!true,a116,a117) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a119 = (M[(M[2067],a115[7:0])] & M[(M[2067],a115[7:0])]) in
                  let:8 a120 = (M[(M[2067],a115[7:0])] | M[(M[2067],a115[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a119)) {
                    let:16 a121 = (1 + a114) in
                    let:16 a122 = (1 + a121) in
                    advance (11)
                    A := a119;
                    B := a31;
                    C := a115[7:0];
                    D := 05;
                    H := M[2067];
                    L := a115[7:0];
                    SPH := a122[15:8];
                    SPL := a122[7:0];
                    FlagS := a119[7];
                    FlagZ := is_zero(a119);
                    FlagA := a120[3];
                    FlagP := parity(a119);
                    FlagCY := true;
                    jump ((M[a121],M[a114]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a123 = addWithCarry(false,0B,a115[7:0]) in
                    let:8 a124 = (0B & 0F) in
                    let:8 a125 = (a115[7:0] & 0F) in
                    let:16 a126 = addWithCarry(false,a124,a125) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a127 = addWithCarry(!true,05,~00) in
                    let:8 a128 = (05 & 0F) in
                    let:8 a129 = (~00 & 0F) in
                    let:16 a130 = addWithCarry(!true,a128,a129) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a127[7:0])) {
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a114[15:8];
                      SPL := a114[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a131 = (1 + a114) in
                      let:16 a132 = (1 + a131) in
                      advance (10)
                      A := a123[7:0];
                      B := a31;
                      C := a115[7:0];
                      D := a127[7:0];
                      H := M[2067];
                      L := a123[7:0];
                      SPH := a132[15:8];
                      SPL := a132[7:0];
                      FlagS := a127[7:0][7];
                      FlagZ := is_zero(a127[7:0]);
                      FlagA := a130[7:0][4];
                      FlagP := parity(a127[7:0]);
                      FlagCY := a123[15:8][0];
                      jump ((M[a131],M[a114]));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            advance (13)
            #0587
            #instruction: CP   B
            let:16 a133 = addWithCarry(!false,M[20CF],~a29) in
            let:8 a134 = (M[20CF] & 0F) in
            let:8 a135 = (~a29 & 0F) in
            let:16 a136 = addWithCarry(!false,a134,a135) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a133[15:8][0]) {
              let:16 a137 = (1 + a2) in
              let:16 a138 = (1 + a137) in
              advance (11)
              A := M[20CF];
              B := a29;
              H := 20;
              L := 74;
              SPH := a138[15:8];
              SPL := a138[7:0];
              FlagS := a133[7:0][7];
              FlagZ := is_zero(a133[7:0]);
              FlagA := a136[7:0][4];
              FlagP := parity(a133[7:0]);
              FlagCY := !a133[15:8][0];
              jump ((M[a137],M[a2]));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a139 = (M[2071] & M[2071]) in
              let:8 a140 = (M[2071] | M[2071]) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a139)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a141 = (M[2075] & M[2075]) in
                let:8 a142 = (M[2075] | M[2075]) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a141)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:16 a143 = addWithCarry(false,08,M[201B]) in
                  let:8 a144 = (08 & 0F) in
                  let:8 a145 = (M[201B] & 0F) in
                  let:16 a146 = addWithCarry(false,a144,a145) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:16 a147 = (-1 + a2) in
                  M[a147] := 06;
                  let:16 a148 = (-1 + a147) in
                  M[a148] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:16 a149 = (-1 + a148) in
                  M[a149] := 15;
                  let:16 a150 = (-1 + a149) in
                  M[a150] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a151 = addWithCarry(!false,M[200A],~a143[7:0]) in
                  let:8 a152 = (M[200A] & 0F) in
                  let:8 a153 = (~a143[7:0] & 0F) in
                  let:16 a154 = addWithCarry(!false,a152,a153) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a151[15:8][0]) {
                    let:16 a155 = (-1 + a150) in
                    M[a155] := 15;
                    let:16 a156 = (-1 + a155) in
                    M[a156] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a157 = addWithCarry(true,00,00) in
                    let:8 a158 = (00 & 0F) in
                    let:8 a159 = (00 & 0F) in
                    let:16 a160 = addWithCarry(true,a158,a159) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a161 = addWithCarry(false,10,M[200A]) in
                    let:8 a162 = (10 & 0F) in
                    let:8 a163 = (M[200A] & 0F) in
                    let:16 a164 = addWithCarry(false,a162,a163) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a161[7:0][7]) {
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a156[15:8];
                      SPL := a156[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a165 = (1 + a156) in
                      let:16 a166 = (1 + a165) in
                      advance (10)
                      A := a161[7:0];
                      B := a29;
                      C := a157[7:0];
                      H := a143[7:0];
                      L := 75;
                      SPH := a166[15:8];
                      SPL := a166[7:0];
                      FlagS := a161[7:0][7];
                      FlagZ := is_zero(a161[7:0]);
                      FlagA := a164[7:0][4];
                      FlagP := parity(a161[7:0]);
                      FlagCY := a161[15:8][0];
                      jump ((M[a165],M[a156]));
                    }
                  } else {
                    advance (11)
                    A := M[200A];
                    B := a29;
                    C := 00;
                    H := a143[7:0];
                    L := 75;
                    SPH := a150[15:8];
                    SPL := a150[7:0];
                    FlagS := a151[7:0][7];
                    FlagZ := is_zero(a151[7:0]);
                    FlagA := a154[7:0][4];
                    FlagP := parity(a151[7:0]);
                    FlagCY := !a151[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:16 a167 = (1 + (M[2077],M[2076])) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  M[2076] := a167[7:0];
                  M[2077] := a167[15:8];
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:16 a168 = (-1 + a2) in
                  M[a168] := 05;
                  let:16 a169 = (-1 + a168) in
                  M[a169] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:16 a170 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                  let:8 a171 = (M[(M[2077],M[2076])] & 0F) in
                  let:8 a172 = (~00 & 0F) in
                  let:16 a173 = addWithCarry(!true,a171,a172) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a174 = (M[(M[2067],a170[7:0])] & M[(M[2067],a170[7:0])]) in
                  let:8 a175 = (M[(M[2067],a170[7:0])] | M[(M[2067],a170[7:0])]) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a174)) {
                    let:16 a176 = (1 + a169) in
                    let:16 a177 = (1 + a176) in
                    advance (11)
                    A := a174;
                    B := a29;
                    C := a170[7:0];
                    D := 05;
                    H := M[2067];
                    L := a170[7:0];
                    SPH := a177[15:8];
                    SPL := a177[7:0];
                    FlagS := a174[7];
                    FlagZ := is_zero(a174);
                    FlagA := a175[3];
                    FlagP := parity(a174);
                    FlagCY := true;
                    jump ((M[a176],M[a169]));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:16 a178 = addWithCarry(false,0B,a170[7:0]) in
                    let:8 a179 = (0B & 0F) in
                    let:8 a180 = (a170[7:0] & 0F) in
                    let:16 a181 = addWithCarry(false,a179,a180) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a182 = addWithCarry(!true,05,~00) in
                    let:8 a183 = (05 & 0F) in
                    let:8 a184 = (~00 & 0F) in
                    let:16 a185 = addWithCarry(!true,a183,a184) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a182[7:0])) {
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a169[15:8];
                      SPL := a169[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:16 a186 = (1 + a169) in
                      let:16 a187 = (1 + a186) in
                      advance (10)
                      A := a178[7:0];
                      B := a29;
                      C := a170[7:0];
                      D := a182[7:0];
                      H := M[2067];
                      L := a178[7:0];
                      SPH := a187[15:8];
                      SPL := a187[7:0];
                      FlagS := a182[7:0][7];
                      FlagZ := is_zero(a182[7:0]);
                      FlagA := a185[7:0][4];
                      FlagP := parity(a182[7:0]);
                      FlagCY := a178[15:8][0];
                      jump ((M[a186],M[a169]));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                advance (13)
                #0594
                #instruction: CP   B
                let:16 a188 = addWithCarry(!false,M[20CF],~a139) in
                let:8 a189 = (M[20CF] & 0F) in
                let:8 a190 = (~a139 & 0F) in
                let:16 a191 = addWithCarry(!false,a189,a190) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a188[15:8][0]) {
                  let:16 a192 = (1 + a2) in
                  let:16 a193 = (1 + a192) in
                  advance (11)
                  A := M[20CF];
                  B := a139;
                  H := 20;
                  L := 74;
                  SPH := a193[15:8];
                  SPL := a193[7:0];
                  FlagS := a188[7:0][7];
                  FlagZ := is_zero(a188[7:0]);
                  FlagA := a191[7:0][4];
                  FlagP := parity(a188[7:0]);
                  FlagCY := !a188[15:8][0];
                  jump ((M[a192],M[a2]));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a194 = (M[2075] & M[2075]) in
                  let:8 a195 = (M[2075] | M[2075]) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a194)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:16 a196 = addWithCarry(false,08,M[201B]) in
                    let:8 a197 = (08 & 0F) in
                    let:8 a198 = (M[201B] & 0F) in
                    let:16 a199 = addWithCarry(false,a197,a198) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:16 a200 = (-1 + a2) in
                    M[a200] := 06;
                    let:16 a201 = (-1 + a200) in
                    M[a201] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:16 a202 = (-1 + a201) in
                    M[a202] := 15;
                    let:16 a203 = (-1 + a202) in
                    M[a203] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:16 a204 = addWithCarry(!false,M[200A],~a196[7:0]) in
                    let:8 a205 = (M[200A] & 0F) in
                    let:8 a206 = (~a196[7:0] & 0F) in
                    let:16 a207 = addWithCarry(!false,a205,a206) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a204[15:8][0]) {
                      let:16 a208 = (-1 + a203) in
                      M[a208] := 15;
                      let:16 a209 = (-1 + a208) in
                      M[a209] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a210 = addWithCarry(true,00,00) in
                      let:8 a211 = (00 & 0F) in
                      let:8 a212 = (00 & 0F) in
                      let:16 a213 = addWithCarry(true,a211,a212) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:16 a214 = addWithCarry(false,10,M[200A]) in
                      let:8 a215 = (10 & 0F) in
                      let:8 a216 = (M[200A] & 0F) in
                      let:16 a217 = addWithCarry(false,a215,a216) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a214[7:0][7]) {
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a209[15:8];
                        SPL := a209[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:16 a218 = (1 + a209) in
                        let:16 a219 = (1 + a218) in
                        advance (10)
                        A := a214[7:0];
                        B := a139;
                        C := a210[7:0];
                        H := a196[7:0];
                        L := 75;
                        SPH := a219[15:8];
                        SPL := a219[7:0];
                        FlagS := a214[7:0][7];
                        FlagZ := is_zero(a214[7:0]);
                        FlagA := a217[7:0][4];
                        FlagP := parity(a214[7:0]);
                        FlagCY := a214[15:8][0];
                        jump ((M[a218],M[a209]));
                      }
                    } else {
                      advance (11)
                      A := M[200A];
                      B := a139;
                      C := 00;
                      H := a196[7:0];
                      L := 75;
                      SPH := a203[15:8];
                      SPL := a203[7:0];
                      FlagS := a204[7:0][7];
                      FlagZ := is_zero(a204[7:0]);
                      FlagA := a207[7:0][4];
                      FlagP := parity(a204[7:0]);
                      FlagCY := !a204[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:16 a220 = (1 + (M[2077],M[2076])) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    M[2076] := a220[7:0];
                    M[2077] := a220[15:8];
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:16 a221 = (-1 + a2) in
                    M[a221] := 05;
                    let:16 a222 = (-1 + a221) in
                    M[a222] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:16 a223 = addWithCarry(!true,M[(M[2077],M[2076])],~00) in
                    let:8 a224 = (M[(M[2077],M[2076])] & 0F) in
                    let:8 a225 = (~00 & 0F) in
                    let:16 a226 = addWithCarry(!true,a224,a225) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a227 = (M[(M[2067],a223[7:0])] & M[(M[2067],a223[7:0])]) in
                    let:8 a228 = (M[(M[2067],a223[7:0])] | M[(M[2067],a223[7:0])]) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a227)) {
                      let:16 a229 = (1 + a222) in
                      let:16 a230 = (1 + a229) in
                      advance (11)
                      A := a227;
                      B := a139;
                      C := a223[7:0];
                      D := 05;
                      H := M[2067];
                      L := a223[7:0];
                      SPH := a230[15:8];
                      SPL := a230[7:0];
                      FlagS := a227[7];
                      FlagZ := is_zero(a227);
                      FlagA := a228[3];
                      FlagP := parity(a227);
                      FlagCY := true;
                      jump ((M[a229],M[a222]));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:16 a231 = addWithCarry(false,0B,a223[7:0]) in
                      let:8 a232 = (0B & 0F) in
                      let:8 a233 = (a223[7:0] & 0F) in
                      let:16 a234 = addWithCarry(false,a232,a233) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a235 = addWithCarry(!true,05,~00) in
                      let:8 a236 = (05 & 0F) in
                      let:8 a237 = (~00 & 0F) in
                      let:16 a238 = addWithCarry(!true,a236,a237) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a235[7:0])) {
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a222[15:8];
                        SPL := a222[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:16 a239 = (1 + a222) in
                        let:16 a240 = (1 + a239) in
                        advance (10)
                        A := a231[7:0];
                        B := a139;
                        C := a223[7:0];
                        D := a235[7:0];
                        H := M[2067];
                        L := a231[7:0];
                        SPH := a240[15:8];
                        SPL := a240[7:0];
                        FlagS := a235[7:0][7];
                        FlagZ := is_zero(a235[7:0]);
                        FlagA := a238[7:0][4];
                        FlagP := parity(a235[7:0]);
                        FlagCY := a231[15:8][0];
                        jump ((M[a239],M[a222]));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

0526:

    #instruction: LD   A,(2076)
    advance (13)
    #0529
    #instruction: CP   15
    let:16 a1 = addWithCarry(!false,M[2076],~15) in
    let:8 a2 = (M[2076] & 0F) in
    let:8 a3 = (~15 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #052B
    #instruction: JP   CY,0534
    if (!a1[15:8][0]) {
      advance (10)
      #0534
      #instruction: LD   A,(2078)
      advance (13)
      #0537
      #instruction: AND  A
      let:8 a5 = (M[2078] & M[2078]) in
      let:8 a6 = (M[2078] | M[2078]) in
      advance (4)
      #0538
      #instruction: LD   HL,2055
      advance (10)
      #053B
      #instruction: JP   NZ,055B
      if (!is_zero(a5)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2055] := M[2073];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a7 = addWithCarry(!true,0B,~00) in
        let:8 a8 = (0B & 0F) in
        let:8 a9 = (~00 & 0F) in
        let:16 a10 = addWithCarry(!true,a8,a9) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a7[7:0])) {
          advance (10)
          A := M[2073];
          B := a7[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          FlagS := a7[7:0][7];
          FlagZ := is_zero(a7[7:0]);
          FlagA := a10[7:0][4];
          FlagP := parity(a7[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a11 = (1 + (SPH,SPL)) in
          let:16 a12 = (1 + a11) in
          advance (10)
          A := M[2073];
          B := a7[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a7[7:0][7];
          FlagZ := is_zero(a7[7:0]);
          FlagA := a10[7:0][4];
          FlagP := parity(a7[7:0]);
          FlagCY := false;
          jump ((M[a11],M[(SPH,SPL)]));
        }
      } else {
        advance (10)
        #053E
        #instruction: LD   DE,1B50
        advance (10)
        #0541
        #instruction: LD   HL,2050
        advance (10)
        #0544
        #instruction: LD   B,10
        advance (7)
        #0546
        #instruction: CALL 1A32
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 05;
        let:16 a14 = (-1 + a13) in
        M[a14] := 49;
        #return-to: 0549
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2050] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a15 = addWithCarry(!true,10,~00) in
        let:8 a16 = (10 & 0F) in
        let:8 a17 = (~00 & 0F) in
        let:16 a18 = addWithCarry(!true,a16,a17) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a15[7:0])) {
          advance (10)
          A := 00;
          B := a15[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a19 = (1 + a14) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := 00;
          B := a15[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := false;
          jump ((M[a19],M[a14]));
        }
      }
    } else {
      advance (10)
      #052E
      #instruction: LD   A,(1B58)
      advance (13)
      #0531
      #instruction: LD   (2076),A
      M[2076] := 06;
      advance (13)
      #0534
      #instruction: LD   A,(2078)
      advance (13)
      #0537
      #instruction: AND  A
      let:8 a21 = (M[2078] & M[2078]) in
      let:8 a22 = (M[2078] | M[2078]) in
      advance (4)
      #0538
      #instruction: LD   HL,2055
      advance (10)
      #053B
      #instruction: JP   NZ,055B
      if (!is_zero(a21)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2055] := M[2073];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a23 = addWithCarry(!true,0B,~00) in
        let:8 a24 = (0B & 0F) in
        let:8 a25 = (~00 & 0F) in
        let:16 a26 = addWithCarry(!true,a24,a25) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a23[7:0])) {
          advance (10)
          A := M[2073];
          B := a23[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          FlagS := a23[7:0][7];
          FlagZ := is_zero(a23[7:0]);
          FlagA := a26[7:0][4];
          FlagP := parity(a23[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a27 = (1 + (SPH,SPL)) in
          let:16 a28 = (1 + a27) in
          advance (10)
          A := M[2073];
          B := a23[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a23[7:0][7];
          FlagZ := is_zero(a23[7:0]);
          FlagA := a26[7:0][4];
          FlagP := parity(a23[7:0]);
          FlagCY := false;
          jump ((M[a27],M[(SPH,SPL)]));
        }
      } else {
        advance (10)
        #053E
        #instruction: LD   DE,1B50
        advance (10)
        #0541
        #instruction: LD   HL,2050
        advance (10)
        #0544
        #instruction: LD   B,10
        advance (7)
        #0546
        #instruction: CALL 1A32
        let:16 a29 = (-1 + (SPH,SPL)) in
        M[a29] := 05;
        let:16 a30 = (-1 + a29) in
        M[a30] := 49;
        #return-to: 0549
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2050] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a31 = addWithCarry(!true,10,~00) in
        let:8 a32 = (10 & 0F) in
        let:8 a33 = (~00 & 0F) in
        let:16 a34 = addWithCarry(!true,a32,a33) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a31[7:0])) {
          advance (10)
          A := 00;
          B := a31[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a30[15:8];
          SPL := a30[7:0];
          FlagS := a31[7:0][7];
          FlagZ := is_zero(a31[7:0]);
          FlagA := a34[7:0][4];
          FlagP := parity(a31[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a35 = (1 + a30) in
          let:16 a36 = (1 + a35) in
          advance (10)
          A := 00;
          B := a31[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a36[15:8];
          SPL := a36[7:0];
          FlagS := a31[7:0][7];
          FlagZ := is_zero(a31[7:0]);
          FlagA := a34[7:0][4];
          FlagP := parity(a31[7:0]);
          FlagCY := false;
          jump ((M[a35],M[a30]));
        }
      }
    }

0549:

    #instruction: LD   HL,(2076)
    advance (16)
    #054C
    #instruction: LD   (2058),HL
    M[2058] := M[2076];
    M[2059] := M[2077];
    advance (16)
    #054F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    H := M[2077];
    L := M[2076];
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

05A8:

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #05A9
      #instruction: CALL 017A
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 05;
      let:16 a4 = (-1 + a3) in
      M[a4] := AC;
      #return-to: 05AC
      advance (17)
      #017A
      #instruction: LD   D,00
      advance (7)
      #017C
      #instruction: LD   A,L
      advance (5)
      #017D
      #instruction: LD   HL,2009
      advance (10)
      #0180
      #instruction: LD   B,(HL)
      advance (7)
      #0181
      #instruction: INC  HL
      advance (5)
      #0182
      #instruction: LD   C,(HL)
      advance (7)
      #0183
      #instruction: CP   0B
      let:16 a5 = addWithCarry(!false,L,~0B) in
      let:8 a6 = (L & 0F) in
      let:8 a7 = (~0B & 0F) in
      let:16 a8 = addWithCarry(!false,a6,a7) in
      advance (7)
      #0185
      #instruction: JP   MI,0194
      if (a5[7:0][7]) {
        advance (10)
        #0194
        #instruction: LD   L,B
        advance (5)
        #0195
        #instruction: AND  A
        let:8 a9 = (L & L) in
        let:8 a10 = (L | L) in
        advance (4)
        #0196
        #instruction: RET  Z
        if (is_zero(a9)) {
          let:16 a11 = (1 + a4) in
          let:16 a12 = (1 + a11) in
          advance (11)
          A := a9;
          B := M[2009];
          C := M[200A];
          D := 00;
          H := 20;
          L := M[2009];
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a9[7];
          FlagZ := is_zero(a9);
          FlagA := a10[3];
          FlagP := parity(a9);
          FlagCY := false;
          jump ((M[a11],M[a4]));
        } else {
          advance (5)
          #0197
          #instruction: LD   E,A
          advance (5)
          #0198
          #instruction: LD   A,C
          advance (5)
          #0199
          #instruction: ADD  10
          let:16 a13 = addWithCarry(false,10,M[200A]) in
          let:8 a14 = (10 & 0F) in
          let:8 a15 = (M[200A] & 0F) in
          let:16 a16 = addWithCarry(false,a14,a15) in
          advance (7)
          #019B
          #instruction: LD   C,A
          advance (5)
          #019C
          #instruction: LD   A,E
          advance (5)
          #019D
          #instruction: DEC  A
          let:16 a17 = addWithCarry(!true,a9,~00) in
          let:8 a18 = (a9 & 0F) in
          let:8 a19 = (~00 & 0F) in
          let:16 a20 = addWithCarry(!true,a18,a19) in
          advance (5)
          #019E
          #instruction: JP   0195
          advance (10)
          A := a17[7:0];
          B := M[2009];
          C := a13[7:0];
          D := 00;
          E := a9;
          H := 20;
          L := M[2009];
          SPH := a4[15:8];
          SPL := a4[7:0];
          FlagS := a17[7:0][7];
          FlagZ := is_zero(a17[7:0]);
          FlagA := a20[7:0][4];
          FlagP := parity(a17[7:0]);
          FlagCY := a13[15:8][0];
          jump (0195);
        }
      } else {
        advance (10)
        #0188
        #instruction: SBC  0B
        let:16 a21 = addWithCarry(!!a5[15:8][0],L,~0B) in
        let:8 a22 = (L & 0F) in
        let:8 a23 = (~0B & 0F) in
        let:16 a24 = addWithCarry(!!a5[15:8][0],a22,a23) in
        advance (7)
        #018A
        #instruction: LD   E,A
        advance (5)
        #018B
        #instruction: LD   A,B
        advance (5)
        #018C
        #instruction: ADD  10
        let:16 a25 = addWithCarry(false,10,M[2009]) in
        let:8 a26 = (10 & 0F) in
        let:8 a27 = (M[2009] & 0F) in
        let:16 a28 = addWithCarry(false,a26,a27) in
        advance (7)
        #018E
        #instruction: LD   B,A
        advance (5)
        #018F
        #instruction: LD   A,E
        advance (5)
        #0190
        #instruction: INC  D
        let:16 a29 = addWithCarry(true,00,00) in
        let:8 a30 = (00 & 0F) in
        let:8 a31 = (00 & 0F) in
        let:16 a32 = addWithCarry(true,a30,a31) in
        advance (5)
        #0191
        #instruction: JP   0183
        advance (10)
        A := a21[7:0];
        B := a25[7:0];
        C := M[200A];
        D := a29[7:0];
        E := a21[7:0];
        H := 20;
        L := 0A;
        SPH := a4[15:8];
        SPL := a4[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := a25[15:8][0];
        jump (0183);
      }
    }

05AC:

    #instruction: LD   A,C
    advance (5)
    #05AD
    #instruction: ADD  07
    let:16 a1 = addWithCarry(false,07,C) in
    let:8 a2 = (07 & 0F) in
    let:8 a3 = (C & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    #05AF
    #instruction: LD   H,A
    advance (5)
    #05B0
    #instruction: LD   A,L
    advance (5)
    #05B1
    #instruction: SUB  0A
    let:16 a5 = addWithCarry(!false,L,~0A) in
    let:8 a6 = (L & 0F) in
    let:8 a7 = (~0A & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #05B3
    #instruction: LD   L,A
    advance (5)
    #05B4
    #instruction: LD   (207B),HL
    M[207B] := a5[7:0];
    M[207C] := a1[7:0];
    advance (16)
    #05B7
    #instruction: LD   HL,2073
    advance (10)
    #05BA
    #instruction: LD   A,(HL)
    advance (7)
    #05BB
    #instruction: OR   80
    let:8 a9 = (80 | M[2073]) in
    advance (7)
    #05BD
    #instruction: LD   (HL),A
    M[2073] := a9;
    advance (7)
    #05BE
    #instruction: INC  HL
    advance (5)
    #05BF
    #instruction: INC  (HL)
    let:16 a10 = addWithCarry(true,M[2074],00) in
    let:8 a11 = (M[2074] & 0F) in
    let:8 a12 = (00 & 0F) in
    let:16 a13 = addWithCarry(true,a11,a12) in
    M[2074] := a10[7:0];
    advance (10)
    #05C0
    #instruction: RET
    let:16 a14 = (1 + (SPH,SPL)) in
    let:16 a15 = (1 + a14) in
    advance (10)
    A := a9;
    H := 20;
    L := 74;
    SPH := a15[15:8];
    SPL := a15[7:0];
    FlagS := a10[7:0][7];
    FlagZ := is_zero(a10[7:0]);
    FlagA := a13[7:0][4];
    FlagP := parity(a10[7:0]);
    FlagCY := false;
    jump ((M[a14],M[(SPH,SPL)]));

05C7:

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #05C8
      #instruction: INC  HL
      let:16 a3 = (1 + (H,L)) in
      advance (5)
      #05C9
      #instruction: LD   A,(HL)
      advance (7)
      #05CA
      #instruction: AND  01
      let:8 a4 = (01 & M[a3]) in
      let:8 a5 = (01 | M[a3]) in
      advance (7)
      #05CC
      #instruction: JP   NZ,0644
      if (!is_zero(a4)) {
        advance (10)
        #0644
        #instruction: LD   HL,2078
        advance (10)
        #0647
        #instruction: DEC  (HL)
        let:16 a6 = addWithCarry(!true,M[2078],~00) in
        let:8 a7 = (M[2078] & 0F) in
        let:8 a8 = (~00 & 0F) in
        let:16 a9 = addWithCarry(!true,a7,a8) in
        M[2078] := a6[7:0];
        advance (10)
        #0648
        #instruction: LD   A,(HL)
        advance (7)
        #0649
        #instruction: CP   03
        let:16 a10 = addWithCarry(!false,M[2078],~03) in
        let:8 a11 = (M[2078] & 0F) in
        let:8 a12 = (~03 & 0F) in
        let:16 a13 = addWithCarry(!false,a11,a12) in
        advance (7)
        #064B
        #instruction: JP   NZ,0667
        if (!is_zero(a10[7:0])) {
          advance (10)
          #0667
          #instruction: AND  A
          let:8 a14 = (M[2078] & M[2078]) in
          let:8 a15 = (M[2078] | M[2078]) in
          advance (4)
          #0668
          #instruction: RET  NZ
          if (!is_zero(a14)) {
            let:16 a16 = (1 + (SPH,SPL)) in
            let:16 a17 = (1 + a16) in
            advance (11)
            A := a14;
            H := 20;
            L := 78;
            SPH := a17[15:8];
            SPL := a17[7:0];
            FlagS := a14[7];
            FlagZ := is_zero(a14);
            FlagA := a15[3];
            FlagP := parity(a14);
            FlagCY := false;
            jump ((M[a16],M[(SPH,SPL)]));
          } else {
            advance (5)
            #0669
            #instruction: JP   0675
            advance (10)
            #0675
            #instruction: LD   HL,2079
            advance (10)
            #0678
            #instruction: CALL 1A3B
            let:16 a18 = (-1 + (SPH,SPL)) in
            M[a18] := 06;
            let:16 a19 = (-1 + a18) in
            M[a19] := 7B;
            #return-to: 067B
            advance (17)
            #1A3B
            #instruction: LD   E,(HL)
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            advance (7)
            #1A44
            #instruction: LD   H,C
            advance (5)
            #1A45
            #instruction: LD   L,A
            advance (5)
            #1A46
            #instruction: RET
            let:16 a20 = (1 + a19) in
            let:16 a21 = (1 + a20) in
            advance (10)
            A := M[207B];
            B := M[207D];
            C := M[207C];
            D := M[207A];
            E := M[2079];
            H := M[207C];
            L := M[207B];
            SPH := a21[15:8];
            SPL := a21[7:0];
            FlagS := a14[7];
            FlagZ := is_zero(a14);
            FlagA := a15[3];
            FlagP := parity(a14);
            FlagCY := false;
            jump ((M[a20],M[a19]));
          }
        } else {
          advance (10)
          #064E
          #instruction: CALL 0675
          let:16 a22 = (-1 + (SPH,SPL)) in
          M[a22] := 06;
          let:16 a23 = (-1 + a22) in
          M[a23] := 51;
          #return-to: 0651
          advance (17)
          #0675
          #instruction: LD   HL,2079
          advance (10)
          #0678
          #instruction: CALL 1A3B
          let:16 a24 = (-1 + a23) in
          M[a24] := 06;
          let:16 a25 = (-1 + a24) in
          M[a25] := 7B;
          #return-to: 067B
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a26 = (1 + a25) in
          let:16 a27 = (1 + a26) in
          advance (10)
          A := M[207B];
          B := M[207D];
          C := M[207C];
          D := M[207A];
          E := M[2079];
          H := M[207C];
          L := M[207B];
          SPH := a27[15:8];
          SPL := a27[7:0];
          FlagS := a10[7:0][7];
          FlagZ := is_zero(a10[7:0]);
          FlagA := a13[7:0][4];
          FlagP := parity(a10[7:0]);
          FlagCY := !a10[15:8][0];
          jump ((M[a26],M[a25]));
        }
      } else {
        advance (10)
        #05CF
        #instruction: INC  HL
        let:16 a28 = (1 + a3) in
        advance (5)
        #05D0
        #instruction: INC  (HL)
        let:16 a29 = addWithCarry(true,M[a28],00) in
        let:8 a30 = (M[a28] & 0F) in
        let:8 a31 = (00 & 0F) in
        let:16 a32 = addWithCarry(true,a30,a31) in
        M[a28] := a29[7:0];
        advance (10)
        #05D1
        #instruction: CALL 0675
        let:16 a33 = (-1 + (SPH,SPL)) in
        M[a33] := 05;
        let:16 a34 = (-1 + a33) in
        M[a34] := D4;
        #return-to: 05D4
        advance (17)
        #0675
        #instruction: LD   HL,2079
        advance (10)
        #0678
        #instruction: CALL 1A3B
        let:16 a35 = (-1 + a34) in
        M[a35] := 06;
        let:16 a36 = (-1 + a35) in
        M[a36] := 7B;
        #return-to: 067B
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a37 = (1 + a36) in
        let:16 a38 = (1 + a37) in
        advance (10)
        A := M[207B];
        B := M[207D];
        C := M[207C];
        D := M[207A];
        E := M[2079];
        H := M[207C];
        L := M[207B];
        SPH := a38[15:8];
        SPL := a38[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := false;
        jump ((M[a37],M[a36]));
      }
    }

05D4:

    #instruction: LD   A,(2079)
    advance (13)
    #05D7
    #instruction: ADD  03
    let:16 a1 = addWithCarry(false,03,M[2079]) in
    let:8 a2 = (03 & 0F) in
    let:8 a3 = (M[2079] & 0F) in
    let:16 a4 = addWithCarry(false,a2,a3) in
    advance (7)
    #05D9
    #instruction: LD   HL,207F
    advance (10)
    #05DC
    #instruction: CP   (HL)
    let:16 a5 = addWithCarry(!false,a1[7:0],~M[207F]) in
    let:8 a6 = (a1[7:0] & 0F) in
    let:8 a7 = (~M[207F] & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #05DD
    #instruction: JP   CY,05E2
    if (!a5[15:8][0]) {
      advance (10)
      #05E2
      #instruction: LD   (2079),A
      M[2079] := a1[7:0];
      advance (13)
      #05E5
      #instruction: LD   A,(207B)
      advance (13)
      #05E8
      #instruction: LD   B,A
      advance (5)
      #05E9
      #instruction: LD   A,(207E)
      advance (13)
      #05EC
      #instruction: ADD  B
      let:16 a9 = addWithCarry(false,M[207B],M[207E]) in
      let:8 a10 = (M[207B] & 0F) in
      let:8 a11 = (M[207E] & 0F) in
      let:16 a12 = addWithCarry(false,a10,a11) in
      advance (4)
      #05ED
      #instruction: LD   (207B),A
      M[207B] := a9[7:0];
      advance (13)
      #05F0
      #instruction: CALL 066C
      let:16 a13 = (-1 + (SPH,SPL)) in
      M[a13] := 05;
      let:16 a14 = (-1 + a13) in
      M[a14] := F3;
      #return-to: 05F3
      advance (17)
      #066C
      #instruction: LD   HL,2079
      advance (10)
      #066F
      #instruction: CALL 1A3B
      let:16 a15 = (-1 + a14) in
      M[a15] := 06;
      let:16 a16 = (-1 + a15) in
      M[a16] := 72;
      #return-to: 0672
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      advance (7)
      #1A44
      #instruction: LD   H,C
      advance (5)
      #1A45
      #instruction: LD   L,A
      advance (5)
      #1A46
      #instruction: RET
      let:16 a17 = (1 + a16) in
      let:16 a18 = (1 + a17) in
      advance (10)
      A := M[207B];
      B := M[207D];
      C := M[207C];
      D := M[207A];
      E := M[2079];
      H := M[207C];
      L := M[207B];
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a9[15:8][0];
      jump ((M[a17],M[a16]));
    } else {
      advance (10)
      #05E0
      #instruction: SUB  0C
      let:16 a19 = addWithCarry(!false,a1[7:0],~0C) in
      let:8 a20 = (a1[7:0] & 0F) in
      let:8 a21 = (~0C & 0F) in
      let:16 a22 = addWithCarry(!false,a20,a21) in
      advance (7)
      #05E2
      #instruction: LD   (2079),A
      M[2079] := a19[7:0];
      advance (13)
      #05E5
      #instruction: LD   A,(207B)
      advance (13)
      #05E8
      #instruction: LD   B,A
      advance (5)
      #05E9
      #instruction: LD   A,(207E)
      advance (13)
      #05EC
      #instruction: ADD  B
      let:16 a23 = addWithCarry(false,M[207B],M[207E]) in
      let:8 a24 = (M[207B] & 0F) in
      let:8 a25 = (M[207E] & 0F) in
      let:16 a26 = addWithCarry(false,a24,a25) in
      advance (4)
      #05ED
      #instruction: LD   (207B),A
      M[207B] := a23[7:0];
      advance (13)
      #05F0
      #instruction: CALL 066C
      let:16 a27 = (-1 + (SPH,SPL)) in
      M[a27] := 05;
      let:16 a28 = (-1 + a27) in
      M[a28] := F3;
      #return-to: 05F3
      advance (17)
      #066C
      #instruction: LD   HL,2079
      advance (10)
      #066F
      #instruction: CALL 1A3B
      let:16 a29 = (-1 + a28) in
      M[a29] := 06;
      let:16 a30 = (-1 + a29) in
      M[a30] := 72;
      #return-to: 0672
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      advance (7)
      #1A44
      #instruction: LD   H,C
      advance (5)
      #1A45
      #instruction: LD   L,A
      advance (5)
      #1A46
      #instruction: RET
      let:16 a31 = (1 + a30) in
      let:16 a32 = (1 + a31) in
      advance (10)
      A := M[207B];
      B := M[207D];
      C := M[207C];
      D := M[207A];
      E := M[2079];
      H := M[207C];
      L := M[207B];
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a23[15:8][0];
      jump ((M[a31],M[a30]));
    }

05F3:

    #instruction: LD   A,(207B)
    advance (13)
    #05F6
    #instruction: CP   15
    let:16 a1 = addWithCarry(!false,M[207B],~15) in
    let:8 a2 = (M[207B] & 0F) in
    let:8 a3 = (~15 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #05F8
    #instruction: JP   CY,0612
    if (!a1[15:8][0]) {
      advance (10)
      #0612
      #instruction: LD   A,(2073)
      advance (13)
      #0615
      #instruction: OR   01
      let:8 a5 = (01 | M[2073]) in
      advance (7)
      #0617
      #instruction: LD   (2073),A
      M[2073] := a5;
      advance (13)
      #061A
      #instruction: RET
      let:16 a6 = (1 + (SPH,SPL)) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a5;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[(SPH,SPL)]));
    } else {
      advance (10)
      #05FB
      #instruction: LD   A,(2061)
      advance (13)
      #05FE
      #instruction: AND  A
      let:8 a8 = (M[2061] & M[2061]) in
      let:8 a9 = (M[2061] | M[2061]) in
      advance (4)
      #05FF
      #instruction: RET  Z
      if (is_zero(a8)) {
        let:16 a10 = (1 + (SPH,SPL)) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a8;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a8[7];
        FlagZ := is_zero(a8);
        FlagA := a9[3];
        FlagP := parity(a8);
        FlagCY := false;
        jump ((M[a10],M[(SPH,SPL)]));
      } else {
        advance (5)
        #0600
        #instruction: LD   A,(207B)
        advance (13)
        #0603
        #instruction: CP   1E
        let:16 a12 = addWithCarry(!false,M[207B],~1E) in
        let:8 a13 = (M[207B] & 0F) in
        let:8 a14 = (~1E & 0F) in
        let:16 a15 = addWithCarry(!false,a13,a14) in
        advance (7)
        #0605
        #instruction: JP   CY,0612
        if (!a12[15:8][0]) {
          advance (10)
          #0612
          #instruction: LD   A,(2073)
          advance (13)
          #0615
          #instruction: OR   01
          let:8 a16 = (01 | M[2073]) in
          advance (7)
          #0617
          #instruction: LD   (2073),A
          M[2073] := a16;
          advance (13)
          #061A
          #instruction: RET
          let:16 a17 = (1 + (SPH,SPL)) in
          let:16 a18 = (1 + a17) in
          advance (10)
          A := a16;
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a16[7];
          FlagZ := is_zero(a16);
          FlagA := false;
          FlagP := parity(a16);
          FlagCY := false;
          jump ((M[a17],M[(SPH,SPL)]));
        } else {
          advance (10)
          #0608
          #instruction: CP   27
          let:16 a19 = addWithCarry(!false,M[207B],~27) in
          let:8 a20 = (M[207B] & 0F) in
          let:8 a21 = (~27 & 0F) in
          let:16 a22 = addWithCarry(!false,a20,a21) in
          advance (7)
          #060A
          #instruction: NOP
          advance (4)
          #060B
          #instruction: JP   NC,0612
          if (!!a19[15:8][0]) {
            advance (10)
            #0612
            #instruction: LD   A,(2073)
            advance (13)
            #0615
            #instruction: OR   01
            let:8 a23 = (01 | M[2073]) in
            advance (7)
            #0617
            #instruction: LD   (2073),A
            M[2073] := a23;
            advance (13)
            #061A
            #instruction: RET
            let:16 a24 = (1 + (SPH,SPL)) in
            let:16 a25 = (1 + a24) in
            advance (10)
            A := a23;
            SPH := a25[15:8];
            SPL := a25[7:0];
            FlagS := a23[7];
            FlagZ := is_zero(a23);
            FlagA := false;
            FlagP := parity(a23);
            FlagCY := false;
            jump ((M[a24],M[(SPH,SPL)]));
          } else {
            advance (10)
            #060E
            #instruction: SUB  A
            let:16 a26 = addWithCarry(!false,M[207B],~M[207B]) in
            let:8 a27 = (M[207B] & 0F) in
            let:8 a28 = (~M[207B] & 0F) in
            let:16 a29 = addWithCarry(!false,a27,a28) in
            advance (4)
            #060F
            #instruction: LD   (2015),A
            M[2015] := a26[7:0];
            advance (13)
            #0612
            #instruction: LD   A,(2073)
            advance (13)
            #0615
            #instruction: OR   01
            let:8 a30 = (01 | M[2073]) in
            advance (7)
            #0617
            #instruction: LD   (2073),A
            M[2073] := a30;
            advance (13)
            #061A
            #instruction: RET
            let:16 a31 = (1 + (SPH,SPL)) in
            let:16 a32 = (1 + a31) in
            advance (10)
            A := a30;
            SPH := a32[15:8];
            SPL := a32[7:0];
            FlagS := a30[7];
            FlagZ := is_zero(a30);
            FlagA := false;
            FlagP := parity(a30);
            FlagCY := false;
            jump ((M[a31],M[(SPH,SPL)]));
          }
        }
      }
    }

0624:

    #instruction: LD   A,C
    advance (5)
    #0625
    #instruction: CP   0C
    let:16 a1 = addWithCarry(!false,C,~0C) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~0C & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #0627
    #instruction: JP   CY,05A5
    if (!a1[15:8][0]) {
      advance (10)
      #05A5
      #instruction: CALL 062F
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 05;
      let:16 a6 = (-1 + a5) in
      M[a6] := A8;
      #return-to: 05A8
      advance (17)
      #062F
      #instruction: DEC  C
      let:16 a7 = addWithCarry(!true,C,~00) in
      let:8 a8 = (C & 0F) in
      let:8 a9 = (~00 & 0F) in
      let:16 a10 = addWithCarry(!true,a8,a9) in
      advance (5)
      #0630
      #instruction: LD   A,(2067)
      advance (13)
      #0633
      #instruction: LD   H,A
      advance (5)
      #0634
      #instruction: LD   L,C
      advance (5)
      #0635
      #instruction: LD   D,05
      advance (7)
      #0637
      #instruction: LD   A,(HL)
      advance (7)
      #0638
      #instruction: AND  A
      let:8 a11 = (M[(M[2067],a7[7:0])] & M[(M[2067],a7[7:0])]) in
      let:8 a12 = (M[(M[2067],a7[7:0])] | M[(M[2067],a7[7:0])]) in
      advance (4)
      #0639
      #instruction: SCF
      advance (4)
      #063A
      #instruction: RET  NZ
      if (!is_zero(a11)) {
        let:16 a13 = (1 + a6) in
        let:16 a14 = (1 + a13) in
        advance (11)
        A := a11;
        C := a7[7:0];
        D := 05;
        H := M[2067];
        L := a7[7:0];
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := true;
        jump ((M[a13],M[a6]));
      } else {
        advance (5)
        #063B
        #instruction: LD   A,L
        advance (5)
        #063C
        #instruction: ADD  0B
        let:16 a15 = addWithCarry(false,0B,a7[7:0]) in
        let:8 a16 = (0B & 0F) in
        let:8 a17 = (a7[7:0] & 0F) in
        let:16 a18 = addWithCarry(false,a16,a17) in
        advance (7)
        #063E
        #instruction: LD   L,A
        advance (5)
        #063F
        #instruction: DEC  D
        let:16 a19 = addWithCarry(!true,05,~00) in
        let:8 a20 = (05 & 0F) in
        let:8 a21 = (~00 & 0F) in
        let:16 a22 = addWithCarry(!true,a20,a21) in
        advance (5)
        #0640
        #instruction: JP   NZ,0637
        if (!is_zero(a19[7:0])) {
          advance (10)
          A := a15[7:0];
          C := a7[7:0];
          D := a19[7:0];
          H := M[2067];
          L := a15[7:0];
          SPH := a6[15:8];
          SPL := a6[7:0];
          FlagS := a19[7:0][7];
          FlagZ := is_zero(a19[7:0]);
          FlagA := a22[7:0][4];
          FlagP := parity(a19[7:0]);
          FlagCY := a15[15:8][0];
          jump (0637);
        } else {
          advance (10)
          #0643
          #instruction: RET
          let:16 a23 = (1 + a6) in
          let:16 a24 = (1 + a23) in
          advance (10)
          A := a15[7:0];
          C := a7[7:0];
          D := a19[7:0];
          H := M[2067];
          L := a15[7:0];
          SPH := a24[15:8];
          SPL := a24[7:0];
          FlagS := a19[7:0][7];
          FlagZ := is_zero(a19[7:0]);
          FlagA := a22[7:0][4];
          FlagP := parity(a19[7:0]);
          FlagCY := a15[15:8][0];
          jump ((M[a23],M[a6]));
        }
      }
    } else {
      advance (10)
      #062A
      #instruction: LD   C,0B
      advance (7)
      #062C
      #instruction: JP   05A5
      advance (10)
      #05A5
      #instruction: CALL 062F
      let:16 a25 = (-1 + (SPH,SPL)) in
      M[a25] := 05;
      let:16 a26 = (-1 + a25) in
      M[a26] := A8;
      #return-to: 05A8
      advance (17)
      #062F
      #instruction: DEC  C
      let:16 a27 = addWithCarry(!true,0B,~00) in
      let:8 a28 = (0B & 0F) in
      let:8 a29 = (~00 & 0F) in
      let:16 a30 = addWithCarry(!true,a28,a29) in
      advance (5)
      #0630
      #instruction: LD   A,(2067)
      advance (13)
      #0633
      #instruction: LD   H,A
      advance (5)
      #0634
      #instruction: LD   L,C
      advance (5)
      #0635
      #instruction: LD   D,05
      advance (7)
      #0637
      #instruction: LD   A,(HL)
      advance (7)
      #0638
      #instruction: AND  A
      let:8 a31 = (M[(M[2067],a27[7:0])] & M[(M[2067],a27[7:0])]) in
      let:8 a32 = (M[(M[2067],a27[7:0])] | M[(M[2067],a27[7:0])]) in
      advance (4)
      #0639
      #instruction: SCF
      advance (4)
      #063A
      #instruction: RET  NZ
      if (!is_zero(a31)) {
        let:16 a33 = (1 + a26) in
        let:16 a34 = (1 + a33) in
        advance (11)
        A := a31;
        C := a27[7:0];
        D := 05;
        H := M[2067];
        L := a27[7:0];
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a31[7];
        FlagZ := is_zero(a31);
        FlagA := a32[3];
        FlagP := parity(a31);
        FlagCY := true;
        jump ((M[a33],M[a26]));
      } else {
        advance (5)
        #063B
        #instruction: LD   A,L
        advance (5)
        #063C
        #instruction: ADD  0B
        let:16 a35 = addWithCarry(false,0B,a27[7:0]) in
        let:8 a36 = (0B & 0F) in
        let:8 a37 = (a27[7:0] & 0F) in
        let:16 a38 = addWithCarry(false,a36,a37) in
        advance (7)
        #063E
        #instruction: LD   L,A
        advance (5)
        #063F
        #instruction: DEC  D
        let:16 a39 = addWithCarry(!true,05,~00) in
        let:8 a40 = (05 & 0F) in
        let:8 a41 = (~00 & 0F) in
        let:16 a42 = addWithCarry(!true,a40,a41) in
        advance (5)
        #0640
        #instruction: JP   NZ,0637
        if (!is_zero(a39[7:0])) {
          advance (10)
          A := a35[7:0];
          C := a27[7:0];
          D := a39[7:0];
          H := M[2067];
          L := a35[7:0];
          SPH := a26[15:8];
          SPL := a26[7:0];
          FlagS := a39[7:0][7];
          FlagZ := is_zero(a39[7:0]);
          FlagA := a42[7:0][4];
          FlagP := parity(a39[7:0]);
          FlagCY := a35[15:8][0];
          jump (0637);
        } else {
          advance (10)
          #0643
          #instruction: RET
          let:16 a43 = (1 + a26) in
          let:16 a44 = (1 + a43) in
          advance (10)
          A := a35[7:0];
          C := a27[7:0];
          D := a39[7:0];
          H := M[2067];
          L := a35[7:0];
          SPH := a44[15:8];
          SPL := a44[7:0];
          FlagS := a39[7:0][7];
          FlagZ := is_zero(a39[7:0]);
          FlagA := a42[7:0][4];
          FlagP := parity(a39[7:0]);
          FlagCY := a35[15:8][0];
          jump ((M[a43],M[a26]));
        }
      }
    }

0651:

    #instruction: LD   HL,1CDC
    advance (10)
    #0654
    #instruction: LD   (2079),HL
    M[2079] := DC;
    M[207A] := 1C;
    advance (16)
    #0657
    #instruction: LD   HL,207C
    advance (10)
    #065A
    #instruction: DEC  (HL)
    let:16 a1 = addWithCarry(!true,M[207C],~00) in
    let:8 a2 = (M[207C] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    M[207C] := a1[7:0];
    advance (10)
    #065B
    #instruction: DEC  (HL)
    let:16 a5 = addWithCarry(!true,M[207C],~00) in
    let:8 a6 = (M[207C] & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    M[207C] := a5[7:0];
    advance (10)
    #065C
    #instruction: DEC  HL
    advance (5)
    #065D
    #instruction: DEC  (HL)
    let:16 a9 = addWithCarry(!true,M[207B],~00) in
    let:8 a10 = (M[207B] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    M[207B] := a9[7:0];
    advance (10)
    #065E
    #instruction: DEC  (HL)
    let:16 a13 = addWithCarry(!true,M[207B],~00) in
    let:8 a14 = (M[207B] & 0F) in
    let:8 a15 = (~00 & 0F) in
    let:16 a16 = addWithCarry(!true,a14,a15) in
    M[207B] := a13[7:0];
    advance (10)
    #065F
    #instruction: LD   A,06
    advance (7)
    #0661
    #instruction: LD   (207D),A
    M[207D] := 06;
    advance (13)
    #0664
    #instruction: JP   066C
    advance (10)
    #066C
    #instruction: LD   HL,2079
    advance (10)
    #066F
    #instruction: CALL 1A3B
    let:16 a17 = (-1 + (SPH,SPL)) in
    M[a17] := 06;
    let:16 a18 = (-1 + a17) in
    M[a18] := 72;
    #return-to: 0672
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    advance (7)
    #1A44
    #instruction: LD   H,C
    advance (5)
    #1A45
    #instruction: LD   L,A
    advance (5)
    #1A46
    #instruction: RET
    let:16 a19 = (1 + a18) in
    let:16 a20 = (1 + a19) in
    advance (10)
    A := M[207B];
    B := M[207D];
    C := M[207C];
    D := M[207A];
    E := M[2079];
    H := M[207C];
    L := M[207B];
    SPH := a20[15:8];
    SPL := a20[7:0];
    FlagS := a13[7:0][7];
    FlagZ := is_zero(a13[7:0]);
    FlagA := a16[7:0][4];
    FlagP := parity(a13[7:0]);
    jump ((M[a19],M[a18]));

0672:

    #instruction: JP   1491
    advance (10)
    #1491
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 94;
    #return-to: 1494
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a3 = (07 & L) in
    let:8 a4 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a5 = (-1 + a2) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,03,~00) in
    let:8 a8 = (03 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a7[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a3;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a11 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a12 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a13 = (20 | a11) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a14 = (1 + a6) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      A := a13;
      B := M[a14];
      C := M[a6];
      H := a13;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := false;
      FlagP := parity(a13);
      FlagCY := false;
      Shifter_OFF := a3;
      jump ((M[a16],M[a15]));
    }

067B:

    #instruction: JP   1452
    advance (10)
    #1452
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 14;
    let:16 a2 = (-1 + a1) in
    M[a2] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a3 = (07 & L) in
    let:8 a4 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a5 = (-1 + a2) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,03,~00) in
    let:8 a8 = (03 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a7[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a3;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a11 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a12 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a13 = (20 | a11) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a14 = (1 + a6) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      A := a13;
      B := M[a14];
      C := M[a6];
      H := a13;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := false;
      FlagP := parity(a13);
      FlagCY := false;
      Shifter_OFF := a3;
      jump ((M[a16],M[a15]));
    }

0682:

    #instruction: POP  HL
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0683
    #instruction: LD   A,(2080)
    advance (13)
    #0686
    #instruction: CP   02
    let:16 a3 = addWithCarry(!false,M[2080],~02) in
    let:8 a4 = (M[2080] & 0F) in
    let:8 a5 = (~02 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0688
    #instruction: RET  NZ
    if (!is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2080];
      H := M[a1];
      L := M[(SPH,SPL)];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #0689
      #instruction: LD   HL,2083
      advance (10)
      #068C
      #instruction: LD   A,(HL)
      advance (7)
      #068D
      #instruction: AND  A
      let:8 a9 = (M[2083] & M[2083]) in
      let:8 a10 = (M[2083] | M[2083]) in
      advance (4)
      #068E
      #instruction: JP   Z,050F
      if (is_zero(a9)) {
        advance (10)
        #050F
        #instruction: LD   DE,2055
        advance (10)
        #0512
        #instruction: LD   A,DB
        advance (7)
        #0514
        #instruction: CALL 0550
        let:16 a11 = (-1 + a2) in
        M[a11] := 05;
        let:16 a12 = (-1 + a11) in
        M[a12] := 17;
        #return-to: 0517
        advance (17)
        #0550
        #instruction: LD   (207F),A
        M[207F] := DB;
        advance (13)
        #0553
        #instruction: LD   HL,2073
        advance (10)
        #0556
        #instruction: LD   B,0B
        advance (7)
        #0558
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2073] := M[2055];
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a13 = addWithCarry(!true,0B,~00) in
        let:8 a14 = (0B & 0F) in
        let:8 a15 = (~00 & 0F) in
        let:16 a16 = addWithCarry(!true,a14,a15) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a13[7:0])) {
          advance (10)
          A := M[2055];
          B := a13[7:0];
          D := 20;
          E := 56;
          H := 20;
          L := 74;
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a13[7:0][7];
          FlagZ := is_zero(a13[7:0]);
          FlagA := a16[7:0][4];
          FlagP := parity(a13[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a17 = (1 + a12) in
          let:16 a18 = (1 + a17) in
          advance (10)
          A := M[2055];
          B := a13[7:0];
          D := 20;
          E := 56;
          H := 20;
          L := 74;
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a13[7:0][7];
          FlagZ := is_zero(a13[7:0]);
          FlagA := a16[7:0][4];
          FlagP := parity(a13[7:0]);
          FlagCY := false;
          jump ((M[a17],M[a12]));
        }
      } else {
        advance (10)
        #0691
        #instruction: LD   A,(2056)
        advance (13)
        #0694
        #instruction: AND  A
        let:8 a19 = (M[2056] & M[2056]) in
        let:8 a20 = (M[2056] | M[2056]) in
        advance (4)
        #0695
        #instruction: JP   NZ,050F
        if (!is_zero(a19)) {
          advance (10)
          #050F
          #instruction: LD   DE,2055
          advance (10)
          #0512
          #instruction: LD   A,DB
          advance (7)
          #0514
          #instruction: CALL 0550
          let:16 a21 = (-1 + a2) in
          M[a21] := 05;
          let:16 a22 = (-1 + a21) in
          M[a22] := 17;
          #return-to: 0517
          advance (17)
          #0550
          #instruction: LD   (207F),A
          M[207F] := DB;
          advance (13)
          #0553
          #instruction: LD   HL,2073
          advance (10)
          #0556
          #instruction: LD   B,0B
          advance (7)
          #0558
          #instruction: JP   1A32
          advance (10)
          #1A32
          #instruction: LD   A,(DE)
          advance (7)
          #1A33
          #instruction: LD   (HL),A
          M[2073] := M[2055];
          advance (7)
          #1A34
          #instruction: INC  HL
          advance (5)
          #1A35
          #instruction: INC  DE
          advance (5)
          #1A36
          #instruction: DEC  B
          let:16 a23 = addWithCarry(!true,0B,~00) in
          let:8 a24 = (0B & 0F) in
          let:8 a25 = (~00 & 0F) in
          let:16 a26 = addWithCarry(!true,a24,a25) in
          advance (5)
          #1A37
          #instruction: JP   NZ,1A32
          if (!is_zero(a23[7:0])) {
            advance (10)
            A := M[2055];
            B := a23[7:0];
            D := 20;
            E := 56;
            H := 20;
            L := 74;
            SPH := a22[15:8];
            SPL := a22[7:0];
            FlagS := a23[7:0][7];
            FlagZ := is_zero(a23[7:0]);
            FlagA := a26[7:0][4];
            FlagP := parity(a23[7:0]);
            FlagCY := false;
            jump (1A32);
          } else {
            advance (10)
            #1A3A
            #instruction: RET
            let:16 a27 = (1 + a22) in
            let:16 a28 = (1 + a27) in
            advance (10)
            A := M[2055];
            B := a23[7:0];
            D := 20;
            E := 56;
            H := 20;
            L := 74;
            SPH := a28[15:8];
            SPL := a28[7:0];
            FlagS := a23[7:0][7];
            FlagZ := is_zero(a23[7:0]);
            FlagA := a26[7:0][4];
            FlagP := parity(a23[7:0]);
            FlagCY := false;
            jump ((M[a27],M[a22]));
          }
        } else {
          advance (10)
          #0698
          #instruction: INC  HL
          advance (5)
          #0699
          #instruction: LD   A,(HL)
          advance (7)
          #069A
          #instruction: AND  A
          let:8 a29 = (M[2084] & M[2084]) in
          let:8 a30 = (M[2084] | M[2084]) in
          advance (4)
          #069B
          #instruction: JP   NZ,06AB
          if (!is_zero(a29)) {
            advance (10)
            A := a29;
            H := 20;
            L := 84;
            SPH := a2[15:8];
            SPL := a2[7:0];
            FlagS := a29[7];
            FlagZ := is_zero(a29);
            FlagA := a30[3];
            FlagP := parity(a29);
            FlagCY := false;
            jump (06AB);
          } else {
            advance (10)
            #069E
            #instruction: LD   A,(2082)
            advance (13)
            #06A1
            #instruction: CP   08
            let:16 a31 = addWithCarry(!false,M[2082],~08) in
            let:8 a32 = (M[2082] & 0F) in
            let:8 a33 = (~08 & 0F) in
            let:16 a34 = addWithCarry(!false,a32,a33) in
            advance (7)
            #06A3
            #instruction: JP   CY,050F
            if (!a31[15:8][0]) {
              advance (10)
              #050F
              #instruction: LD   DE,2055
              advance (10)
              #0512
              #instruction: LD   A,DB
              advance (7)
              #0514
              #instruction: CALL 0550
              let:16 a35 = (-1 + a2) in
              M[a35] := 05;
              let:16 a36 = (-1 + a35) in
              M[a36] := 17;
              #return-to: 0517
              advance (17)
              #0550
              #instruction: LD   (207F),A
              M[207F] := DB;
              advance (13)
              #0553
              #instruction: LD   HL,2073
              advance (10)
              #0556
              #instruction: LD   B,0B
              advance (7)
              #0558
              #instruction: JP   1A32
              advance (10)
              #1A32
              #instruction: LD   A,(DE)
              advance (7)
              #1A33
              #instruction: LD   (HL),A
              M[2073] := M[2055];
              advance (7)
              #1A34
              #instruction: INC  HL
              advance (5)
              #1A35
              #instruction: INC  DE
              advance (5)
              #1A36
              #instruction: DEC  B
              let:16 a37 = addWithCarry(!true,0B,~00) in
              let:8 a38 = (0B & 0F) in
              let:8 a39 = (~00 & 0F) in
              let:16 a40 = addWithCarry(!true,a38,a39) in
              advance (5)
              #1A37
              #instruction: JP   NZ,1A32
              if (!is_zero(a37[7:0])) {
                advance (10)
                A := M[2055];
                B := a37[7:0];
                D := 20;
                E := 56;
                H := 20;
                L := 74;
                SPH := a36[15:8];
                SPL := a36[7:0];
                FlagS := a37[7:0][7];
                FlagZ := is_zero(a37[7:0]);
                FlagA := a40[7:0][4];
                FlagP := parity(a37[7:0]);
                FlagCY := !a31[15:8][0];
                jump (1A32);
              } else {
                advance (10)
                #1A3A
                #instruction: RET
                let:16 a41 = (1 + a36) in
                let:16 a42 = (1 + a41) in
                advance (10)
                A := M[2055];
                B := a37[7:0];
                D := 20;
                E := 56;
                H := 20;
                L := 74;
                SPH := a42[15:8];
                SPL := a42[7:0];
                FlagS := a37[7:0][7];
                FlagZ := is_zero(a37[7:0]);
                FlagA := a40[7:0][4];
                FlagP := parity(a37[7:0]);
                FlagCY := !a31[15:8][0];
                jump ((M[a41],M[a36]));
              }
            } else {
              advance (10)
              #06A6
              #instruction: LD   (HL),01
              M[2084] := 01;
              advance (10)
              #06A8
              #instruction: CALL 073C
              let:16 a43 = (-1 + a2) in
              M[a43] := 06;
              let:16 a44 = (-1 + a43) in
              M[a44] := AB;
              #return-to: 06AB
              advance (17)
              #073C
              #instruction: CALL 0742
              let:16 a45 = (-1 + a44) in
              M[a45] := 07;
              let:16 a46 = (-1 + a45) in
              M[a46] := 3F;
              #return-to: 073F
              advance (17)
              #0742
              #instruction: LD   HL,2087
              advance (10)
              #0745
              #instruction: CALL 1A3B
              let:16 a47 = (-1 + a46) in
              M[a47] := 07;
              let:16 a48 = (-1 + a47) in
              M[a48] := 48;
              #return-to: 0748
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              advance (7)
              #1A44
              #instruction: LD   H,C
              advance (5)
              #1A45
              #instruction: LD   L,A
              advance (5)
              #1A46
              #instruction: RET
              let:16 a49 = (1 + a48) in
              let:16 a50 = (1 + a49) in
              advance (10)
              A := M[2089];
              B := M[208B];
              C := M[208A];
              D := M[2088];
              E := M[2087];
              H := M[208A];
              L := M[2089];
              SPH := a50[15:8];
              SPL := a50[7:0];
              FlagS := a31[7:0][7];
              FlagZ := is_zero(a31[7:0]);
              FlagA := a34[7:0][4];
              FlagP := parity(a31[7:0]);
              FlagCY := !a31[15:8][0];
              jump ((M[a49],M[a48]));
            }
          }
        }
      }
    }

06AB:

    #instruction: LD   DE,208A
    advance (10)
    #06AE
    #instruction: CALL 1A06
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := B1;
    #return-to: 06B1
    advance (17)
    #1A06
    #instruction: LD   HL,2072
    advance (10)
    #1A09
    #instruction: LD   B,(HL)
    advance (7)
    #1A0A
    #instruction: LD   A,(DE)
    advance (7)
    #1A0B
    #instruction: AND  80
    let:8 a3 = (80 & M[208A]) in
    let:8 a4 = (80 | M[208A]) in
    advance (7)
    #1A0D
    #instruction: XOR  B
    let:8 a5 = (M[2072] ^ a3) in
    advance (4)
    #1A0E
    #instruction: RET  NZ
    if (!is_zero(a5)) {
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (11)
      A := a5;
      B := M[2072];
      D := 20;
      E := 8A;
      H := 20;
      L := 72;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    } else {
      advance (5)
      #1A0F
      #instruction: SCF
      advance (4)
      #1A10
      #instruction: RET
      let:16 a8 = (1 + a2) in
      let:16 a9 = (1 + a8) in
      advance (10)
      A := a5;
      B := M[2072];
      D := 20;
      E := 8A;
      H := 20;
      L := 72;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := true;
      jump ((M[a8],M[a2]));
    }

06B1:

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #06B2
      #instruction: LD   HL,2085
      advance (10)
      #06B5
      #instruction: LD   A,(HL)
      advance (7)
      #06B6
      #instruction: AND  A
      let:8 a3 = (M[2085] & M[2085]) in
      let:8 a4 = (M[2085] | M[2085]) in
      advance (4)
      #06B7
      #instruction: JP   NZ,06D6
      if (!is_zero(a3)) {
        advance (10)
        #06D6
        #instruction: LD   B,FE
        advance (7)
        #06D8
        #instruction: CALL 19DC
        let:16 a5 = (-1 + (SPH,SPL)) in
        M[a5] := 06;
        let:16 a6 = (-1 + a5) in
        M[a6] := DB;
        #return-to: 06DB
        advance (17)
        #19DC
        #instruction: LD   A,(2094)
        advance (13)
        #19DF
        #instruction: AND  B
        let:8 a7 = (FE & M[2094]) in
        let:8 a8 = (FE | M[2094]) in
        advance (4)
        #19E0
        #instruction: LD   (2094),A
        M[2094] := a7;
        advance (13)
        #19E3
        #instruction: OUT  03
        sound_control(Ufo,a7[0]);
        sound_control(Shot,a7[1]);
        sound_control(PlayerDie,a7[2]);
        sound_control(InvaderDie,a7[3]);
        sound_control(ExtraLife,a7[4]);
        advance (10)
        #19E5
        #instruction: RET
        let:16 a9 = (1 + a6) in
        let:16 a10 = (1 + a9) in
        advance (10)
        A := a7;
        B := FE;
        H := 20;
        L := 85;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a7[7];
        FlagZ := is_zero(a7);
        FlagA := a8[3];
        FlagP := parity(a7);
        FlagCY := false;
        jump ((M[a9],M[a6]));
      } else {
        advance (10)
        #06BA
        #instruction: LD   HL,208A
        advance (10)
        #06BD
        #instruction: LD   A,(HL)
        advance (7)
        #06BE
        #instruction: INC  HL
        advance (5)
        #06BF
        #instruction: INC  HL
        advance (5)
        #06C0
        #instruction: ADD  (HL)
        let:16 a11 = addWithCarry(false,M[208C],M[208A]) in
        let:8 a12 = (M[208C] & 0F) in
        let:8 a13 = (M[208A] & 0F) in
        let:16 a14 = addWithCarry(false,a12,a13) in
        advance (7)
        #06C1
        #instruction: LD   (208A),A
        M[208A] := a11[7:0];
        advance (13)
        #06C4
        #instruction: CALL 073C
        let:16 a15 = (-1 + (SPH,SPL)) in
        M[a15] := 06;
        let:16 a16 = (-1 + a15) in
        M[a16] := C7;
        #return-to: 06C7
        advance (17)
        #073C
        #instruction: CALL 0742
        let:16 a17 = (-1 + a16) in
        M[a17] := 07;
        let:16 a18 = (-1 + a17) in
        M[a18] := 3F;
        #return-to: 073F
        advance (17)
        #0742
        #instruction: LD   HL,2087
        advance (10)
        #0745
        #instruction: CALL 1A3B
        let:16 a19 = (-1 + a18) in
        M[a19] := 07;
        let:16 a20 = (-1 + a19) in
        M[a20] := 48;
        #return-to: 0748
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a21 = (1 + a20) in
        let:16 a22 = (1 + a21) in
        advance (10)
        A := M[2089];
        B := M[208B];
        C := M[208A];
        D := M[2088];
        E := M[2087];
        H := M[208A];
        L := M[2089];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := a11[15:8][0];
        jump ((M[a21],M[a20]));
      }
    }

06C7:

    #instruction: LD   HL,208A
    advance (10)
    #06CA
    #instruction: LD   A,(HL)
    advance (7)
    #06CB
    #instruction: CP   28
    let:16 a1 = addWithCarry(!false,M[208A],~28) in
    let:8 a2 = (M[208A] & 0F) in
    let:8 a3 = (~28 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #06CD
    #instruction: JP   CY,06F9
    if (!a1[15:8][0]) {
      advance (10)
      #06F9
      #instruction: CALL 0742
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 06;
      let:16 a6 = (-1 + a5) in
      M[a6] := FC;
      #return-to: 06FC
      advance (17)
      #0742
      #instruction: LD   HL,2087
      advance (10)
      #0745
      #instruction: CALL 1A3B
      let:16 a7 = (-1 + a6) in
      M[a7] := 07;
      let:16 a8 = (-1 + a7) in
      M[a8] := 48;
      #return-to: 0748
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      advance (7)
      #1A44
      #instruction: LD   H,C
      advance (5)
      #1A45
      #instruction: LD   L,A
      advance (5)
      #1A46
      #instruction: RET
      let:16 a9 = (1 + a8) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := M[2089];
      B := M[208B];
      C := M[208A];
      D := M[2088];
      E := M[2087];
      H := M[208A];
      L := M[2089];
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump ((M[a9],M[a8]));
    } else {
      advance (10)
      #06D0
      #instruction: CP   E1
      let:16 a11 = addWithCarry(!false,M[208A],~E1) in
      let:8 a12 = (M[208A] & 0F) in
      let:8 a13 = (~E1 & 0F) in
      let:16 a14 = addWithCarry(!false,a12,a13) in
      advance (7)
      #06D2
      #instruction: JP   NC,06F9
      if (!!a11[15:8][0]) {
        advance (10)
        #06F9
        #instruction: CALL 0742
        let:16 a15 = (-1 + (SPH,SPL)) in
        M[a15] := 06;
        let:16 a16 = (-1 + a15) in
        M[a16] := FC;
        #return-to: 06FC
        advance (17)
        #0742
        #instruction: LD   HL,2087
        advance (10)
        #0745
        #instruction: CALL 1A3B
        let:16 a17 = (-1 + a16) in
        M[a17] := 07;
        let:16 a18 = (-1 + a17) in
        M[a18] := 48;
        #return-to: 0748
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a19 = (1 + a18) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := M[2089];
        B := M[208B];
        C := M[208A];
        D := M[2088];
        E := M[2087];
        H := M[208A];
        L := M[2089];
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := !a11[15:8][0];
        jump ((M[a19],M[a18]));
      } else {
        advance (10)
        #06D5
        #instruction: RET
        let:16 a21 = (1 + (SPH,SPL)) in
        let:16 a22 = (1 + a21) in
        advance (10)
        A := M[208A];
        H := 20;
        L := 8A;
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := !a11[15:8][0];
        jump ((M[a21],M[(SPH,SPL)]));
      }
    }

06DB:

    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    #06DC
    #instruction: DEC  (HL)
    let:16 a2 = addWithCarry(!true,M[a1],~00) in
    let:8 a3 = (M[a1] & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    M[a1] := a2[7:0];
    advance (10)
    #06DD
    #instruction: LD   A,(HL)
    advance (7)
    #06DE
    #instruction: CP   1F
    let:16 a6 = addWithCarry(!false,M[a1],~1F) in
    let:8 a7 = (M[a1] & 0F) in
    let:8 a8 = (~1F & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    #06E0
    #instruction: JP   Z,074B
    if (is_zero(a6[7:0])) {
      advance (10)
      #074B
      #instruction: LD   B,10
      advance (7)
      #074D
      #instruction: LD   HL,2098
      advance (10)
      #0750
      #instruction: LD   A,(HL)
      advance (7)
      #0751
      #instruction: OR   B
      let:8 a10 = (10 | M[2098]) in
      advance (4)
      #0752
      #instruction: LD   (HL),A
      M[2098] := a10;
      advance (7)
      #0753
      #instruction: CALL 1770
      let:16 a11 = (-1 + (SPH,SPL)) in
      M[a11] := 07;
      let:16 a12 = (-1 + a11) in
      M[a12] := 56;
      #return-to: 0756
      advance (17)
      #1770
      #instruction: AND  30
      let:8 a13 = (30 & a10) in
      let:8 a14 = (30 | a10) in
      advance (7)
      #1772
      #instruction: OUT  05
      sound_control(FleetMovement1,a13[0]);
      sound_control(FleetMovement2,a13[1]);
      sound_control(FleetMovement3,a13[2]);
      sound_control(FleetMovement4,a13[3]);
      sound_control(UfoHit,a13[4]);
      advance (10)
      #1774
      #instruction: RET
      let:16 a15 = (1 + a12) in
      let:16 a16 = (1 + a15) in
      advance (10)
      A := a13;
      B := 10;
      H := 20;
      L := 98;
      SPH := a16[15:8];
      SPL := a16[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := a14[3];
      FlagP := parity(a13);
      FlagCY := false;
      jump ((M[a15],M[a12]));
    } else {
      advance (10)
      #06E3
      #instruction: CP   18
      let:16 a17 = addWithCarry(!false,M[a1],~18) in
      let:8 a18 = (M[a1] & 0F) in
      let:8 a19 = (~18 & 0F) in
      let:16 a20 = addWithCarry(!false,a18,a19) in
      advance (7)
      #06E5
      #instruction: JP   Z,070C
      if (is_zero(a17[7:0])) {
        advance (10)
        #070C
        #instruction: LD   A,01
        advance (7)
        #070E
        #instruction: LD   (20F1),A
        M[20F1] := 01;
        advance (13)
        #0711
        #instruction: LD   HL,(208D)
        advance (16)
        #0714
        #instruction: LD   B,(HL)
        advance (7)
        #0715
        #instruction: LD   C,04
        advance (7)
        #0717
        #instruction: LD   HL,1D50
        advance (10)
        #071A
        #instruction: LD   DE,1D4C
        advance (10)
        #071D
        #instruction: LD   A,(DE)
        advance (7)
        #071E
        #instruction: CP   B
        let:16 a21 = addWithCarry(!false,05,~M[(M[208E],M[208D])]) in
        let:8 a22 = (05 & 0F) in
        let:8 a23 = (~M[(M[208E],M[208D])] & 0F) in
        let:16 a24 = addWithCarry(!false,a22,a23) in
        advance (4)
        #071F
        #instruction: JP   Z,0728
        if (is_zero(a21[7:0])) {
          advance (10)
          #0728
          #instruction: LD   A,(HL)
          advance (7)
          #0729
          #instruction: LD   (2087),A
          M[2087] := 94;
          advance (13)
          #072C
          #instruction: LD   H,00
          advance (7)
          #072E
          #instruction: LD   L,B
          advance (5)
          #072F
          #instruction: ADD  HL,HL
          let:17 a25 = add17((00,M[(M[208E],M[208D])]),(00,M[(M[208E],M[208D])])) in
          advance (10)
          #0730
          #instruction: ADD  HL,HL
          let:17 a26 = add17(a25[15:0],a25[15:0]) in
          advance (10)
          #0731
          #instruction: ADD  HL,HL
          let:17 a27 = add17(a26[15:0],a26[15:0]) in
          advance (10)
          #0732
          #instruction: ADD  HL,HL
          let:17 a28 = add17(a27[15:0],a27[15:0]) in
          advance (10)
          #0733
          #instruction: LD   (20F2),HL
          M[20F2] := a28[15:0][7:0];
          M[20F3] := a28[15:0][15:8];
          advance (16)
          #0736
          #instruction: CALL 0742
          let:16 a29 = (-1 + (SPH,SPL)) in
          M[a29] := 07;
          let:16 a30 = (-1 + a29) in
          M[a30] := 39;
          #return-to: 0739
          advance (17)
          #0742
          #instruction: LD   HL,2087
          advance (10)
          #0745
          #instruction: CALL 1A3B
          let:16 a31 = (-1 + a30) in
          M[a31] := 07;
          let:16 a32 = (-1 + a31) in
          M[a32] := 48;
          #return-to: 0748
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a33 = (1 + a32) in
          let:16 a34 = (1 + a33) in
          advance (10)
          A := M[2089];
          B := M[208B];
          C := M[208A];
          D := M[2088];
          E := M[2087];
          H := M[208A];
          L := M[2089];
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := a28[16];
          jump ((M[a33],M[a32]));
        } else {
          advance (10)
          #0722
          #instruction: INC  HL
          advance (5)
          #0723
          #instruction: INC  DE
          advance (5)
          #0724
          #instruction: DEC  C
          let:16 a35 = addWithCarry(!true,04,~00) in
          let:8 a36 = (04 & 0F) in
          let:8 a37 = (~00 & 0F) in
          let:16 a38 = addWithCarry(!true,a36,a37) in
          advance (5)
          #0725
          #instruction: JP   NZ,071D
          if (!is_zero(a35[7:0])) {
            advance (10)
            A := 05;
            B := M[(M[208E],M[208D])];
            C := a35[7:0];
            D := 1D;
            E := 4D;
            H := 1D;
            L := 51;
            FlagS := a35[7:0][7];
            FlagZ := is_zero(a35[7:0]);
            FlagA := a38[7:0][4];
            FlagP := parity(a35[7:0]);
            FlagCY := !a21[15:8][0];
            jump (071D);
          } else {
            advance (10)
            #0728
            #instruction: LD   A,(HL)
            advance (7)
            #0729
            #instruction: LD   (2087),A
            M[2087] := 97;
            advance (13)
            #072C
            #instruction: LD   H,00
            advance (7)
            #072E
            #instruction: LD   L,B
            advance (5)
            #072F
            #instruction: ADD  HL,HL
            let:17 a39 = add17((00,M[(M[208E],M[208D])]),(00,M[(M[208E],M[208D])])) in
            advance (10)
            #0730
            #instruction: ADD  HL,HL
            let:17 a40 = add17(a39[15:0],a39[15:0]) in
            advance (10)
            #0731
            #instruction: ADD  HL,HL
            let:17 a41 = add17(a40[15:0],a40[15:0]) in
            advance (10)
            #0732
            #instruction: ADD  HL,HL
            let:17 a42 = add17(a41[15:0],a41[15:0]) in
            advance (10)
            #0733
            #instruction: LD   (20F2),HL
            M[20F2] := a42[15:0][7:0];
            M[20F3] := a42[15:0][15:8];
            advance (16)
            #0736
            #instruction: CALL 0742
            let:16 a43 = (-1 + (SPH,SPL)) in
            M[a43] := 07;
            let:16 a44 = (-1 + a43) in
            M[a44] := 39;
            #return-to: 0739
            advance (17)
            #0742
            #instruction: LD   HL,2087
            advance (10)
            #0745
            #instruction: CALL 1A3B
            let:16 a45 = (-1 + a44) in
            M[a45] := 07;
            let:16 a46 = (-1 + a45) in
            M[a46] := 48;
            #return-to: 0748
            advance (17)
            #1A3B
            #instruction: LD   E,(HL)
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            advance (7)
            #1A44
            #instruction: LD   H,C
            advance (5)
            #1A45
            #instruction: LD   L,A
            advance (5)
            #1A46
            #instruction: RET
            let:16 a47 = (1 + a46) in
            let:16 a48 = (1 + a47) in
            advance (10)
            A := M[2089];
            B := M[208B];
            C := M[208A];
            D := M[2088];
            E := M[2087];
            H := M[208A];
            L := M[2089];
            SPH := a48[15:8];
            SPL := a48[7:0];
            FlagS := a35[7:0][7];
            FlagZ := is_zero(a35[7:0]);
            FlagA := a38[7:0][4];
            FlagP := parity(a35[7:0]);
            FlagCY := a42[16];
            jump ((M[a47],M[a46]));
          }
        }
      } else {
        advance (10)
        #06E8
        #instruction: AND  A
        let:8 a49 = (M[a1] & M[a1]) in
        let:8 a50 = (M[a1] | M[a1]) in
        advance (4)
        #06E9
        #instruction: RET  NZ
        if (!is_zero(a49)) {
          let:16 a51 = (1 + (SPH,SPL)) in
          let:16 a52 = (1 + a51) in
          advance (11)
          A := a49;
          H := a1[15:8];
          L := a1[7:0];
          SPH := a52[15:8];
          SPL := a52[7:0];
          FlagS := a49[7];
          FlagZ := is_zero(a49);
          FlagA := a50[3];
          FlagP := parity(a49);
          FlagCY := false;
          jump ((M[a51],M[(SPH,SPL)]));
        } else {
          advance (5)
          #06EA
          #instruction: LD   B,EF
          advance (7)
          #06EC
          #instruction: LD   HL,2098
          advance (10)
          #06EF
          #instruction: LD   A,(HL)
          advance (7)
          #06F0
          #instruction: AND  B
          let:8 a53 = (EF & M[2098]) in
          let:8 a54 = (EF | M[2098]) in
          advance (4)
          #06F1
          #instruction: LD   (HL),A
          M[2098] := a53;
          advance (7)
          #06F2
          #instruction: AND  20
          let:8 a55 = (20 & a53) in
          let:8 a56 = (20 | a53) in
          advance (7)
          #06F4
          #instruction: OUT  05
          sound_control(FleetMovement1,a55[0]);
          sound_control(FleetMovement2,a55[1]);
          sound_control(FleetMovement3,a55[2]);
          sound_control(FleetMovement4,a55[3]);
          sound_control(UfoHit,a55[4]);
          advance (10)
          #06F6
          #instruction: NOP
          advance (4)
          #06F7
          #instruction: NOP
          advance (4)
          #06F8
          #instruction: NOP
          advance (4)
          #06F9
          #instruction: CALL 0742
          let:16 a57 = (-1 + (SPH,SPL)) in
          M[a57] := 06;
          let:16 a58 = (-1 + a57) in
          M[a58] := FC;
          #return-to: 06FC
          advance (17)
          #0742
          #instruction: LD   HL,2087
          advance (10)
          #0745
          #instruction: CALL 1A3B
          let:16 a59 = (-1 + a58) in
          M[a59] := 07;
          let:16 a60 = (-1 + a59) in
          M[a60] := 48;
          #return-to: 0748
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          advance (7)
          #1A44
          #instruction: LD   H,C
          advance (5)
          #1A45
          #instruction: LD   L,A
          advance (5)
          #1A46
          #instruction: RET
          let:16 a61 = (1 + a60) in
          let:16 a62 = (1 + a61) in
          advance (10)
          A := M[2089];
          B := M[208B];
          C := M[208A];
          D := M[2088];
          E := M[2087];
          H := M[208A];
          L := M[2089];
          SPH := a62[15:8];
          SPL := a62[7:0];
          FlagS := a55[7];
          FlagZ := is_zero(a55);
          FlagA := a56[3];
          FlagP := parity(a55);
          FlagCY := false;
          jump ((M[a61],M[a60]));
        }
      }
    }

06FC:

    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 06;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 06FF
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a3 = (A ^ A) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:16 a4 = (-1 + a2) in
    M[a4] := B;
    let:16 a5 = (-1 + a4) in
    M[a5] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[(H,L)] := a3;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a6 = add17(0020,(H,L)) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a7 = (1 + a5) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,M[a7],~00) in
    let:8 a10 = (M[a7] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := a3;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a13 = (1 + a8) in
      let:16 a14 = (1 + a13) in
      advance (10)
      A := a3;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump ((M[a13],M[a8]));
    }

06FF:

    #instruction: LD   HL,2083
    advance (10)
    #0702
    #instruction: LD   B,0A
    advance (7)
    #0704
    #instruction: CALL 075F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0707
    advance (17)
    #075F
    #instruction: LD   DE,1B83
    advance (10)
    #0762
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2083] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,0A,~00) in
    let:8 a4 = (0A & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 84;
      H := 20;
      L := 84;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := 84;
      H := 20;
      L := 84;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0707:

    #instruction: LD   B,FE
    advance (7)
    #0709
    #instruction: JP   19DC
    advance (10)
    #19DC
    #instruction: LD   A,(2094)
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a1 = (FE & M[2094]) in
    let:8 a2 = (FE | M[2094]) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    M[2094] := a1;
    advance (13)
    #19E3
    #instruction: OUT  03
    sound_control(Ufo,a1[0]);
    sound_control(Shot,a1[1]);
    sound_control(PlayerDie,a1[2]);
    sound_control(InvaderDie,a1[3]);
    sound_control(ExtraLife,a1[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:16 a3 = (1 + (SPH,SPL)) in
    let:16 a4 = (1 + a3) in
    advance (10)
    A := a1;
    B := FE;
    SPH := a4[15:8];
    SPL := a4[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a3],M[(SPH,SPL)]));

0739:

    #instruction: JP   08F1
    advance (10)
    #08F1
    #instruction: LD   C,03
    advance (7)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a3 = (-1 + a2) in
    M[a3] := 08;
    let:16 a4 = (-1 + a3) in
    M[a4] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a5 = (-1 + a4) in
    M[a5] := H;
    let:16 a6 = (-1 + a5) in
    M[a6] := L;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a7 = add17((00,M[(D,E)]),(00,M[(D,E)])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a8 = add17(a7[15:0],a7[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a9 = add17(a8[15:0],a8[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a10 = add17(1E00,a9[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a11 = (1 + a6) in
    let:16 a12 = (1 + a11) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a13 = (-1 + a12) in
    M[a13] := 08;
    let:16 a14 = (-1 + a13) in
    M[a14] := 03;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a11],M[a6])] := M[a10[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a15 = (1 + a10[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a16 = add17(0020,(M[a11],M[a6])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a17 = (1 + a14) in
    let:16 a18 = (1 + a17) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,M[a17],~00) in
    let:8 a20 = (M[a17] & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := M[a10[15:0]];
      B := a19[7:0];
      C := M[a14];
      D := a15[15:8];
      E := a15[7:0];
      H := a16[15:0][15:8];
      L := a16[15:0][7:0];
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a16[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a23 = (1 + a18) in
      let:16 a24 = (1 + a23) in
      advance (10)
      A := M[a10[15:0]];
      B := a19[7:0];
      C := M[a14];
      D := a15[15:8];
      E := a15[7:0];
      H := a16[15:0][15:8];
      L := a16[15:0][7:0];
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a16[16];
      jump ((M[a23],M[a18]));
    }

073F:

    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(H,L)] := M[(D,E)];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a3 = (1 + (D,E)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a4 = add17(0020,(H,L)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a5 = (1 + a2) in
    let:16 a6 = (1 + a5) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,M[a5],~00) in
    let:8 a8 = (M[a5] & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := M[(D,E)];
      B := a7[7:0];
      C := M[a2];
      D := a3[15:8];
      E := a3[7:0];
      H := a4[15:0][15:8];
      L := a4[15:0][7:0];
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a4[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := M[(D,E)];
      B := a7[7:0];
      C := M[a2];
      D := a3[15:8];
      E := a3[7:0];
      H := a4[15:0][15:8];
      L := a4[15:0][7:0];
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a4[16];
      jump ((M[a11],M[a6]));
    }

0748:

    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,03,~00) in
    let:8 a4 = (03 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a3[7:0];
      H := updateBit((H >> 01),7,FlagCY);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := L[0];
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a7 = (3F & updateBit((H >> 01),7,FlagCY)) in
      let:8 a8 = (3F | updateBit((H >> 01),7,FlagCY)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a9 = (20 | a7) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a10 = (1 + a2) in
      let:16 a11 = (1 + a10) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a12 = (1 + a11) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := a9;
      B := M[a10];
      C := M[a2];
      H := a9;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := false;
      FlagP := parity(a9);
      FlagCY := false;
      jump ((M[a12],M[a11]));
    }

0756:

    #instruction: LD   HL,1D7C
    advance (10)
    #0759
    #instruction: LD   (2087),HL
    M[2087] := 7C;
    M[2088] := 1D;
    advance (16)
    #075C
    #instruction: JP   073C
    advance (10)
    #073C
    #instruction: CALL 0742
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3F;
    #return-to: 073F
    advance (17)
    #0742
    #instruction: LD   HL,2087
    advance (10)
    #0745
    #instruction: CALL 1A3B
    let:16 a3 = (-1 + a2) in
    M[a3] := 07;
    let:16 a4 = (-1 + a3) in
    M[a4] := 48;
    #return-to: 0748
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    advance (7)
    #1A44
    #instruction: LD   H,C
    advance (5)
    #1A45
    #instruction: LD   L,A
    advance (5)
    #1A46
    #instruction: RET
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := M[2089];
    B := M[208B];
    C := M[208A];
    D := M[2088];
    E := M[2087];
    H := M[208A];
    L := M[2089];
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump ((M[a5],M[a4]));

0771:

    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 0774
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a3 = (1F & 03) in
    let:8 a4 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a5 = addWithCarry(!false,a3,~1C) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~1C & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a5[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a9 = addWithCarry(!false,24,~40) in
      let:8 a10 = (24 & 0F) in
      let:8 a11 = (~40 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a9[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a15 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a16 = addWithCarry(!false,a15[15:0][15:8],~40) in
      let:8 a17 = (a15[15:0][15:8] & 0F) in
      let:8 a18 = (~40 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a16[15:8][0]) {
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a20 = (1 + a2) in
        let:16 a21 = (1 + a20) in
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((M[a20],M[a2]));
      }
    }

0774:

    #instruction: LD   HL,3013
    advance (10)
    #0777
    #instruction: LD   DE,1FF3
    advance (10)
    #077A
    #instruction: LD   C,04
    advance (7)
    #077C
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7F;
    #return-to: 077F
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1F;
    let:16 a4 = (-1 + a3) in
    M[a4] := F3;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 08;
    let:16 a6 = (-1 + a5) in
    M[a6] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 30;
    let:16 a8 = (-1 + a7) in
    M[a8] := 13;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(000F,000F) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 04;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

077F:

    #instruction: LD   A,(20EB)
    advance (13)
    #0782
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,M[20EB],~00) in
    let:8 a2 = (M[20EB] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #0783
    #instruction: LD   HL,2810
    advance (10)
    #0786
    #instruction: LD   C,14
    advance (7)
    #0788
    #instruction: JP   NZ,0857
    if (!is_zero(a1[7:0])) {
      advance (10)
      #0857
      #instruction: LD   DE,1ABA
      advance (10)
      #085A
      #instruction: CALL 08F3
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 08;
      let:16 a6 = (-1 + a5) in
      M[a6] := 5D;
      #return-to: 085D
      advance (17)
      #08F3
      #instruction: LD   A,(DE)
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:16 a7 = (-1 + a6) in
      M[a7] := 1A;
      let:16 a8 = (-1 + a7) in
      M[a8] := BA;
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:16 a9 = (-1 + a8) in
      M[a9] := 08;
      let:16 a10 = (-1 + a9) in
      M[a10] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a11 = (-1 + a10) in
      M[a11] := 28;
      let:16 a12 = (-1 + a11) in
      M[a12] := 10;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a13 = add17(001B,001B) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a14 = add17(a13[15:0],a13[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a15 = add17(a14[15:0],a14[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a16 = add17(1E00,a15[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a17 = (1 + a12) in
      let:16 a18 = (1 + a17) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a19 = (-1 + a18) in
      M[a19] := 08;
      let:16 a20 = (-1 + a19) in
      M[a20] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a17],M[a12])] := M[a16[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a21 = (1 + a16[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a22 = add17(0020,(M[a17],M[a12])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a23 = (1 + a20) in
      let:16 a24 = (1 + a23) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a25 = addWithCarry(!true,M[a23],~00) in
      let:8 a26 = (M[a23] & 0F) in
      let:8 a27 = (~00 & 0F) in
      let:16 a28 = addWithCarry(!true,a26,a27) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a25[7:0])) {
        advance (10)
        A := M[a16[15:0]];
        B := a25[7:0];
        C := M[a20];
        D := a21[15:8];
        E := a21[7:0];
        H := a22[15:0][15:8];
        L := a22[15:0][7:0];
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a25[7:0][7];
        FlagZ := is_zero(a25[7:0]);
        FlagA := a28[7:0][4];
        FlagP := parity(a25[7:0]);
        FlagCY := a22[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a29 = (1 + a24) in
        let:16 a30 = (1 + a29) in
        advance (10)
        A := M[a16[15:0]];
        B := a25[7:0];
        C := M[a20];
        D := a21[15:8];
        E := a21[7:0];
        H := a22[15:0][15:8];
        L := a22[15:0][7:0];
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a25[7:0][7];
        FlagZ := is_zero(a25[7:0]);
        FlagA := a28[7:0][4];
        FlagP := parity(a25[7:0]);
        FlagCY := a22[16];
        jump ((M[a29],M[a24]));
      }
    } else {
      advance (10)
      #078B
      #instruction: LD   DE,1ACF
      advance (10)
      #078E
      #instruction: CALL 08F3
      let:16 a31 = (-1 + (SPH,SPL)) in
      M[a31] := 07;
      let:16 a32 = (-1 + a31) in
      M[a32] := 91;
      #return-to: 0791
      advance (17)
      #08F3
      #instruction: LD   A,(DE)
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:16 a33 = (-1 + a32) in
      M[a33] := 1A;
      let:16 a34 = (-1 + a33) in
      M[a34] := CF;
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:16 a35 = (-1 + a34) in
      M[a35] := 08;
      let:16 a36 = (-1 + a35) in
      M[a36] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a37 = (-1 + a36) in
      M[a37] := 28;
      let:16 a38 = (-1 + a37) in
      M[a38] := 10;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a39 = add17(000E,000E) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a40 = add17(a39[15:0],a39[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a41 = add17(a40[15:0],a40[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a42 = add17(1E00,a41[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a43 = (1 + a38) in
      let:16 a44 = (1 + a43) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a45 = (-1 + a44) in
      M[a45] := 08;
      let:16 a46 = (-1 + a45) in
      M[a46] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a43],M[a38])] := M[a42[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a47 = (1 + a42[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a48 = add17(0020,(M[a43],M[a38])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a49 = (1 + a46) in
      let:16 a50 = (1 + a49) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a51 = addWithCarry(!true,M[a49],~00) in
      let:8 a52 = (M[a49] & 0F) in
      let:8 a53 = (~00 & 0F) in
      let:16 a54 = addWithCarry(!true,a52,a53) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a51[7:0])) {
        advance (10)
        A := M[a42[15:0]];
        B := a51[7:0];
        C := M[a46];
        D := a47[15:8];
        E := a47[7:0];
        H := a48[15:0][15:8];
        L := a48[15:0][7:0];
        SPH := a50[15:8];
        SPL := a50[7:0];
        FlagS := a51[7:0][7];
        FlagZ := is_zero(a51[7:0]);
        FlagA := a54[7:0][4];
        FlagP := parity(a51[7:0]);
        FlagCY := a48[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a55 = (1 + a50) in
        let:16 a56 = (1 + a55) in
        advance (10)
        A := M[a42[15:0]];
        B := a51[7:0];
        C := M[a46];
        D := a47[15:8];
        E := a47[7:0];
        H := a48[15:0][15:8];
        L := a48[15:0][7:0];
        SPH := a56[15:8];
        SPL := a56[7:0];
        FlagS := a51[7:0][7];
        FlagZ := is_zero(a51[7:0]);
        FlagA := a54[7:0][4];
        FlagP := parity(a51[7:0]);
        FlagCY := a48[16];
        jump ((M[a55],M[a50]));
      }
    }

0791:

    #instruction: IN   01
    advance (10)
    #0793
    #instruction: AND  04
    let:8 a1 = (04 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
    let:8 a2 = (04 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
    advance (7)
    #0795
    #instruction: JP   Z,077F
    if (is_zero(a1)) {
      advance (10)
      A := a1;
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump (077F);
    } else {
      advance (10)
      #0798
      #instruction: LD   B,99
      advance (7)
      #079A
      #instruction: XOR  A
      let:8 a3 = (a1 ^ a1) in
      advance (4)
      #079B
      #instruction: LD   (20CE),A
      M[20CE] := a3;
      advance (13)
      #079E
      #instruction: LD   A,(20EB)
      advance (13)
      #07A1
      #instruction: ADD  B
      let:16 a4 = addWithCarry(false,99,M[20EB]) in
      let:8 a5 = (99 & 0F) in
      let:8 a6 = (M[20EB] & 0F) in
      let:16 a7 = addWithCarry(false,a5,a6) in
      advance (4)
      #07A2
      #instruction: DAA
      let:8 a8 = (a4[7:0] & 0F) in
      let:16 a9 = addWithCarry(false,a8,06) in
      let:16 a10 = addWithCarry(((((a8[1] || a8[2]) && a8[3]) || a7[7:0][4]) ? a9[7:0] : a8)[4],(a4[7:0] >> 04),00) in
      let:16 a11 = addWithCarry(false,a10[7:0],06) in
      let:8 a12 = (((((a8[1] || a8[2]) && a8[3]) || a7[7:0][4]) ? a9[7:0] : a8) & 0F) in
      let:8 a13 = ((((((a10[7:0][1] || a10[7:0][2]) && a10[7:0][3]) || a4[15:8][0]) ? a11[7:0] : a10[7:0]) << 04) | a12) in
      advance (4)
      #07A3
      #instruction: LD   (20EB),A
      M[20EB] := a13;
      advance (13)
      #07A6
      #instruction: CALL 1947
      let:16 a14 = (-1 + (SPH,SPL)) in
      M[a14] := 07;
      let:16 a15 = (-1 + a14) in
      M[a15] := A9;
      #return-to: 07A9
      advance (17)
      #1947
      #instruction: LD   A,(20EB)
      advance (13)
      #194A
      #instruction: LD   HL,3C01
      advance (10)
      #194D
      #instruction: JP   09B2
      advance (10)
      #09B2
      #instruction: PUSH DE
      let:16 a16 = (-1 + a15) in
      M[a16] := D;
      let:16 a17 = (-1 + a16) in
      M[a17] := E;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:16 a18 = (-1 + a17) in
      M[a18] := M[20EB];
      let:16 a19 = (-1 + a18) in
      M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a13[7]),6,is_zero(a13)),4,((((a8[1] || a8[2]) && a8[3]) || a7[7:0][4]) ? a9[7:0] : a8)[4]),2,parity(a13)),0,(((((a10[7:0][1] || a10[7:0][2]) && a10[7:0][3]) || a4[15:8][0]) ? a11[7:0] : a10[7:0])[4] || a4[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA 
      advance (4)
      #09B5
      #instruction: RRCA 
      advance (4)
      #09B6
      #instruction: RRCA 
      advance (4)
      #09B7
      #instruction: RRCA 
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a20 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
      let:8 a21 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:16 a22 = (-1 + a19) in
      M[a22] := 09;
      let:16 a23 = (-1 + a22) in
      M[a23] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:16 a24 = addWithCarry(false,1A,a20) in
      let:8 a25 = (1A & 0F) in
      let:8 a26 = (a20 & 0F) in
      let:16 a27 = addWithCarry(false,a25,a26) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a28 = (-1 + a23) in
      M[a28] := 3C;
      let:16 a29 = (-1 + a28) in
      M[a29] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a30 = add17((00,a24[7:0]),(00,a24[7:0])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a31 = add17(a30[15:0],a30[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a32 = add17(a31[15:0],a31[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a33 = add17(1E00,a32[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a34 = (1 + a29) in
      let:16 a35 = (1 + a34) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a36 = (-1 + a35) in
      M[a36] := 08;
      let:16 a37 = (-1 + a36) in
      M[a37] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a34],M[a29])] := M[a33[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a38 = (1 + a33[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a39 = add17(0020,(M[a34],M[a29])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a40 = (1 + a37) in
      let:16 a41 = (1 + a40) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a42 = addWithCarry(!true,M[a40],~00) in
      let:8 a43 = (M[a40] & 0F) in
      let:8 a44 = (~00 & 0F) in
      let:16 a45 = addWithCarry(!true,a43,a44) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a42[7:0])) {
        advance (10)
        A := M[a33[15:0]];
        B := a42[7:0];
        C := M[a37];
        D := a38[15:8];
        E := a38[7:0];
        H := a39[15:0][15:8];
        L := a39[15:0][7:0];
        SPH := a41[15:8];
        SPL := a41[7:0];
        FlagS := a42[7:0][7];
        FlagZ := is_zero(a42[7:0]);
        FlagA := a45[7:0][4];
        FlagP := parity(a42[7:0]);
        FlagCY := a39[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a46 = (1 + a41) in
        let:16 a47 = (1 + a46) in
        advance (10)
        A := M[a33[15:0]];
        B := a42[7:0];
        C := M[a37];
        D := a38[15:8];
        E := a38[7:0];
        H := a39[15:0][15:8];
        L := a39[15:0][7:0];
        SPH := a47[15:8];
        SPL := a47[7:0];
        FlagS := a42[7:0][7];
        FlagZ := is_zero(a42[7:0]);
        FlagA := a45[7:0][4];
        FlagP := parity(a42[7:0]);
        FlagCY := a39[16];
        jump ((M[a46],M[a41]));
      }
    }

07A9:

    #instruction: LD   HL,0000
    advance (10)
    #07AC
    #instruction: LD   (20F8),HL
    M[20F8] := 00;
    M[20F9] := 00;
    advance (16)
    #07AF
    #instruction: LD   (20FC),HL
    M[20FC] := 00;
    M[20FD] := 00;
    advance (16)
    #07B2
    #instruction: CALL 1925
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := B5;
    #return-to: 07B5
    advance (17)
    #1925
    #instruction: LD   HL,20F8
    advance (10)
    #1928
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20F9];
    let:16 a6 = (-1 + a5) in
    M[a6] := M[20F8];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a7 = (-1 + a6) in
    M[a7] := M[20F9];
    let:16 a8 = (-1 + a7) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a9 = (0F & updateBit((updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0])[0])) in
    let:8 a10 = (0F | updateBit((updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a11 = (-1 + a8) in
    M[a11] := 09;
    let:16 a12 = (-1 + a11) in
    M[a12] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a13 = addWithCarry(false,1A,a9) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a9 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a17 = (-1 + a12) in
    M[a17] := M[20FB];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[20FA];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17((00,a13[7:0]),(00,a13[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a20 = add17(a19[15:0],a19[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a21 = add17(a20[15:0],a20[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a22 = add17(1E00,a21[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a23 = (1 + a18) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a25 = (-1 + a24) in
    M[a25] := 08;
    let:16 a26 = (-1 + a25) in
    M[a26] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a23],M[a18])] := M[a22[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a27 = (1 + a22[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a28 = add17(0020,(M[a23],M[a18])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a29 = (1 + a26) in
    let:16 a30 = (1 + a29) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a31 = addWithCarry(!true,M[a29],~00) in
    let:8 a32 = (M[a29] & 0F) in
    let:8 a33 = (~00 & 0F) in
    let:16 a34 = addWithCarry(!true,a32,a33) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a31[7:0])) {
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a35 = (1 + a30) in
      let:16 a36 = (1 + a35) in
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump ((M[a35],M[a30]));
    }

07B5:

    #instruction: CALL 192B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := B8;
    #return-to: 07B8
    advance (17)
    #192B
    #instruction: LD   HL,20FC
    advance (10)
    #192E
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20FD];
    let:16 a6 = (-1 + a5) in
    M[a6] := M[20FC];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a7 = (-1 + a6) in
    M[a7] := M[20FD];
    let:16 a8 = (-1 + a7) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a9 = (0F & updateBit((updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0])[0])) in
    let:8 a10 = (0F | updateBit((updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a11 = (-1 + a8) in
    M[a11] := 09;
    let:16 a12 = (-1 + a11) in
    M[a12] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a13 = addWithCarry(false,1A,a9) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a9 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a17 = (-1 + a12) in
    M[a17] := M[20FF];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[20FE];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17((00,a13[7:0]),(00,a13[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a20 = add17(a19[15:0],a19[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a21 = add17(a20[15:0],a20[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a22 = add17(1E00,a21[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a23 = (1 + a18) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a25 = (-1 + a24) in
    M[a25] := 08;
    let:16 a26 = (-1 + a25) in
    M[a26] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a23],M[a18])] := M[a22[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a27 = (1 + a22[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a28 = add17(0020,(M[a23],M[a18])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a29 = (1 + a26) in
    let:16 a30 = (1 + a29) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a31 = addWithCarry(!true,M[a29],~00) in
    let:8 a32 = (M[a29] & 0F) in
    let:8 a33 = (~00 & 0F) in
    let:16 a34 = addWithCarry(!true,a32,a33) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a31[7:0])) {
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a35 = (1 + a30) in
      let:16 a36 = (1 + a35) in
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump ((M[a35],M[a30]));
    }

07B8:

    #instruction: CALL 19D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := BB;
    #return-to: 07BB
    advance (17)
    #19D7
    #instruction: XOR  A
    let:8 a3 = (A ^ A) in
    advance (4)
    #19D8
    #instruction: JP   19D3
    advance (10)
    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := a3;
    advance (13)
    #19D6
    #instruction: RET
    let:16 a4 = (1 + a2) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a3;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a4],M[a2]));

07BB:

    #instruction: LD   HL,0101
    advance (10)
    #07BE
    #instruction: LD   A,H
    advance (5)
    #07BF
    #instruction: LD   (20EF),A
    M[20EF] := 01;
    advance (13)
    #07C2
    #instruction: LD   (20E7),HL
    M[20E7] := 01;
    M[20E8] := 01;
    advance (16)
    #07C5
    #instruction: LD   (20E5),HL
    M[20E5] := 01;
    M[20E6] := 01;
    advance (16)
    #07C8
    #instruction: CALL 1956
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := CB;
    #return-to: 07CB
    advance (17)
    #1956
    #instruction: CALL 1A5C
    let:16 a3 = (-1 + a2) in
    M[a3] := 19;
    let:16 a4 = (-1 + a3) in
    M[a4] := 59;
    #return-to: 1959
    advance (17)
    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    #1A5F
    #instruction: LD   (HL),00
    M[2400] := 00;
    advance (10)
    #1A61
    #instruction: INC  HL
    advance (5)
    #1A62
    #instruction: LD   A,H
    advance (5)
    #1A63
    #instruction: CP   40
    let:16 a5 = addWithCarry(!false,24,~40) in
    let:8 a6 = (24 & 0F) in
    let:8 a7 = (~40 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #1A65
    #instruction: JP   NZ,1A5F
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump (1A5F);
    } else {
      advance (10)
      #1A68
      #instruction: RET
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((M[a9],M[a4]));
    }

07CB:

    #instruction: CALL 01EF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := CE;
    #return-to: 07CE
    advance (17)
    #01EF
    #instruction: LD   HL,2142
    advance (10)
    #01F2
    #instruction: JP   01F8
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1D;
    let:16 a4 = (-1 + a3) in
    M[a4] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:16 a5 = (-1 + a4) in
    M[a5] := 02;
    let:16 a6 = (-1 + a5) in
    M[a6] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2142] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,2C,~00) in
    let:8 a8 = (2C & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((M[a11],M[a6]));
    }

07CE:

    #instruction: CALL 01F5
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D1;
    #return-to: 07D1
    advance (17)
    #01F5
    #instruction: LD   HL,2242
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1D;
    let:16 a4 = (-1 + a3) in
    M[a4] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:16 a5 = (-1 + a4) in
    M[a5] := 02;
    let:16 a6 = (-1 + a5) in
    M[a6] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2242] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,2C,~00) in
    let:8 a8 = (2C & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 22;
      L := 43;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 22;
      L := 43;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((M[a11],M[a6]));
    }

07D1:

    #instruction: CALL 08D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := D4;
    #return-to: 07D4
    advance (17)
    #08D1
    #instruction: IN   02
    advance (10)
    #08D3
    #instruction: AND  03
    let:8 a3 = (03 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
    let:8 a4 = (03 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
    advance (7)
    #08D5
    #instruction: ADD  03
    let:16 a5 = addWithCarry(false,03,a3) in
    let:8 a6 = (03 & 0F) in
    let:8 a7 = (a3 & 0F) in
    let:16 a8 = addWithCarry(false,a6,a7) in
    advance (7)
    #08D7
    #instruction: RET
    let:16 a9 = (1 + a2) in
    let:16 a10 = (1 + a9) in
    advance (10)
    A := a5[7:0];
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := a5[7:0][7];
    FlagZ := is_zero(a5[7:0]);
    FlagA := a8[7:0][4];
    FlagP := parity(a5[7:0]);
    FlagCY := a5[15:8][0];
    jump ((M[a9],M[a2]));

07D4:

    #instruction: LD   (21FF),A
    M[21FF] := A;
    advance (13)
    #07D7
    #instruction: LD   (22FF),A
    M[22FF] := A;
    advance (13)
    #07DA
    #instruction: CALL 00D7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := DD;
    #return-to: 07DD
    advance (17)
    #00D7
    #instruction: LD   A,02
    advance (7)
    #00D9
    #instruction: LD   (21FB),A
    M[21FB] := 02;
    advance (13)
    #00DC
    #instruction: LD   (22FB),A
    M[22FB] := 02;
    advance (13)
    #00DF
    #instruction: JP   08E4
    advance (10)
    #08E4
    #instruction: LD   A,(20CE)
    advance (13)
    #08E7
    #instruction: AND  A
    let:8 a3 = (M[20CE] & M[20CE]) in
    let:8 a4 = (M[20CE] | M[20CE]) in
    advance (4)
    #08E8
    #instruction: RET  NZ
    if (!is_zero(a3)) {
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    } else {
      advance (5)
      #08E9
      #instruction: LD   HL,391C
      advance (10)
      #08EC
      #instruction: LD   B,20
      advance (7)
      #08EE
      #instruction: JP   14CB
      advance (10)
      #14CB
      #instruction: XOR  A
      let:8 a7 = (a3 ^ a3) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:16 a8 = (-1 + a2) in
      M[a8] := 20;
      let:16 a9 = (-1 + a8) in
      M[a9] := C;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      M[391C] := a7;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:17 a10 = add17(0020,391C) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:16 a11 = (1 + a9) in
      let:16 a12 = (1 + a11) in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:16 a13 = addWithCarry(!true,M[a11],~00) in
      let:8 a14 = (M[a11] & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a13[7:0])) {
        advance (10)
        A := a7;
        B := a13[7:0];
        C := M[a9];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:16 a17 = (1 + a12) in
        let:16 a18 = (1 + a17) in
        advance (10)
        A := a7;
        B := a13[7:0];
        C := M[a9];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump ((M[a17],M[a12]));
      }
    }

07DD:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #07DE
    #instruction: LD   (21FE),A
    M[21FE] := a1;
    advance (13)
    #07E1
    #instruction: LD   (22FE),A
    M[22FE] := a1;
    advance (13)
    #07E4
    #instruction: CALL 01C0
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := E7;
    #return-to: 07E7
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a4 = addWithCarry(!true,37,~00) in
    let:8 a5 = (37 & 0F) in
    let:8 a6 = (~00 & 0F) in
    let:16 a7 = addWithCarry(!true,a5,a6) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a4[7:0])) {
      advance (10)
      A := a1;
      B := a4[7:0];
      H := 21;
      L := 01;
      SPH := a3[15:8];
      SPL := a3[7:0];
      FlagS := a4[7:0][7];
      FlagZ := is_zero(a4[7:0]);
      FlagA := a7[7:0][4];
      FlagP := parity(a4[7:0]);
      FlagCY := false;
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:16 a8 = (1 + a3) in
      let:16 a9 = (1 + a8) in
      advance (10)
      A := a1;
      B := a4[7:0];
      H := 21;
      L := 01;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a4[7:0][7];
      FlagZ := is_zero(a4[7:0]);
      FlagA := a7[7:0][4];
      FlagP := parity(a4[7:0]);
      FlagCY := false;
      jump ((M[a8],M[a3]));
    }

07E7:

    #instruction: CALL 1904
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := EA;
    #return-to: 07EA
    advance (17)
    #1904
    #instruction: LD   HL,2200
    advance (10)
    #1907
    #instruction: JP   01C3
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2200] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,37,~00) in
    let:8 a4 = (37 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a3[7:0])) {
      advance (10)
      B := a3[7:0];
      H := 22;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      B := a3[7:0];
      H := 22;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

07EA:

    #instruction: LD   HL,3878
    advance (10)
    #07ED
    #instruction: LD   (21FC),HL
    M[21FC] := 78;
    M[21FD] := 38;
    advance (16)
    #07F0
    #instruction: LD   (22FC),HL
    M[22FC] := 78;
    M[22FD] := 38;
    advance (16)
    #07F3
    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 07F6
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,C0,~00) in
    let:8 a4 = (C0 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 01;
      B := a3[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 01;
      B := a3[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

07F6:

    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := F9;
    #return-to: 07F9
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    let:16 a4 = (-1 + a3) in
    M[a4] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:16 a5 = (-1 + a4) in
    M[a5] := 09;
    let:16 a6 = (-1 + a5) in
    M[a6] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    advance (13)
    #1616
    #instruction: LD   H,A
    advance (5)
    #1617
    #instruction: RET
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := 00;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((M[a7],M[a6]));

07F9:

    #instruction: CALL 088D
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := FC;
    #return-to: 07FC
    advance (17)
    #088D
    #instruction: LD   HL,2B11
    advance (10)
    #0890
    #instruction: LD   DE,1B70
    advance (10)
    #0893
    #instruction: LD   C,0E
    advance (7)
    #0895
    #instruction: CALL 08F3
    let:16 a3 = (-1 + a2) in
    M[a3] := 08;
    let:16 a4 = (-1 + a3) in
    M[a4] := 98;
    #return-to: 0898
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := 1B;
    let:16 a6 = (-1 + a5) in
    M[a6] := 70;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a7 = (-1 + a6) in
    M[a7] := 08;
    let:16 a8 = (-1 + a7) in
    M[a8] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a9 = (-1 + a8) in
    M[a9] := 2B;
    let:16 a10 = (-1 + a9) in
    M[a10] := 11;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a11 = add17(000F,000F) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a12 = add17(a11[15:0],a11[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a13 = add17(a12[15:0],a12[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a14 = add17(1E00,a13[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a15 = (1 + a10) in
    let:16 a16 = (1 + a15) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a17 = (-1 + a16) in
    M[a17] := 08;
    let:16 a18 = (-1 + a17) in
    M[a18] := 0E;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a15],M[a10])] := M[a14[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a19 = (1 + a14[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a20 = add17(0020,(M[a15],M[a10])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a21 = (1 + a18) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a23 = addWithCarry(!true,M[a21],~00) in
    let:8 a24 = (M[a21] & 0F) in
    let:8 a25 = (~00 & 0F) in
    let:16 a26 = addWithCarry(!true,a24,a25) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a23[7:0])) {
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a27 = (1 + a22) in
      let:16 a28 = (1 + a27) in
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump ((M[a27],M[a22]));
    }

07FC:

    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 07;
    let:16 a2 = (-1 + a1) in
    M[a2] := FF;
    #return-to: 07FF
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a3 = (1F & 03) in
    let:8 a4 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a5 = addWithCarry(!false,a3,~1C) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~1C & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a5[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a9 = addWithCarry(!false,24,~40) in
      let:8 a10 = (24 & 0F) in
      let:8 a11 = (~40 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a9[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a15 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a16 = addWithCarry(!false,a15[15:0][15:8],~40) in
      let:8 a17 = (a15[15:0][15:8] & 0F) in
      let:8 a18 = (~40 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a16[15:8][0]) {
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a20 = (1 + a2) in
        let:16 a21 = (1 + a20) in
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((M[a20],M[a2]));
      }
    }

07FF:

    #instruction: NOP
    advance (4)
    #0800
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #0801
    #instruction: LD   (20C1),A
    M[20C1] := a1;
    advance (13)
    #0804
    #instruction: CALL 01CF
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:16 a4 = (-1 + a3) in
    M[a4] := E0;
    let:16 a5 = (-1 + a4) in
    M[a5] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a6 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a7 = (1 + a5) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,M[a7],~00) in
    let:8 a10 = (M[a7] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := 01;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a13 = (1 + a8) in
      let:16 a14 = (1 + a13) in
      advance (10)
      A := 01;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump ((M[a13],M[a8]));
    }

0807:

    #instruction: LD   A,(2067)
    advance (13)
    #080A
    #instruction: RRCA 
    advance (4)
    #080B
    #instruction: JP   CY,0872
    if (M[2067][0]) {
      advance (10)
      #0872
      #instruction: CALL 021A
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 08;
      let:16 a2 = (-1 + a1) in
      M[a2] := 75;
      #return-to: 0875
      advance (17)
      #021A
      #instruction: XOR  A
      let:8 a3 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
      advance (4)
      #021B
      #instruction: LD   DE,2142
      advance (10)
      #021E
      #instruction: LD   (2081),A
      M[2081] := a3;
      advance (13)
      #0221
      #instruction: LD   BC,1602
      advance (10)
      #0224
      #instruction: LD   HL,2806
      advance (10)
      #0227
      #instruction: LD   A,04
      advance (7)
      #0229
      #instruction: PUSH PSW
      let:16 a4 = (-1 + a2) in
      M[a4] := 04;
      let:16 a5 = (-1 + a4) in
      M[a5] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a3[7]),6,is_zero(a3)),4,false),2,parity(a3)),0,false);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:16 a6 = (-1 + a5) in
      M[a6] := 16;
      let:16 a7 = (-1 + a6) in
      M[a7] := 02;
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a8 = (M[2081] & M[2081]) in
      let:8 a9 = (M[2081] | M[2081]) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a8)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:16 a10 = (-1 + a7) in
        M[a10] := 02;
        let:16 a11 = (-1 + a10) in
        M[a11] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:16 a12 = (-1 + a11) in
        M[a12] := 16;
        let:16 a13 = (-1 + a12) in
        M[a13] := 02;
        advance (11)
        #147D
        #instruction: PUSH HL
        let:16 a14 = (-1 + a13) in
        M[a14] := 28;
        let:16 a15 = (-1 + a14) in
        M[a15] := 06;
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        advance (7)
        #147F
        #instruction: LD   (DE),A
        M[2142] := M[2806];
        advance (7)
        #1480
        #instruction: INC  DE
        advance (5)
        #1481
        #instruction: INC  HL
        advance (5)
        #1482
        #instruction: DEC  C
        let:16 a16 = addWithCarry(!true,02,~00) in
        let:8 a17 = (02 & 0F) in
        let:8 a18 = (~00 & 0F) in
        let:16 a19 = addWithCarry(!true,a17,a18) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a16[7:0])) {
          advance (10)
          A := M[2806];
          B := 16;
          C := a16[7:0];
          D := 21;
          E := 43;
          H := 28;
          L := 07;
          SPH := a15[15:8];
          SPL := a15[7:0];
          FlagS := a16[7:0][7];
          FlagZ := is_zero(a16[7:0]);
          FlagA := a19[7:0][4];
          FlagP := parity(a16[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:16 a20 = (1 + a15) in
          let:16 a21 = (1 + a20) in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:17 a22 = add17(0020,(M[a20],M[a15])) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:16 a23 = (1 + a21) in
          let:16 a24 = (1 + a23) in
          advance (10)
          #148C
          #instruction: DEC  B
          let:16 a25 = addWithCarry(!true,M[a23],~00) in
          let:8 a26 = (M[a23] & 0F) in
          let:8 a27 = (~00 & 0F) in
          let:16 a28 = addWithCarry(!true,a26,a27) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a25[7:0])) {
            advance (10)
            A := M[2806];
            B := a25[7:0];
            C := M[a21];
            D := 21;
            E := 43;
            H := a22[15:0][15:8];
            L := a22[15:0][7:0];
            SPH := a24[15:8];
            SPL := a24[7:0];
            FlagS := a25[7:0][7];
            FlagZ := is_zero(a25[7:0]);
            FlagA := a28[7:0][4];
            FlagP := parity(a25[7:0]);
            FlagCY := a22[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:16 a29 = (1 + a24) in
            let:16 a30 = (1 + a29) in
            advance (10)
            A := M[2806];
            B := a25[7:0];
            C := M[a21];
            D := 21;
            E := 43;
            H := a22[15:0][15:8];
            L := a22[15:0][7:0];
            SPH := a30[15:8];
            SPL := a30[7:0];
            FlagS := a25[7:0][7];
            FlagZ := is_zero(a25[7:0]);
            FlagA := a28[7:0][4];
            FlagP := parity(a25[7:0]);
            FlagCY := a22[16];
            jump ((M[a29],M[a24]));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:16 a31 = (-1 + a7) in
        M[a31] := 02;
        let:16 a32 = (-1 + a31) in
        M[a32] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:16 a33 = (-1 + a32) in
        M[a33] := 16;
        let:16 a34 = (-1 + a33) in
        M[a34] := 02;
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:16 a35 = (-1 + a34) in
        M[a35] := 28;
        let:16 a36 = (-1 + a35) in
        M[a36] := 06;
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a37 = (M[2806] | M[2142]) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        M[2806] := a37;
        advance (7)
        #1A6E
        #instruction: INC  DE
        advance (5)
        #1A6F
        #instruction: INC  HL
        advance (5)
        #1A70
        #instruction: DEC  C
        let:16 a38 = addWithCarry(!true,02,~00) in
        let:8 a39 = (02 & 0F) in
        let:8 a40 = (~00 & 0F) in
        let:16 a41 = addWithCarry(!true,a39,a40) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a38[7:0])) {
          advance (10)
          A := a37;
          B := 16;
          C := a38[7:0];
          D := 21;
          E := 43;
          H := 28;
          L := 07;
          SPH := a36[15:8];
          SPL := a36[7:0];
          FlagS := a38[7:0][7];
          FlagZ := is_zero(a38[7:0]);
          FlagA := a41[7:0][4];
          FlagP := parity(a38[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:16 a42 = (1 + a36) in
          let:16 a43 = (1 + a42) in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:17 a44 = add17(0020,(M[a42],M[a36])) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:16 a45 = (1 + a43) in
          let:16 a46 = (1 + a45) in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:16 a47 = addWithCarry(!true,M[a45],~00) in
          let:8 a48 = (M[a45] & 0F) in
          let:8 a49 = (~00 & 0F) in
          let:16 a50 = addWithCarry(!true,a48,a49) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a47[7:0])) {
            advance (10)
            A := a37;
            B := a47[7:0];
            C := M[a43];
            D := 21;
            E := 43;
            H := a44[15:0][15:8];
            L := a44[15:0][7:0];
            SPH := a46[15:8];
            SPL := a46[7:0];
            FlagS := a47[7:0][7];
            FlagZ := is_zero(a47[7:0]);
            FlagA := a50[7:0][4];
            FlagP := parity(a47[7:0]);
            FlagCY := a44[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:16 a51 = (1 + a46) in
            let:16 a52 = (1 + a51) in
            advance (10)
            A := a37;
            B := a47[7:0];
            C := M[a43];
            D := 21;
            E := 43;
            H := a44[15:0][15:8];
            L := a44[15:0][7:0];
            SPH := a52[15:8];
            SPL := a52[7:0];
            FlagS := a47[7:0][7];
            FlagZ := is_zero(a47[7:0]);
            FlagA := a50[7:0][4];
            FlagP := parity(a47[7:0]);
            FlagCY := a44[16];
            jump ((M[a51],M[a46]));
          }
        }
      }
    } else {
      advance (10)
      #080E
      #instruction: CALL 0213
      let:16 a53 = (-1 + (SPH,SPL)) in
      M[a53] := 08;
      let:16 a54 = (-1 + a53) in
      M[a54] := 11;
      #return-to: 0811
      advance (17)
      #0213
      #instruction: XOR  A
      let:8 a55 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
      advance (4)
      #0214
      #instruction: LD   DE,2242
      advance (10)
      #0217
      #instruction: JP   021E
      advance (10)
      #021E
      #instruction: LD   (2081),A
      M[2081] := a55;
      advance (13)
      #0221
      #instruction: LD   BC,1602
      advance (10)
      #0224
      #instruction: LD   HL,2806
      advance (10)
      #0227
      #instruction: LD   A,04
      advance (7)
      #0229
      #instruction: PUSH PSW
      let:16 a56 = (-1 + a54) in
      M[a56] := 04;
      let:16 a57 = (-1 + a56) in
      M[a57] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a55[7]),6,is_zero(a55)),4,false),2,parity(a55)),0,false);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:16 a58 = (-1 + a57) in
      M[a58] := 16;
      let:16 a59 = (-1 + a58) in
      M[a59] := 02;
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a60 = (M[2081] & M[2081]) in
      let:8 a61 = (M[2081] | M[2081]) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a60)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:16 a62 = (-1 + a59) in
        M[a62] := 02;
        let:16 a63 = (-1 + a62) in
        M[a63] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:16 a64 = (-1 + a63) in
        M[a64] := 16;
        let:16 a65 = (-1 + a64) in
        M[a65] := 02;
        advance (11)
        #147D
        #instruction: PUSH HL
        let:16 a66 = (-1 + a65) in
        M[a66] := 28;
        let:16 a67 = (-1 + a66) in
        M[a67] := 06;
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        advance (7)
        #147F
        #instruction: LD   (DE),A
        M[2242] := M[2806];
        advance (7)
        #1480
        #instruction: INC  DE
        advance (5)
        #1481
        #instruction: INC  HL
        advance (5)
        #1482
        #instruction: DEC  C
        let:16 a68 = addWithCarry(!true,02,~00) in
        let:8 a69 = (02 & 0F) in
        let:8 a70 = (~00 & 0F) in
        let:16 a71 = addWithCarry(!true,a69,a70) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a68[7:0])) {
          advance (10)
          A := M[2806];
          B := 16;
          C := a68[7:0];
          D := 22;
          E := 43;
          H := 28;
          L := 07;
          SPH := a67[15:8];
          SPL := a67[7:0];
          FlagS := a68[7:0][7];
          FlagZ := is_zero(a68[7:0]);
          FlagA := a71[7:0][4];
          FlagP := parity(a68[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:16 a72 = (1 + a67) in
          let:16 a73 = (1 + a72) in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:17 a74 = add17(0020,(M[a72],M[a67])) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:16 a75 = (1 + a73) in
          let:16 a76 = (1 + a75) in
          advance (10)
          #148C
          #instruction: DEC  B
          let:16 a77 = addWithCarry(!true,M[a75],~00) in
          let:8 a78 = (M[a75] & 0F) in
          let:8 a79 = (~00 & 0F) in
          let:16 a80 = addWithCarry(!true,a78,a79) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a77[7:0])) {
            advance (10)
            A := M[2806];
            B := a77[7:0];
            C := M[a73];
            D := 22;
            E := 43;
            H := a74[15:0][15:8];
            L := a74[15:0][7:0];
            SPH := a76[15:8];
            SPL := a76[7:0];
            FlagS := a77[7:0][7];
            FlagZ := is_zero(a77[7:0]);
            FlagA := a80[7:0][4];
            FlagP := parity(a77[7:0]);
            FlagCY := a74[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:16 a81 = (1 + a76) in
            let:16 a82 = (1 + a81) in
            advance (10)
            A := M[2806];
            B := a77[7:0];
            C := M[a73];
            D := 22;
            E := 43;
            H := a74[15:0][15:8];
            L := a74[15:0][7:0];
            SPH := a82[15:8];
            SPL := a82[7:0];
            FlagS := a77[7:0][7];
            FlagZ := is_zero(a77[7:0]);
            FlagA := a80[7:0][4];
            FlagP := parity(a77[7:0]);
            FlagCY := a74[16];
            jump ((M[a81],M[a76]));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:16 a83 = (-1 + a59) in
        M[a83] := 02;
        let:16 a84 = (-1 + a83) in
        M[a84] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:16 a85 = (-1 + a84) in
        M[a85] := 16;
        let:16 a86 = (-1 + a85) in
        M[a86] := 02;
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:16 a87 = (-1 + a86) in
        M[a87] := 28;
        let:16 a88 = (-1 + a87) in
        M[a88] := 06;
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a89 = (M[2806] | M[2242]) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        M[2806] := a89;
        advance (7)
        #1A6E
        #instruction: INC  DE
        advance (5)
        #1A6F
        #instruction: INC  HL
        advance (5)
        #1A70
        #instruction: DEC  C
        let:16 a90 = addWithCarry(!true,02,~00) in
        let:8 a91 = (02 & 0F) in
        let:8 a92 = (~00 & 0F) in
        let:16 a93 = addWithCarry(!true,a91,a92) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a90[7:0])) {
          advance (10)
          A := a89;
          B := 16;
          C := a90[7:0];
          D := 22;
          E := 43;
          H := 28;
          L := 07;
          SPH := a88[15:8];
          SPL := a88[7:0];
          FlagS := a90[7:0][7];
          FlagZ := is_zero(a90[7:0]);
          FlagA := a93[7:0][4];
          FlagP := parity(a90[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:16 a94 = (1 + a88) in
          let:16 a95 = (1 + a94) in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:17 a96 = add17(0020,(M[a94],M[a88])) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:16 a97 = (1 + a95) in
          let:16 a98 = (1 + a97) in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:16 a99 = addWithCarry(!true,M[a97],~00) in
          let:8 a100 = (M[a97] & 0F) in
          let:8 a101 = (~00 & 0F) in
          let:16 a102 = addWithCarry(!true,a100,a101) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a99[7:0])) {
            advance (10)
            A := a89;
            B := a99[7:0];
            C := M[a95];
            D := 22;
            E := 43;
            H := a96[15:0][15:8];
            L := a96[15:0][7:0];
            SPH := a98[15:8];
            SPL := a98[7:0];
            FlagS := a99[7:0][7];
            FlagZ := is_zero(a99[7:0]);
            FlagA := a102[7:0][4];
            FlagP := parity(a99[7:0]);
            FlagCY := a96[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:16 a103 = (1 + a98) in
            let:16 a104 = (1 + a103) in
            advance (10)
            A := a89;
            B := a99[7:0];
            C := M[a95];
            D := 22;
            E := 43;
            H := a96[15:0][15:8];
            L := a96[15:0][7:0];
            SPH := a104[15:8];
            SPL := a104[7:0];
            FlagS := a99[7:0][7];
            FlagZ := is_zero(a99[7:0]);
            FlagA := a102[7:0][4];
            FlagP := parity(a99[7:0]);
            FlagCY := a96[16];
            jump ((M[a103],M[a98]));
          }
        }
      }
    }

0811:

    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    #return-to: 0814
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := E0;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a5 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a6 = (1 + a4) in
    let:16 a7 = (1 + a6) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a8 = addWithCarry(!true,M[a6],~00) in
    let:8 a9 = (M[a6] & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a12 = (1 + a7) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump ((M[a12],M[a7]));
    }

0814:

    #instruction: CALL 00B1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    #return-to: 0817
    advance (17)
    #00B1
    #instruction: CALL 0886
    let:16 a3 = (-1 + a2) in
    M[a3] := 00;
    let:16 a4 = (-1 + a3) in
    M[a4] := B4;
    #return-to: 00B4
    advance (17)
    #0886
    #instruction: LD   A,(2067)
    advance (13)
    #0889
    #instruction: LD   H,A
    advance (5)
    #088A
    #instruction: LD   L,FC
    advance (7)
    #088C
    #instruction: RET
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := FC;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump ((M[a5],M[a4]));

0817:

    #instruction: CALL 19D1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    #return-to: 081A
    advance (17)
    #19D1
    #instruction: LD   A,01
    advance (7)
    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := 01;
    advance (13)
    #19D6
    #instruction: RET
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    A := 01;
    SPH := a4[15:8];
    SPL := a4[7:0];
    jump ((M[a3],M[a2]));

081A:

    #instruction: LD   B,20
    advance (7)
    #081C
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1F;
    #return-to: 081F
    advance (17)
    #18FA
    #instruction: LD   A,(2094)
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a3 = (20 | M[2094]) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    M[2094] := a3;
    advance (13)
    #1901
    #instruction: OUT  03
    sound_control(Ufo,a3[0]);
    sound_control(Shot,a3[1]);
    sound_control(PlayerDie,a3[2]);
    sound_control(InvaderDie,a3[3]);
    sound_control(ExtraLife,a3[4]);
    advance (10)
    #1903
    #instruction: RET
    let:16 a4 = (1 + a2) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a3;
    B := 20;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a4],M[a2]));

081F:

    #instruction: CALL 1618
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 22;
    #return-to: 0822
    advance (17)
    #1618
    #instruction: LD   A,(2015)
    advance (13)
    #161B
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2015],~FF) in
    let:8 a4 = (M[2015] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #161D
    #instruction: RET  NZ
    if (!is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2015];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #161E
      #instruction: LD   HL,2010
      advance (10)
      #1621
      #instruction: LD   A,(HL)
      advance (7)
      #1622
      #instruction: INC  HL
      advance (5)
      #1623
      #instruction: LD   B,(HL)
      advance (7)
      #1624
      #instruction: OR   B
      let:8 a9 = (M[2011] | M[2010]) in
      advance (4)
      #1625
      #instruction: RET  NZ
      if (!is_zero(a9)) {
        let:16 a10 = (1 + a2) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a9;
        B := M[2011];
        H := 20;
        L := 11;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a2]));
      } else {
        advance (5)
        #1626
        #instruction: LD   A,(2025)
        advance (13)
        #1629
        #instruction: AND  A
        let:8 a12 = (M[2025] & M[2025]) in
        let:8 a13 = (M[2025] | M[2025]) in
        advance (4)
        #162A
        #instruction: RET  NZ
        if (!is_zero(a12)) {
          let:16 a14 = (1 + a2) in
          let:16 a15 = (1 + a14) in
          advance (11)
          A := a12;
          B := M[2011];
          H := 20;
          L := 11;
          SPH := a15[15:8];
          SPL := a15[7:0];
          FlagS := a12[7];
          FlagZ := is_zero(a12);
          FlagA := a13[3];
          FlagP := parity(a12);
          FlagCY := false;
          jump ((M[a14],M[a2]));
        } else {
          advance (5)
          #162B
          #instruction: LD   A,(20EF)
          advance (13)
          #162E
          #instruction: AND  A
          let:8 a16 = (M[20EF] & M[20EF]) in
          let:8 a17 = (M[20EF] | M[20EF]) in
          advance (4)
          #162F
          #instruction: JP   Z,1652
          if (is_zero(a16)) {
            advance (10)
            #1652
            #instruction: LD   HL,2025
            advance (10)
            #1655
            #instruction: LD   (HL),01
            M[2025] := 01;
            advance (10)
            #1657
            #instruction: LD   HL,(20ED)
            advance (16)
            #165A
            #instruction: INC  HL
            let:16 a18 = (1 + (M[20EE],M[20ED])) in
            advance (5)
            #165B
            #instruction: LD   A,L
            advance (5)
            #165C
            #instruction: CP   7E
            let:16 a19 = addWithCarry(!false,a18[7:0],~7E) in
            let:8 a20 = (a18[7:0] & 0F) in
            let:8 a21 = (~7E & 0F) in
            let:16 a22 = addWithCarry(!false,a20,a21) in
            advance (7)
            #165E
            #instruction: JP   CY,1663
            if (!a19[15:8][0]) {
              advance (10)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := a18[7:0];
              M[20EE] := a18[15:8];
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              advance (7)
              #1667
              #instruction: LD   (201D),A
              M[201D] := M[a18];
              advance (13)
              #166A
              #instruction: RET
              let:16 a23 = (1 + a2) in
              let:16 a24 = (1 + a23) in
              advance (10)
              A := M[a18];
              B := M[2011];
              H := a18[15:8];
              L := a18[7:0];
              SPH := a24[15:8];
              SPL := a24[7:0];
              FlagS := a19[7:0][7];
              FlagZ := is_zero(a19[7:0]);
              FlagA := a22[7:0][4];
              FlagP := parity(a19[7:0]);
              FlagCY := !a19[15:8][0];
              jump ((M[a23],M[a2]));
            } else {
              advance (10)
              #1661
              #instruction: LD   L,74
              advance (7)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := 74;
              M[20EE] := a18[15:8];
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              advance (7)
              #1667
              #instruction: LD   (201D),A
              M[201D] := M[(a18[15:8],74)];
              advance (13)
              #166A
              #instruction: RET
              let:16 a25 = (1 + a2) in
              let:16 a26 = (1 + a25) in
              advance (10)
              A := M[(a18[15:8],74)];
              B := M[2011];
              H := a18[15:8];
              L := 74;
              SPH := a26[15:8];
              SPL := a26[7:0];
              FlagS := a19[7:0][7];
              FlagZ := is_zero(a19[7:0]);
              FlagA := a22[7:0][4];
              FlagP := parity(a19[7:0]);
              FlagCY := !a19[15:8][0];
              jump ((M[a25],M[a2]));
            }
          } else {
            advance (10)
            #1632
            #instruction: LD   A,(202D)
            advance (13)
            #1635
            #instruction: AND  A
            let:8 a27 = (M[202D] & M[202D]) in
            let:8 a28 = (M[202D] | M[202D]) in
            advance (4)
            #1636
            #instruction: JP   NZ,1648
            if (!is_zero(a27)) {
              advance (10)
              #1648
              #instruction: CALL 17C0
              let:16 a29 = (-1 + a2) in
              M[a29] := 16;
              let:16 a30 = (-1 + a29) in
              M[a30] := 4B;
              #return-to: 164B
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              advance (13)
              #17C3
              #instruction: RRCA 
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!M[2067][0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:16 a31 = (1 + a30) in
                let:16 a32 = (1 + a31) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a32[15:8];
                SPL := a32[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a31],M[a30]));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:16 a33 = (1 + a30) in
                let:16 a34 = (1 + a33) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a34[15:8];
                SPL := a34[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a33],M[a30]));
              }
            } else {
              advance (10)
              #1639
              #instruction: CALL 17C0
              let:16 a35 = (-1 + a2) in
              M[a35] := 16;
              let:16 a36 = (-1 + a35) in
              M[a36] := 3C;
              #return-to: 163C
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              advance (13)
              #17C3
              #instruction: RRCA 
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!M[2067][0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:16 a37 = (1 + a36) in
                let:16 a38 = (1 + a37) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a38[15:8];
                SPL := a38[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a37],M[a36]));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:16 a39 = (1 + a36) in
                let:16 a40 = (1 + a39) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a40[15:8];
                SPL := a40[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a39],M[a36]));
              }
            }
          }
        }
      }
    }

0822:

    #instruction: CALL 190A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 25;
    #return-to: 0825
    advance (17)
    #190A
    #instruction: CALL 14D8
    let:16 a3 = (-1 + a2) in
    M[a3] := 19;
    let:16 a4 = (-1 + a3) in
    M[a4] := 0D;
    #return-to: 190D
    advance (17)
    #14D8
    #instruction: LD   A,(2025)
    advance (13)
    #14DB
    #instruction: CP   05
    let:16 a5 = addWithCarry(!false,M[2025],~05) in
    let:8 a6 = (M[2025] & 0F) in
    let:8 a7 = (~05 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #14DD
    #instruction: RET  Z
    if (is_zero(a5[7:0])) {
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (11)
      A := M[2025];
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((M[a9],M[a4]));
    } else {
      advance (5)
      #14DE
      #instruction: CP   02
      let:16 a11 = addWithCarry(!false,M[2025],~02) in
      let:8 a12 = (M[2025] & 0F) in
      let:8 a13 = (~02 & 0F) in
      let:16 a14 = addWithCarry(!false,a12,a13) in
      advance (7)
      #14E0
      #instruction: RET  NZ
      if (!is_zero(a11[7:0])) {
        let:16 a15 = (1 + a4) in
        let:16 a16 = (1 + a15) in
        advance (11)
        A := M[2025];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := !a11[15:8][0];
        jump ((M[a15],M[a4]));
      } else {
        advance (5)
        #14E1
        #instruction: LD   A,(2029)
        advance (13)
        #14E4
        #instruction: CP   D8
        let:16 a17 = addWithCarry(!false,M[2029],~D8) in
        let:8 a18 = (M[2029] & 0F) in
        let:8 a19 = (~D8 & 0F) in
        let:16 a20 = addWithCarry(!false,a18,a19) in
        advance (7)
        #14E6
        #instruction: LD   B,A
        advance (5)
        #14E7
        #instruction: JP   NC,1530
        if (!!a17[15:8][0]) {
          advance (10)
          #1530
          #instruction: LD   A,03
          advance (7)
          #1532
          #instruction: LD   (2025),A
          M[2025] := 03;
          advance (13)
          #1535
          #instruction: JP   154A
          advance (10)
          #154A
          #instruction: XOR  A
          let:8 a21 = (03 ^ 03) in
          advance (4)
          #154B
          #instruction: LD   (2002),A
          M[2002] := a21;
          advance (13)
          #154E
          #instruction: LD   B,F7
          advance (7)
          #1550
          #instruction: JP   19DC
          advance (10)
          #19DC
          #instruction: LD   A,(2094)
          advance (13)
          #19DF
          #instruction: AND  B
          let:8 a22 = (F7 & M[2094]) in
          let:8 a23 = (F7 | M[2094]) in
          advance (4)
          #19E0
          #instruction: LD   (2094),A
          M[2094] := a22;
          advance (13)
          #19E3
          #instruction: OUT  03
          sound_control(Ufo,a22[0]);
          sound_control(Shot,a22[1]);
          sound_control(PlayerDie,a22[2]);
          sound_control(InvaderDie,a22[3]);
          sound_control(ExtraLife,a22[4]);
          advance (10)
          #19E5
          #instruction: RET
          let:16 a24 = (1 + a4) in
          let:16 a25 = (1 + a24) in
          advance (10)
          A := a22;
          B := F7;
          SPH := a25[15:8];
          SPL := a25[7:0];
          FlagS := a22[7];
          FlagZ := is_zero(a22);
          FlagA := a23[3];
          FlagP := parity(a22);
          FlagCY := false;
          jump ((M[a24],M[a4]));
        } else {
          advance (10)
          #14EA
          #instruction: LD   A,(2002)
          advance (13)
          #14ED
          #instruction: AND  A
          let:8 a26 = (M[2002] & M[2002]) in
          let:8 a27 = (M[2002] | M[2002]) in
          advance (4)
          #14EE
          #instruction: RET  Z
          if (is_zero(a26)) {
            let:16 a28 = (1 + a4) in
            let:16 a29 = (1 + a28) in
            advance (11)
            A := a26;
            B := M[2029];
            SPH := a29[15:8];
            SPL := a29[7:0];
            FlagS := a26[7];
            FlagZ := is_zero(a26);
            FlagA := a27[3];
            FlagP := parity(a26);
            FlagCY := false;
            jump ((M[a28],M[a4]));
          } else {
            advance (5)
            #14EF
            #instruction: LD   A,B
            advance (5)
            #14F0
            #instruction: CP   CE
            let:16 a30 = addWithCarry(!false,M[2029],~CE) in
            let:8 a31 = (M[2029] & 0F) in
            let:8 a32 = (~CE & 0F) in
            let:16 a33 = addWithCarry(!false,a31,a32) in
            advance (7)
            #14F2
            #instruction: JP   NC,1579
            if (!!a30[15:8][0]) {
              advance (10)
              #1579
              #instruction: LD   A,01
              advance (7)
              #157B
              #instruction: LD   (2085),A
              M[2085] := 01;
              advance (13)
              #157E
              #instruction: JP   1545
              advance (10)
              A := 01;
              B := M[2029];
              SPH := a4[15:8];
              SPL := a4[7:0];
              FlagS := a30[7:0][7];
              FlagZ := is_zero(a30[7:0]);
              FlagA := a33[7:0][4];
              FlagP := parity(a30[7:0]);
              FlagCY := !a30[15:8][0];
              jump (1545);
            } else {
              advance (10)
              #14F5
              #instruction: ADD  06
              let:16 a34 = addWithCarry(false,06,M[2029]) in
              let:8 a35 = (06 & 0F) in
              let:8 a36 = (M[2029] & 0F) in
              let:16 a37 = addWithCarry(false,a35,a36) in
              advance (7)
              #14F7
              #instruction: LD   B,A
              advance (5)
              #14F8
              #instruction: LD   A,(2009)
              advance (13)
              #14FB
              #instruction: CP   90
              let:16 a38 = addWithCarry(!false,M[2009],~90) in
              let:8 a39 = (M[2009] & 0F) in
              let:8 a40 = (~90 & 0F) in
              let:16 a41 = addWithCarry(!false,a39,a40) in
              advance (7)
              #14FD
              #instruction: JP   NC,1504
              if (!!a38[15:8][0]) {
                advance (10)
                #1504
                #instruction: LD   L,B
                advance (5)
                #1505
                #instruction: CALL 1562
                let:16 a42 = (-1 + a4) in
                M[a42] := 15;
                let:16 a43 = (-1 + a42) in
                M[a43] := 08;
                #return-to: 1508
                advance (17)
                #1562
                #instruction: LD   A,(2009)
                advance (13)
                #1565
                #instruction: LD   H,L
                advance (5)
                #1566
                #instruction: CALL 1554
                let:16 a44 = (-1 + a43) in
                M[a44] := 15;
                let:16 a45 = (-1 + a44) in
                M[a45] := 69;
                #return-to: 1569
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:16 a46 = addWithCarry(!false,M[2009],~a34[7:0]) in
                let:8 a47 = (M[2009] & 0F) in
                let:8 a48 = (~a34[7:0] & 0F) in
                let:16 a49 = addWithCarry(!false,a47,a48) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a46[15:8][0]) {
                  let:16 a50 = (-1 + a45) in
                  M[a50] := 15;
                  let:16 a51 = (-1 + a50) in
                  M[a51] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a52 = addWithCarry(true,00,00) in
                  let:8 a53 = (00 & 0F) in
                  let:8 a54 = (00 & 0F) in
                  let:16 a55 = addWithCarry(true,a53,a54) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:16 a56 = addWithCarry(false,10,M[2009]) in
                  let:8 a57 = (10 & 0F) in
                  let:8 a58 = (M[2009] & 0F) in
                  let:16 a59 = addWithCarry(false,a57,a58) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a56[7:0][7]) {
                    advance (10)
                    A := a56[7:0];
                    B := a34[7:0];
                    C := a52[7:0];
                    H := a34[7:0];
                    L := a34[7:0];
                    SPH := a51[15:8];
                    SPL := a51[7:0];
                    FlagS := a56[7:0][7];
                    FlagZ := is_zero(a56[7:0]);
                    FlagA := a59[7:0][4];
                    FlagP := parity(a56[7:0]);
                    FlagCY := a56[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:16 a60 = (1 + a51) in
                    let:16 a61 = (1 + a60) in
                    advance (10)
                    A := a56[7:0];
                    B := a34[7:0];
                    C := a52[7:0];
                    H := a34[7:0];
                    L := a34[7:0];
                    SPH := a61[15:8];
                    SPL := a61[7:0];
                    FlagS := a56[7:0][7];
                    FlagZ := is_zero(a56[7:0]);
                    FlagA := a59[7:0][4];
                    FlagP := parity(a56[7:0]);
                    FlagCY := a56[15:8][0];
                    jump ((M[a60],M[a51]));
                  }
                } else {
                  advance (11)
                  A := M[2009];
                  B := a34[7:0];
                  C := 00;
                  H := a34[7:0];
                  L := a34[7:0];
                  SPH := a45[15:8];
                  SPL := a45[7:0];
                  FlagS := a46[7:0][7];
                  FlagZ := is_zero(a46[7:0]);
                  FlagA := a49[7:0][4];
                  FlagP := parity(a46[7:0]);
                  FlagCY := !a46[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #1500
                #instruction: CP   B
                let:16 a62 = addWithCarry(!false,M[2009],~a34[7:0]) in
                let:8 a63 = (M[2009] & 0F) in
                let:8 a64 = (~a34[7:0] & 0F) in
                let:16 a65 = addWithCarry(!false,a63,a64) in
                advance (4)
                #1501
                #instruction: JP   NC,1530
                if (!!a62[15:8][0]) {
                  advance (10)
                  #1530
                  #instruction: LD   A,03
                  advance (7)
                  #1532
                  #instruction: LD   (2025),A
                  M[2025] := 03;
                  advance (13)
                  #1535
                  #instruction: JP   154A
                  advance (10)
                  #154A
                  #instruction: XOR  A
                  let:8 a66 = (03 ^ 03) in
                  advance (4)
                  #154B
                  #instruction: LD   (2002),A
                  M[2002] := a66;
                  advance (13)
                  #154E
                  #instruction: LD   B,F7
                  advance (7)
                  #1550
                  #instruction: JP   19DC
                  advance (10)
                  #19DC
                  #instruction: LD   A,(2094)
                  advance (13)
                  #19DF
                  #instruction: AND  B
                  let:8 a67 = (F7 & M[2094]) in
                  let:8 a68 = (F7 | M[2094]) in
                  advance (4)
                  #19E0
                  #instruction: LD   (2094),A
                  M[2094] := a67;
                  advance (13)
                  #19E3
                  #instruction: OUT  03
                  sound_control(Ufo,a67[0]);
                  sound_control(Shot,a67[1]);
                  sound_control(PlayerDie,a67[2]);
                  sound_control(InvaderDie,a67[3]);
                  sound_control(ExtraLife,a67[4]);
                  advance (10)
                  #19E5
                  #instruction: RET
                  let:16 a69 = (1 + a4) in
                  let:16 a70 = (1 + a69) in
                  advance (10)
                  A := a67;
                  B := F7;
                  SPH := a70[15:8];
                  SPL := a70[7:0];
                  FlagS := a67[7];
                  FlagZ := is_zero(a67);
                  FlagA := a68[3];
                  FlagP := parity(a67);
                  FlagCY := false;
                  jump ((M[a69],M[a4]));
                } else {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:16 a71 = (-1 + a4) in
                  M[a71] := 15;
                  let:16 a72 = (-1 + a71) in
                  M[a72] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:16 a73 = (-1 + a72) in
                  M[a73] := 15;
                  let:16 a74 = (-1 + a73) in
                  M[a74] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a75 = addWithCarry(!false,M[2009],~a34[7:0]) in
                  let:8 a76 = (M[2009] & 0F) in
                  let:8 a77 = (~a34[7:0] & 0F) in
                  let:16 a78 = addWithCarry(!false,a76,a77) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a75[15:8][0]) {
                    let:16 a79 = (-1 + a74) in
                    M[a79] := 15;
                    let:16 a80 = (-1 + a79) in
                    M[a80] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a81 = addWithCarry(true,00,00) in
                    let:8 a82 = (00 & 0F) in
                    let:8 a83 = (00 & 0F) in
                    let:16 a84 = addWithCarry(true,a82,a83) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a85 = addWithCarry(false,10,M[2009]) in
                    let:8 a86 = (10 & 0F) in
                    let:8 a87 = (M[2009] & 0F) in
                    let:16 a88 = addWithCarry(false,a86,a87) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a85[7:0][7]) {
                      advance (10)
                      A := a85[7:0];
                      B := a34[7:0];
                      C := a81[7:0];
                      H := a34[7:0];
                      L := a34[7:0];
                      SPH := a80[15:8];
                      SPL := a80[7:0];
                      FlagS := a85[7:0][7];
                      FlagZ := is_zero(a85[7:0]);
                      FlagA := a88[7:0][4];
                      FlagP := parity(a85[7:0]);
                      FlagCY := a85[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a89 = (1 + a80) in
                      let:16 a90 = (1 + a89) in
                      advance (10)
                      A := a85[7:0];
                      B := a34[7:0];
                      C := a81[7:0];
                      H := a34[7:0];
                      L := a34[7:0];
                      SPH := a90[15:8];
                      SPL := a90[7:0];
                      FlagS := a85[7:0][7];
                      FlagZ := is_zero(a85[7:0]);
                      FlagA := a88[7:0][4];
                      FlagP := parity(a85[7:0]);
                      FlagCY := a85[15:8][0];
                      jump ((M[a89],M[a80]));
                    }
                  } else {
                    advance (11)
                    A := M[2009];
                    B := a34[7:0];
                    C := 00;
                    H := a34[7:0];
                    L := a34[7:0];
                    SPH := a74[15:8];
                    SPL := a74[7:0];
                    FlagS := a75[7:0][7];
                    FlagZ := is_zero(a75[7:0]);
                    FlagA := a78[7:0][4];
                    FlagP := parity(a75[7:0]);
                    FlagCY := !a75[15:8][0];
                    jump (155A);
                  }
                }
              }
            }
          }
        }
      }
    }

0825:

    #instruction: CALL 15F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 28;
    #return-to: 0828
    advance (17)
    #15F3
    #instruction: CALL 1611
    let:16 a3 = (-1 + a2) in
    M[a3] := 15;
    let:16 a4 = (-1 + a3) in
    M[a4] := F6;
    #return-to: 15F6
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    advance (13)
    #1616
    #instruction: LD   H,A
    advance (5)
    #1617
    #instruction: RET
    let:16 a5 = (1 + a4) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump ((M[a5],M[a4]));

0828:

    #instruction: CALL 0988
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2B;
    #return-to: 082B
    advance (17)
    #0988
    #instruction: CALL 09CA
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := 8B;
    #return-to: 098B
    advance (17)
    #09CA
    #instruction: LD   A,(2067)
    advance (13)
    #09CD
    #instruction: RRCA 
    advance (4)
    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    #09D1
    #instruction: RET  CY
    if (M[2067][0]) {
      let:16 a5 = (1 + a4) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := F8;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a4]));
    } else {
      advance (5)
      #09D2
      #instruction: LD   HL,20FC
      advance (10)
      #09D5
      #instruction: RET
      let:16 a7 = (1 + a4) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := FC;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagCY := M[2067][0];
      jump ((M[a7],M[a4]));
    }

082B:

    #instruction: LD   A,(2082)
    advance (13)
    #082E
    #instruction: AND  A
    let:8 a1 = (M[2082] & M[2082]) in
    let:8 a2 = (M[2082] | M[2082]) in
    advance (4)
    #082F
    #instruction: JP   Z,09EF
    if (is_zero(a1)) {
      advance (10)
      #09EF
      #instruction: CALL 0A3C
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 09;
      let:16 a4 = (-1 + a3) in
      M[a4] := F2;
      #return-to: 09F2
      advance (17)
      #0A3C
      #instruction: CALL 0A59
      let:16 a5 = (-1 + a4) in
      M[a5] := 0A;
      let:16 a6 = (-1 + a5) in
      M[a6] := 3F;
      #return-to: 0A3F
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a7 = addWithCarry(!false,M[2015],~FF) in
      let:8 a8 = (M[2015] & 0F) in
      let:8 a9 = (~FF & 0F) in
      let:16 a10 = addWithCarry(!false,a8,a9) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := M[2015];
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := !a7[15:8][0];
      jump ((M[a11],M[a6]));
    } else {
      advance (10)
      #0832
      #instruction: CALL 170E
      let:16 a13 = (-1 + (SPH,SPL)) in
      M[a13] := 08;
      let:16 a14 = (-1 + a13) in
      M[a14] := 35;
      #return-to: 0835
      advance (17)
      #170E
      #instruction: CALL 09CA
      let:16 a15 = (-1 + a14) in
      M[a15] := 17;
      let:16 a16 = (-1 + a15) in
      M[a16] := 11;
      #return-to: 1711
      advance (17)
      #09CA
      #instruction: LD   A,(2067)
      advance (13)
      #09CD
      #instruction: RRCA 
      advance (4)
      #09CE
      #instruction: LD   HL,20F8
      advance (10)
      #09D1
      #instruction: RET  CY
      if (M[2067][0]) {
        let:16 a17 = (1 + a16) in
        let:16 a18 = (1 + a17) in
        advance (11)
        A := updateBit((M[2067] >> 01),7,M[2067][0]);
        H := 20;
        L := F8;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a1[7];
        FlagZ := is_zero(a1);
        FlagA := a2[3];
        FlagP := parity(a1);
        FlagCY := M[2067][0];
        jump ((M[a17],M[a16]));
      } else {
        advance (5)
        #09D2
        #instruction: LD   HL,20FC
        advance (10)
        #09D5
        #instruction: RET
        let:16 a19 = (1 + a16) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := updateBit((M[2067] >> 01),7,M[2067][0]);
        H := 20;
        L := FC;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a1[7];
        FlagZ := is_zero(a1);
        FlagA := a2[3];
        FlagP := parity(a1);
        FlagCY := M[2067][0];
        jump ((M[a19],M[a16]));
      }
    }

0835:

    #instruction: CALL 0935
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 38;
    #return-to: 0838
    advance (17)
    #0935
    #instruction: CALL 1910
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := 38;
    #return-to: 0938
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    advance (13)
    #1916
    #instruction: RRCA 
    advance (4)
    #1917
    #instruction: RET  CY
    if (M[2067][0]) {
      let:16 a5 = (1 + a4) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E7;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a4]));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:16 a7 = (1 + a4) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E8;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagCY := M[2067][0];
      jump ((M[a7],M[a4]));
    }

0838:

    #instruction: CALL 08D8
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3B;
    #return-to: 083B
    advance (17)
    #08D8
    #instruction: LD   A,(2082)
    advance (13)
    #08DB
    #instruction: CP   09
    let:16 a3 = addWithCarry(!false,M[2082],~09) in
    let:8 a4 = (M[2082] & 0F) in
    let:8 a5 = (~09 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #08DD
    #instruction: RET  NC
    if (!!a3[15:8][0]) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2082];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #08DE
      #instruction: LD   A,FB
      advance (7)
      #08E0
      #instruction: LD   (207E),A
      M[207E] := FB;
      advance (13)
      #08E3
      #instruction: RET
      let:16 a9 = (1 + a2) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := FB;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a9],M[a2]));
    }

083B:

    #instruction: CALL 172C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3E;
    #return-to: 083E
    advance (17)
    #172C
    #instruction: LD   A,(2025)
    advance (13)
    #172F
    #instruction: CP   00
    let:16 a3 = addWithCarry(!false,M[2025],~00) in
    let:8 a4 = (M[2025] & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1731
    #instruction: JP   NZ,1739
    if (!is_zero(a3[7:0])) {
      advance (10)
      #1739
      #instruction: LD   B,02
      advance (7)
      #173B
      #instruction: JP   18FA
      advance (10)
      #18FA
      #instruction: LD   A,(2094)
      advance (13)
      #18FD
      #instruction: OR   B
      let:8 a7 = (02 | M[2094]) in
      advance (4)
      #18FE
      #instruction: LD   (2094),A
      M[2094] := a7;
      advance (13)
      #1901
      #instruction: OUT  03
      sound_control(Ufo,a7[0]);
      sound_control(Shot,a7[1]);
      sound_control(PlayerDie,a7[2]);
      sound_control(InvaderDie,a7[3]);
      sound_control(ExtraLife,a7[4]);
      advance (10)
      #1903
      #instruction: RET
      let:16 a8 = (1 + a2) in
      let:16 a9 = (1 + a8) in
      advance (10)
      A := a7;
      B := 02;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a7[7];
      FlagZ := is_zero(a7);
      FlagA := false;
      FlagP := parity(a7);
      FlagCY := false;
      jump ((M[a8],M[a2]));
    } else {
      advance (10)
      #1734
      #instruction: LD   B,FD
      advance (7)
      #1736
      #instruction: JP   19DC
      advance (10)
      #19DC
      #instruction: LD   A,(2094)
      advance (13)
      #19DF
      #instruction: AND  B
      let:8 a10 = (FD & M[2094]) in
      let:8 a11 = (FD | M[2094]) in
      advance (4)
      #19E0
      #instruction: LD   (2094),A
      M[2094] := a10;
      advance (13)
      #19E3
      #instruction: OUT  03
      sound_control(Ufo,a10[0]);
      sound_control(Shot,a10[1]);
      sound_control(PlayerDie,a10[2]);
      sound_control(InvaderDie,a10[3]);
      sound_control(ExtraLife,a10[4]);
      advance (10)
      #19E5
      #instruction: RET
      let:16 a12 = (1 + a2) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := a10;
      B := FD;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((M[a12],M[a2]));
    }

083E:

    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 41;
    #return-to: 0841
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2015],~FF) in
    let:8 a4 = (M[2015] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0A5E
    #instruction: RET
    let:16 a7 = (1 + a2) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2015];
    SPH := a8[15:8];
    SPL := a8[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((M[a7],M[a2]));

0841:

    #instruction: JP   Z,0849
    if (FlagZ) {
      advance (10)
      jump (0849);
    } else {
      advance (10)
      #0844
      #instruction: LD   B,04
      advance (7)
      #0846
      #instruction: CALL 18FA
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 08;
      let:16 a2 = (-1 + a1) in
      M[a2] := 49;
      #return-to: 0849
      advance (17)
      #18FA
      #instruction: LD   A,(2094)
      advance (13)
      #18FD
      #instruction: OR   B
      let:8 a3 = (04 | M[2094]) in
      advance (4)
      #18FE
      #instruction: LD   (2094),A
      M[2094] := a3;
      advance (13)
      #1901
      #instruction: OUT  03
      sound_control(Ufo,a3[0]);
      sound_control(Shot,a3[1]);
      sound_control(PlayerDie,a3[2]);
      sound_control(InvaderDie,a3[3]);
      sound_control(ExtraLife,a3[4]);
      advance (10)
      #1903
      #instruction: RET
      let:16 a4 = (1 + a2) in
      let:16 a5 = (1 + a4) in
      advance (10)
      A := a3;
      B := 04;
      SPH := a5[15:8];
      SPL := a5[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := false;
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a4],M[a2]));
    }

0849:

    #instruction: CALL 1775
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4C;
    #return-to: 084C
    advance (17)
    #1775
    #instruction: LD   A,(2095)
    advance (13)
    #1778
    #instruction: AND  A
    let:8 a3 = (M[2095] & M[2095]) in
    let:8 a4 = (M[2095] | M[2095]) in
    advance (4)
    #1779
    #instruction: JP   Z,17AA
    if (is_zero(a3)) {
      advance (10)
      #17AA
      #instruction: LD   HL,2099
      advance (10)
      #17AD
      #instruction: DEC  (HL)
      let:16 a5 = addWithCarry(!true,M[2099],~00) in
      let:8 a6 = (M[2099] & 0F) in
      let:8 a7 = (~00 & 0F) in
      let:16 a8 = addWithCarry(!true,a6,a7) in
      M[2099] := a5[7:0];
      advance (10)
      #17AE
      #instruction: RET  NZ
      if (!is_zero(a5[7:0])) {
        let:16 a9 = (1 + a2) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := a3;
        H := 20;
        L := 99;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := false;
        jump ((M[a9],M[a2]));
      } else {
        advance (5)
        #17AF
        #instruction: LD   B,EF
        advance (7)
        #17B1
        #instruction: JP   19DC
        advance (10)
        #19DC
        #instruction: LD   A,(2094)
        advance (13)
        #19DF
        #instruction: AND  B
        let:8 a11 = (EF & M[2094]) in
        let:8 a12 = (EF | M[2094]) in
        advance (4)
        #19E0
        #instruction: LD   (2094),A
        M[2094] := a11;
        advance (13)
        #19E3
        #instruction: OUT  03
        sound_control(Ufo,a11[0]);
        sound_control(Shot,a11[1]);
        sound_control(PlayerDie,a11[2]);
        sound_control(InvaderDie,a11[3]);
        sound_control(ExtraLife,a11[4]);
        advance (10)
        #19E5
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := a11;
        B := EF;
        H := 20;
        L := 99;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #177C
      #instruction: LD   HL,1A11
      advance (10)
      #177F
      #instruction: LD   DE,1A21
      advance (10)
      #1782
      #instruction: LD   A,(2082)
      advance (13)
      #1785
      #instruction: CP   (HL)
      let:16 a15 = addWithCarry(!false,M[2082],~32) in
      let:8 a16 = (M[2082] & 0F) in
      let:8 a17 = (~32 & 0F) in
      let:16 a18 = addWithCarry(!false,a16,a17) in
      advance (7)
      #1786
      #instruction: JP   NC,178E
      if (!!a15[15:8][0]) {
        advance (10)
        #178E
        #instruction: LD   A,(DE)
        advance (7)
        #178F
        #instruction: LD   (2097),A
        M[2097] := 34;
        advance (13)
        #1792
        #instruction: LD   HL,2098
        advance (10)
        #1795
        #instruction: LD   A,(HL)
        advance (7)
        #1796
        #instruction: AND  30
        let:8 a19 = (30 & M[2098]) in
        let:8 a20 = (30 | M[2098]) in
        advance (7)
        #1798
        #instruction: LD   B,A
        advance (5)
        #1799
        #instruction: LD   A,(HL)
        advance (7)
        #179A
        #instruction: AND  0F
        let:8 a21 = (0F & M[2098]) in
        let:8 a22 = (0F | M[2098]) in
        advance (7)
        #179C
        #instruction: RLCA 
        advance (4)
        #179D
        #instruction: CP   10
        let:16 a23 = addWithCarry(!false,updateBit((a21 << 01),0,a21[7]),~10) in
        let:8 a24 = (updateBit((a21 << 01),0,a21[7]) & 0F) in
        let:8 a25 = (~10 & 0F) in
        let:16 a26 = addWithCarry(!false,a24,a25) in
        advance (7)
        #179F
        #instruction: JP   NZ,17A4
        if (!is_zero(a23[7:0])) {
          advance (10)
          #17A4
          #instruction: OR   B
          let:8 a27 = (a19 | updateBit((a21 << 01),0,a21[7])) in
          advance (4)
          #17A5
          #instruction: LD   (HL),A
          M[2098] := a27;
          advance (7)
          #17A6
          #instruction: XOR  A
          let:8 a28 = (a27 ^ a27) in
          advance (4)
          #17A7
          #instruction: LD   (2095),A
          M[2095] := a28;
          advance (13)
          #17AA
          #instruction: LD   HL,2099
          advance (10)
          #17AD
          #instruction: DEC  (HL)
          let:16 a29 = addWithCarry(!true,M[2099],~00) in
          let:8 a30 = (M[2099] & 0F) in
          let:8 a31 = (~00 & 0F) in
          let:16 a32 = addWithCarry(!true,a30,a31) in
          M[2099] := a29[7:0];
          advance (10)
          #17AE
          #instruction: RET  NZ
          if (!is_zero(a29[7:0])) {
            let:16 a33 = (1 + a2) in
            let:16 a34 = (1 + a33) in
            advance (11)
            A := a28;
            B := a19;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a34[15:8];
            SPL := a34[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := false;
            jump ((M[a33],M[a2]));
          } else {
            advance (5)
            #17AF
            #instruction: LD   B,EF
            advance (7)
            #17B1
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a35 = (EF & M[2094]) in
            let:8 a36 = (EF | M[2094]) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            M[2094] := a35;
            advance (13)
            #19E3
            #instruction: OUT  03
            sound_control(Ufo,a35[0]);
            sound_control(Shot,a35[1]);
            sound_control(PlayerDie,a35[2]);
            sound_control(InvaderDie,a35[3]);
            sound_control(ExtraLife,a35[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:16 a37 = (1 + a2) in
            let:16 a38 = (1 + a37) in
            advance (10)
            A := a35;
            B := EF;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a38[15:8];
            SPL := a38[7:0];
            FlagS := a35[7];
            FlagZ := is_zero(a35);
            FlagA := a36[3];
            FlagP := parity(a35);
            FlagCY := false;
            jump ((M[a37],M[a2]));
          }
        } else {
          advance (10)
          #17A2
          #instruction: LD   A,01
          advance (7)
          #17A4
          #instruction: OR   B
          let:8 a39 = (a19 | 01) in
          advance (4)
          #17A5
          #instruction: LD   (HL),A
          M[2098] := a39;
          advance (7)
          #17A6
          #instruction: XOR  A
          let:8 a40 = (a39 ^ a39) in
          advance (4)
          #17A7
          #instruction: LD   (2095),A
          M[2095] := a40;
          advance (13)
          #17AA
          #instruction: LD   HL,2099
          advance (10)
          #17AD
          #instruction: DEC  (HL)
          let:16 a41 = addWithCarry(!true,M[2099],~00) in
          let:8 a42 = (M[2099] & 0F) in
          let:8 a43 = (~00 & 0F) in
          let:16 a44 = addWithCarry(!true,a42,a43) in
          M[2099] := a41[7:0];
          advance (10)
          #17AE
          #instruction: RET  NZ
          if (!is_zero(a41[7:0])) {
            let:16 a45 = (1 + a2) in
            let:16 a46 = (1 + a45) in
            advance (11)
            A := a40;
            B := a19;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a46[15:8];
            SPL := a46[7:0];
            FlagS := a41[7:0][7];
            FlagZ := is_zero(a41[7:0]);
            FlagA := a44[7:0][4];
            FlagP := parity(a41[7:0]);
            FlagCY := false;
            jump ((M[a45],M[a2]));
          } else {
            advance (5)
            #17AF
            #instruction: LD   B,EF
            advance (7)
            #17B1
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a47 = (EF & M[2094]) in
            let:8 a48 = (EF | M[2094]) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            M[2094] := a47;
            advance (13)
            #19E3
            #instruction: OUT  03
            sound_control(Ufo,a47[0]);
            sound_control(Shot,a47[1]);
            sound_control(PlayerDie,a47[2]);
            sound_control(InvaderDie,a47[3]);
            sound_control(ExtraLife,a47[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:16 a49 = (1 + a2) in
            let:16 a50 = (1 + a49) in
            advance (10)
            A := a47;
            B := EF;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a50[15:8];
            SPL := a50[7:0];
            FlagS := a47[7];
            FlagZ := is_zero(a47);
            FlagA := a48[3];
            FlagP := parity(a47);
            FlagCY := false;
            jump ((M[a49],M[a2]));
          }
        }
      } else {
        advance (10)
        #1789
        #instruction: INC  HL
        advance (5)
        #178A
        #instruction: INC  DE
        advance (5)
        #178B
        #instruction: JP   1785
        advance (10)
        A := M[2082];
        D := 1A;
        E := 22;
        H := 1A;
        L := 12;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := !a15[15:8][0];
        jump (1785);
      }
    }

084C:

    #instruction: OUT  06
    advance (10)
    #084E
    #instruction: CALL 1804
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 51;
    #return-to: 0851
    advance (17)
    #1804
    #instruction: LD   HL,2084
    advance (10)
    #1807
    #instruction: LD   A,(HL)
    advance (7)
    #1808
    #instruction: AND  A
    let:8 a3 = (M[2084] & M[2084]) in
    let:8 a4 = (M[2084] | M[2084]) in
    advance (4)
    #1809
    #instruction: JP   Z,0707
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      H := 20;
      L := 84;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0707);
    } else {
      advance (10)
      #180C
      #instruction: INC  HL
      advance (5)
      #180D
      #instruction: LD   A,(HL)
      advance (7)
      #180E
      #instruction: AND  A
      let:8 a5 = (M[2085] & M[2085]) in
      let:8 a6 = (M[2085] | M[2085]) in
      advance (4)
      #180F
      #instruction: RET  NZ
      if (!is_zero(a5)) {
        let:16 a7 = (1 + a2) in
        let:16 a8 = (1 + a7) in
        advance (11)
        A := a5;
        H := 20;
        L := 85;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := false;
        jump ((M[a7],M[a2]));
      } else {
        advance (5)
        #1810
        #instruction: LD   B,01
        advance (7)
        #1812
        #instruction: JP   18FA
        advance (10)
        #18FA
        #instruction: LD   A,(2094)
        advance (13)
        #18FD
        #instruction: OR   B
        let:8 a9 = (01 | M[2094]) in
        advance (4)
        #18FE
        #instruction: LD   (2094),A
        M[2094] := a9;
        advance (13)
        #1901
        #instruction: OUT  03
        sound_control(Ufo,a9[0]);
        sound_control(Shot,a9[1]);
        sound_control(PlayerDie,a9[2]);
        sound_control(InvaderDie,a9[3]);
        sound_control(ExtraLife,a9[4]);
        advance (10)
        #1903
        #instruction: RET
        let:16 a10 = (1 + a2) in
        let:16 a11 = (1 + a10) in
        advance (10)
        A := a9;
        B := 01;
        H := 20;
        L := 85;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a2]));
      }
    }

0851:

    #instruction: JP   081F
    advance (10)
    jump (081F);

085D:

    #instruction: LD   B,98
    advance (7)
    #085F
    #instruction: IN   01
    advance (10)
    #0861
    #instruction: RRCA 
    advance (4)
    #0862
    #instruction: RRCA 
    advance (4)
    #0863
    #instruction: JP   CY,086D
    if (updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0]) {
      advance (10)
      #086D
      #instruction: LD   A,01
      advance (7)
      #086F
      #instruction: JP   079B
      advance (10)
      #079B
      #instruction: LD   (20CE),A
      M[20CE] := 01;
      advance (13)
      #079E
      #instruction: LD   A,(20EB)
      advance (13)
      #07A1
      #instruction: ADD  B
      let:16 a1 = addWithCarry(false,98,M[20EB]) in
      let:8 a2 = (98 & 0F) in
      let:8 a3 = (M[20EB] & 0F) in
      let:16 a4 = addWithCarry(false,a2,a3) in
      advance (4)
      #07A2
      #instruction: DAA
      let:8 a5 = (a1[7:0] & 0F) in
      let:16 a6 = addWithCarry(false,a5,06) in
      let:16 a7 = addWithCarry(((((a5[1] || a5[2]) && a5[3]) || a4[7:0][4]) ? a6[7:0] : a5)[4],(a1[7:0] >> 04),00) in
      let:16 a8 = addWithCarry(false,a7[7:0],06) in
      let:8 a9 = (((((a5[1] || a5[2]) && a5[3]) || a4[7:0][4]) ? a6[7:0] : a5) & 0F) in
      let:8 a10 = ((((((a7[7:0][1] || a7[7:0][2]) && a7[7:0][3]) || a1[15:8][0]) ? a8[7:0] : a7[7:0]) << 04) | a9) in
      advance (4)
      #07A3
      #instruction: LD   (20EB),A
      M[20EB] := a10;
      advance (13)
      #07A6
      #instruction: CALL 1947
      let:16 a11 = (-1 + (SPH,SPL)) in
      M[a11] := 07;
      let:16 a12 = (-1 + a11) in
      M[a12] := A9;
      #return-to: 07A9
      advance (17)
      #1947
      #instruction: LD   A,(20EB)
      advance (13)
      #194A
      #instruction: LD   HL,3C01
      advance (10)
      #194D
      #instruction: JP   09B2
      advance (10)
      #09B2
      #instruction: PUSH DE
      let:16 a13 = (-1 + a12) in
      M[a13] := D;
      let:16 a14 = (-1 + a13) in
      M[a14] := E;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:16 a15 = (-1 + a14) in
      M[a15] := M[20EB];
      let:16 a16 = (-1 + a15) in
      M[a16] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a10[7]),6,is_zero(a10)),4,((((a5[1] || a5[2]) && a5[3]) || a4[7:0][4]) ? a6[7:0] : a5)[4]),2,parity(a10)),0,(((((a7[7:0][1] || a7[7:0][2]) && a7[7:0][3]) || a1[15:8][0]) ? a8[7:0] : a7[7:0])[4] || a1[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA 
      advance (4)
      #09B5
      #instruction: RRCA 
      advance (4)
      #09B6
      #instruction: RRCA 
      advance (4)
      #09B7
      #instruction: RRCA 
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a17 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
      let:8 a18 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:16 a19 = (-1 + a16) in
      M[a19] := 09;
      let:16 a20 = (-1 + a19) in
      M[a20] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:16 a21 = addWithCarry(false,1A,a17) in
      let:8 a22 = (1A & 0F) in
      let:8 a23 = (a17 & 0F) in
      let:16 a24 = addWithCarry(false,a22,a23) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a25 = (-1 + a20) in
      M[a25] := 3C;
      let:16 a26 = (-1 + a25) in
      M[a26] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a27 = add17((00,a21[7:0]),(00,a21[7:0])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a28 = add17(a27[15:0],a27[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a29 = add17(a28[15:0],a28[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a30 = add17(1E00,a29[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a31 = (1 + a26) in
      let:16 a32 = (1 + a31) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a33 = (-1 + a32) in
      M[a33] := 08;
      let:16 a34 = (-1 + a33) in
      M[a34] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a31],M[a26])] := M[a30[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a35 = (1 + a30[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a36 = add17(0020,(M[a31],M[a26])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a37 = (1 + a34) in
      let:16 a38 = (1 + a37) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a39 = addWithCarry(!true,M[a37],~00) in
      let:8 a40 = (M[a37] & 0F) in
      let:8 a41 = (~00 & 0F) in
      let:16 a42 = addWithCarry(!true,a40,a41) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a39[7:0])) {
        advance (10)
        A := M[a30[15:0]];
        B := a39[7:0];
        C := M[a34];
        D := a35[15:8];
        E := a35[7:0];
        H := a36[15:0][15:8];
        L := a36[15:0][7:0];
        SPH := a38[15:8];
        SPL := a38[7:0];
        FlagS := a39[7:0][7];
        FlagZ := is_zero(a39[7:0]);
        FlagA := a42[7:0][4];
        FlagP := parity(a39[7:0]);
        FlagCY := a36[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a43 = (1 + a38) in
        let:16 a44 = (1 + a43) in
        advance (10)
        A := M[a30[15:0]];
        B := a39[7:0];
        C := M[a34];
        D := a35[15:8];
        E := a35[7:0];
        H := a36[15:0][15:8];
        L := a36[15:0][7:0];
        SPH := a44[15:8];
        SPL := a44[7:0];
        FlagS := a39[7:0][7];
        FlagZ := is_zero(a39[7:0]);
        FlagA := a42[7:0][4];
        FlagP := parity(a39[7:0]);
        FlagCY := a36[16];
        jump ((M[a43],M[a38]));
      }
    } else {
      advance (10)
      #0866
      #instruction: RRCA 
      advance (4)
      #0867
      #instruction: JP   CY,0798
      if (updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0])[0]) {
        advance (10)
        #0798
        #instruction: LD   B,99
        advance (7)
        #079A
        #instruction: XOR  A
        let:8 a45 = (updateBit((updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0]) >> 01),7,updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0])[0]) ^ updateBit((updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0]) >> 01),7,updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0])[0])) in
        advance (4)
        #079B
        #instruction: LD   (20CE),A
        M[20CE] := a45;
        advance (13)
        #079E
        #instruction: LD   A,(20EB)
        advance (13)
        #07A1
        #instruction: ADD  B
        let:16 a46 = addWithCarry(false,99,M[20EB]) in
        let:8 a47 = (99 & 0F) in
        let:8 a48 = (M[20EB] & 0F) in
        let:16 a49 = addWithCarry(false,a47,a48) in
        advance (4)
        #07A2
        #instruction: DAA
        let:8 a50 = (a46[7:0] & 0F) in
        let:16 a51 = addWithCarry(false,a50,06) in
        let:16 a52 = addWithCarry(((((a50[1] || a50[2]) && a50[3]) || a49[7:0][4]) ? a51[7:0] : a50)[4],(a46[7:0] >> 04),00) in
        let:16 a53 = addWithCarry(false,a52[7:0],06) in
        let:8 a54 = (((((a50[1] || a50[2]) && a50[3]) || a49[7:0][4]) ? a51[7:0] : a50) & 0F) in
        let:8 a55 = ((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a46[15:8][0]) ? a53[7:0] : a52[7:0]) << 04) | a54) in
        advance (4)
        #07A3
        #instruction: LD   (20EB),A
        M[20EB] := a55;
        advance (13)
        #07A6
        #instruction: CALL 1947
        let:16 a56 = (-1 + (SPH,SPL)) in
        M[a56] := 07;
        let:16 a57 = (-1 + a56) in
        M[a57] := A9;
        #return-to: 07A9
        advance (17)
        #1947
        #instruction: LD   A,(20EB)
        advance (13)
        #194A
        #instruction: LD   HL,3C01
        advance (10)
        #194D
        #instruction: JP   09B2
        advance (10)
        #09B2
        #instruction: PUSH DE
        let:16 a58 = (-1 + a57) in
        M[a58] := D;
        let:16 a59 = (-1 + a58) in
        M[a59] := E;
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:16 a60 = (-1 + a59) in
        M[a60] := M[20EB];
        let:16 a61 = (-1 + a60) in
        M[a61] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a55[7]),6,is_zero(a55)),4,((((a50[1] || a50[2]) && a50[3]) || a49[7:0][4]) ? a51[7:0] : a50)[4]),2,parity(a55)),0,(((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a46[15:8][0]) ? a53[7:0] : a52[7:0])[4] || a46[15:8][0]));
        advance (11)
        #09B4
        #instruction: RRCA 
        advance (4)
        #09B5
        #instruction: RRCA 
        advance (4)
        #09B6
        #instruction: RRCA 
        advance (4)
        #09B7
        #instruction: RRCA 
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a62 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
        let:8 a63 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:16 a64 = (-1 + a61) in
        M[a64] := 09;
        let:16 a65 = (-1 + a64) in
        M[a65] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:16 a66 = addWithCarry(false,1A,a62) in
        let:8 a67 = (1A & 0F) in
        let:8 a68 = (a62 & 0F) in
        let:16 a69 = addWithCarry(false,a67,a68) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a70 = (-1 + a65) in
        M[a70] := 3C;
        let:16 a71 = (-1 + a70) in
        M[a71] := 01;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a72 = add17((00,a66[7:0]),(00,a66[7:0])) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a73 = add17(a72[15:0],a72[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a74 = add17(a73[15:0],a73[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a75 = add17(1E00,a74[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a76 = (1 + a71) in
        let:16 a77 = (1 + a76) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a78 = (-1 + a77) in
        M[a78] := 08;
        let:16 a79 = (-1 + a78) in
        M[a79] := C;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a76],M[a71])] := M[a75[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a80 = (1 + a75[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a81 = add17(0020,(M[a76],M[a71])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a82 = (1 + a79) in
        let:16 a83 = (1 + a82) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a84 = addWithCarry(!true,M[a82],~00) in
        let:8 a85 = (M[a82] & 0F) in
        let:8 a86 = (~00 & 0F) in
        let:16 a87 = addWithCarry(!true,a85,a86) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a84[7:0])) {
          advance (10)
          A := M[a75[15:0]];
          B := a84[7:0];
          C := M[a79];
          D := a80[15:8];
          E := a80[7:0];
          H := a81[15:0][15:8];
          L := a81[15:0][7:0];
          SPH := a83[15:8];
          SPL := a83[7:0];
          FlagS := a84[7:0][7];
          FlagZ := is_zero(a84[7:0]);
          FlagA := a87[7:0][4];
          FlagP := parity(a84[7:0]);
          FlagCY := a81[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a88 = (1 + a83) in
          let:16 a89 = (1 + a88) in
          advance (10)
          A := M[a75[15:0]];
          B := a84[7:0];
          C := M[a79];
          D := a80[15:8];
          E := a80[7:0];
          H := a81[15:0][15:8];
          L := a81[15:0][7:0];
          SPH := a89[15:8];
          SPL := a89[7:0];
          FlagS := a84[7:0][7];
          FlagZ := is_zero(a84[7:0]);
          FlagA := a87[7:0][4];
          FlagP := parity(a84[7:0]);
          FlagCY := a81[16];
          jump ((M[a88],M[a83]));
        }
      } else {
        advance (10)
        #086A
        #instruction: JP   077F
        advance (10)
        A := updateBit((updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0]) >> 01),7,updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0])[0]);
        B := 98;
        FlagCY := updateBit((updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0]) >> 01),7,updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) >> 01),7,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))[0])[0])[0];
        jump (077F);
      }
    }

0875:

    #instruction: JP   0814
    advance (10)
    jump (0814);

0898:

    #instruction: LD   A,(2067)
    advance (13)
    #089B
    #instruction: RRCA 
    advance (4)
    #089C
    #instruction: LD   A,1C
    advance (7)
    #089E
    #instruction: LD   HL,3711
    advance (10)
    #08A1
    #instruction: CALL NC,08FF
    if (!M[2067][0]) {
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 08;
      let:16 a2 = (-1 + a1) in
      M[a2] := A4;
      #return-to: 08A4
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a3 = (-1 + a2) in
      M[a3] := 37;
      let:16 a4 = (-1 + a3) in
      M[a4] := 11;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a5 = add17(001C,001C) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a6 = add17(a5[15:0],a5[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a7 = add17(a6[15:0],a6[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a8 = add17(1E00,a7[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a11 = (-1 + a10) in
      M[a11] := 08;
      let:16 a12 = (-1 + a11) in
      M[a12] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a9],M[a4])] := M[a8[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a13 = (1 + a8[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a14 = add17(0020,(M[a9],M[a4])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a15 = (1 + a12) in
      let:16 a16 = (1 + a15) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a17 = addWithCarry(!true,M[a15],~00) in
      let:8 a18 = (M[a15] & 0F) in
      let:8 a19 = (~00 & 0F) in
      let:16 a20 = addWithCarry(!true,a18,a19) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a17[7:0])) {
        advance (10)
        A := M[a8[15:0]];
        B := a17[7:0];
        C := M[a12];
        D := a13[15:8];
        E := a13[7:0];
        H := a14[15:0][15:8];
        L := a14[15:0][7:0];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := a14[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a21 = (1 + a16) in
        let:16 a22 = (1 + a21) in
        advance (10)
        A := M[a8[15:0]];
        B := a17[7:0];
        C := M[a12];
        D := a13[15:8];
        E := a13[7:0];
        H := a14[15:0][15:8];
        L := a14[15:0][7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := a14[16];
        jump ((M[a21],M[a16]));
      }
    } else {
      advance (11)
      A := 1C;
      H := 37;
      L := 11;
      FlagCY := M[2067][0];
      jump (08A4);
    }

08A4:

    #instruction: LD   A,B0
    advance (7)
    #08A6
    #instruction: LD   (20C0),A
    M[20C0] := B0;
    advance (13)
    #08A9
    #instruction: LD   A,(20C0)
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a1 = (M[20C0] & M[20C0]) in
    let:8 a2 = (M[20C0] | M[20C0]) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a5 = (04 & a1) in
      let:8 a6 = (04 | a1) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a5)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        advance (13)
        #08C4
        #instruction: RRCA 
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (M[2067][0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a7 = (-1 + (SPH,SPL)) in
          M[a7] := 08;
          let:16 a8 = (-1 + a7) in
          M[a8] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a9 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a10 = (-1 + a8) in
          M[a10] := 20;
          let:16 a11 = (-1 + a10) in
          M[a11] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[271C] := a9;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a12 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a13 = (1 + a11) in
          let:16 a14 = (1 + a13) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a15 = addWithCarry(!true,M[a13],~00) in
          let:8 a16 = (M[a13] & 0F) in
          let:8 a17 = (~00 & 0F) in
          let:16 a18 = addWithCarry(!true,a16,a17) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a15[7:0])) {
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a14[15:8];
            SPL := a14[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a19 = (1 + a14) in
            let:16 a20 = (1 + a19) in
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a20[15:8];
            SPL := a20[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump ((M[a19],M[a14]));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a21 = (-1 + (SPH,SPL)) in
          M[a21] := 08;
          let:16 a22 = (-1 + a21) in
          M[a22] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a23 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a24 = (-1 + a22) in
          M[a24] := 20;
          let:16 a25 = (-1 + a24) in
          M[a25] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[391C] := a23;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a26 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a27 = (1 + a25) in
          let:16 a28 = (1 + a27) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a29 = addWithCarry(!true,M[a27],~00) in
          let:8 a30 = (M[a27] & 0F) in
          let:8 a31 = (~00 & 0F) in
          let:16 a32 = addWithCarry(!true,a30,a31) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a29[7:0])) {
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a28[15:8];
            SPL := a28[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a33 = (1 + a28) in
            let:16 a34 = (1 + a33) in
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a34[15:8];
            SPL := a34[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump ((M[a33],M[a28]));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:16 a35 = (-1 + (SPH,SPL)) in
        M[a35] := 08;
        let:16 a36 = (-1 + a35) in
        M[a36] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        advance (13)
        #09CD
        #instruction: RRCA 
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (M[2067][0]) {
          let:16 a37 = (1 + a36) in
          let:16 a38 = (1 + a37) in
          advance (11)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := F8;
          SPH := a38[15:8];
          SPL := a38[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a37],M[a36]));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:16 a39 = (1 + a36) in
          let:16 a40 = (1 + a39) in
          advance (10)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := FC;
          SPH := a40[15:8];
          SPL := a40[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a39],M[a36]));
        }
      }
    }

08B6:

    #instruction: CALL 1931
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := B9;
    #return-to: 08B9
    advance (17)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    let:16 a3 = (1 + (H,L)) in
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    let:16 a4 = (1 + a3) in
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    let:16 a5 = (1 + a4) in
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a6 = (-1 + a2) in
    M[a6] := 09;
    let:16 a7 = (-1 + a6) in
    M[a7] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a8 = (-1 + a7) in
    M[a8] := M[a3];
    let:16 a9 = (-1 + a8) in
    M[a9] := M[(H,L)];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a10 = (-1 + a9) in
    M[a10] := M[a3];
    let:16 a11 = (-1 + a10) in
    M[a11] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a12 = (0F & updateBit((updateBit((updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0]) >> 01),7,updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0]) >> 01),7,updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0])[0])[0])) in
    let:8 a13 = (0F | updateBit((updateBit((updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0]) >> 01),7,updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0]) >> 01),7,updateBit((updateBit((M[a3] >> 01),7,M[a3][0]) >> 01),7,updateBit((M[a3] >> 01),7,M[a3][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a14 = (-1 + a11) in
    M[a14] := 09;
    let:16 a15 = (-1 + a14) in
    M[a15] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a16 = addWithCarry(false,1A,a12) in
    let:8 a17 = (1A & 0F) in
    let:8 a18 = (a12 & 0F) in
    let:16 a19 = addWithCarry(false,a17,a18) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a20 = (-1 + a15) in
    M[a20] := M[a5];
    let:16 a21 = (-1 + a20) in
    M[a21] := M[a4];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a22 = add17((00,a16[7:0]),(00,a16[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a23 = add17(a22[15:0],a22[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a24 = add17(a23[15:0],a23[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a25 = add17(1E00,a24[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a26 = (1 + a21) in
    let:16 a27 = (1 + a26) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a28 = (-1 + a27) in
    M[a28] := 08;
    let:16 a29 = (-1 + a28) in
    M[a29] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a26],M[a21])] := M[a25[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a30 = (1 + a25[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a31 = add17(0020,(M[a26],M[a21])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a32 = (1 + a29) in
    let:16 a33 = (1 + a32) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a34 = addWithCarry(!true,M[a32],~00) in
    let:8 a35 = (M[a32] & 0F) in
    let:8 a36 = (~00 & 0F) in
    let:16 a37 = addWithCarry(!true,a35,a36) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a34[7:0])) {
      advance (10)
      A := M[a25[15:0]];
      B := a34[7:0];
      C := M[a29];
      D := a30[15:8];
      E := a30[7:0];
      H := a31[15:0][15:8];
      L := a31[15:0][7:0];
      SPH := a33[15:8];
      SPL := a33[7:0];
      FlagS := a34[7:0][7];
      FlagZ := is_zero(a34[7:0]);
      FlagA := a37[7:0][4];
      FlagP := parity(a34[7:0]);
      FlagCY := a31[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a38 = (1 + a33) in
      let:16 a39 = (1 + a38) in
      advance (10)
      A := M[a25[15:0]];
      B := a34[7:0];
      C := M[a29];
      D := a30[15:8];
      E := a30[7:0];
      H := a31[15:0][15:8];
      L := a31[15:0][7:0];
      SPH := a39[15:8];
      SPL := a39[7:0];
      FlagS := a34[7:0][7];
      FlagZ := is_zero(a34[7:0]);
      FlagA := a37[7:0][4];
      FlagP := parity(a34[7:0]);
      FlagCY := a31[16];
      jump ((M[a38],M[a33]));
    }

08B9:

    #instruction: JP   08A9
    advance (10)
    #08A9
    #instruction: LD   A,(20C0)
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a1 = (M[20C0] & M[20C0]) in
    let:8 a2 = (M[20C0] | M[20C0]) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a5 = (04 & a1) in
      let:8 a6 = (04 | a1) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a5)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        advance (13)
        #08C4
        #instruction: RRCA 
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (M[2067][0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a7 = (-1 + (SPH,SPL)) in
          M[a7] := 08;
          let:16 a8 = (-1 + a7) in
          M[a8] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a9 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a10 = (-1 + a8) in
          M[a10] := 20;
          let:16 a11 = (-1 + a10) in
          M[a11] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[271C] := a9;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a12 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a13 = (1 + a11) in
          let:16 a14 = (1 + a13) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a15 = addWithCarry(!true,M[a13],~00) in
          let:8 a16 = (M[a13] & 0F) in
          let:8 a17 = (~00 & 0F) in
          let:16 a18 = addWithCarry(!true,a16,a17) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a15[7:0])) {
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a14[15:8];
            SPL := a14[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a19 = (1 + a14) in
            let:16 a20 = (1 + a19) in
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a20[15:8];
            SPL := a20[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump ((M[a19],M[a14]));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a21 = (-1 + (SPH,SPL)) in
          M[a21] := 08;
          let:16 a22 = (-1 + a21) in
          M[a22] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a23 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a24 = (-1 + a22) in
          M[a24] := 20;
          let:16 a25 = (-1 + a24) in
          M[a25] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[391C] := a23;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a26 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a27 = (1 + a25) in
          let:16 a28 = (1 + a27) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a29 = addWithCarry(!true,M[a27],~00) in
          let:8 a30 = (M[a27] & 0F) in
          let:8 a31 = (~00 & 0F) in
          let:16 a32 = addWithCarry(!true,a30,a31) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a29[7:0])) {
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a28[15:8];
            SPL := a28[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a33 = (1 + a28) in
            let:16 a34 = (1 + a33) in
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a34[15:8];
            SPL := a34[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump ((M[a33],M[a28]));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:16 a35 = (-1 + (SPH,SPL)) in
        M[a35] := 08;
        let:16 a36 = (-1 + a35) in
        M[a36] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        advance (13)
        #09CD
        #instruction: RRCA 
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (M[2067][0]) {
          let:16 a37 = (1 + a36) in
          let:16 a38 = (1 + a37) in
          advance (11)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := F8;
          SPH := a38[15:8];
          SPL := a38[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a37],M[a36]));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:16 a39 = (1 + a36) in
          let:16 a40 = (1 + a39) in
          advance (10)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := FC;
          SPH := a40[15:8];
          SPL := a40[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a39],M[a36]));
        }
      }
    }

08CE:

    #instruction: JP   08A9
    advance (10)
    #08A9
    #instruction: LD   A,(20C0)
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a1 = (M[20C0] & M[20C0]) in
    let:8 a2 = (M[20C0] | M[20C0]) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a5 = (04 & a1) in
      let:8 a6 = (04 | a1) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a5)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        advance (13)
        #08C4
        #instruction: RRCA 
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (M[2067][0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a7 = (-1 + (SPH,SPL)) in
          M[a7] := 08;
          let:16 a8 = (-1 + a7) in
          M[a8] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a9 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a10 = (-1 + a8) in
          M[a10] := 20;
          let:16 a11 = (-1 + a10) in
          M[a11] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[271C] := a9;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a12 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a13 = (1 + a11) in
          let:16 a14 = (1 + a13) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a15 = addWithCarry(!true,M[a13],~00) in
          let:8 a16 = (M[a13] & 0F) in
          let:8 a17 = (~00 & 0F) in
          let:16 a18 = addWithCarry(!true,a16,a17) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a15[7:0])) {
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a14[15:8];
            SPL := a14[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a19 = (1 + a14) in
            let:16 a20 = (1 + a19) in
            advance (10)
            A := a9;
            B := a15[7:0];
            C := M[a11];
            H := a12[15:0][15:8];
            L := a12[15:0][7:0];
            SPH := a20[15:8];
            SPL := a20[7:0];
            FlagS := a15[7:0][7];
            FlagZ := is_zero(a15[7:0]);
            FlagA := a18[7:0][4];
            FlagP := parity(a15[7:0]);
            FlagCY := a12[16];
            jump ((M[a19],M[a14]));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:16 a21 = (-1 + (SPH,SPL)) in
          M[a21] := 08;
          let:16 a22 = (-1 + a21) in
          M[a22] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a23 = (updateBit((M[2067] >> 01),7,M[2067][0]) ^ updateBit((M[2067] >> 01),7,M[2067][0])) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:16 a24 = (-1 + a22) in
          M[a24] := 20;
          let:16 a25 = (-1 + a24) in
          M[a25] := C;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          M[391C] := a23;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a26 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:16 a27 = (1 + a25) in
          let:16 a28 = (1 + a27) in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:16 a29 = addWithCarry(!true,M[a27],~00) in
          let:8 a30 = (M[a27] & 0F) in
          let:8 a31 = (~00 & 0F) in
          let:16 a32 = addWithCarry(!true,a30,a31) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a29[7:0])) {
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a28[15:8];
            SPL := a28[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:16 a33 = (1 + a28) in
            let:16 a34 = (1 + a33) in
            advance (10)
            A := a23;
            B := a29[7:0];
            C := M[a25];
            H := a26[15:0][15:8];
            L := a26[15:0][7:0];
            SPH := a34[15:8];
            SPL := a34[7:0];
            FlagS := a29[7:0][7];
            FlagZ := is_zero(a29[7:0]);
            FlagA := a32[7:0][4];
            FlagP := parity(a29[7:0]);
            FlagCY := a26[16];
            jump ((M[a33],M[a28]));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:16 a35 = (-1 + (SPH,SPL)) in
        M[a35] := 08;
        let:16 a36 = (-1 + a35) in
        M[a36] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        advance (13)
        #09CD
        #instruction: RRCA 
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (M[2067][0]) {
          let:16 a37 = (1 + a36) in
          let:16 a38 = (1 + a37) in
          advance (11)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := F8;
          SPH := a38[15:8];
          SPL := a38[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a37],M[a36]));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:16 a39 = (1 + a36) in
          let:16 a40 = (1 + a39) in
          advance (10)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          H := 20;
          L := FC;
          SPH := a40[15:8];
          SPL := a40[7:0];
          FlagS := a5[7];
          FlagZ := is_zero(a5);
          FlagA := a6[3];
          FlagP := parity(a5);
          FlagCY := M[2067][0];
          jump ((M[a39],M[a36]));
        }
      }
    }

08F8:

    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #08F9
    #instruction: INC  DE
    let:16 a3 = (1 + (M[a1],M[(SPH,SPL)])) in
    advance (5)
    #08FA
    #instruction: DEC  C
    let:16 a4 = addWithCarry(!true,C,~00) in
    let:8 a5 = (C & 0F) in
    let:8 a6 = (~00 & 0F) in
    let:16 a7 = addWithCarry(!true,a5,a6) in
    advance (5)
    #08FB
    #instruction: JP   NZ,08F3
    if (!is_zero(a4[7:0])) {
      advance (10)
      #08F3
      #instruction: LD   A,(DE)
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:16 a8 = (-1 + a2) in
      M[a8] := a3[15:8];
      let:16 a9 = (-1 + a8) in
      M[a9] := a3[7:0];
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:16 a10 = (-1 + a9) in
      M[a10] := 08;
      let:16 a11 = (-1 + a10) in
      M[a11] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a12 = (-1 + a11) in
      M[a12] := H;
      let:16 a13 = (-1 + a12) in
      M[a13] := L;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a14 = add17((00,M[a3]),(00,M[a3])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a15 = add17(a14[15:0],a14[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a16 = add17(a15[15:0],a15[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a17 = add17(1E00,a16[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a18 = (1 + a13) in
      let:16 a19 = (1 + a18) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a20 = (-1 + a19) in
      M[a20] := 08;
      let:16 a21 = (-1 + a20) in
      M[a21] := a4[7:0];
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a18],M[a13])] := M[a17[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a22 = (1 + a17[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a23 = add17(0020,(M[a18],M[a13])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a24 = (1 + a21) in
      let:16 a25 = (1 + a24) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a26 = addWithCarry(!true,M[a24],~00) in
      let:8 a27 = (M[a24] & 0F) in
      let:8 a28 = (~00 & 0F) in
      let:16 a29 = addWithCarry(!true,a27,a28) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a26[7:0])) {
        advance (10)
        A := M[a17[15:0]];
        B := a26[7:0];
        C := M[a21];
        D := a22[15:8];
        E := a22[7:0];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a30 = (1 + a25) in
        let:16 a31 = (1 + a30) in
        advance (10)
        A := M[a17[15:0]];
        B := a26[7:0];
        C := M[a21];
        D := a22[15:8];
        E := a22[7:0];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump ((M[a30],M[a25]));
      }
    } else {
      advance (10)
      #08FE
      #instruction: RET
      let:16 a32 = (1 + a2) in
      let:16 a33 = (1 + a32) in
      advance (10)
      C := a4[7:0];
      D := a3[15:8];
      E := a3[7:0];
      SPH := a33[15:8];
      SPL := a33[7:0];
      FlagS := a4[7:0][7];
      FlagZ := is_zero(a4[7:0]);
      FlagA := a7[7:0][4];
      FlagP := parity(a4[7:0]);
      jump ((M[a32],M[a2]));
    }

0931:

    #instruction: LD   L,FF
    advance (7)
    #0933
    #instruction: LD   A,(HL)
    advance (7)
    #0934
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[(H,FF)];
    L := FF;
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0938:

    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    #0939
    #instruction: DEC  HL
    let:16 a2 = (-1 + a1) in
    advance (5)
    #093A
    #instruction: LD   A,(HL)
    advance (7)
    #093B
    #instruction: AND  A
    let:8 a3 = (M[a2] & M[a2]) in
    let:8 a4 = (M[a2] | M[a2]) in
    advance (4)
    #093C
    #instruction: RET  Z
    if (is_zero(a3)) {
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (11)
      A := a3;
      H := a2[15:8];
      L := a2[7:0];
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[(SPH,SPL)]));
    } else {
      advance (5)
      #093D
      #instruction: LD   B,15
      advance (7)
      #093F
      #instruction: IN   02
      advance (10)
      #0941
      #instruction: AND  08
      let:8 a7 = (08 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
      let:8 a8 = (08 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
      advance (7)
      #0943
      #instruction: JP   Z,0948
      if (is_zero(a7)) {
        advance (10)
        #0948
        #instruction: CALL 09CA
        let:16 a9 = (-1 + (SPH,SPL)) in
        M[a9] := 09;
        let:16 a10 = (-1 + a9) in
        M[a10] := 4B;
        #return-to: 094B
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        advance (13)
        #09CD
        #instruction: RRCA 
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (M[2067][0]) {
          let:16 a11 = (1 + a10) in
          let:16 a12 = (1 + a11) in
          advance (11)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          B := 15;
          H := 20;
          L := F8;
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a7[7];
          FlagZ := is_zero(a7);
          FlagA := a8[3];
          FlagP := parity(a7);
          FlagCY := M[2067][0];
          jump ((M[a11],M[a10]));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:16 a13 = (1 + a10) in
          let:16 a14 = (1 + a13) in
          advance (10)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          B := 15;
          H := 20;
          L := FC;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a7[7];
          FlagZ := is_zero(a7);
          FlagA := a8[3];
          FlagP := parity(a7);
          FlagCY := M[2067][0];
          jump ((M[a13],M[a10]));
        }
      } else {
        advance (10)
        #0946
        #instruction: LD   B,10
        advance (7)
        #0948
        #instruction: CALL 09CA
        let:16 a15 = (-1 + (SPH,SPL)) in
        M[a15] := 09;
        let:16 a16 = (-1 + a15) in
        M[a16] := 4B;
        #return-to: 094B
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        advance (13)
        #09CD
        #instruction: RRCA 
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (M[2067][0]) {
          let:16 a17 = (1 + a16) in
          let:16 a18 = (1 + a17) in
          advance (11)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          B := 10;
          H := 20;
          L := F8;
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a7[7];
          FlagZ := is_zero(a7);
          FlagA := a8[3];
          FlagP := parity(a7);
          FlagCY := M[2067][0];
          jump ((M[a17],M[a16]));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:16 a19 = (1 + a16) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := updateBit((M[2067] >> 01),7,M[2067][0]);
          B := 10;
          H := 20;
          L := FC;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a7[7];
          FlagZ := is_zero(a7);
          FlagA := a8[3];
          FlagP := parity(a7);
          FlagCY := M[2067][0];
          jump ((M[a19],M[a16]));
        }
      }
    }

094B:

    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    #094C
    #instruction: LD   A,(HL)
    advance (7)
    #094D
    #instruction: CP   B
    let:16 a2 = addWithCarry(!false,M[a1],~B) in
    let:8 a3 = (M[a1] & 0F) in
    let:8 a4 = (~B & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (4)
    #094E
    #instruction: RET  CY
    if (!a2[15:8][0]) {
      let:16 a6 = (1 + (SPH,SPL)) in
      let:16 a7 = (1 + a6) in
      advance (11)
      A := M[a1];
      H := a1[15:8];
      L := a1[7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      FlagCY := !a2[15:8][0];
      jump ((M[a6],M[(SPH,SPL)]));
    } else {
      advance (5)
      #094F
      #instruction: CALL 092E
      let:16 a8 = (-1 + (SPH,SPL)) in
      M[a8] := 09;
      let:16 a9 = (-1 + a8) in
      M[a9] := 52;
      #return-to: 0952
      advance (17)
      #092E
      #instruction: CALL 1611
      let:16 a10 = (-1 + a9) in
      M[a10] := 09;
      let:16 a11 = (-1 + a10) in
      M[a11] := 31;
      #return-to: 0931
      advance (17)
      #1611
      #instruction: LD   L,00
      advance (7)
      #1613
      #instruction: LD   A,(2067)
      advance (13)
      #1616
      #instruction: LD   H,A
      advance (5)
      #1617
      #instruction: RET
      let:16 a12 = (1 + a11) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := M[2067];
      H := M[2067];
      L := 00;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      FlagCY := !a2[15:8][0];
      jump ((M[a12],M[a11]));
    }

0952:

    #instruction: INC  (HL)
    let:16 a1 = addWithCarry(true,M[(H,L)],00) in
    let:8 a2 = (M[(H,L)] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    M[(H,L)] := a1[7:0];
    advance (10)
    #0953
    #instruction: LD   A,(HL)
    advance (7)
    #0954
    #instruction: PUSH PSW
    let:16 a5 = (-1 + (SPH,SPL)) in
    M[a5] := M[(H,L)];
    let:16 a6 = (-1 + a5) in
    M[a6] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7:0][7]),6,is_zero(a1[7:0])),4,a4[7:0][4]),2,parity(a1[7:0])),0,FlagCY);
    advance (11)
    #0955
    #instruction: LD   HL,2501
    advance (10)
    #0958
    #instruction: INC  H
    let:16 a7 = addWithCarry(true,25,00) in
    let:8 a8 = (25 & 0F) in
    let:8 a9 = (00 & 0F) in
    let:16 a10 = addWithCarry(true,a8,a9) in
    advance (5)
    #0959
    #instruction: INC  H
    let:16 a11 = addWithCarry(true,a7[7:0],00) in
    let:8 a12 = (a7[7:0] & 0F) in
    let:8 a13 = (00 & 0F) in
    let:16 a14 = addWithCarry(true,a12,a13) in
    advance (5)
    #095A
    #instruction: DEC  A
    let:16 a15 = addWithCarry(!true,M[(H,L)],~00) in
    let:8 a16 = (M[(H,L)] & 0F) in
    let:8 a17 = (~00 & 0F) in
    let:16 a18 = addWithCarry(!true,a16,a17) in
    advance (5)
    #095B
    #instruction: JP   NZ,0958
    if (!is_zero(a15[7:0])) {
      advance (10)
      A := a15[7:0];
      H := a11[7:0];
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      jump (0958);
    } else {
      advance (10)
      #095E
      #instruction: LD   B,10
      advance (7)
      #0960
      #instruction: LD   DE,1C60
      advance (10)
      #0963
      #instruction: CALL 1439
      let:16 a19 = (-1 + a6) in
      M[a19] := 09;
      let:16 a20 = (-1 + a19) in
      M[a20] := 66;
      #return-to: 0966
      advance (17)
      #1439
      #instruction: PUSH BC
      let:16 a21 = (-1 + a20) in
      M[a21] := 10;
      let:16 a22 = (-1 + a21) in
      M[a22] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(a11[7:0],01)] := 00;
      advance (7)
      #143C
      #instruction: INC  DE
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a23 = add17(0020,(a11[7:0],01)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a24 = (1 + a22) in
      let:16 a25 = (1 + a24) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a26 = addWithCarry(!true,M[a24],~00) in
      let:8 a27 = (M[a24] & 0F) in
      let:8 a28 = (~00 & 0F) in
      let:16 a29 = addWithCarry(!true,a27,a28) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a26[7:0])) {
        advance (10)
        A := 00;
        B := a26[7:0];
        C := M[a22];
        D := 1C;
        E := 61;
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a30 = (1 + a25) in
        let:16 a31 = (1 + a30) in
        advance (10)
        A := 00;
        B := a26[7:0];
        C := M[a22];
        D := 1C;
        E := 61;
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump ((M[a30],M[a25]));
      }
    }

0966:

    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0967
    #instruction: INC  A
    let:16 a3 = addWithCarry(true,M[a1],00) in
    let:8 a4 = (M[a1] & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    advance (5)
    #0968
    #instruction: CALL 1A8B
    let:16 a7 = (-1 + a2) in
    M[a7] := 09;
    let:16 a8 = (-1 + a7) in
    M[a8] := 6B;
    #return-to: 096B
    advance (17)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a9 = (0F & a3[7:0]) in
    let:8 a10 = (0F | a3[7:0]) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:16 a11 = addWithCarry(false,1A,a9) in
    let:8 a12 = (1A & 0F) in
    let:8 a13 = (a9 & 0F) in
    let:16 a14 = addWithCarry(false,a12,a13) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a15 = (-1 + a8) in
    M[a15] := 25;
    let:16 a16 = (-1 + a15) in
    M[a16] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a17 = add17((00,a11[7:0]),(00,a11[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a18 = add17(a17[15:0],a17[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a19 = add17(a18[15:0],a18[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a20 = add17(1E00,a19[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a21 = (1 + a16) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a23 = (-1 + a22) in
    M[a23] := 08;
    let:16 a24 = (-1 + a23) in
    M[a24] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a21],M[a16])] := M[a20[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a25 = (1 + a20[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a26 = add17(0020,(M[a21],M[a16])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a27 = (1 + a24) in
    let:16 a28 = (1 + a27) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a29 = addWithCarry(!true,M[a27],~00) in
    let:8 a30 = (M[a27] & 0F) in
    let:8 a31 = (~00 & 0F) in
    let:16 a32 = addWithCarry(!true,a30,a31) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a29[7:0])) {
      advance (10)
      A := M[a20[15:0]];
      B := a29[7:0];
      C := M[a24];
      D := a25[15:8];
      E := a25[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a29[7:0][7];
      FlagZ := is_zero(a29[7:0]);
      FlagA := a32[7:0][4];
      FlagP := parity(a29[7:0]);
      FlagCY := a26[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a33 = (1 + a28) in
      let:16 a34 = (1 + a33) in
      advance (10)
      A := M[a20[15:0]];
      B := a29[7:0];
      C := M[a24];
      D := a25[15:8];
      E := a25[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a29[7:0][7];
      FlagZ := is_zero(a29[7:0]);
      FlagA := a32[7:0][4];
      FlagP := parity(a29[7:0]);
      FlagCY := a26[16];
      jump ((M[a33],M[a28]));
    }

096B:

    #instruction: CALL 1910
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 09;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6E;
    #return-to: 096E
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    advance (13)
    #1916
    #instruction: RRCA 
    advance (4)
    #1917
    #instruction: RET  CY
    if (M[2067][0]) {
      let:16 a3 = (1 + a2) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E7;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagCY := M[2067][0];
      jump ((M[a3],M[a2]));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E8;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a2]));
    }

096E:

    #instruction: DEC  HL
    let:16 a1 = (-1 + (H,L)) in
    advance (5)
    #096F
    #instruction: DEC  HL
    let:16 a2 = (-1 + a1) in
    advance (5)
    #0970
    #instruction: LD   (HL),00
    M[a2] := 00;
    advance (10)
    #0972
    #instruction: LD   A,FF
    advance (7)
    #0974
    #instruction: LD   (2099),A
    M[2099] := FF;
    advance (13)
    #0977
    #instruction: LD   B,10
    advance (7)
    #0979
    #instruction: JP   18FA
    advance (10)
    #18FA
    #instruction: LD   A,(2094)
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a3 = (10 | M[2094]) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    M[2094] := a3;
    advance (13)
    #1901
    #instruction: OUT  03
    sound_control(Ufo,a3[0]);
    sound_control(Shot,a3[1]);
    sound_control(PlayerDie,a3[2]);
    sound_control(InvaderDie,a3[3]);
    sound_control(ExtraLife,a3[4]);
    advance (10)
    #1903
    #instruction: RET
    let:16 a4 = (1 + (SPH,SPL)) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a3;
    B := 10;
    H := a2[15:8];
    L := a2[7:0];
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a4],M[(SPH,SPL)]));

098B:

    #instruction: LD   A,(20F1)
    advance (13)
    #098E
    #instruction: AND  A
    let:8 a1 = (M[20F1] & M[20F1]) in
    let:8 a2 = (M[20F1] | M[20F1]) in
    advance (4)
    #098F
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #0990
      #instruction: XOR  A
      let:8 a5 = (a1 ^ a1) in
      advance (4)
      #0991
      #instruction: LD   (20F1),A
      M[20F1] := a5;
      advance (13)
      #0994
      #instruction: PUSH HL
      let:16 a6 = (-1 + (SPH,SPL)) in
      M[a6] := H;
      let:16 a7 = (-1 + a6) in
      M[a7] := L;
      advance (11)
      #0995
      #instruction: LD   HL,(20F2)
      advance (16)
      #0998
      #instruction: EX   DE,HL
      advance (4)
      #0999
      #instruction: POP  HL
      let:16 a8 = (1 + a7) in
      let:16 a9 = (1 + a8) in
      advance (10)
      #099A
      #instruction: LD   A,(HL)
      advance (7)
      #099B
      #instruction: ADD  E
      let:16 a10 = addWithCarry(false,M[20F2],M[(M[a8],M[a7])]) in
      let:8 a11 = (M[20F2] & 0F) in
      let:8 a12 = (M[(M[a8],M[a7])] & 0F) in
      let:16 a13 = addWithCarry(false,a11,a12) in
      advance (4)
      #099C
      #instruction: DAA
      let:8 a14 = (a10[7:0] & 0F) in
      let:16 a15 = addWithCarry(false,a14,06) in
      let:16 a16 = addWithCarry(((((a14[1] || a14[2]) && a14[3]) || a13[7:0][4]) ? a15[7:0] : a14)[4],(a10[7:0] >> 04),00) in
      let:16 a17 = addWithCarry(false,a16[7:0],06) in
      let:8 a18 = (((((a14[1] || a14[2]) && a14[3]) || a13[7:0][4]) ? a15[7:0] : a14) & 0F) in
      let:8 a19 = ((((((a16[7:0][1] || a16[7:0][2]) && a16[7:0][3]) || a10[15:8][0]) ? a17[7:0] : a16[7:0]) << 04) | a18) in
      advance (4)
      #099D
      #instruction: LD   (HL),A
      M[(M[a8],M[a7])] := a19;
      advance (7)
      #099E
      #instruction: LD   E,A
      advance (5)
      #099F
      #instruction: INC  HL
      let:16 a20 = (1 + (M[a8],M[a7])) in
      advance (5)
      #09A0
      #instruction: LD   A,(HL)
      advance (7)
      #09A1
      #instruction: ADC  D
      let:16 a21 = addWithCarry((((((a16[7:0][1] || a16[7:0][2]) && a16[7:0][3]) || a10[15:8][0]) ? a17[7:0] : a16[7:0])[4] || a10[15:8][0]),M[20F3],M[a20]) in
      let:8 a22 = (M[20F3] & 0F) in
      let:8 a23 = (M[a20] & 0F) in
      let:16 a24 = addWithCarry((((((a16[7:0][1] || a16[7:0][2]) && a16[7:0][3]) || a10[15:8][0]) ? a17[7:0] : a16[7:0])[4] || a10[15:8][0]),a22,a23) in
      advance (4)
      #09A2
      #instruction: DAA
      let:8 a25 = (a21[7:0] & 0F) in
      let:16 a26 = addWithCarry(false,a25,06) in
      let:16 a27 = addWithCarry(((((a25[1] || a25[2]) && a25[3]) || a24[7:0][4]) ? a26[7:0] : a25)[4],(a21[7:0] >> 04),00) in
      let:16 a28 = addWithCarry(false,a27[7:0],06) in
      let:8 a29 = (((((a25[1] || a25[2]) && a25[3]) || a24[7:0][4]) ? a26[7:0] : a25) & 0F) in
      let:8 a30 = ((((((a27[7:0][1] || a27[7:0][2]) && a27[7:0][3]) || a21[15:8][0]) ? a28[7:0] : a27[7:0]) << 04) | a29) in
      advance (4)
      #09A3
      #instruction: LD   (HL),A
      M[a20] := a30;
      advance (7)
      #09A4
      #instruction: LD   D,A
      advance (5)
      #09A5
      #instruction: INC  HL
      let:16 a31 = (1 + a20) in
      advance (5)
      #09A6
      #instruction: LD   A,(HL)
      advance (7)
      #09A7
      #instruction: INC  HL
      let:16 a32 = (1 + a31) in
      advance (5)
      #09A8
      #instruction: LD   H,(HL)
      advance (7)
      #09A9
      #instruction: LD   L,A
      advance (5)
      #09AA
      #instruction: JP   09AD
      advance (10)
      #09AD
      #instruction: LD   A,D
      advance (5)
      #09AE
      #instruction: CALL 09B2
      let:16 a33 = (-1 + a9) in
      M[a33] := 09;
      let:16 a34 = (-1 + a33) in
      M[a34] := B1;
      #return-to: 09B1
      advance (17)
      #09B2
      #instruction: PUSH DE
      let:16 a35 = (-1 + a34) in
      M[a35] := a30;
      let:16 a36 = (-1 + a35) in
      M[a36] := a19;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:16 a37 = (-1 + a36) in
      M[a37] := a30;
      let:16 a38 = (-1 + a37) in
      M[a38] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a30[7]),6,is_zero(a30)),4,((((a25[1] || a25[2]) && a25[3]) || a24[7:0][4]) ? a26[7:0] : a25)[4]),2,parity(a30)),0,(((((a27[7:0][1] || a27[7:0][2]) && a27[7:0][3]) || a21[15:8][0]) ? a28[7:0] : a27[7:0])[4] || a21[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA 
      advance (4)
      #09B5
      #instruction: RRCA 
      advance (4)
      #09B6
      #instruction: RRCA 
      advance (4)
      #09B7
      #instruction: RRCA 
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a39 = (0F & updateBit((updateBit((updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0]) >> 01),7,updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0]) >> 01),7,updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0])[0])[0])) in
      let:8 a40 = (0F | updateBit((updateBit((updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0]) >> 01),7,updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0]) >> 01),7,updateBit((updateBit((a30 >> 01),7,a30[0]) >> 01),7,updateBit((a30 >> 01),7,a30[0])[0])[0])[0])) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:16 a41 = (-1 + a38) in
      M[a41] := 09;
      let:16 a42 = (-1 + a41) in
      M[a42] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:16 a43 = addWithCarry(false,1A,a39) in
      let:8 a44 = (1A & 0F) in
      let:8 a45 = (a39 & 0F) in
      let:16 a46 = addWithCarry(false,a44,a45) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a47 = (-1 + a42) in
      M[a47] := M[a32];
      let:16 a48 = (-1 + a47) in
      M[a48] := M[a31];
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a49 = add17((00,a43[7:0]),(00,a43[7:0])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a50 = add17(a49[15:0],a49[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a51 = add17(a50[15:0],a50[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a52 = add17(1E00,a51[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a53 = (1 + a48) in
      let:16 a54 = (1 + a53) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a55 = (-1 + a54) in
      M[a55] := 08;
      let:16 a56 = (-1 + a55) in
      M[a56] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a53],M[a48])] := M[a52[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a57 = (1 + a52[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a58 = add17(0020,(M[a53],M[a48])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a59 = (1 + a56) in
      let:16 a60 = (1 + a59) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a61 = addWithCarry(!true,M[a59],~00) in
      let:8 a62 = (M[a59] & 0F) in
      let:8 a63 = (~00 & 0F) in
      let:16 a64 = addWithCarry(!true,a62,a63) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a61[7:0])) {
        advance (10)
        A := M[a52[15:0]];
        B := a61[7:0];
        C := M[a56];
        D := a57[15:8];
        E := a57[7:0];
        H := a58[15:0][15:8];
        L := a58[15:0][7:0];
        SPH := a60[15:8];
        SPL := a60[7:0];
        FlagS := a61[7:0][7];
        FlagZ := is_zero(a61[7:0]);
        FlagA := a64[7:0][4];
        FlagP := parity(a61[7:0]);
        FlagCY := a58[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a65 = (1 + a60) in
        let:16 a66 = (1 + a65) in
        advance (10)
        A := M[a52[15:0]];
        B := a61[7:0];
        C := M[a56];
        D := a57[15:8];
        E := a57[7:0];
        H := a58[15:0][15:8];
        L := a58[15:0][7:0];
        SPH := a66[15:8];
        SPL := a66[7:0];
        FlagS := a61[7:0][7];
        FlagZ := is_zero(a61[7:0]);
        FlagA := a64[7:0][4];
        FlagP := parity(a61[7:0]);
        FlagCY := a58[16];
        jump ((M[a65],M[a60]));
      }
    }

09B1:

    #instruction: LD   A,E
    advance (5)
    #09B2
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a3 = (-1 + a2) in
    M[a3] := E;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a5 = (0F & updateBit((updateBit((updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0]) >> 01),7,updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0]) >> 01),7,updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0])[0])[0])) in
    let:8 a6 = (0F | updateBit((updateBit((updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0]) >> 01),7,updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0]) >> 01),7,updateBit((updateBit((E >> 01),7,E[0]) >> 01),7,updateBit((E >> 01),7,E[0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a7 = (-1 + a4) in
    M[a7] := 09;
    let:16 a8 = (-1 + a7) in
    M[a8] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a9 = addWithCarry(false,1A,a5) in
    let:8 a10 = (1A & 0F) in
    let:8 a11 = (a5 & 0F) in
    let:16 a12 = addWithCarry(false,a10,a11) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a13 = (-1 + a8) in
    M[a13] := H;
    let:16 a14 = (-1 + a13) in
    M[a14] := L;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a15 = add17((00,a9[7:0]),(00,a9[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a16 = add17(a15[15:0],a15[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a17 = add17(a16[15:0],a16[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a18 = add17(1E00,a17[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a19 = (1 + a14) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a21 = (-1 + a20) in
    M[a21] := 08;
    let:16 a22 = (-1 + a21) in
    M[a22] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a19],M[a14])] := M[a18[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a23 = (1 + a18[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a24 = add17(0020,(M[a19],M[a14])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a25 = (1 + a22) in
    let:16 a26 = (1 + a25) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a27 = addWithCarry(!true,M[a25],~00) in
    let:8 a28 = (M[a25] & 0F) in
    let:8 a29 = (~00 & 0F) in
    let:16 a30 = addWithCarry(!true,a28,a29) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a27[7:0])) {
      advance (10)
      A := M[a18[15:0]];
      B := a27[7:0];
      C := M[a22];
      D := a23[15:8];
      E := a23[7:0];
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a27[7:0][7];
      FlagZ := is_zero(a27[7:0]);
      FlagA := a30[7:0][4];
      FlagP := parity(a27[7:0]);
      FlagCY := a24[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a31 = (1 + a26) in
      let:16 a32 = (1 + a31) in
      advance (10)
      A := M[a18[15:0]];
      B := a27[7:0];
      C := M[a22];
      D := a23[15:8];
      E := a23[7:0];
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a27[7:0][7];
      FlagZ := is_zero(a27[7:0]);
      FlagA := a30[7:0][4];
      FlagP := parity(a27[7:0]);
      FlagCY := a24[16];
      jump ((M[a31],M[a26]));
    }

09BD:

    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #09BE
    #instruction: AND  0F
    let:8 a3 = (0F & M[a1]) in
    let:8 a4 = (0F | M[a1]) in
    advance (7)
    #09C0
    #instruction: CALL 09C5
    let:16 a5 = (-1 + a2) in
    M[a5] := 09;
    let:16 a6 = (-1 + a5) in
    M[a6] := C3;
    #return-to: 09C3
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a7 = addWithCarry(false,1A,a3) in
    let:8 a8 = (1A & 0F) in
    let:8 a9 = (a3 & 0F) in
    let:16 a10 = addWithCarry(false,a8,a9) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a11 = (-1 + a6) in
    M[a11] := H;
    let:16 a12 = (-1 + a11) in
    M[a12] := L;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a13 = add17((00,a7[7:0]),(00,a7[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a14 = add17(a13[15:0],a13[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a15 = add17(a14[15:0],a14[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a16 = add17(1E00,a15[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a17 = (1 + a12) in
    let:16 a18 = (1 + a17) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a19 = (-1 + a18) in
    M[a19] := 08;
    let:16 a20 = (-1 + a19) in
    M[a20] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a17],M[a12])] := M[a16[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a21 = (1 + a16[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a22 = add17(0020,(M[a17],M[a12])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a23 = (1 + a20) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a25 = addWithCarry(!true,M[a23],~00) in
    let:8 a26 = (M[a23] & 0F) in
    let:8 a27 = (~00 & 0F) in
    let:16 a28 = addWithCarry(!true,a26,a27) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a25[7:0])) {
      advance (10)
      A := M[a16[15:0]];
      B := a25[7:0];
      C := M[a20];
      D := a21[15:8];
      E := a21[7:0];
      H := a22[15:0][15:8];
      L := a22[15:0][7:0];
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      FlagCY := a22[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a29 = (1 + a24) in
      let:16 a30 = (1 + a29) in
      advance (10)
      A := M[a16[15:0]];
      B := a25[7:0];
      C := M[a20];
      D := a21[15:8];
      E := a21[7:0];
      H := a22[15:0][15:8];
      L := a22[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      FlagCY := a22[16];
      jump ((M[a29],M[a24]));
    }

09C3:

    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #09C4
    #instruction: RET
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    D := M[a1];
    E := M[(SPH,SPL)];
    SPH := a4[15:8];
    SPL := a4[7:0];
    jump ((M[a3],M[a2]));

09F2:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #09F3
    #instruction: LD   (20E9),A
    M[20E9] := a1;
    advance (13)
    #09F6
    #instruction: CALL 09D6
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := F9;
    #return-to: 09F9
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a4 = (1F & 03) in
    let:8 a5 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a6 = addWithCarry(!false,a4,~1C) in
    let:8 a7 = (a4 & 0F) in
    let:8 a8 = (~1C & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a6[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a10 = addWithCarry(!false,24,~40) in
      let:8 a11 = (24 & 0F) in
      let:8 a12 = (~40 & 0F) in
      let:16 a13 = addWithCarry(!false,a11,a12) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a10[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a3[15:8];
        SPL := a3[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a14 = (1 + a3) in
        let:16 a15 = (1 + a14) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a15[15:8];
        SPL := a15[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump ((M[a14],M[a3]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a16 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a17 = addWithCarry(!false,a16[15:0][15:8],~40) in
      let:8 a18 = (a16[15:0][15:8] & 0F) in
      let:8 a19 = (~40 & 0F) in
      let:16 a20 = addWithCarry(!false,a18,a19) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a17[15:8][0]) {
        advance (10)
        A := a16[15:0][15:8];
        D := 00;
        E := 06;
        H := a16[15:0][15:8];
        L := a16[15:0][7:0];
        SPH := a3[15:8];
        SPL := a3[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a17[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a21 = (1 + a3) in
        let:16 a22 = (1 + a21) in
        advance (10)
        A := a16[15:0][15:8];
        D := 00;
        E := 06;
        H := a16[15:0][15:8];
        L := a16[15:0][7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a17[15:8][0];
        jump ((M[a21],M[a3]));
      }
    }

09F9:

    #instruction: LD   A,(2067)
    advance (13)
    #09FC
    #instruction: PUSH PSW
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := M[2067];
    let:16 a2 = (-1 + a1) in
    M[a2] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09FD
    #instruction: CALL 01E4
    let:16 a3 = (-1 + a2) in
    M[a3] := 0A;
    let:16 a4 = (-1 + a3) in
    M[a4] := 00;
    #return-to: 0A00
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a5 = addWithCarry(!true,C0,~00) in
    let:8 a6 = (C0 & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := 01;
      B := a5[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := 01;
      B := a5[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump ((M[a9],M[a4]));
    }

0A00:

    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0A01
    #instruction: LD   (2067),A
    M[2067] := M[a1];
    advance (13)
    #0A04
    #instruction: LD   A,(2067)
    advance (13)
    #0A07
    #instruction: LD   H,A
    advance (5)
    #0A08
    #instruction: PUSH HL
    let:16 a3 = (-1 + a2) in
    M[a3] := M[2067];
    let:16 a4 = (-1 + a3) in
    M[a4] := L;
    advance (11)
    #0A09
    #instruction: LD   L,FE
    advance (7)
    #0A0B
    #instruction: LD   A,(HL)
    advance (7)
    #0A0C
    #instruction: AND  07
    let:8 a5 = (07 & M[(M[2067],FE)]) in
    let:8 a6 = (07 | M[(M[2067],FE)]) in
    advance (7)
    #0A0E
    #instruction: INC  A
    let:16 a7 = addWithCarry(true,a5,00) in
    let:8 a8 = (a5 & 0F) in
    let:8 a9 = (00 & 0F) in
    let:16 a10 = addWithCarry(true,a8,a9) in
    advance (5)
    #0A0F
    #instruction: LD   (HL),A
    M[(M[2067],FE)] := a7[7:0];
    advance (7)
    #0A10
    #instruction: LD   HL,1DA2
    advance (10)
    #0A13
    #instruction: INC  HL
    advance (5)
    #0A14
    #instruction: DEC  A
    let:16 a11 = addWithCarry(!true,a7[7:0],~00) in
    let:8 a12 = (a7[7:0] & 0F) in
    let:8 a13 = (~00 & 0F) in
    let:16 a14 = addWithCarry(!true,a12,a13) in
    advance (5)
    #0A15
    #instruction: JP   NZ,0A13
    if (!is_zero(a11[7:0])) {
      advance (10)
      A := a11[7:0];
      H := 1D;
      L := A3;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := false;
      jump (0A13);
    } else {
      advance (10)
      #0A18
      #instruction: LD   A,(HL)
      advance (7)
      #0A19
      #instruction: POP  HL
      let:16 a15 = (1 + a4) in
      let:16 a16 = (1 + a15) in
      advance (10)
      #0A1A
      #instruction: LD   L,FC
      advance (7)
      #0A1C
      #instruction: LD   (HL),A
      M[(M[a15],FC)] := 60;
      advance (7)
      #0A1D
      #instruction: INC  HL
      let:16 a17 = (1 + (M[a15],FC)) in
      advance (5)
      #0A1E
      #instruction: LD   (HL),38
      M[a17] := 38;
      advance (10)
      #0A20
      #instruction: LD   A,H
      advance (5)
      #0A21
      #instruction: RRCA 
      advance (4)
      #0A22
      #instruction: JP   CY,0A33
      if (a17[15:8][0]) {
        advance (10)
        #0A33
        #instruction: CALL 01EF
        let:16 a18 = (-1 + a16) in
        M[a18] := 0A;
        let:16 a19 = (-1 + a18) in
        M[a19] := 36;
        #return-to: 0A36
        advance (17)
        #01EF
        #instruction: LD   HL,2142
        advance (10)
        #01F2
        #instruction: JP   01F8
        advance (10)
        #01F8
        #instruction: LD   C,04
        advance (7)
        #01FA
        #instruction: LD   DE,1D20
        advance (10)
        #01FD
        #instruction: PUSH DE
        let:16 a20 = (-1 + a19) in
        M[a20] := 1D;
        let:16 a21 = (-1 + a20) in
        M[a21] := 20;
        advance (11)
        #01FE
        #instruction: LD   B,2C
        advance (7)
        #0200
        #instruction: CALL 1A32
        let:16 a22 = (-1 + a21) in
        M[a22] := 02;
        let:16 a23 = (-1 + a22) in
        M[a23] := 03;
        #return-to: 0203
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2142] := FF;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a24 = addWithCarry(!true,2C,~00) in
        let:8 a25 = (2C & 0F) in
        let:8 a26 = (~00 & 0F) in
        let:16 a27 = addWithCarry(!true,a25,a26) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a24[7:0])) {
          advance (10)
          A := FF;
          B := a24[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 21;
          L := 43;
          SPH := a23[15:8];
          SPL := a23[7:0];
          FlagS := a24[7:0][7];
          FlagZ := is_zero(a24[7:0]);
          FlagA := a27[7:0][4];
          FlagP := parity(a24[7:0]);
          FlagCY := a17[15:8][0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a28 = (1 + a23) in
          let:16 a29 = (1 + a28) in
          advance (10)
          A := FF;
          B := a24[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 21;
          L := 43;
          SPH := a29[15:8];
          SPL := a29[7:0];
          FlagS := a24[7:0][7];
          FlagZ := is_zero(a24[7:0]);
          FlagA := a27[7:0][4];
          FlagP := parity(a24[7:0]);
          FlagCY := a17[15:8][0];
          jump ((M[a28],M[a23]));
        }
      } else {
        advance (10)
        #0A25
        #instruction: LD   A,21
        advance (7)
        #0A27
        #instruction: LD   (2098),A
        M[2098] := 21;
        advance (13)
        #0A2A
        #instruction: CALL 01F5
        let:16 a30 = (-1 + a16) in
        M[a30] := 0A;
        let:16 a31 = (-1 + a30) in
        M[a31] := 2D;
        #return-to: 0A2D
        advance (17)
        #01F5
        #instruction: LD   HL,2242
        advance (10)
        #01F8
        #instruction: LD   C,04
        advance (7)
        #01FA
        #instruction: LD   DE,1D20
        advance (10)
        #01FD
        #instruction: PUSH DE
        let:16 a32 = (-1 + a31) in
        M[a32] := 1D;
        let:16 a33 = (-1 + a32) in
        M[a33] := 20;
        advance (11)
        #01FE
        #instruction: LD   B,2C
        advance (7)
        #0200
        #instruction: CALL 1A32
        let:16 a34 = (-1 + a33) in
        M[a34] := 02;
        let:16 a35 = (-1 + a34) in
        M[a35] := 03;
        #return-to: 0203
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2242] := FF;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a36 = addWithCarry(!true,2C,~00) in
        let:8 a37 = (2C & 0F) in
        let:8 a38 = (~00 & 0F) in
        let:16 a39 = addWithCarry(!true,a37,a38) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a36[7:0])) {
          advance (10)
          A := FF;
          B := a36[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 22;
          L := 43;
          SPH := a35[15:8];
          SPL := a35[7:0];
          FlagS := a36[7:0][7];
          FlagZ := is_zero(a36[7:0]);
          FlagA := a39[7:0][4];
          FlagP := parity(a36[7:0]);
          FlagCY := a17[15:8][0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:16 a40 = (1 + a35) in
          let:16 a41 = (1 + a40) in
          advance (10)
          A := FF;
          B := a36[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 22;
          L := 43;
          SPH := a41[15:8];
          SPL := a41[7:0];
          FlagS := a36[7:0][7];
          FlagZ := is_zero(a36[7:0]);
          FlagA := a39[7:0][4];
          FlagP := parity(a36[7:0]);
          FlagCY := a17[15:8][0];
          jump ((M[a40],M[a35]));
        }
      }
    }

0A2D:

    #instruction: CALL 1904
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    #return-to: 0A30
    advance (17)
    #1904
    #instruction: LD   HL,2200
    advance (10)
    #1907
    #instruction: JP   01C3
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2200] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,37,~00) in
    let:8 a4 = (37 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a3[7:0])) {
      advance (10)
      B := a3[7:0];
      H := 22;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      B := a3[7:0];
      H := 22;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0A30:

    #instruction: JP   0804
    advance (10)
    #0804
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := E0;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a5 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a6 = (1 + a4) in
    let:16 a7 = (1 + a6) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a8 = addWithCarry(!true,M[a6],~00) in
    let:8 a9 = (M[a6] & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a12 = (1 + a7) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump ((M[a12],M[a7]));
    }

0A36:

    #instruction: CALL 01C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0A39
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,37,~00) in
    let:8 a4 = (37 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a3[7:0])) {
      advance (10)
      B := a3[7:0];
      H := 21;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      B := a3[7:0];
      H := 21;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0A39:

    #instruction: JP   0804
    advance (10)
    #0804
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 08;
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := E0;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a5 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a6 = (1 + a4) in
    let:16 a7 = (1 + a6) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a8 = addWithCarry(!true,M[a6],~00) in
    let:8 a9 = (M[a6] & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a12 = (1 + a7) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump ((M[a12],M[a7]));
    }

0A3F:

    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0A;
      let:16 a2 = (-1 + a1) in
      M[a2] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a3 = addWithCarry(!false,M[2015],~FF) in
      let:8 a4 = (M[2015] & 0F) in
      let:8 a5 = (~FF & 0F) in
      let:16 a6 = addWithCarry(!false,a4,a5) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := M[2015];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (10)
      #0A42
      #instruction: LD   A,30
      advance (7)
      #0A44
      #instruction: LD   (20C0),A
      M[20C0] := 30;
      advance (13)
      #0A47
      #instruction: LD   A,(20C0)
      advance (13)
      #0A4A
      #instruction: AND  A
      let:8 a9 = (M[20C0] & M[20C0]) in
      let:8 a10 = (M[20C0] | M[20C0]) in
      advance (4)
      #0A4B
      #instruction: RET  Z
      if (is_zero(a9)) {
        let:16 a11 = (1 + (SPH,SPL)) in
        let:16 a12 = (1 + a11) in
        advance (11)
        A := a9;
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := a10[3];
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a11],M[(SPH,SPL)]));
      } else {
        advance (5)
        #0A4C
        #instruction: CALL 0A59
        let:16 a13 = (-1 + (SPH,SPL)) in
        M[a13] := 0A;
        let:16 a14 = (-1 + a13) in
        M[a14] := 4F;
        #return-to: 0A4F
        advance (17)
        #0A59
        #instruction: LD   A,(2015)
        advance (13)
        #0A5C
        #instruction: CP   FF
        let:16 a15 = addWithCarry(!false,M[2015],~FF) in
        let:8 a16 = (M[2015] & 0F) in
        let:8 a17 = (~FF & 0F) in
        let:16 a18 = addWithCarry(!false,a16,a17) in
        advance (7)
        #0A5E
        #instruction: RET
        let:16 a19 = (1 + a14) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := M[2015];
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := !a15[15:8][0];
        jump ((M[a19],M[a14]));
      }
    }

0A4F:

    #instruction: JP   Z,0A47
    if (FlagZ) {
      advance (10)
      #0A47
      #instruction: LD   A,(20C0)
      advance (13)
      #0A4A
      #instruction: AND  A
      let:8 a1 = (M[20C0] & M[20C0]) in
      let:8 a2 = (M[20C0] | M[20C0]) in
      advance (4)
      #0A4B
      #instruction: RET  Z
      if (is_zero(a1)) {
        let:16 a3 = (1 + (SPH,SPL)) in
        let:16 a4 = (1 + a3) in
        advance (11)
        A := a1;
        SPH := a4[15:8];
        SPL := a4[7:0];
        FlagS := a1[7];
        FlagZ := is_zero(a1);
        FlagA := a2[3];
        FlagP := parity(a1);
        FlagCY := false;
        jump ((M[a3],M[(SPH,SPL)]));
      } else {
        advance (5)
        #0A4C
        #instruction: CALL 0A59
        let:16 a5 = (-1 + (SPH,SPL)) in
        M[a5] := 0A;
        let:16 a6 = (-1 + a5) in
        M[a6] := 4F;
        #return-to: 0A4F
        advance (17)
        #0A59
        #instruction: LD   A,(2015)
        advance (13)
        #0A5C
        #instruction: CP   FF
        let:16 a7 = addWithCarry(!false,M[2015],~FF) in
        let:8 a8 = (M[2015] & 0F) in
        let:8 a9 = (~FF & 0F) in
        let:16 a10 = addWithCarry(!false,a8,a9) in
        advance (7)
        #0A5E
        #instruction: RET
        let:16 a11 = (1 + a6) in
        let:16 a12 = (1 + a11) in
        advance (10)
        A := M[2015];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := !a7[15:8][0];
        jump ((M[a11],M[a6]));
      }
    } else {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:16 a13 = (-1 + (SPH,SPL)) in
      M[a13] := 0A;
      let:16 a14 = (-1 + a13) in
      M[a14] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a15 = addWithCarry(!false,M[2015],~FF) in
      let:8 a16 = (M[2015] & 0F) in
      let:8 a17 = (~FF & 0F) in
      let:16 a18 = addWithCarry(!false,a16,a17) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a19 = (1 + a14) in
      let:16 a20 = (1 + a19) in
      advance (10)
      A := M[2015];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      FlagCY := !a15[15:8][0];
      jump ((M[a19],M[a14]));
    }

0A55:

    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0A;
      let:16 a2 = (-1 + a1) in
      M[a2] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a3 = addWithCarry(!false,M[2015],~FF) in
      let:8 a4 = (M[2015] & 0F) in
      let:8 a5 = (~FF & 0F) in
      let:16 a6 = addWithCarry(!false,a4,a5) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := M[2015];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (10)
      #0A58
      #instruction: RET
      let:16 a9 = (1 + (SPH,SPL)) in
      let:16 a10 = (1 + a9) in
      advance (10)
      SPH := a10[15:8];
      SPL := a10[7:0];
      jump ((M[a9],M[(SPH,SPL)]));
    }

0A6C:

    #instruction: LD   B,C
    advance (5)
    #0A6D
    #instruction: LD   A,B
    advance (5)
    #0A6E
    #instruction: CALL 097C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 0A71
    advance (17)
    #097C
    #instruction: LD   HL,1DA0
    advance (10)
    #097F
    #instruction: CP   02
    let:16 a3 = addWithCarry(!false,C,~02) in
    let:8 a4 = (C & 0F) in
    let:8 a5 = (~02 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0981
    #instruction: RET  CY
    if (!a3[15:8][0]) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := C;
      B := C;
      H := 1D;
      L := A0;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #0982
      #instruction: INC  HL
      advance (5)
      #0983
      #instruction: CP   04
      let:16 a9 = addWithCarry(!false,C,~04) in
      let:8 a10 = (C & 0F) in
      let:8 a11 = (~04 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0985
      #instruction: RET  CY
      if (!a9[15:8][0]) {
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (11)
        A := C;
        B := C;
        H := 1D;
        L := A1;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      } else {
        advance (5)
        #0986
        #instruction: INC  HL
        advance (5)
        #0987
        #instruction: RET
        let:16 a15 = (1 + a2) in
        let:16 a16 = (1 + a15) in
        advance (10)
        A := C;
        B := C;
        H := 1D;
        L := A2;
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a15],M[a2]));
      }
    }

0A71:

    #instruction: LD   A,(HL)
    advance (7)
    #0A72
    #instruction: LD   HL,20F3
    advance (10)
    #0A75
    #instruction: LD   (HL),00
    M[20F3] := 00;
    advance (10)
    #0A77
    #instruction: DEC  HL
    advance (5)
    #0A78
    #instruction: LD   (HL),A
    M[20F2] := M[(H,L)];
    advance (7)
    #0A79
    #instruction: DEC  HL
    advance (5)
    #0A7A
    #instruction: LD   (HL),01
    M[20F1] := 01;
    advance (10)
    #0A7C
    #instruction: LD   HL,2062
    advance (10)
    #0A7F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := M[(H,L)];
    H := 20;
    L := 62;
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

0A98:

    #instruction: POP  DE
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #0A99
    #instruction: LD   A,07
    advance (7)
    #0A9B
    #instruction: LD   (20C0),A
    M[20C0] := 07;
    advance (13)
    #0A9E
    #instruction: LD   A,(20C0)
    advance (13)
    #0AA1
    #instruction: DEC  A
    let:16 a3 = addWithCarry(!true,M[20C0],~00) in
    let:8 a4 = (M[20C0] & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0AA2
    #instruction: JP   NZ,0A9E
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a3[7:0];
      D := M[a1];
      E := M[(SPH,SPL)];
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (0A9E);
    } else {
      advance (10)
      #0AA5
      #instruction: INC  DE
      let:16 a7 = (1 + (M[a1],M[(SPH,SPL)])) in
      advance (5)
      #0AA6
      #instruction: DEC  C
      let:16 a8 = addWithCarry(!true,C,~00) in
      let:8 a9 = (C & 0F) in
      let:8 a10 = (~00 & 0F) in
      let:16 a11 = addWithCarry(!true,a9,a10) in
      advance (5)
      #0AA7
      #instruction: JP   NZ,0A93
      if (!is_zero(a8[7:0])) {
        advance (10)
        #0A93
        #instruction: PUSH DE
        let:16 a12 = (-1 + a2) in
        M[a12] := a7[15:8];
        let:16 a13 = (-1 + a12) in
        M[a13] := a7[7:0];
        advance (11)
        #0A94
        #instruction: LD   A,(DE)
        advance (7)
        #0A95
        #instruction: CALL 08FF
        let:16 a14 = (-1 + a13) in
        M[a14] := 0A;
        let:16 a15 = (-1 + a14) in
        M[a15] := 98;
        #return-to: 0A98
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a16 = (-1 + a15) in
        M[a16] := H;
        let:16 a17 = (-1 + a16) in
        M[a17] := L;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a18 = add17((00,M[a7]),(00,M[a7])) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a19 = add17(a18[15:0],a18[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a20 = add17(a19[15:0],a19[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a21 = add17(1E00,a20[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a22 = (1 + a17) in
        let:16 a23 = (1 + a22) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a24 = (-1 + a23) in
        M[a24] := 08;
        let:16 a25 = (-1 + a24) in
        M[a25] := a8[7:0];
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a22],M[a17])] := M[a21[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a26 = (1 + a21[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a27 = add17(0020,(M[a22],M[a17])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a28 = (1 + a25) in
        let:16 a29 = (1 + a28) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a30 = addWithCarry(!true,M[a28],~00) in
        let:8 a31 = (M[a28] & 0F) in
        let:8 a32 = (~00 & 0F) in
        let:16 a33 = addWithCarry(!true,a31,a32) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a30[7:0])) {
          advance (10)
          A := M[a21[15:0]];
          B := a30[7:0];
          C := M[a25];
          D := a26[15:8];
          E := a26[7:0];
          H := a27[15:0][15:8];
          L := a27[15:0][7:0];
          SPH := a29[15:8];
          SPL := a29[7:0];
          FlagS := a30[7:0][7];
          FlagZ := is_zero(a30[7:0]);
          FlagA := a33[7:0][4];
          FlagP := parity(a30[7:0]);
          FlagCY := a27[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a34 = (1 + a29) in
          let:16 a35 = (1 + a34) in
          advance (10)
          A := M[a21[15:0]];
          B := a30[7:0];
          C := M[a25];
          D := a26[15:8];
          E := a26[7:0];
          H := a27[15:0][15:8];
          L := a27[15:0][7:0];
          SPH := a35[15:8];
          SPL := a35[7:0];
          FlagS := a30[7:0][7];
          FlagZ := is_zero(a30[7:0]);
          FlagA := a33[7:0][4];
          FlagP := parity(a30[7:0]);
          FlagCY := a27[16];
          jump ((M[a34],M[a29]));
        }
      } else {
        advance (10)
        #0AAA
        #instruction: RET
        let:16 a36 = (1 + a2) in
        let:16 a37 = (1 + a36) in
        advance (10)
        A := a3[7:0];
        C := a8[7:0];
        D := a7[15:8];
        E := a7[7:0];
        SPH := a37[15:8];
        SPL := a37[7:0];
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        jump ((M[a36],M[a2]));
      }
    }

0AF2:

    #instruction: EI
    enable_interrupts()
    advance (4)
    #0AF3
    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0A;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 0AF6
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0AF6:

    #instruction: LD   A,(20EC)
    advance (13)
    #0AF9
    #instruction: AND  A
    let:8 a1 = (M[20EC] & M[20EC]) in
    let:8 a2 = (M[20EC] | M[20EC]) in
    advance (4)
    #0AFA
    #instruction: LD   HL,3017
    advance (10)
    #0AFD
    #instruction: LD   C,04
    advance (7)
    #0AFF
    #instruction: JP   NZ,0BE8
    if (!is_zero(a1)) {
      advance (10)
      #0BE8
      #instruction: LD   DE,1DAB
      advance (10)
      #0BEB
      #instruction: CALL 0A93
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 0B;
      let:16 a4 = (-1 + a3) in
      M[a4] := EE;
      #return-to: 0BEE
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a5 = (-1 + a4) in
      M[a5] := 1D;
      let:16 a6 = (-1 + a5) in
      M[a6] := AB;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a7 = (-1 + a6) in
      M[a7] := 0A;
      let:16 a8 = (-1 + a7) in
      M[a8] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a9 = (-1 + a8) in
      M[a9] := 30;
      let:16 a10 = (-1 + a9) in
      M[a10] := 17;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a11 = add17(000F,000F) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a12 = add17(a11[15:0],a11[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a13 = add17(a12[15:0],a12[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a14 = add17(1E00,a13[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a15 = (1 + a10) in
      let:16 a16 = (1 + a15) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a17 = (-1 + a16) in
      M[a17] := 08;
      let:16 a18 = (-1 + a17) in
      M[a18] := 04;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a15],M[a10])] := M[a14[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a19 = (1 + a14[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a20 = add17(0020,(M[a15],M[a10])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a21 = (1 + a18) in
      let:16 a22 = (1 + a21) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a23 = addWithCarry(!true,M[a21],~00) in
      let:8 a24 = (M[a21] & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a23[7:0])) {
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a27 = (1 + a22) in
        let:16 a28 = (1 + a27) in
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a28[15:8];
        SPL := a28[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump ((M[a27],M[a22]));
      }
    } else {
      advance (10)
      #0B02
      #instruction: LD   DE,1CFA
      advance (10)
      #0B05
      #instruction: CALL 0A93
      let:16 a29 = (-1 + (SPH,SPL)) in
      M[a29] := 0B;
      let:16 a30 = (-1 + a29) in
      M[a30] := 08;
      #return-to: 0B08
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a31 = (-1 + a30) in
      M[a31] := 1C;
      let:16 a32 = (-1 + a31) in
      M[a32] := FA;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a33 = (-1 + a32) in
      M[a33] := 0A;
      let:16 a34 = (-1 + a33) in
      M[a34] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a35 = (-1 + a34) in
      M[a35] := 30;
      let:16 a36 = (-1 + a35) in
      M[a36] := 17;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a37 = add17(000F,000F) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a38 = add17(a37[15:0],a37[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a39 = add17(a38[15:0],a38[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a40 = add17(1E00,a39[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a41 = (1 + a36) in
      let:16 a42 = (1 + a41) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a43 = (-1 + a42) in
      M[a43] := 08;
      let:16 a44 = (-1 + a43) in
      M[a44] := 04;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a41],M[a36])] := M[a40[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a45 = (1 + a40[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a46 = add17(0020,(M[a41],M[a36])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a47 = (1 + a44) in
      let:16 a48 = (1 + a47) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a49 = addWithCarry(!true,M[a47],~00) in
      let:8 a50 = (M[a47] & 0F) in
      let:8 a51 = (~00 & 0F) in
      let:16 a52 = addWithCarry(!true,a50,a51) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a49[7:0])) {
        advance (10)
        A := M[a40[15:0]];
        B := a49[7:0];
        C := M[a44];
        D := a45[15:8];
        E := a45[7:0];
        H := a46[15:0][15:8];
        L := a46[15:0][7:0];
        SPH := a48[15:8];
        SPL := a48[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a46[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a53 = (1 + a48) in
        let:16 a54 = (1 + a53) in
        advance (10)
        A := M[a40[15:0]];
        B := a49[7:0];
        C := M[a44];
        D := a45[15:8];
        E := a45[7:0];
        H := a46[15:0][15:8];
        L := a46[15:0][7:0];
        SPH := a54[15:8];
        SPL := a54[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a46[16];
        jump ((M[a53],M[a48]));
      }
    }

0B08:

    #instruction: LD   DE,1DAF
    advance (10)
    #0B0B
    #instruction: CALL 0ACF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0E;
    #return-to: 0B0E
    advance (17)
    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    #0AD2
    #instruction: LD   C,0F
    advance (7)
    #0AD4
    #instruction: JP   0A93
    advance (10)
    #0A93
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1D;
    let:16 a4 = (-1 + a3) in
    M[a4] := AF;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 0A;
    let:16 a6 = (-1 + a5) in
    M[a6] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 2B;
    let:16 a8 = (-1 + a7) in
    M[a8] := 14;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(0012,0012) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 0F;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

0B0E:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 11;
    #return-to: 0B11
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0B11:

    #instruction: CALL 1815
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    #return-to: 0B14
    advance (17)
    #1815
    #instruction: LD   HL,2810
    advance (10)
    #1818
    #instruction: LD   DE,1CA3
    advance (10)
    #181B
    #instruction: LD   C,15
    advance (7)
    #181D
    #instruction: CALL 08F3
    let:16 a3 = (-1 + a2) in
    M[a3] := 18;
    let:16 a4 = (-1 + a3) in
    M[a4] := 20;
    #return-to: 1820
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := 1C;
    let:16 a6 = (-1 + a5) in
    M[a6] := A3;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a7 = (-1 + a6) in
    M[a7] := 08;
    let:16 a8 = (-1 + a7) in
    M[a8] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a9 = (-1 + a8) in
    M[a9] := 28;
    let:16 a10 = (-1 + a9) in
    M[a10] := 10;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a11 = add17(0028,0028) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a12 = add17(a11[15:0],a11[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a13 = add17(a12[15:0],a12[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a14 = add17(1E00,a13[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a15 = (1 + a10) in
    let:16 a16 = (1 + a15) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a17 = (-1 + a16) in
    M[a17] := 08;
    let:16 a18 = (-1 + a17) in
    M[a18] := 15;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a15],M[a10])] := M[a14[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a19 = (1 + a14[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a20 = add17(0020,(M[a15],M[a10])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a21 = (1 + a18) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a23 = addWithCarry(!true,M[a21],~00) in
    let:8 a24 = (M[a21] & 0F) in
    let:8 a25 = (~00 & 0F) in
    let:16 a26 = addWithCarry(!true,a24,a25) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a23[7:0])) {
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a27 = (1 + a22) in
      let:16 a28 = (1 + a27) in
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump ((M[a27],M[a22]));
    }

0B14:

    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    #return-to: 0B17
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0B17:

    #instruction: LD   A,(20EC)
    advance (13)
    #0B1A
    #instruction: AND  A
    let:8 a1 = (M[20EC] & M[20EC]) in
    let:8 a2 = (M[20EC] | M[20EC]) in
    advance (4)
    #0B1B
    #instruction: JP   NZ,0B4A
    if (!is_zero(a1)) {
      advance (10)
      A := a1;
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump (0B4A);
    } else {
      advance (10)
      #0B1E
      #instruction: LD   DE,1A95
      advance (10)
      #0B21
      #instruction: CALL 0AE2
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 0B;
      let:16 a4 = (-1 + a3) in
      M[a4] := 24;
      #return-to: 0B24
      advance (17)
      #0AE2
      #instruction: LD   HL,20C2
      advance (10)
      #0AE5
      #instruction: LD   B,0C
      advance (7)
      #0AE7
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[20C2] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a5 = addWithCarry(!true,0C,~00) in
      let:8 a6 = (0C & 0F) in
      let:8 a7 = (~00 & 0F) in
      let:16 a8 = addWithCarry(!true,a6,a7) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a5[7:0])) {
        advance (10)
        A := 00;
        B := a5[7:0];
        D := 1A;
        E := 96;
        H := 20;
        L := C3;
        SPH := a4[15:8];
        SPL := a4[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a9 = (1 + a4) in
        let:16 a10 = (1 + a9) in
        advance (10)
        A := 00;
        B := a5[7:0];
        D := 1A;
        E := 96;
        H := 20;
        L := C3;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := false;
        jump ((M[a9],M[a4]));
      }
    }

0B24:

    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    #return-to: 0B27
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a3 = (M[20CB] & M[20CB]) in
    let:8 a4 = (M[20CB] | M[20CB]) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a5 = (a3 ^ a3) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      M[20C1] := a5;
      advance (13)
      #0A92
      #instruction: RET
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a5;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    }

0B27:

    #instruction: LD   DE,1BB0
    advance (10)
    #0B2A
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2D;
    #return-to: 0B2D
    advance (17)
    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    #0AE5
    #instruction: LD   B,0C
    advance (7)
    #0AE7
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[20C2] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,0C,~00) in
    let:8 a4 = (0C & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := B1;
      H := 20;
      L := C3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1B;
      E := B1;
      H := 20;
      L := C3;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0B2D:

    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 30;
    #return-to: 0B30
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a3 = (M[20CB] & M[20CB]) in
    let:8 a4 = (M[20CB] | M[20CB]) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a5 = (a3 ^ a3) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      M[20C1] := a5;
      advance (13)
      #0A92
      #instruction: RET
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a5;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    }

0B30:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 33;
    #return-to: 0B33
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0B33:

    #instruction: LD   DE,1FC9
    advance (10)
    #0B36
    #instruction: CALL 0AE2
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 39;
    #return-to: 0B39
    advance (17)
    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    #0AE5
    #instruction: LD   B,0C
    advance (7)
    #0AE7
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[20C2] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,0C,~00) in
    let:8 a4 = (0C & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1F;
      E := CA;
      H := 20;
      L := C3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 00;
      B := a3[7:0];
      D := 1F;
      E := CA;
      H := 20;
      L := C3;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0B39:

    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3C;
    #return-to: 0B3C
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a3 = (M[20CB] & M[20CB]) in
    let:8 a4 = (M[20CB] | M[20CB]) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a5 = (a3 ^ a3) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      M[20C1] := a5;
      advance (13)
      #0A92
      #instruction: RET
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a5;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    }

0B3C:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3F;
    #return-to: 0B3F
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0B3F:

    #instruction: LD   HL,33B7
    advance (10)
    #0B42
    #instruction: LD   B,0A
    advance (7)
    #0B44
    #instruction: CALL 14CB
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 47;
    #return-to: 0B47
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a3 = (A ^ A) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:16 a4 = (-1 + a2) in
    M[a4] := 0A;
    let:16 a5 = (-1 + a4) in
    M[a5] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[33B7] := a3;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a6 = add17(0020,33B7) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a7 = (1 + a5) in
    let:16 a8 = (1 + a7) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,M[a7],~00) in
    let:8 a10 = (M[a7] & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := a3;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a13 = (1 + a8) in
      let:16 a14 = (1 + a13) in
      advance (10)
      A := a3;
      B := a9[7:0];
      C := M[a5];
      H := a6[15:0][15:8];
      L := a6[15:0][7:0];
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := a6[16];
      jump ((M[a13],M[a8]));
    }

0B47:

    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4A;
    #return-to: 0B4A
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0B4A:

    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 4D;
    #return-to: 0B4D
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a3 = (1F & 03) in
    let:8 a4 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a5 = addWithCarry(!false,a3,~1C) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~1C & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a5[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a9 = addWithCarry(!false,24,~40) in
      let:8 a10 = (24 & 0F) in
      let:8 a11 = (~40 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a9[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a15 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a16 = addWithCarry(!false,a15[15:0][15:8],~40) in
      let:8 a17 = (a15[15:0][15:8] & 0F) in
      let:8 a18 = (~40 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a16[15:8][0]) {
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a20 = (1 + a2) in
        let:16 a21 = (1 + a20) in
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((M[a20],M[a2]));
      }
    }

0B4D:

    #instruction: LD   A,(21FF)
    advance (13)
    #0B50
    #instruction: AND  A
    let:8 a1 = (M[21FF] & M[21FF]) in
    let:8 a2 = (M[21FF] | M[21FF]) in
    advance (4)
    #0B51
    #instruction: JP   NZ,0B5D
    if (!is_zero(a1)) {
      advance (10)
      A := a1;
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump (0B5D);
    } else {
      advance (10)
      #0B54
      #instruction: CALL 08D1
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 0B;
      let:16 a4 = (-1 + a3) in
      M[a4] := 57;
      #return-to: 0B57
      advance (17)
      #08D1
      #instruction: IN   02
      advance (10)
      #08D3
      #instruction: AND  03
      let:8 a5 = (03 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
      let:8 a6 = (03 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))) in
      advance (7)
      #08D5
      #instruction: ADD  03
      let:16 a7 = addWithCarry(false,03,a5) in
      let:8 a8 = (03 & 0F) in
      let:8 a9 = (a5 & 0F) in
      let:16 a10 = addWithCarry(false,a8,a9) in
      advance (7)
      #08D7
      #instruction: RET
      let:16 a11 = (1 + a4) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := a7[7:0];
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a7[15:8][0];
      jump ((M[a11],M[a4]));
    }

0B57:

    #instruction: LD   (21FF),A
    M[21FF] := A;
    advance (13)
    #0B5A
    #instruction: CALL 1A7F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5D;
    #return-to: 0B5D
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    let:16 a4 = (-1 + a3) in
    M[a4] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:16 a5 = (-1 + a4) in
    M[a5] := 09;
    let:16 a6 = (-1 + a5) in
    M[a6] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    advance (13)
    #1616
    #instruction: LD   H,A
    advance (5)
    #1617
    #instruction: RET
    let:16 a7 = (1 + a6) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := 00;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((M[a7],M[a6]));

0B5D:

    #instruction: CALL 01E4
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 60;
    #return-to: 0B60
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,C0,~00) in
    let:8 a4 = (C0 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 01;
      B := a3[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := 01;
      B := a3[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0B60:

    #instruction: CALL 01C0
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 63;
    #return-to: 0B63
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a3 = addWithCarry(!true,37,~00) in
    let:8 a4 = (37 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a3[7:0])) {
      advance (10)
      B := a3[7:0];
      H := 21;
      L := 01;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      B := a3[7:0];
      H := 21;
      L := 01;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((M[a7],M[a2]));
    }

0B63:

    #instruction: CALL 01EF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 66;
    #return-to: 0B66
    advance (17)
    #01EF
    #instruction: LD   HL,2142
    advance (10)
    #01F2
    #instruction: JP   01F8
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1D;
    let:16 a4 = (-1 + a3) in
    M[a4] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:16 a5 = (-1 + a4) in
    M[a5] := 02;
    let:16 a6 = (-1 + a5) in
    M[a6] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2142] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,2C,~00) in
    let:8 a8 = (2C & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := FF;
      B := a7[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((M[a11],M[a6]));
    }

0B66:

    #instruction: CALL 021A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 69;
    #return-to: 0B69
    advance (17)
    #021A
    #instruction: XOR  A
    let:8 a3 = (A ^ A) in
    advance (4)
    #021B
    #instruction: LD   DE,2142
    advance (10)
    #021E
    #instruction: LD   (2081),A
    M[2081] := a3;
    advance (13)
    #0221
    #instruction: LD   BC,1602
    advance (10)
    #0224
    #instruction: LD   HL,2806
    advance (10)
    #0227
    #instruction: LD   A,04
    advance (7)
    #0229
    #instruction: PUSH PSW
    let:16 a4 = (-1 + a2) in
    M[a4] := 04;
    let:16 a5 = (-1 + a4) in
    M[a5] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a3[7]),6,is_zero(a3)),4,false),2,parity(a3)),0,false);
    advance (11)
    #022A
    #instruction: PUSH BC
    let:16 a6 = (-1 + a5) in
    M[a6] := 16;
    let:16 a7 = (-1 + a6) in
    M[a7] := 02;
    advance (11)
    #022B
    #instruction: LD   A,(2081)
    advance (13)
    #022E
    #instruction: AND  A
    let:8 a8 = (M[2081] & M[2081]) in
    let:8 a9 = (M[2081] | M[2081]) in
    advance (4)
    #022F
    #instruction: JP   NZ,0242
    if (!is_zero(a8)) {
      advance (10)
      #0242
      #instruction: CALL 147C
      let:16 a10 = (-1 + a7) in
      M[a10] := 02;
      let:16 a11 = (-1 + a10) in
      M[a11] := 45;
      #return-to: 0245
      advance (17)
      #147C
      #instruction: PUSH BC
      let:16 a12 = (-1 + a11) in
      M[a12] := 16;
      let:16 a13 = (-1 + a12) in
      M[a13] := 02;
      advance (11)
      #147D
      #instruction: PUSH HL
      let:16 a14 = (-1 + a13) in
      M[a14] := 28;
      let:16 a15 = (-1 + a14) in
      M[a15] := 06;
      advance (11)
      #147E
      #instruction: LD   A,(HL)
      advance (7)
      #147F
      #instruction: LD   (DE),A
      M[2142] := M[2806];
      advance (7)
      #1480
      #instruction: INC  DE
      advance (5)
      #1481
      #instruction: INC  HL
      advance (5)
      #1482
      #instruction: DEC  C
      let:16 a16 = addWithCarry(!true,02,~00) in
      let:8 a17 = (02 & 0F) in
      let:8 a18 = (~00 & 0F) in
      let:16 a19 = addWithCarry(!true,a17,a18) in
      advance (5)
      #1483
      #instruction: JP   NZ,147E
      if (!is_zero(a16[7:0])) {
        advance (10)
        A := M[2806];
        B := 16;
        C := a16[7:0];
        D := 21;
        E := 43;
        H := 28;
        L := 07;
        SPH := a15[15:8];
        SPL := a15[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := false;
        jump (147E);
      } else {
        advance (10)
        #1486
        #instruction: POP  HL
        let:16 a20 = (1 + a15) in
        let:16 a21 = (1 + a20) in
        advance (10)
        #1487
        #instruction: LD   BC,0020
        advance (10)
        #148A
        #instruction: ADD  HL,BC
        let:17 a22 = add17(0020,(M[a20],M[a15])) in
        advance (10)
        #148B
        #instruction: POP  BC
        let:16 a23 = (1 + a21) in
        let:16 a24 = (1 + a23) in
        advance (10)
        #148C
        #instruction: DEC  B
        let:16 a25 = addWithCarry(!true,M[a23],~00) in
        let:8 a26 = (M[a23] & 0F) in
        let:8 a27 = (~00 & 0F) in
        let:16 a28 = addWithCarry(!true,a26,a27) in
        advance (5)
        #148D
        #instruction: JP   NZ,147C
        if (!is_zero(a25[7:0])) {
          advance (10)
          A := M[2806];
          B := a25[7:0];
          C := M[a21];
          D := 21;
          E := 43;
          H := a22[15:0][15:8];
          L := a22[15:0][7:0];
          SPH := a24[15:8];
          SPL := a24[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := a22[16];
          jump (147C);
        } else {
          advance (10)
          #1490
          #instruction: RET
          let:16 a29 = (1 + a24) in
          let:16 a30 = (1 + a29) in
          advance (10)
          A := M[2806];
          B := a25[7:0];
          C := M[a21];
          D := 21;
          E := 43;
          H := a22[15:0][15:8];
          L := a22[15:0][7:0];
          SPH := a30[15:8];
          SPL := a30[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := a22[16];
          jump ((M[a29],M[a24]));
        }
      }
    } else {
      advance (10)
      #0232
      #instruction: CALL 1A69
      let:16 a31 = (-1 + a7) in
      M[a31] := 02;
      let:16 a32 = (-1 + a31) in
      M[a32] := 35;
      #return-to: 0235
      advance (17)
      #1A69
      #instruction: PUSH BC
      let:16 a33 = (-1 + a32) in
      M[a33] := 16;
      let:16 a34 = (-1 + a33) in
      M[a34] := 02;
      advance (11)
      #1A6A
      #instruction: PUSH HL
      let:16 a35 = (-1 + a34) in
      M[a35] := 28;
      let:16 a36 = (-1 + a35) in
      M[a36] := 06;
      advance (11)
      #1A6B
      #instruction: LD   A,(DE)
      advance (7)
      #1A6C
      #instruction: OR   (HL)
      let:8 a37 = (M[2806] | M[2142]) in
      advance (7)
      #1A6D
      #instruction: LD   (HL),A
      M[2806] := a37;
      advance (7)
      #1A6E
      #instruction: INC  DE
      advance (5)
      #1A6F
      #instruction: INC  HL
      advance (5)
      #1A70
      #instruction: DEC  C
      let:16 a38 = addWithCarry(!true,02,~00) in
      let:8 a39 = (02 & 0F) in
      let:8 a40 = (~00 & 0F) in
      let:16 a41 = addWithCarry(!true,a39,a40) in
      advance (5)
      #1A71
      #instruction: JP   NZ,1A6B
      if (!is_zero(a38[7:0])) {
        advance (10)
        A := a37;
        B := 16;
        C := a38[7:0];
        D := 21;
        E := 43;
        H := 28;
        L := 07;
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagS := a38[7:0][7];
        FlagZ := is_zero(a38[7:0]);
        FlagA := a41[7:0][4];
        FlagP := parity(a38[7:0]);
        FlagCY := false;
        jump (1A6B);
      } else {
        advance (10)
        #1A74
        #instruction: POP  HL
        let:16 a42 = (1 + a36) in
        let:16 a43 = (1 + a42) in
        advance (10)
        #1A75
        #instruction: LD   BC,0020
        advance (10)
        #1A78
        #instruction: ADD  HL,BC
        let:17 a44 = add17(0020,(M[a42],M[a36])) in
        advance (10)
        #1A79
        #instruction: POP  BC
        let:16 a45 = (1 + a43) in
        let:16 a46 = (1 + a45) in
        advance (10)
        #1A7A
        #instruction: DEC  B
        let:16 a47 = addWithCarry(!true,M[a45],~00) in
        let:8 a48 = (M[a45] & 0F) in
        let:8 a49 = (~00 & 0F) in
        let:16 a50 = addWithCarry(!true,a48,a49) in
        advance (5)
        #1A7B
        #instruction: JP   NZ,1A69
        if (!is_zero(a47[7:0])) {
          advance (10)
          A := a37;
          B := a47[7:0];
          C := M[a43];
          D := 21;
          E := 43;
          H := a44[15:0][15:8];
          L := a44[15:0][7:0];
          SPH := a46[15:8];
          SPL := a46[7:0];
          FlagS := a47[7:0][7];
          FlagZ := is_zero(a47[7:0]);
          FlagA := a50[7:0][4];
          FlagP := parity(a47[7:0]);
          FlagCY := a44[16];
          jump (1A69);
        } else {
          advance (10)
          #1A7E
          #instruction: RET
          let:16 a51 = (1 + a46) in
          let:16 a52 = (1 + a51) in
          advance (10)
          A := a37;
          B := a47[7:0];
          C := M[a43];
          D := 21;
          E := 43;
          H := a44[15:0][15:8];
          L := a44[15:0][7:0];
          SPH := a52[15:8];
          SPL := a52[7:0];
          FlagS := a47[7:0][7];
          FlagZ := is_zero(a47[7:0]);
          FlagA := a50[7:0][4];
          FlagP := parity(a47[7:0]);
          FlagCY := a44[16];
          jump ((M[a51],M[a46]));
        }
      }
    }

0B69:

    #instruction: LD   A,01
    advance (7)
    #0B6B
    #instruction: LD   (20C1),A
    M[20C1] := 01;
    advance (13)
    #0B6E
    #instruction: CALL 01CF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 71;
    #return-to: 0B71
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := E0;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a5 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a6 = (1 + a4) in
    let:16 a7 = (1 + a6) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a8 = addWithCarry(!true,M[a6],~00) in
    let:8 a9 = (M[a6] & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a12 = (1 + a7) in
      let:16 a13 = (1 + a12) in
      advance (10)
      A := 01;
      B := a8[7:0];
      C := M[a4];
      H := a5[15:0][15:8];
      L := a5[15:0][7:0];
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[16];
      jump ((M[a12],M[a7]));
    }

0B71:

    #instruction: CALL 1618
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 0B74
    advance (17)
    #1618
    #instruction: LD   A,(2015)
    advance (13)
    #161B
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2015],~FF) in
    let:8 a4 = (M[2015] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #161D
    #instruction: RET  NZ
    if (!is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[2015];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #161E
      #instruction: LD   HL,2010
      advance (10)
      #1621
      #instruction: LD   A,(HL)
      advance (7)
      #1622
      #instruction: INC  HL
      advance (5)
      #1623
      #instruction: LD   B,(HL)
      advance (7)
      #1624
      #instruction: OR   B
      let:8 a9 = (M[2011] | M[2010]) in
      advance (4)
      #1625
      #instruction: RET  NZ
      if (!is_zero(a9)) {
        let:16 a10 = (1 + a2) in
        let:16 a11 = (1 + a10) in
        advance (11)
        A := a9;
        B := M[2011];
        H := 20;
        L := 11;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a9[7];
        FlagZ := is_zero(a9);
        FlagA := false;
        FlagP := parity(a9);
        FlagCY := false;
        jump ((M[a10],M[a2]));
      } else {
        advance (5)
        #1626
        #instruction: LD   A,(2025)
        advance (13)
        #1629
        #instruction: AND  A
        let:8 a12 = (M[2025] & M[2025]) in
        let:8 a13 = (M[2025] | M[2025]) in
        advance (4)
        #162A
        #instruction: RET  NZ
        if (!is_zero(a12)) {
          let:16 a14 = (1 + a2) in
          let:16 a15 = (1 + a14) in
          advance (11)
          A := a12;
          B := M[2011];
          H := 20;
          L := 11;
          SPH := a15[15:8];
          SPL := a15[7:0];
          FlagS := a12[7];
          FlagZ := is_zero(a12);
          FlagA := a13[3];
          FlagP := parity(a12);
          FlagCY := false;
          jump ((M[a14],M[a2]));
        } else {
          advance (5)
          #162B
          #instruction: LD   A,(20EF)
          advance (13)
          #162E
          #instruction: AND  A
          let:8 a16 = (M[20EF] & M[20EF]) in
          let:8 a17 = (M[20EF] | M[20EF]) in
          advance (4)
          #162F
          #instruction: JP   Z,1652
          if (is_zero(a16)) {
            advance (10)
            #1652
            #instruction: LD   HL,2025
            advance (10)
            #1655
            #instruction: LD   (HL),01
            M[2025] := 01;
            advance (10)
            #1657
            #instruction: LD   HL,(20ED)
            advance (16)
            #165A
            #instruction: INC  HL
            let:16 a18 = (1 + (M[20EE],M[20ED])) in
            advance (5)
            #165B
            #instruction: LD   A,L
            advance (5)
            #165C
            #instruction: CP   7E
            let:16 a19 = addWithCarry(!false,a18[7:0],~7E) in
            let:8 a20 = (a18[7:0] & 0F) in
            let:8 a21 = (~7E & 0F) in
            let:16 a22 = addWithCarry(!false,a20,a21) in
            advance (7)
            #165E
            #instruction: JP   CY,1663
            if (!a19[15:8][0]) {
              advance (10)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := a18[7:0];
              M[20EE] := a18[15:8];
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              advance (7)
              #1667
              #instruction: LD   (201D),A
              M[201D] := M[a18];
              advance (13)
              #166A
              #instruction: RET
              let:16 a23 = (1 + a2) in
              let:16 a24 = (1 + a23) in
              advance (10)
              A := M[a18];
              B := M[2011];
              H := a18[15:8];
              L := a18[7:0];
              SPH := a24[15:8];
              SPL := a24[7:0];
              FlagS := a19[7:0][7];
              FlagZ := is_zero(a19[7:0]);
              FlagA := a22[7:0][4];
              FlagP := parity(a19[7:0]);
              FlagCY := !a19[15:8][0];
              jump ((M[a23],M[a2]));
            } else {
              advance (10)
              #1661
              #instruction: LD   L,74
              advance (7)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := 74;
              M[20EE] := a18[15:8];
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              advance (7)
              #1667
              #instruction: LD   (201D),A
              M[201D] := M[(a18[15:8],74)];
              advance (13)
              #166A
              #instruction: RET
              let:16 a25 = (1 + a2) in
              let:16 a26 = (1 + a25) in
              advance (10)
              A := M[(a18[15:8],74)];
              B := M[2011];
              H := a18[15:8];
              L := 74;
              SPH := a26[15:8];
              SPL := a26[7:0];
              FlagS := a19[7:0][7];
              FlagZ := is_zero(a19[7:0]);
              FlagA := a22[7:0][4];
              FlagP := parity(a19[7:0]);
              FlagCY := !a19[15:8][0];
              jump ((M[a25],M[a2]));
            }
          } else {
            advance (10)
            #1632
            #instruction: LD   A,(202D)
            advance (13)
            #1635
            #instruction: AND  A
            let:8 a27 = (M[202D] & M[202D]) in
            let:8 a28 = (M[202D] | M[202D]) in
            advance (4)
            #1636
            #instruction: JP   NZ,1648
            if (!is_zero(a27)) {
              advance (10)
              #1648
              #instruction: CALL 17C0
              let:16 a29 = (-1 + a2) in
              M[a29] := 16;
              let:16 a30 = (-1 + a29) in
              M[a30] := 4B;
              #return-to: 164B
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              advance (13)
              #17C3
              #instruction: RRCA 
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!M[2067][0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:16 a31 = (1 + a30) in
                let:16 a32 = (1 + a31) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a32[15:8];
                SPL := a32[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a31],M[a30]));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:16 a33 = (1 + a30) in
                let:16 a34 = (1 + a33) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a34[15:8];
                SPL := a34[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a33],M[a30]));
              }
            } else {
              advance (10)
              #1639
              #instruction: CALL 17C0
              let:16 a35 = (-1 + a2) in
              M[a35] := 16;
              let:16 a36 = (-1 + a35) in
              M[a36] := 3C;
              #return-to: 163C
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              advance (13)
              #17C3
              #instruction: RRCA 
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!M[2067][0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:16 a37 = (1 + a36) in
                let:16 a38 = (1 + a37) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a38[15:8];
                SPL := a38[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a37],M[a36]));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:16 a39 = (1 + a36) in
                let:16 a40 = (1 + a39) in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := M[2011];
                H := 20;
                L := 11;
                SPH := a40[15:8];
                SPL := a40[7:0];
                FlagS := a27[7];
                FlagZ := is_zero(a27);
                FlagA := a28[3];
                FlagP := parity(a27);
                FlagCY := M[2067][0];
                jump ((M[a39],M[a36]));
              }
            }
          }
        }
      }
    }

0B74:

    #instruction: CALL 0BF1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 77;
    #return-to: 0B77
    advance (17)
    #0BF1
    #instruction: CALL 190A
    let:16 a3 = (-1 + a2) in
    M[a3] := 0B;
    let:16 a4 = (-1 + a3) in
    M[a4] := F4;
    #return-to: 0BF4
    advance (17)
    #190A
    #instruction: CALL 14D8
    let:16 a5 = (-1 + a4) in
    M[a5] := 19;
    let:16 a6 = (-1 + a5) in
    M[a6] := 0D;
    #return-to: 190D
    advance (17)
    #14D8
    #instruction: LD   A,(2025)
    advance (13)
    #14DB
    #instruction: CP   05
    let:16 a7 = addWithCarry(!false,M[2025],~05) in
    let:8 a8 = (M[2025] & 0F) in
    let:8 a9 = (~05 & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #14DD
    #instruction: RET  Z
    if (is_zero(a7[7:0])) {
      let:16 a11 = (1 + a6) in
      let:16 a12 = (1 + a11) in
      advance (11)
      A := M[2025];
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := !a7[15:8][0];
      jump ((M[a11],M[a6]));
    } else {
      advance (5)
      #14DE
      #instruction: CP   02
      let:16 a13 = addWithCarry(!false,M[2025],~02) in
      let:8 a14 = (M[2025] & 0F) in
      let:8 a15 = (~02 & 0F) in
      let:16 a16 = addWithCarry(!false,a14,a15) in
      advance (7)
      #14E0
      #instruction: RET  NZ
      if (!is_zero(a13[7:0])) {
        let:16 a17 = (1 + a6) in
        let:16 a18 = (1 + a17) in
        advance (11)
        A := M[2025];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := !a13[15:8][0];
        jump ((M[a17],M[a6]));
      } else {
        advance (5)
        #14E1
        #instruction: LD   A,(2029)
        advance (13)
        #14E4
        #instruction: CP   D8
        let:16 a19 = addWithCarry(!false,M[2029],~D8) in
        let:8 a20 = (M[2029] & 0F) in
        let:8 a21 = (~D8 & 0F) in
        let:16 a22 = addWithCarry(!false,a20,a21) in
        advance (7)
        #14E6
        #instruction: LD   B,A
        advance (5)
        #14E7
        #instruction: JP   NC,1530
        if (!!a19[15:8][0]) {
          advance (10)
          #1530
          #instruction: LD   A,03
          advance (7)
          #1532
          #instruction: LD   (2025),A
          M[2025] := 03;
          advance (13)
          #1535
          #instruction: JP   154A
          advance (10)
          #154A
          #instruction: XOR  A
          let:8 a23 = (03 ^ 03) in
          advance (4)
          #154B
          #instruction: LD   (2002),A
          M[2002] := a23;
          advance (13)
          #154E
          #instruction: LD   B,F7
          advance (7)
          #1550
          #instruction: JP   19DC
          advance (10)
          #19DC
          #instruction: LD   A,(2094)
          advance (13)
          #19DF
          #instruction: AND  B
          let:8 a24 = (F7 & M[2094]) in
          let:8 a25 = (F7 | M[2094]) in
          advance (4)
          #19E0
          #instruction: LD   (2094),A
          M[2094] := a24;
          advance (13)
          #19E3
          #instruction: OUT  03
          sound_control(Ufo,a24[0]);
          sound_control(Shot,a24[1]);
          sound_control(PlayerDie,a24[2]);
          sound_control(InvaderDie,a24[3]);
          sound_control(ExtraLife,a24[4]);
          advance (10)
          #19E5
          #instruction: RET
          let:16 a26 = (1 + a6) in
          let:16 a27 = (1 + a26) in
          advance (10)
          A := a24;
          B := F7;
          SPH := a27[15:8];
          SPL := a27[7:0];
          FlagS := a24[7];
          FlagZ := is_zero(a24);
          FlagA := a25[3];
          FlagP := parity(a24);
          FlagCY := false;
          jump ((M[a26],M[a6]));
        } else {
          advance (10)
          #14EA
          #instruction: LD   A,(2002)
          advance (13)
          #14ED
          #instruction: AND  A
          let:8 a28 = (M[2002] & M[2002]) in
          let:8 a29 = (M[2002] | M[2002]) in
          advance (4)
          #14EE
          #instruction: RET  Z
          if (is_zero(a28)) {
            let:16 a30 = (1 + a6) in
            let:16 a31 = (1 + a30) in
            advance (11)
            A := a28;
            B := M[2029];
            SPH := a31[15:8];
            SPL := a31[7:0];
            FlagS := a28[7];
            FlagZ := is_zero(a28);
            FlagA := a29[3];
            FlagP := parity(a28);
            FlagCY := false;
            jump ((M[a30],M[a6]));
          } else {
            advance (5)
            #14EF
            #instruction: LD   A,B
            advance (5)
            #14F0
            #instruction: CP   CE
            let:16 a32 = addWithCarry(!false,M[2029],~CE) in
            let:8 a33 = (M[2029] & 0F) in
            let:8 a34 = (~CE & 0F) in
            let:16 a35 = addWithCarry(!false,a33,a34) in
            advance (7)
            #14F2
            #instruction: JP   NC,1579
            if (!!a32[15:8][0]) {
              advance (10)
              #1579
              #instruction: LD   A,01
              advance (7)
              #157B
              #instruction: LD   (2085),A
              M[2085] := 01;
              advance (13)
              #157E
              #instruction: JP   1545
              advance (10)
              A := 01;
              B := M[2029];
              SPH := a6[15:8];
              SPL := a6[7:0];
              FlagS := a32[7:0][7];
              FlagZ := is_zero(a32[7:0]);
              FlagA := a35[7:0][4];
              FlagP := parity(a32[7:0]);
              FlagCY := !a32[15:8][0];
              jump (1545);
            } else {
              advance (10)
              #14F5
              #instruction: ADD  06
              let:16 a36 = addWithCarry(false,06,M[2029]) in
              let:8 a37 = (06 & 0F) in
              let:8 a38 = (M[2029] & 0F) in
              let:16 a39 = addWithCarry(false,a37,a38) in
              advance (7)
              #14F7
              #instruction: LD   B,A
              advance (5)
              #14F8
              #instruction: LD   A,(2009)
              advance (13)
              #14FB
              #instruction: CP   90
              let:16 a40 = addWithCarry(!false,M[2009],~90) in
              let:8 a41 = (M[2009] & 0F) in
              let:8 a42 = (~90 & 0F) in
              let:16 a43 = addWithCarry(!false,a41,a42) in
              advance (7)
              #14FD
              #instruction: JP   NC,1504
              if (!!a40[15:8][0]) {
                advance (10)
                #1504
                #instruction: LD   L,B
                advance (5)
                #1505
                #instruction: CALL 1562
                let:16 a44 = (-1 + a6) in
                M[a44] := 15;
                let:16 a45 = (-1 + a44) in
                M[a45] := 08;
                #return-to: 1508
                advance (17)
                #1562
                #instruction: LD   A,(2009)
                advance (13)
                #1565
                #instruction: LD   H,L
                advance (5)
                #1566
                #instruction: CALL 1554
                let:16 a46 = (-1 + a45) in
                M[a46] := 15;
                let:16 a47 = (-1 + a46) in
                M[a47] := 69;
                #return-to: 1569
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:16 a48 = addWithCarry(!false,M[2009],~a36[7:0]) in
                let:8 a49 = (M[2009] & 0F) in
                let:8 a50 = (~a36[7:0] & 0F) in
                let:16 a51 = addWithCarry(!false,a49,a50) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a48[15:8][0]) {
                  let:16 a52 = (-1 + a47) in
                  M[a52] := 15;
                  let:16 a53 = (-1 + a52) in
                  M[a53] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a54 = addWithCarry(true,00,00) in
                  let:8 a55 = (00 & 0F) in
                  let:8 a56 = (00 & 0F) in
                  let:16 a57 = addWithCarry(true,a55,a56) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:16 a58 = addWithCarry(false,10,M[2009]) in
                  let:8 a59 = (10 & 0F) in
                  let:8 a60 = (M[2009] & 0F) in
                  let:16 a61 = addWithCarry(false,a59,a60) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a58[7:0][7]) {
                    advance (10)
                    A := a58[7:0];
                    B := a36[7:0];
                    C := a54[7:0];
                    H := a36[7:0];
                    L := a36[7:0];
                    SPH := a53[15:8];
                    SPL := a53[7:0];
                    FlagS := a58[7:0][7];
                    FlagZ := is_zero(a58[7:0]);
                    FlagA := a61[7:0][4];
                    FlagP := parity(a58[7:0]);
                    FlagCY := a58[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:16 a62 = (1 + a53) in
                    let:16 a63 = (1 + a62) in
                    advance (10)
                    A := a58[7:0];
                    B := a36[7:0];
                    C := a54[7:0];
                    H := a36[7:0];
                    L := a36[7:0];
                    SPH := a63[15:8];
                    SPL := a63[7:0];
                    FlagS := a58[7:0][7];
                    FlagZ := is_zero(a58[7:0]);
                    FlagA := a61[7:0][4];
                    FlagP := parity(a58[7:0]);
                    FlagCY := a58[15:8][0];
                    jump ((M[a62],M[a53]));
                  }
                } else {
                  advance (11)
                  A := M[2009];
                  B := a36[7:0];
                  C := 00;
                  H := a36[7:0];
                  L := a36[7:0];
                  SPH := a47[15:8];
                  SPL := a47[7:0];
                  FlagS := a48[7:0][7];
                  FlagZ := is_zero(a48[7:0]);
                  FlagA := a51[7:0][4];
                  FlagP := parity(a48[7:0]);
                  FlagCY := !a48[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #1500
                #instruction: CP   B
                let:16 a64 = addWithCarry(!false,M[2009],~a36[7:0]) in
                let:8 a65 = (M[2009] & 0F) in
                let:8 a66 = (~a36[7:0] & 0F) in
                let:16 a67 = addWithCarry(!false,a65,a66) in
                advance (4)
                #1501
                #instruction: JP   NC,1530
                if (!!a64[15:8][0]) {
                  advance (10)
                  #1530
                  #instruction: LD   A,03
                  advance (7)
                  #1532
                  #instruction: LD   (2025),A
                  M[2025] := 03;
                  advance (13)
                  #1535
                  #instruction: JP   154A
                  advance (10)
                  #154A
                  #instruction: XOR  A
                  let:8 a68 = (03 ^ 03) in
                  advance (4)
                  #154B
                  #instruction: LD   (2002),A
                  M[2002] := a68;
                  advance (13)
                  #154E
                  #instruction: LD   B,F7
                  advance (7)
                  #1550
                  #instruction: JP   19DC
                  advance (10)
                  #19DC
                  #instruction: LD   A,(2094)
                  advance (13)
                  #19DF
                  #instruction: AND  B
                  let:8 a69 = (F7 & M[2094]) in
                  let:8 a70 = (F7 | M[2094]) in
                  advance (4)
                  #19E0
                  #instruction: LD   (2094),A
                  M[2094] := a69;
                  advance (13)
                  #19E3
                  #instruction: OUT  03
                  sound_control(Ufo,a69[0]);
                  sound_control(Shot,a69[1]);
                  sound_control(PlayerDie,a69[2]);
                  sound_control(InvaderDie,a69[3]);
                  sound_control(ExtraLife,a69[4]);
                  advance (10)
                  #19E5
                  #instruction: RET
                  let:16 a71 = (1 + a6) in
                  let:16 a72 = (1 + a71) in
                  advance (10)
                  A := a69;
                  B := F7;
                  SPH := a72[15:8];
                  SPL := a72[7:0];
                  FlagS := a69[7];
                  FlagZ := is_zero(a69);
                  FlagA := a70[3];
                  FlagP := parity(a69);
                  FlagCY := false;
                  jump ((M[a71],M[a6]));
                } else {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:16 a73 = (-1 + a6) in
                  M[a73] := 15;
                  let:16 a74 = (-1 + a73) in
                  M[a74] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:16 a75 = (-1 + a74) in
                  M[a75] := 15;
                  let:16 a76 = (-1 + a75) in
                  M[a76] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a77 = addWithCarry(!false,M[2009],~a36[7:0]) in
                  let:8 a78 = (M[2009] & 0F) in
                  let:8 a79 = (~a36[7:0] & 0F) in
                  let:16 a80 = addWithCarry(!false,a78,a79) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a77[15:8][0]) {
                    let:16 a81 = (-1 + a76) in
                    M[a81] := 15;
                    let:16 a82 = (-1 + a81) in
                    M[a82] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a83 = addWithCarry(true,00,00) in
                    let:8 a84 = (00 & 0F) in
                    let:8 a85 = (00 & 0F) in
                    let:16 a86 = addWithCarry(true,a84,a85) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a87 = addWithCarry(false,10,M[2009]) in
                    let:8 a88 = (10 & 0F) in
                    let:8 a89 = (M[2009] & 0F) in
                    let:16 a90 = addWithCarry(false,a88,a89) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a87[7:0][7]) {
                      advance (10)
                      A := a87[7:0];
                      B := a36[7:0];
                      C := a83[7:0];
                      H := a36[7:0];
                      L := a36[7:0];
                      SPH := a82[15:8];
                      SPL := a82[7:0];
                      FlagS := a87[7:0][7];
                      FlagZ := is_zero(a87[7:0]);
                      FlagA := a90[7:0][4];
                      FlagP := parity(a87[7:0]);
                      FlagCY := a87[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a91 = (1 + a82) in
                      let:16 a92 = (1 + a91) in
                      advance (10)
                      A := a87[7:0];
                      B := a36[7:0];
                      C := a83[7:0];
                      H := a36[7:0];
                      L := a36[7:0];
                      SPH := a92[15:8];
                      SPL := a92[7:0];
                      FlagS := a87[7:0][7];
                      FlagZ := is_zero(a87[7:0]);
                      FlagA := a90[7:0][4];
                      FlagP := parity(a87[7:0]);
                      FlagCY := a87[15:8][0];
                      jump ((M[a91],M[a82]));
                    }
                  } else {
                    advance (11)
                    A := M[2009];
                    B := a36[7:0];
                    C := 00;
                    H := a36[7:0];
                    L := a36[7:0];
                    SPH := a76[15:8];
                    SPL := a76[7:0];
                    FlagS := a77[7:0][7];
                    FlagZ := is_zero(a77[7:0]);
                    FlagA := a80[7:0][4];
                    FlagP := parity(a77[7:0]);
                    FlagCY := !a77[15:8][0];
                    jump (155A);
                  }
                }
              }
            }
          }
        }
      }
    }

0B77:

    #instruction: OUT  06
    advance (10)
    #0B79
    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7C;
    #return-to: 0B7C
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2015],~FF) in
    let:8 a4 = (M[2015] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0A5E
    #instruction: RET
    let:16 a7 = (1 + a2) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2015];
    SPH := a8[15:8];
    SPL := a8[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((M[a7],M[a2]));

0B7C:

    #instruction: JP   Z,0B71
    if (FlagZ) {
      advance (10)
      jump (0B71);
    } else {
      advance (10)
      #0B7F
      #instruction: XOR  A
      let:8 a1 = (A ^ A) in
      advance (4)
      #0B80
      #instruction: LD   (2025),A
      M[2025] := a1;
      advance (13)
      #0B83
      #instruction: CALL 0A59
      let:16 a2 = (-1 + (SPH,SPL)) in
      M[a2] := 0B;
      let:16 a3 = (-1 + a2) in
      M[a3] := 86;
      #return-to: 0B86
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a4 = addWithCarry(!false,M[2015],~FF) in
      let:8 a5 = (M[2015] & 0F) in
      let:8 a6 = (~FF & 0F) in
      let:16 a7 = addWithCarry(!false,a5,a6) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a8 = (1 + a3) in
      let:16 a9 = (1 + a8) in
      advance (10)
      A := M[2015];
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagS := a4[7:0][7];
      FlagZ := is_zero(a4[7:0]);
      FlagA := a7[7:0][4];
      FlagP := parity(a4[7:0]);
      FlagCY := !a4[15:8][0];
      jump ((M[a8],M[a3]));
    }

0B86:

    #instruction: JP   NZ,0B83
    if (!FlagZ) {
      advance (10)
      #0B83
      #instruction: CALL 0A59
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := 86;
      #return-to: 0B86
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:16 a3 = addWithCarry(!false,M[2015],~FF) in
      let:8 a4 = (M[2015] & 0F) in
      let:8 a5 = (~FF & 0F) in
      let:16 a6 = addWithCarry(!false,a4,a5) in
      advance (7)
      #0A5E
      #instruction: RET
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (10)
      A := M[2015];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((M[a7],M[a2]));
    } else {
      advance (10)
      #0B89
      #instruction: XOR  A
      let:8 a9 = (A ^ A) in
      advance (4)
      #0B8A
      #instruction: LD   (20C1),A
      M[20C1] := a9;
      advance (13)
      #0B8D
      #instruction: CALL 0AB1
      let:16 a10 = (-1 + (SPH,SPL)) in
      M[a10] := 0B;
      let:16 a11 = (-1 + a10) in
      M[a11] := 90;
      #return-to: 0B90
      advance (17)
      #0AB1
      #instruction: LD   A,40
      advance (7)
      #0AB3
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 40;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a12 = (M[20C0] & M[20C0]) in
      let:8 a13 = (M[20C0] | M[20C0]) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a12)) {
        advance (10)
        A := a12;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a12[7];
        FlagZ := is_zero(a12);
        FlagA := a13[3];
        FlagP := parity(a12);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:16 a14 = (1 + a11) in
        let:16 a15 = (1 + a14) in
        advance (10)
        A := a12;
        SPH := a15[15:8];
        SPL := a15[7:0];
        FlagS := a12[7];
        FlagZ := is_zero(a12);
        FlagA := a13[3];
        FlagP := parity(a12);
        FlagCY := false;
        jump ((M[a14],M[a11]));
      }
    }

0B90:

    #instruction: CALL 1988
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 93;
    #return-to: 0B93
    advance (17)
    #1988
    #instruction: JP   09D6
    advance (10)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a3 = (1F & 03) in
    let:8 a4 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a5 = addWithCarry(!false,a3,~1C) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~1C & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a5[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a9 = addWithCarry(!false,24,~40) in
      let:8 a10 = (24 & 0F) in
      let:8 a11 = (~40 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a9[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a15 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a16 = addWithCarry(!false,a15[15:0][15:8],~40) in
      let:8 a17 = (a15[15:0][15:8] & 0F) in
      let:8 a18 = (~40 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a16[15:8][0]) {
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a20 = (1 + a2) in
        let:16 a21 = (1 + a20) in
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((M[a20],M[a2]));
      }
    }

0B93:

    #instruction: LD   C,0C
    advance (7)
    #0B95
    #instruction: LD   HL,2C11
    advance (10)
    #0B98
    #instruction: LD   DE,1F90
    advance (10)
    #0B9B
    #instruction: CALL 08F3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 9E;
    #return-to: 0B9E
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1F;
    let:16 a4 = (-1 + a3) in
    M[a4] := 90;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 08;
    let:16 a6 = (-1 + a5) in
    M[a6] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 2C;
    let:16 a8 = (-1 + a7) in
    M[a8] := 11;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(0008,0008) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 0C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

0B9E:

    #instruction: LD   A,(20EC)
    advance (13)
    #0BA1
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,M[20EC],~00) in
    let:8 a2 = (M[20EC] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #0BA3
    #instruction: JP   NZ,0BAE
    if (!is_zero(a1[7:0])) {
      advance (10)
      A := M[20EC];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump (0BAE);
    } else {
      advance (10)
      #0BA6
      #instruction: LD   HL,3311
      advance (10)
      #0BA9
      #instruction: LD   A,02
      advance (7)
      #0BAB
      #instruction: CALL 08FF
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 0B;
      let:16 a6 = (-1 + a5) in
      M[a6] := AE;
      #return-to: 0BAE
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a7 = (-1 + a6) in
      M[a7] := 33;
      let:16 a8 = (-1 + a7) in
      M[a8] := 11;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a9 = add17(0002,0002) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a10 = add17(a9[15:0],a9[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a11 = add17(a10[15:0],a10[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a12 = add17(1E00,a11[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a13 = (1 + a8) in
      let:16 a14 = (1 + a13) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a15 = (-1 + a14) in
      M[a15] := 08;
      let:16 a16 = (-1 + a15) in
      M[a16] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a13],M[a8])] := M[a12[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a17 = (1 + a12[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a18 = add17(0020,(M[a13],M[a8])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a19 = (1 + a16) in
      let:16 a20 = (1 + a19) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a21 = addWithCarry(!true,M[a19],~00) in
      let:8 a22 = (M[a19] & 0F) in
      let:8 a23 = (~00 & 0F) in
      let:16 a24 = addWithCarry(!true,a22,a23) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a21[7:0])) {
        advance (10)
        A := M[a12[15:0]];
        B := a21[7:0];
        C := M[a16];
        D := a17[15:8];
        E := a17[7:0];
        H := a18[15:0][15:8];
        L := a18[15:0][7:0];
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := a18[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a25 = (1 + a20) in
        let:16 a26 = (1 + a25) in
        advance (10)
        A := M[a12[15:0]];
        B := a21[7:0];
        C := M[a16];
        D := a17[15:8];
        E := a17[7:0];
        H := a18[15:0][15:8];
        L := a18[15:0][7:0];
        SPH := a26[15:8];
        SPL := a26[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := a18[16];
        jump ((M[a25],M[a20]));
      }
    }

0BAE:

    #instruction: LD   BC,1F9C
    advance (10)
    #0BB1
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := B4;
    #return-to: 0BB4
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,0D,~FF) in
    let:8 a4 = (0D & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := 0D;
      B := 1F;
      C := 9C;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := true;
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a9 = (1F & 1F) in
      let:8 a10 = (1F | 1F) in
      advance (4)
      #1867
      #instruction: RET
      let:16 a11 = (1 + a2) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := a9;
      B := 1F;
      C := A0;
      D := 1F;
      E := 50;
      H := 2A;
      L := 0D;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := a10[3];
      FlagP := parity(a9);
      FlagCY := false;
      jump ((M[a11],M[a2]));
    }

0BB4:

    #instruction: CALL 184C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := B7;
    #return-to: 0BB7
    advance (17)
    #184C
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #184D
    #instruction: LD   A,(206C)
    advance (13)
    #1850
    #instruction: LD   C,A
    advance (5)
    #1851
    #instruction: CALL 0A93
    let:16 a5 = (-1 + a4) in
    M[a5] := 18;
    let:16 a6 = (-1 + a5) in
    M[a6] := 54;
    #return-to: 1854
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:16 a7 = (-1 + a6) in
    M[a7] := D;
    let:16 a8 = (-1 + a7) in
    M[a8] := E;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:16 a9 = (-1 + a8) in
    M[a9] := 0A;
    let:16 a10 = (-1 + a9) in
    M[a10] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a11 = (-1 + a10) in
    M[a11] := H;
    let:16 a12 = (-1 + a11) in
    M[a12] := L;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a13 = add17((00,M[(D,E)]),(00,M[(D,E)])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a14 = add17(a13[15:0],a13[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a15 = add17(a14[15:0],a14[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a16 = add17(1E00,a15[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a17 = (1 + a12) in
    let:16 a18 = (1 + a17) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a19 = (-1 + a18) in
    M[a19] := 08;
    let:16 a20 = (-1 + a19) in
    M[a20] := M[206C];
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a17],M[a12])] := M[a16[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a21 = (1 + a16[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a22 = add17(0020,(M[a17],M[a12])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a23 = (1 + a20) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a25 = addWithCarry(!true,M[a23],~00) in
    let:8 a26 = (M[a23] & 0F) in
    let:8 a27 = (~00 & 0F) in
    let:16 a28 = addWithCarry(!true,a26,a27) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a25[7:0])) {
      advance (10)
      A := M[a16[15:0]];
      B := a25[7:0];
      C := M[a20];
      D := a21[15:8];
      E := a21[7:0];
      H := a22[15:0][15:8];
      L := a22[15:0][7:0];
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      FlagCY := a22[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a29 = (1 + a24) in
      let:16 a30 = (1 + a29) in
      advance (10)
      A := M[a16[15:0]];
      B := a25[7:0];
      C := M[a20];
      D := a21[15:8];
      E := a21[7:0];
      H := a22[15:0][15:8];
      L := a22[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      FlagCY := a22[16];
      jump ((M[a29],M[a24]));
    }

0BB7:

    #instruction: IN   02
    advance (10)
    #0BB9
    #instruction: RLCA 
    advance (4)
    #0BBA
    #instruction: JP   CY,0BC3
    if (updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))[7]) {
      advance (10)
      A := updateBit((updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) << 01),0,updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))[7]);
      FlagCY := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off))[7];
      jump (0BC3);
    } else {
      advance (10)
      #0BBD
      #instruction: LD   BC,1FA0
      advance (10)
      #0BC0
      #instruction: CALL 183A
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 0B;
      let:16 a2 = (-1 + a1) in
      M[a2] := C3;
      #return-to: 0BC3
      advance (17)
      #183A
      #instruction: CALL 1856
      let:16 a3 = (-1 + a2) in
      M[a3] := 18;
      let:16 a4 = (-1 + a3) in
      M[a4] := 3D;
      #return-to: 183D
      advance (17)
      #1856
      #instruction: LD   A,(BC)
      advance (7)
      #1857
      #instruction: CP   FF
      let:16 a5 = addWithCarry(!false,0A,~FF) in
      let:8 a6 = (0A & 0F) in
      let:8 a7 = (~FF & 0F) in
      let:16 a8 = addWithCarry(!false,a6,a7) in
      advance (7)
      #1859
      #instruction: SCF
      advance (4)
      #185A
      #instruction: RET  Z
      if (is_zero(a5[7:0])) {
        let:16 a9 = (1 + a4) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := 0A;
        B := 1F;
        C := A0;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := true;
        jump ((M[a9],M[a4]));
      } else {
        advance (5)
        #185B
        #instruction: LD   L,A
        advance (5)
        #185C
        #instruction: INC  BC
        advance (5)
        #185D
        #instruction: LD   A,(BC)
        advance (7)
        #185E
        #instruction: LD   H,A
        advance (5)
        #185F
        #instruction: INC  BC
        advance (5)
        #1860
        #instruction: LD   A,(BC)
        advance (7)
        #1861
        #instruction: LD   E,A
        advance (5)
        #1862
        #instruction: INC  BC
        advance (5)
        #1863
        #instruction: LD   A,(BC)
        advance (7)
        #1864
        #instruction: LD   D,A
        advance (5)
        #1865
        #instruction: INC  BC
        advance (5)
        #1866
        #instruction: AND  A
        let:8 a11 = (1F & 1F) in
        let:8 a12 = (1F | 1F) in
        advance (4)
        #1867
        #instruction: RET
        let:16 a13 = (1 + a4) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := a11;
        B := 1F;
        C := A4;
        D := 1F;
        E := 62;
        H := 2A;
        L := 0A;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump ((M[a13],M[a4]));
      }
    }

0BC3:

    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C6;
    #return-to: 0BC6
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

0BC6:

    #instruction: LD   A,(20EC)
    advance (13)
    #0BC9
    #instruction: CP   00
    let:16 a1 = addWithCarry(!false,M[20EC],~00) in
    let:8 a2 = (M[20EC] & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #0BCB
    #instruction: JP   NZ,0BDA
    if (!is_zero(a1[7:0])) {
      advance (10)
      A := M[20EC];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump (0BDA);
    } else {
      advance (10)
      #0BCE
      #instruction: LD   DE,1FD5
      advance (10)
      #0BD1
      #instruction: CALL 0AE2
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 0B;
      let:16 a6 = (-1 + a5) in
      M[a6] := D4;
      #return-to: 0BD4
      advance (17)
      #0AE2
      #instruction: LD   HL,20C2
      advance (10)
      #0AE5
      #instruction: LD   B,0C
      advance (7)
      #0AE7
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[20C2] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a7 = addWithCarry(!true,0C,~00) in
      let:8 a8 = (0C & 0F) in
      let:8 a9 = (~00 & 0F) in
      let:16 a10 = addWithCarry(!true,a8,a9) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a7[7:0])) {
        advance (10)
        A := 00;
        B := a7[7:0];
        D := 1F;
        E := D6;
        H := 20;
        L := C3;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := !a1[15:8][0];
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:16 a11 = (1 + a6) in
        let:16 a12 = (1 + a11) in
        advance (10)
        A := 00;
        B := a7[7:0];
        D := 1F;
        E := D6;
        H := 20;
        L := C3;
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := !a1[15:8][0];
        jump ((M[a11],M[a6]));
      }
    }

0BD4:

    #instruction: CALL 0A80
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := D7;
    #return-to: 0BD7
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a3 = (M[20CB] & M[20CB]) in
    let:8 a4 = (M[20CB] | M[20CB]) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a5 = (a3 ^ a3) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      M[20C1] := a5;
      advance (13)
      #0A92
      #instruction: RET
      let:16 a6 = (1 + a2) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a5;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := false;
      FlagP := parity(a5);
      FlagCY := false;
      jump ((M[a6],M[a2]));
    }

0BD7:

    #instruction: CALL 189E
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 0BDA
    advance (17)
    #189E
    #instruction: LD   HL,2050
    advance (10)
    #18A1
    #instruction: LD   DE,1BC0
    advance (10)
    #18A4
    #instruction: LD   B,10
    advance (7)
    #18A6
    #instruction: CALL 1A32
    let:16 a3 = (-1 + a2) in
    M[a3] := 18;
    let:16 a4 = (-1 + a3) in
    M[a4] := A9;
    #return-to: 18A9
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2050] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a5 = addWithCarry(!true,10,~00) in
    let:8 a6 = (10 & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := 00;
      B := a5[7:0];
      D := 1B;
      E := C1;
      H := 20;
      L := 51;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := 00;
      B := a5[7:0];
      D := 1B;
      E := C1;
      H := 20;
      L := 51;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump ((M[a9],M[a4]));
    }

0BDA:

    #instruction: LD   HL,20EC
    advance (10)
    #0BDD
    #instruction: LD   A,(HL)
    advance (7)
    #0BDE
    #instruction: INC  A
    let:16 a1 = addWithCarry(true,M[20EC],00) in
    let:8 a2 = (M[20EC] & 0F) in
    let:8 a3 = (00 & 0F) in
    let:16 a4 = addWithCarry(true,a2,a3) in
    advance (5)
    #0BDF
    #instruction: AND  01
    let:8 a5 = (01 & a1[7:0]) in
    let:8 a6 = (01 | a1[7:0]) in
    advance (7)
    #0BE1
    #instruction: LD   (HL),A
    M[20EC] := a5;
    advance (7)
    #0BE2
    #instruction: CALL 09D6
    let:16 a7 = (-1 + (SPH,SPL)) in
    M[a7] := 0B;
    let:16 a8 = (-1 + a7) in
    M[a8] := E5;
    #return-to: 0BE5
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a9 = (1F & 03) in
    let:8 a10 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a11 = addWithCarry(!false,a9,~1C) in
    let:8 a12 = (a9 & 0F) in
    let:8 a13 = (~1C & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a11[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a15 = addWithCarry(!false,24,~40) in
      let:8 a16 = (24 & 0F) in
      let:8 a17 = (~40 & 0F) in
      let:16 a18 = addWithCarry(!false,a16,a17) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a15[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := !a15[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a19 = (1 + a8) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := !a15[15:8][0];
        jump ((M[a19],M[a8]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a21 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a22 = addWithCarry(!false,a21[15:0][15:8],~40) in
      let:8 a23 = (a21[15:0][15:8] & 0F) in
      let:8 a24 = (~40 & 0F) in
      let:16 a25 = addWithCarry(!false,a23,a24) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a22[15:8][0]) {
        advance (10)
        A := a21[15:0][15:8];
        D := 00;
        E := 06;
        H := a21[15:0][15:8];
        L := a21[15:0][7:0];
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a22[7:0][7];
        FlagZ := is_zero(a22[7:0]);
        FlagA := a25[7:0][4];
        FlagP := parity(a22[7:0]);
        FlagCY := !a22[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a26 = (1 + a8) in
        let:16 a27 = (1 + a26) in
        advance (10)
        A := a21[15:0][15:8];
        D := 00;
        E := 06;
        H := a21[15:0][15:8];
        L := a21[15:0][7:0];
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a22[7:0][7];
        FlagZ := is_zero(a22[7:0]);
        FlagA := a25[7:0][4];
        FlagP := parity(a22[7:0]);
        FlagCY := !a22[15:8][0];
        jump ((M[a26],M[a8]));
      }
    }

0BE5:

    #instruction: JP   18DF
    advance (10)
    jump (18DF);

0BEE:

    #instruction: JP   0B0B
    advance (10)
    #0B0B
    #instruction: CALL 0ACF
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 0B;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0E;
    #return-to: 0B0E
    advance (17)
    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    #0AD2
    #instruction: LD   C,0F
    advance (7)
    #0AD4
    #instruction: JP   0A93
    advance (10)
    #0A93
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := D;
    let:16 a4 = (-1 + a3) in
    M[a4] := E;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 0A;
    let:16 a6 = (-1 + a5) in
    M[a6] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 2B;
    let:16 a8 = (-1 + a7) in
    M[a8] := 14;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17((00,M[(D,E)]),(00,M[(D,E)])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 0F;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

0BF4:

    #instruction: JP   199A
    advance (10)
    #199A
    #instruction: LD   A,(201E)
    advance (13)
    #199D
    #instruction: AND  A
    let:8 a1 = (M[201E] & M[201E]) in
    let:8 a2 = (M[201E] | M[201E]) in
    advance (4)
    #199E
    #instruction: JP   NZ,19AC
    if (!is_zero(a1)) {
      advance (10)
      #19AC
      #instruction: IN   01
      advance (10)
      #19AE
      #instruction: AND  76
      let:8 a3 = (76 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
      let:8 a4 = (76 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
      advance (7)
      #19B0
      #instruction: CP   34
      let:16 a5 = addWithCarry(!false,a3,~34) in
      let:8 a6 = (a3 & 0F) in
      let:8 a7 = (~34 & 0F) in
      let:16 a8 = addWithCarry(!false,a6,a7) in
      advance (7)
      #19B2
      #instruction: RET  NZ
      if (!is_zero(a5[7:0])) {
        let:16 a9 = (1 + (SPH,SPL)) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := a3;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := !a5[15:8][0];
        jump ((M[a9],M[(SPH,SPL)]));
      } else {
        advance (5)
        #19B3
        #instruction: LD   HL,2E1B
        advance (10)
        #19B6
        #instruction: LD   DE,0BF7
        advance (10)
        #19B9
        #instruction: LD   C,09
        advance (7)
        #19BB
        #instruction: JP   08F3
        advance (10)
        #08F3
        #instruction: LD   A,(DE)
        advance (7)
        #08F4
        #instruction: PUSH DE
        let:16 a11 = (-1 + (SPH,SPL)) in
        M[a11] := 0B;
        let:16 a12 = (-1 + a11) in
        M[a12] := F7;
        advance (11)
        #08F5
        #instruction: CALL 08FF
        let:16 a13 = (-1 + a12) in
        M[a13] := 08;
        let:16 a14 = (-1 + a13) in
        M[a14] := F8;
        #return-to: 08F8
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a15 = (-1 + a14) in
        M[a15] := 2E;
        let:16 a16 = (-1 + a15) in
        M[a16] := 1B;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a17 = add17(0013,0013) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a18 = add17(a17[15:0],a17[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a19 = add17(a18[15:0],a18[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a20 = add17(1E00,a19[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a21 = (1 + a16) in
        let:16 a22 = (1 + a21) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a23 = (-1 + a22) in
        M[a23] := 08;
        let:16 a24 = (-1 + a23) in
        M[a24] := 09;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a21],M[a16])] := M[a20[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a25 = (1 + a20[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a26 = add17(0020,(M[a21],M[a16])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a27 = (1 + a24) in
        let:16 a28 = (1 + a27) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a29 = addWithCarry(!true,M[a27],~00) in
        let:8 a30 = (M[a27] & 0F) in
        let:8 a31 = (~00 & 0F) in
        let:16 a32 = addWithCarry(!true,a30,a31) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a29[7:0])) {
          advance (10)
          A := M[a20[15:0]];
          B := a29[7:0];
          C := M[a24];
          D := a25[15:8];
          E := a25[7:0];
          H := a26[15:0][15:8];
          L := a26[15:0][7:0];
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a29[7:0][7];
          FlagZ := is_zero(a29[7:0]);
          FlagA := a32[7:0][4];
          FlagP := parity(a29[7:0]);
          FlagCY := a26[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a33 = (1 + a28) in
          let:16 a34 = (1 + a33) in
          advance (10)
          A := M[a20[15:0]];
          B := a29[7:0];
          C := M[a24];
          D := a25[15:8];
          E := a25[7:0];
          H := a26[15:0][15:8];
          L := a26[15:0][7:0];
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a29[7:0][7];
          FlagZ := is_zero(a29[7:0]);
          FlagA := a32[7:0][4];
          FlagP := parity(a29[7:0]);
          FlagCY := a26[16];
          jump ((M[a33],M[a28]));
        }
      }
    } else {
      advance (10)
      #19A1
      #instruction: IN   01
      advance (10)
      #19A3
      #instruction: AND  76
      let:8 a35 = (76 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
      let:8 a36 = (76 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
      advance (7)
      #19A5
      #instruction: SUB  72
      let:16 a37 = addWithCarry(!false,a35,~72) in
      let:8 a38 = (a35 & 0F) in
      let:8 a39 = (~72 & 0F) in
      let:16 a40 = addWithCarry(!false,a38,a39) in
      advance (7)
      #19A7
      #instruction: RET  NZ
      if (!is_zero(a37[7:0])) {
        let:16 a41 = (1 + (SPH,SPL)) in
        let:16 a42 = (1 + a41) in
        advance (11)
        A := a37[7:0];
        SPH := a42[15:8];
        SPL := a42[7:0];
        FlagS := a37[7:0][7];
        FlagZ := is_zero(a37[7:0]);
        FlagA := a40[7:0][4];
        FlagP := parity(a37[7:0]);
        FlagCY := !a37[15:8][0];
        jump ((M[a41],M[(SPH,SPL)]));
      } else {
        advance (5)
        #19A8
        #instruction: INC  A
        let:16 a43 = addWithCarry(true,a37[7:0],00) in
        let:8 a44 = (a37[7:0] & 0F) in
        let:8 a45 = (00 & 0F) in
        let:16 a46 = addWithCarry(true,a44,a45) in
        advance (5)
        #19A9
        #instruction: LD   (201E),A
        M[201E] := a43[7:0];
        advance (13)
        #19AC
        #instruction: IN   01
        advance (10)
        #19AE
        #instruction: AND  76
        let:8 a47 = (76 & updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
        let:8 a48 = (76 | updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right))) in
        advance (7)
        #19B0
        #instruction: CP   34
        let:16 a49 = addWithCarry(!false,a47,~34) in
        let:8 a50 = (a47 & 0F) in
        let:8 a51 = (~34 & 0F) in
        let:16 a52 = addWithCarry(!false,a50,a51) in
        advance (7)
        #19B2
        #instruction: RET  NZ
        if (!is_zero(a49[7:0])) {
          let:16 a53 = (1 + (SPH,SPL)) in
          let:16 a54 = (1 + a53) in
          advance (11)
          A := a47;
          SPH := a54[15:8];
          SPL := a54[7:0];
          FlagS := a49[7:0][7];
          FlagZ := is_zero(a49[7:0]);
          FlagA := a52[7:0][4];
          FlagP := parity(a49[7:0]);
          FlagCY := !a49[15:8][0];
          jump ((M[a53],M[(SPH,SPL)]));
        } else {
          advance (5)
          #19B3
          #instruction: LD   HL,2E1B
          advance (10)
          #19B6
          #instruction: LD   DE,0BF7
          advance (10)
          #19B9
          #instruction: LD   C,09
          advance (7)
          #19BB
          #instruction: JP   08F3
          advance (10)
          #08F3
          #instruction: LD   A,(DE)
          advance (7)
          #08F4
          #instruction: PUSH DE
          let:16 a55 = (-1 + (SPH,SPL)) in
          M[a55] := 0B;
          let:16 a56 = (-1 + a55) in
          M[a56] := F7;
          advance (11)
          #08F5
          #instruction: CALL 08FF
          let:16 a57 = (-1 + a56) in
          M[a57] := 08;
          let:16 a58 = (-1 + a57) in
          M[a58] := F8;
          #return-to: 08F8
          advance (17)
          #08FF
          #instruction: LD   DE,1E00
          advance (10)
          #0902
          #instruction: PUSH HL
          let:16 a59 = (-1 + a58) in
          M[a59] := 2E;
          let:16 a60 = (-1 + a59) in
          M[a60] := 1B;
          advance (11)
          #0903
          #instruction: LD   H,00
          advance (7)
          #0905
          #instruction: LD   L,A
          advance (5)
          #0906
          #instruction: ADD  HL,HL
          let:17 a61 = add17(0013,0013) in
          advance (10)
          #0907
          #instruction: ADD  HL,HL
          let:17 a62 = add17(a61[15:0],a61[15:0]) in
          advance (10)
          #0908
          #instruction: ADD  HL,HL
          let:17 a63 = add17(a62[15:0],a62[15:0]) in
          advance (10)
          #0909
          #instruction: ADD  HL,DE
          let:17 a64 = add17(1E00,a63[15:0]) in
          advance (10)
          #090A
          #instruction: EX   DE,HL
          advance (4)
          #090B
          #instruction: POP  HL
          let:16 a65 = (1 + a60) in
          let:16 a66 = (1 + a65) in
          advance (10)
          #090C
          #instruction: LD   B,08
          advance (7)
          #090E
          #instruction: OUT  06
          advance (10)
          #0910
          #instruction: JP   1439
          advance (10)
          #1439
          #instruction: PUSH BC
          let:16 a67 = (-1 + a66) in
          M[a67] := 08;
          let:16 a68 = (-1 + a67) in
          M[a68] := 09;
          advance (11)
          #143A
          #instruction: LD   A,(DE)
          advance (7)
          #143B
          #instruction: LD   (HL),A
          M[(M[a65],M[a60])] := M[a64[15:0]];
          advance (7)
          #143C
          #instruction: INC  DE
          let:16 a69 = (1 + a64[15:0]) in
          advance (5)
          #143D
          #instruction: LD   BC,0020
          advance (10)
          #1440
          #instruction: ADD  HL,BC
          let:17 a70 = add17(0020,(M[a65],M[a60])) in
          advance (10)
          #1441
          #instruction: POP  BC
          let:16 a71 = (1 + a68) in
          let:16 a72 = (1 + a71) in
          advance (10)
          #1442
          #instruction: DEC  B
          let:16 a73 = addWithCarry(!true,M[a71],~00) in
          let:8 a74 = (M[a71] & 0F) in
          let:8 a75 = (~00 & 0F) in
          let:16 a76 = addWithCarry(!true,a74,a75) in
          advance (5)
          #1443
          #instruction: JP   NZ,1439
          if (!is_zero(a73[7:0])) {
            advance (10)
            A := M[a64[15:0]];
            B := a73[7:0];
            C := M[a68];
            D := a69[15:8];
            E := a69[7:0];
            H := a70[15:0][15:8];
            L := a70[15:0][7:0];
            SPH := a72[15:8];
            SPL := a72[7:0];
            FlagS := a73[7:0][7];
            FlagZ := is_zero(a73[7:0]);
            FlagA := a76[7:0][4];
            FlagP := parity(a73[7:0]);
            FlagCY := a70[16];
            jump (1439);
          } else {
            advance (10)
            #1446
            #instruction: RET
            let:16 a77 = (1 + a72) in
            let:16 a78 = (1 + a77) in
            advance (10)
            A := M[a64[15:0]];
            B := a73[7:0];
            C := M[a68];
            D := a69[15:8];
            E := a69[7:0];
            H := a70[15:0][15:8];
            L := a70[15:0][7:0];
            SPH := a78[15:8];
            SPL := a78[7:0];
            FlagS := a73[7:0][7];
            FlagZ := is_zero(a73[7:0]);
            FlagA := a76[7:0][4];
            FlagP := parity(a73[7:0]);
            FlagCY := a70[16];
            jump ((M[a77],M[a72]));
          }
        }
      }
    }

1404:

    #instruction: NOP
    advance (4)
    #1405
    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    #1406
    #instruction: PUSH HL
    let:16 a3 = (-1 + a2) in
    M[a3] := H;
    let:16 a4 = (-1 + a3) in
    M[a4] := L;
    advance (11)
    #1407
    #instruction: LD   A,(DE)
    advance (7)
    #1408
    #instruction: OUT  04
    advance (10)
    #140A
    #instruction: IN   03
    let:8 a5 = (Shifter_OFF & 07) in
    let:8 a6 = (~Shifter_OFF & 07) in
    let:8 a7 = ((M[(D,E)] << a5) | ((Shifter_HI >> a6) >> 01)) in
    advance (10)
    #140C
    #instruction: OR   (HL)
    let:8 a8 = (M[(H,L)] | a7) in
    advance (7)
    #140D
    #instruction: LD   (HL),A
    M[(H,L)] := a8;
    advance (7)
    #140E
    #instruction: INC  HL
    let:16 a9 = (1 + (H,L)) in
    advance (5)
    #140F
    #instruction: INC  DE
    let:16 a10 = (1 + (D,E)) in
    advance (5)
    #1410
    #instruction: XOR  A
    let:8 a11 = (a8 ^ a8) in
    advance (4)
    #1411
    #instruction: OUT  04
    advance (10)
    #1413
    #instruction: IN   03
    let:8 a12 = (Shifter_OFF & 07) in
    let:8 a13 = (~Shifter_OFF & 07) in
    let:8 a14 = ((a11 << a12) | ((M[(D,E)] >> a13) >> 01)) in
    advance (10)
    #1415
    #instruction: OR   (HL)
    let:8 a15 = (M[a9] | a14) in
    advance (7)
    #1416
    #instruction: LD   (HL),A
    M[a9] := a15;
    advance (7)
    #1417
    #instruction: POP  HL
    let:16 a16 = (1 + a4) in
    let:16 a17 = (1 + a16) in
    advance (10)
    #1418
    #instruction: LD   BC,0020
    advance (10)
    #141B
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a16],M[a4])) in
    advance (10)
    #141C
    #instruction: POP  BC
    let:16 a19 = (1 + a17) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #141D
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #141E
    #instruction: JP   NZ,1405
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := a15;
      B := a21[7:0];
      C := M[a17];
      D := a10[15:8];
      E := a10[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      Shifter_HI := a11;
      Shifter_LO := M[(D,E)];
      jump (1405);
    } else {
      advance (10)
      #1421
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := a15;
      B := a21[7:0];
      C := M[a17];
      D := a10[15:8];
      E := a10[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      Shifter_HI := a11;
      Shifter_LO := M[(D,E)];
      jump ((M[a25],M[a20]));
    }

1427:

    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    #1428
    #instruction: PUSH HL
    let:16 a3 = (-1 + a2) in
    M[a3] := H;
    let:16 a4 = (-1 + a3) in
    M[a4] := L;
    advance (11)
    #1429
    #instruction: XOR  A
    let:8 a5 = (A ^ A) in
    advance (4)
    #142A
    #instruction: LD   (HL),A
    M[(H,L)] := a5;
    advance (7)
    #142B
    #instruction: INC  HL
    let:16 a6 = (1 + (H,L)) in
    advance (5)
    #142C
    #instruction: LD   (HL),A
    M[a6] := a5;
    advance (7)
    #142D
    #instruction: INC  HL
    let:16 a7 = (1 + a6) in
    advance (5)
    #142E
    #instruction: POP  HL
    let:16 a8 = (1 + a4) in
    let:16 a9 = (1 + a8) in
    advance (10)
    #142F
    #instruction: LD   BC,0020
    advance (10)
    #1432
    #instruction: ADD  HL,BC
    let:17 a10 = add17(0020,(M[a8],M[a4])) in
    advance (10)
    #1433
    #instruction: POP  BC
    let:16 a11 = (1 + a9) in
    let:16 a12 = (1 + a11) in
    advance (10)
    #1434
    #instruction: DEC  B
    let:16 a13 = addWithCarry(!true,M[a11],~00) in
    let:8 a14 = (M[a11] & 0F) in
    let:8 a15 = (~00 & 0F) in
    let:16 a16 = addWithCarry(!true,a14,a15) in
    advance (5)
    #1435
    #instruction: JP   NZ,1427
    if (!is_zero(a13[7:0])) {
      advance (10)
      A := a5;
      B := a13[7:0];
      C := M[a9];
      H := a10[15:0][15:8];
      L := a10[15:0][7:0];
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := a10[16];
      jump (1427);
    } else {
      advance (10)
      #1438
      #instruction: RET
      let:16 a17 = (1 + a12) in
      let:16 a18 = (1 + a17) in
      advance (10)
      A := a5;
      B := a13[7:0];
      C := M[a9];
      H := a10[15:0][15:8];
      L := a10[15:0][7:0];
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := a10[16];
      jump ((M[a17],M[a12]));
    }

1455:

    #instruction: PUSH BC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := B;
    let:16 a2 = (-1 + a1) in
    M[a2] := C;
    advance (11)
    #1456
    #instruction: PUSH HL
    let:16 a3 = (-1 + a2) in
    M[a3] := H;
    let:16 a4 = (-1 + a3) in
    M[a4] := L;
    advance (11)
    #1457
    #instruction: LD   A,(DE)
    advance (7)
    #1458
    #instruction: OUT  04
    advance (10)
    #145A
    #instruction: IN   03
    let:8 a5 = (Shifter_OFF & 07) in
    let:8 a6 = (~Shifter_OFF & 07) in
    let:8 a7 = ((M[(D,E)] << a5) | ((Shifter_HI >> a6) >> 01)) in
    advance (10)
    #145C
    #instruction: CPL
    advance (4)
    #145D
    #instruction: AND  (HL)
    let:8 a8 = (M[(H,L)] & ~a7) in
    let:8 a9 = (M[(H,L)] | ~a7) in
    advance (7)
    #145E
    #instruction: LD   (HL),A
    M[(H,L)] := a8;
    advance (7)
    #145F
    #instruction: INC  HL
    let:16 a10 = (1 + (H,L)) in
    advance (5)
    #1460
    #instruction: INC  DE
    let:16 a11 = (1 + (D,E)) in
    advance (5)
    #1461
    #instruction: XOR  A
    let:8 a12 = (a8 ^ a8) in
    advance (4)
    #1462
    #instruction: OUT  04
    advance (10)
    #1464
    #instruction: IN   03
    let:8 a13 = (Shifter_OFF & 07) in
    let:8 a14 = (~Shifter_OFF & 07) in
    let:8 a15 = ((a12 << a13) | ((M[(D,E)] >> a14) >> 01)) in
    advance (10)
    #1466
    #instruction: CPL
    advance (4)
    #1467
    #instruction: AND  (HL)
    let:8 a16 = (M[a10] & ~a15) in
    let:8 a17 = (M[a10] | ~a15) in
    advance (7)
    #1468
    #instruction: LD   (HL),A
    M[a10] := a16;
    advance (7)
    #1469
    #instruction: POP  HL
    let:16 a18 = (1 + a4) in
    let:16 a19 = (1 + a18) in
    advance (10)
    #146A
    #instruction: LD   BC,0020
    advance (10)
    #146D
    #instruction: ADD  HL,BC
    let:17 a20 = add17(0020,(M[a18],M[a4])) in
    advance (10)
    #146E
    #instruction: POP  BC
    let:16 a21 = (1 + a19) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #146F
    #instruction: DEC  B
    let:16 a23 = addWithCarry(!true,M[a21],~00) in
    let:8 a24 = (M[a21] & 0F) in
    let:8 a25 = (~00 & 0F) in
    let:16 a26 = addWithCarry(!true,a24,a25) in
    advance (5)
    #1470
    #instruction: JP   NZ,1455
    if (!is_zero(a23[7:0])) {
      advance (10)
      A := a16;
      B := a23[7:0];
      C := M[a19];
      D := a11[15:8];
      E := a11[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      Shifter_HI := a12;
      Shifter_LO := M[(D,E)];
      jump (1455);
    } else {
      advance (10)
      #1473
      #instruction: RET
      let:16 a27 = (1 + a22) in
      let:16 a28 = (1 + a27) in
      advance (10)
      A := a16;
      B := a23[7:0];
      C := M[a19];
      D := a11[15:8];
      E := a11[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      Shifter_HI := a12;
      Shifter_LO := M[(D,E)];
      jump ((M[a27],M[a22]));
    }

1494:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #1495
    #instruction: LD   (2061),A
    M[2061] := a1;
    advance (13)
    #1498
    #instruction: PUSH BC
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := B;
    let:16 a3 = (-1 + a2) in
    M[a3] := C;
    advance (11)
    #1499
    #instruction: PUSH HL
    let:16 a4 = (-1 + a3) in
    M[a4] := H;
    let:16 a5 = (-1 + a4) in
    M[a5] := L;
    advance (11)
    #149A
    #instruction: LD   A,(DE)
    advance (7)
    #149B
    #instruction: OUT  04
    advance (10)
    #149D
    #instruction: IN   03
    let:8 a6 = (Shifter_OFF & 07) in
    let:8 a7 = (~Shifter_OFF & 07) in
    let:8 a8 = ((M[(D,E)] << a6) | ((Shifter_HI >> a7) >> 01)) in
    advance (10)
    #149F
    #instruction: PUSH PSW
    let:16 a9 = (-1 + a5) in
    M[a9] := a8;
    let:16 a10 = (-1 + a9) in
    M[a10] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7]),6,is_zero(a1)),4,false),2,parity(a1)),0,false);
    advance (11)
    #14A0
    #instruction: AND  (HL)
    let:8 a11 = (M[(H,L)] & a8) in
    let:8 a12 = (M[(H,L)] | a8) in
    advance (7)
    #14A1
    #instruction: JP   Z,14A9
    if (is_zero(a11)) {
      advance (10)
      #14A9
      #instruction: POP  PSW
      let:16 a13 = (1 + a10) in
      let:16 a14 = (1 + a13) in
      advance (10)
      #14AA
      #instruction: OR   (HL)
      let:8 a15 = (M[(H,L)] | M[a13]) in
      advance (7)
      #14AB
      #instruction: LD   (HL),A
      M[(H,L)] := a15;
      advance (7)
      #14AC
      #instruction: INC  HL
      let:16 a16 = (1 + (H,L)) in
      advance (5)
      #14AD
      #instruction: INC  DE
      let:16 a17 = (1 + (D,E)) in
      advance (5)
      #14AE
      #instruction: XOR  A
      let:8 a18 = (a15 ^ a15) in
      advance (4)
      #14AF
      #instruction: OUT  04
      advance (10)
      #14B1
      #instruction: IN   03
      let:8 a19 = (Shifter_OFF & 07) in
      let:8 a20 = (~Shifter_OFF & 07) in
      let:8 a21 = ((a18 << a19) | ((M[(D,E)] >> a20) >> 01)) in
      advance (10)
      #14B3
      #instruction: PUSH PSW
      let:16 a22 = (-1 + a14) in
      M[a22] := a21;
      let:16 a23 = (-1 + a22) in
      M[a23] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a18[7]),6,is_zero(a18)),4,false),2,parity(a18)),0,false);
      advance (11)
      #14B4
      #instruction: AND  (HL)
      let:8 a24 = (M[a16] & a21) in
      let:8 a25 = (M[a16] | a21) in
      advance (7)
      #14B5
      #instruction: JP   Z,14BD
      if (is_zero(a24)) {
        advance (10)
        #14BD
        #instruction: POP  PSW
        let:16 a26 = (1 + a23) in
        let:16 a27 = (1 + a26) in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a28 = (M[a16] | M[a26]) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        M[a16] := a28;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:16 a29 = (1 + a27) in
        let:16 a30 = (1 + a29) in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:17 a31 = add17(0020,(M[a29],M[a27])) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:16 a32 = (1 + a30) in
        let:16 a33 = (1 + a32) in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:16 a34 = addWithCarry(!true,M[a32],~00) in
        let:8 a35 = (M[a32] & 0F) in
        let:8 a36 = (~00 & 0F) in
        let:16 a37 = addWithCarry(!true,a35,a36) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a34[7:0])) {
          advance (10)
          A := a28;
          B := a34[7:0];
          C := M[a30];
          D := a17[15:8];
          E := a17[7:0];
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a33[15:8];
          SPL := a33[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := a31[16];
          Shifter_HI := a18;
          Shifter_LO := M[(D,E)];
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:16 a38 = (1 + a33) in
          let:16 a39 = (1 + a38) in
          advance (10)
          A := a28;
          B := a34[7:0];
          C := M[a30];
          D := a17[15:8];
          E := a17[7:0];
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a39[15:8];
          SPL := a39[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := a31[16];
          Shifter_HI := a18;
          Shifter_LO := M[(D,E)];
          jump ((M[a38],M[a33]));
        }
      } else {
        advance (10)
        #14B8
        #instruction: LD   A,01
        advance (7)
        #14BA
        #instruction: LD   (2061),A
        M[2061] := 01;
        advance (13)
        #14BD
        #instruction: POP  PSW
        let:16 a40 = (1 + a23) in
        let:16 a41 = (1 + a40) in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a42 = (M[a16] | M[a40]) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        M[a16] := a42;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:16 a43 = (1 + a41) in
        let:16 a44 = (1 + a43) in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:17 a45 = add17(0020,(M[a43],M[a41])) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:16 a46 = (1 + a44) in
        let:16 a47 = (1 + a46) in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:16 a48 = addWithCarry(!true,M[a46],~00) in
        let:8 a49 = (M[a46] & 0F) in
        let:8 a50 = (~00 & 0F) in
        let:16 a51 = addWithCarry(!true,a49,a50) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a48[7:0])) {
          advance (10)
          A := a42;
          B := a48[7:0];
          C := M[a44];
          D := a17[15:8];
          E := a17[7:0];
          H := a45[15:0][15:8];
          L := a45[15:0][7:0];
          SPH := a47[15:8];
          SPL := a47[7:0];
          FlagS := a48[7:0][7];
          FlagZ := is_zero(a48[7:0]);
          FlagA := a51[7:0][4];
          FlagP := parity(a48[7:0]);
          FlagCY := a45[16];
          Shifter_HI := a18;
          Shifter_LO := M[(D,E)];
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:16 a52 = (1 + a47) in
          let:16 a53 = (1 + a52) in
          advance (10)
          A := a42;
          B := a48[7:0];
          C := M[a44];
          D := a17[15:8];
          E := a17[7:0];
          H := a45[15:0][15:8];
          L := a45[15:0][7:0];
          SPH := a53[15:8];
          SPL := a53[7:0];
          FlagS := a48[7:0][7];
          FlagZ := is_zero(a48[7:0]);
          FlagA := a51[7:0][4];
          FlagP := parity(a48[7:0]);
          FlagCY := a45[16];
          Shifter_HI := a18;
          Shifter_LO := M[(D,E)];
          jump ((M[a52],M[a47]));
        }
      }
    } else {
      advance (10)
      #14A4
      #instruction: LD   A,01
      advance (7)
      #14A6
      #instruction: LD   (2061),A
      M[2061] := 01;
      advance (13)
      #14A9
      #instruction: POP  PSW
      let:16 a54 = (1 + a10) in
      let:16 a55 = (1 + a54) in
      advance (10)
      #14AA
      #instruction: OR   (HL)
      let:8 a56 = (M[(H,L)] | M[a54]) in
      advance (7)
      #14AB
      #instruction: LD   (HL),A
      M[(H,L)] := a56;
      advance (7)
      #14AC
      #instruction: INC  HL
      let:16 a57 = (1 + (H,L)) in
      advance (5)
      #14AD
      #instruction: INC  DE
      let:16 a58 = (1 + (D,E)) in
      advance (5)
      #14AE
      #instruction: XOR  A
      let:8 a59 = (a56 ^ a56) in
      advance (4)
      #14AF
      #instruction: OUT  04
      advance (10)
      #14B1
      #instruction: IN   03
      let:8 a60 = (Shifter_OFF & 07) in
      let:8 a61 = (~Shifter_OFF & 07) in
      let:8 a62 = ((a59 << a60) | ((M[(D,E)] >> a61) >> 01)) in
      advance (10)
      #14B3
      #instruction: PUSH PSW
      let:16 a63 = (-1 + a55) in
      M[a63] := a62;
      let:16 a64 = (-1 + a63) in
      M[a64] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a59[7]),6,is_zero(a59)),4,false),2,parity(a59)),0,false);
      advance (11)
      #14B4
      #instruction: AND  (HL)
      let:8 a65 = (M[a57] & a62) in
      let:8 a66 = (M[a57] | a62) in
      advance (7)
      #14B5
      #instruction: JP   Z,14BD
      if (is_zero(a65)) {
        advance (10)
        #14BD
        #instruction: POP  PSW
        let:16 a67 = (1 + a64) in
        let:16 a68 = (1 + a67) in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a69 = (M[a57] | M[a67]) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        M[a57] := a69;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:16 a70 = (1 + a68) in
        let:16 a71 = (1 + a70) in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:17 a72 = add17(0020,(M[a70],M[a68])) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:16 a73 = (1 + a71) in
        let:16 a74 = (1 + a73) in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:16 a75 = addWithCarry(!true,M[a73],~00) in
        let:8 a76 = (M[a73] & 0F) in
        let:8 a77 = (~00 & 0F) in
        let:16 a78 = addWithCarry(!true,a76,a77) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a75[7:0])) {
          advance (10)
          A := a69;
          B := a75[7:0];
          C := M[a71];
          D := a58[15:8];
          E := a58[7:0];
          H := a72[15:0][15:8];
          L := a72[15:0][7:0];
          SPH := a74[15:8];
          SPL := a74[7:0];
          FlagS := a75[7:0][7];
          FlagZ := is_zero(a75[7:0]);
          FlagA := a78[7:0][4];
          FlagP := parity(a75[7:0]);
          FlagCY := a72[16];
          Shifter_HI := a59;
          Shifter_LO := M[(D,E)];
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:16 a79 = (1 + a74) in
          let:16 a80 = (1 + a79) in
          advance (10)
          A := a69;
          B := a75[7:0];
          C := M[a71];
          D := a58[15:8];
          E := a58[7:0];
          H := a72[15:0][15:8];
          L := a72[15:0][7:0];
          SPH := a80[15:8];
          SPL := a80[7:0];
          FlagS := a75[7:0][7];
          FlagZ := is_zero(a75[7:0]);
          FlagA := a78[7:0][4];
          FlagP := parity(a75[7:0]);
          FlagCY := a72[16];
          Shifter_HI := a59;
          Shifter_LO := M[(D,E)];
          jump ((M[a79],M[a74]));
        }
      } else {
        advance (10)
        #14B8
        #instruction: LD   A,01
        advance (7)
        #14BA
        #instruction: LD   (2061),A
        M[2061] := 01;
        advance (13)
        #14BD
        #instruction: POP  PSW
        let:16 a81 = (1 + a64) in
        let:16 a82 = (1 + a81) in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a83 = (M[a57] | M[a81]) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        M[a57] := a83;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:16 a84 = (1 + a82) in
        let:16 a85 = (1 + a84) in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:17 a86 = add17(0020,(M[a84],M[a82])) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:16 a87 = (1 + a85) in
        let:16 a88 = (1 + a87) in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:16 a89 = addWithCarry(!true,M[a87],~00) in
        let:8 a90 = (M[a87] & 0F) in
        let:8 a91 = (~00 & 0F) in
        let:16 a92 = addWithCarry(!true,a90,a91) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a89[7:0])) {
          advance (10)
          A := a83;
          B := a89[7:0];
          C := M[a85];
          D := a58[15:8];
          E := a58[7:0];
          H := a86[15:0][15:8];
          L := a86[15:0][7:0];
          SPH := a88[15:8];
          SPL := a88[7:0];
          FlagS := a89[7:0][7];
          FlagZ := is_zero(a89[7:0]);
          FlagA := a92[7:0][4];
          FlagP := parity(a89[7:0]);
          FlagCY := a86[16];
          Shifter_HI := a59;
          Shifter_LO := M[(D,E)];
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:16 a93 = (1 + a88) in
          let:16 a94 = (1 + a93) in
          advance (10)
          A := a83;
          B := a89[7:0];
          C := M[a85];
          D := a58[15:8];
          E := a58[7:0];
          H := a86[15:0][15:8];
          L := a86[15:0][7:0];
          SPH := a94[15:8];
          SPL := a94[7:0];
          FlagS := a89[7:0][7];
          FlagZ := is_zero(a89[7:0]);
          FlagA := a92[7:0][4];
          FlagP := parity(a89[7:0]);
          FlagCY := a86[16];
          Shifter_HI := a59;
          Shifter_LO := M[(D,E)];
          jump ((M[a93],M[a88]));
        }
      }
    }

1508:

    #instruction: LD   A,(202A)
    advance (13)
    #150B
    #instruction: LD   H,A
    advance (5)
    #150C
    #instruction: CALL 156F
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 0F;
    #return-to: 150F
    advance (17)
    #156F
    #instruction: LD   A,(200A)
    advance (13)
    #1572
    #instruction: CALL 1554
    let:16 a3 = (-1 + a2) in
    M[a3] := 15;
    let:16 a4 = (-1 + a3) in
    M[a4] := 75;
    #return-to: 1575
    advance (17)
    #1554
    #instruction: LD   C,00
    advance (7)
    #1556
    #instruction: CP   H
    let:16 a5 = addWithCarry(!false,M[200A],~M[202A]) in
    let:8 a6 = (M[200A] & 0F) in
    let:8 a7 = (~M[202A] & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (4)
    #1557
    #instruction: CALL NC,1590
    if (!!a5[15:8][0]) {
      let:16 a9 = (-1 + a4) in
      M[a9] := 15;
      let:16 a10 = (-1 + a9) in
      M[a10] := 5A;
      #return-to: 155A
      advance (17)
      #1590
      #instruction: INC  C
      let:16 a11 = addWithCarry(true,00,00) in
      let:8 a12 = (00 & 0F) in
      let:8 a13 = (00 & 0F) in
      let:16 a14 = addWithCarry(true,a12,a13) in
      advance (5)
      #1591
      #instruction: ADD  10
      let:16 a15 = addWithCarry(false,10,M[200A]) in
      let:8 a16 = (10 & 0F) in
      let:8 a17 = (M[200A] & 0F) in
      let:16 a18 = addWithCarry(false,a16,a17) in
      advance (7)
      #1593
      #instruction: JP   MI,1590
      if (a15[7:0][7]) {
        advance (10)
        A := a15[7:0];
        C := a11[7:0];
        H := M[202A];
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := a15[15:8][0];
        jump (1590);
      } else {
        advance (10)
        #1596
        #instruction: RET
        let:16 a19 = (1 + a10) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := a15[7:0];
        C := a11[7:0];
        H := M[202A];
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := a15[15:8][0];
        jump ((M[a19],M[a10]));
      }
    } else {
      advance (11)
      A := M[200A];
      C := 00;
      H := M[202A];
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump (155A);
    }

150F:

    #instruction: LD   (2064),HL
    M[2064] := L;
    M[2065] := H;
    advance (16)
    #1512
    #instruction: LD   A,05
    advance (7)
    #1514
    #instruction: LD   (2025),A
    M[2025] := 05;
    advance (13)
    #1517
    #instruction: CALL 1581
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    #return-to: 151A
    advance (17)
    #1581
    #instruction: LD   A,B
    advance (5)
    #1582
    #instruction: RLCA 
    advance (4)
    #1583
    #instruction: RLCA 
    advance (4)
    #1584
    #instruction: RLCA 
    advance (4)
    #1585
    #instruction: ADD  B
    let:16 a3 = addWithCarry(false,B,updateBit((updateBit((updateBit((B << 01),0,B[7]) << 01),0,updateBit((B << 01),0,B[7])[7]) << 01),0,updateBit((updateBit((B << 01),0,B[7]) << 01),0,updateBit((B << 01),0,B[7])[7])[7])) in
    let:8 a4 = (B & 0F) in
    let:8 a5 = (updateBit((updateBit((updateBit((B << 01),0,B[7]) << 01),0,updateBit((B << 01),0,B[7])[7]) << 01),0,updateBit((updateBit((B << 01),0,B[7]) << 01),0,updateBit((B << 01),0,B[7])[7])[7]) & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    #1586
    #instruction: ADD  B
    let:16 a7 = addWithCarry(false,B,a3[7:0]) in
    let:8 a8 = (B & 0F) in
    let:8 a9 = (a3[7:0] & 0F) in
    let:16 a10 = addWithCarry(false,a8,a9) in
    advance (4)
    #1587
    #instruction: ADD  B
    let:16 a11 = addWithCarry(false,B,a7[7:0]) in
    let:8 a12 = (B & 0F) in
    let:8 a13 = (a7[7:0] & 0F) in
    let:16 a14 = addWithCarry(false,a12,a13) in
    advance (4)
    #1588
    #instruction: ADD  C
    let:16 a15 = addWithCarry(false,C,a11[7:0]) in
    let:8 a16 = (C & 0F) in
    let:8 a17 = (a11[7:0] & 0F) in
    let:16 a18 = addWithCarry(false,a16,a17) in
    advance (4)
    #1589
    #instruction: DEC  A
    let:16 a19 = addWithCarry(!true,a15[7:0],~00) in
    let:8 a20 = (a15[7:0] & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #158A
    #instruction: LD   L,A
    advance (5)
    #158B
    #instruction: LD   A,(2067)
    advance (13)
    #158E
    #instruction: LD   H,A
    advance (5)
    #158F
    #instruction: RET
    let:16 a23 = (1 + a2) in
    let:16 a24 = (1 + a23) in
    advance (10)
    A := M[2067];
    H := M[2067];
    L := a19[7:0];
    SPH := a24[15:8];
    SPL := a24[7:0];
    FlagS := a19[7:0][7];
    FlagZ := is_zero(a19[7:0]);
    FlagA := a22[7:0][4];
    FlagP := parity(a19[7:0]);
    FlagCY := a15[15:8][0];
    jump ((M[a23],M[a2]));

151A:

    #instruction: LD   A,(HL)
    advance (7)
    #151B
    #instruction: AND  A
    let:8 a1 = (M[(H,L)] & M[(H,L)]) in
    let:8 a2 = (M[(H,L)] | M[(H,L)]) in
    advance (4)
    #151C
    #instruction: JP   Z,1530
    if (is_zero(a1)) {
      advance (10)
      #1530
      #instruction: LD   A,03
      advance (7)
      #1532
      #instruction: LD   (2025),A
      M[2025] := 03;
      advance (13)
      #1535
      #instruction: JP   154A
      advance (10)
      #154A
      #instruction: XOR  A
      let:8 a3 = (03 ^ 03) in
      advance (4)
      #154B
      #instruction: LD   (2002),A
      M[2002] := a3;
      advance (13)
      #154E
      #instruction: LD   B,F7
      advance (7)
      #1550
      #instruction: JP   19DC
      advance (10)
      #19DC
      #instruction: LD   A,(2094)
      advance (13)
      #19DF
      #instruction: AND  B
      let:8 a4 = (F7 & M[2094]) in
      let:8 a5 = (F7 | M[2094]) in
      advance (4)
      #19E0
      #instruction: LD   (2094),A
      M[2094] := a4;
      advance (13)
      #19E3
      #instruction: OUT  03
      sound_control(Ufo,a4[0]);
      sound_control(Shot,a4[1]);
      sound_control(PlayerDie,a4[2]);
      sound_control(InvaderDie,a4[3]);
      sound_control(ExtraLife,a4[4]);
      advance (10)
      #19E5
      #instruction: RET
      let:16 a6 = (1 + (SPH,SPL)) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a4;
      B := F7;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((M[a6],M[(SPH,SPL)]));
    } else {
      advance (10)
      #151F
      #instruction: LD   (HL),00
      M[(H,L)] := 00;
      advance (10)
      #1521
      #instruction: CALL 0A5F
      let:16 a8 = (-1 + (SPH,SPL)) in
      M[a8] := 15;
      let:16 a9 = (-1 + a8) in
      M[a9] := 24;
      #return-to: 1524
      advance (17)
      #0A5F
      #instruction: LD   A,(20EF)
      advance (13)
      #0A62
      #instruction: AND  A
      let:8 a10 = (M[20EF] & M[20EF]) in
      let:8 a11 = (M[20EF] | M[20EF]) in
      advance (4)
      #0A63
      #instruction: JP   Z,0A7C
      if (is_zero(a10)) {
        advance (10)
        #0A7C
        #instruction: LD   HL,2062
        advance (10)
        #0A7F
        #instruction: RET
        let:16 a12 = (1 + a9) in
        let:16 a13 = (1 + a12) in
        advance (10)
        A := a10;
        H := 20;
        L := 62;
        SPH := a13[15:8];
        SPL := a13[7:0];
        FlagS := a10[7];
        FlagZ := is_zero(a10);
        FlagA := a11[3];
        FlagP := parity(a10);
        FlagCY := false;
        jump ((M[a12],M[a9]));
      } else {
        advance (10)
        #0A66
        #instruction: LD   C,B
        advance (5)
        #0A67
        #instruction: LD   B,08
        advance (7)
        #0A69
        #instruction: CALL 18FA
        let:16 a14 = (-1 + a9) in
        M[a14] := 0A;
        let:16 a15 = (-1 + a14) in
        M[a15] := 6C;
        #return-to: 0A6C
        advance (17)
        #18FA
        #instruction: LD   A,(2094)
        advance (13)
        #18FD
        #instruction: OR   B
        let:8 a16 = (08 | M[2094]) in
        advance (4)
        #18FE
        #instruction: LD   (2094),A
        M[2094] := a16;
        advance (13)
        #1901
        #instruction: OUT  03
        sound_control(Ufo,a16[0]);
        sound_control(Shot,a16[1]);
        sound_control(PlayerDie,a16[2]);
        sound_control(InvaderDie,a16[3]);
        sound_control(ExtraLife,a16[4]);
        advance (10)
        #1903
        #instruction: RET
        let:16 a17 = (1 + a15) in
        let:16 a18 = (1 + a17) in
        advance (10)
        A := a16;
        B := 08;
        C := B;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a16[7];
        FlagZ := is_zero(a16);
        FlagA := false;
        FlagP := parity(a16);
        FlagCY := false;
        jump ((M[a17],M[a15]));
      }
    }

1524:

    #instruction: CALL 1A3B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 27;
    #return-to: 1527
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    advance (7)
    #1A3C
    #instruction: INC  HL
    let:16 a3 = (1 + (H,L)) in
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    advance (7)
    #1A3E
    #instruction: INC  HL
    let:16 a4 = (1 + a3) in
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    advance (7)
    #1A40
    #instruction: INC  HL
    let:16 a5 = (1 + a4) in
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    advance (7)
    #1A42
    #instruction: INC  HL
    let:16 a6 = (1 + a5) in
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    advance (7)
    #1A44
    #instruction: LD   H,C
    advance (5)
    #1A45
    #instruction: LD   L,A
    advance (5)
    #1A46
    #instruction: RET
    let:16 a7 = (1 + a2) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[a4];
    B := M[a6];
    C := M[a5];
    D := M[a3];
    E := M[(H,L)];
    H := M[a5];
    L := M[a4];
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((M[a7],M[a2]));

1527:

    #instruction: CALL 15D3
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2A;
    #return-to: 152A
    advance (17)
    #15D3
    #instruction: CALL 1474
    let:16 a3 = (-1 + a2) in
    M[a3] := 15;
    let:16 a4 = (-1 + a3) in
    M[a4] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a5 = (07 & L) in
    let:8 a6 = (07 | L) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a7 = (-1 + a4) in
    M[a7] := B;
    let:16 a8 = (-1 + a7) in
    M[a8] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a9 = addWithCarry(!true,03,~00) in
    let:8 a10 = (03 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!true,a10,a11) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a9[7:0])) {
      advance (10)
      A := updateBit((L >> 01),7,H[0]);
      B := a9[7:0];
      H := updateBit((H >> 01),7,false);
      L := updateBit((L >> 01),7,H[0]);
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := L[0];
      Shifter_OFF := a5;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a13 = (3F & updateBit((H >> 01),7,false)) in
      let:8 a14 = (3F | updateBit((H >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a15 = (20 | a13) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a16 = (1 + a8) in
      let:16 a17 = (1 + a16) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a18 = (1 + a17) in
      let:16 a19 = (1 + a18) in
      advance (10)
      A := a15;
      B := M[a16];
      C := M[a8];
      H := a15;
      L := updateBit((L >> 01),7,H[0]);
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := false;
      FlagP := parity(a15);
      FlagCY := false;
      Shifter_OFF := a5;
      jump ((M[a18],M[a17]));
    }

152A:

    #instruction: LD   A,10
    advance (7)
    #152C
    #instruction: LD   (2003),A
    M[2003] := 10;
    advance (13)
    #152F
    #instruction: RET
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    A := 10;
    SPH := a2[15:8];
    SPL := a2[7:0];
    jump ((M[a1],M[(SPH,SPL)]));

1545:

    #instruction: LD   A,04
    advance (7)
    #1547
    #instruction: LD   (2025),A
    M[2025] := 04;
    advance (13)
    #154A
    #instruction: XOR  A
    let:8 a1 = (04 ^ 04) in
    advance (4)
    #154B
    #instruction: LD   (2002),A
    M[2002] := a1;
    advance (13)
    #154E
    #instruction: LD   B,F7
    advance (7)
    #1550
    #instruction: JP   19DC
    advance (10)
    #19DC
    #instruction: LD   A,(2094)
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a2 = (F7 & M[2094]) in
    let:8 a3 = (F7 | M[2094]) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    M[2094] := a2;
    advance (13)
    #19E3
    #instruction: OUT  03
    sound_control(Ufo,a2[0]);
    sound_control(Shot,a2[1]);
    sound_control(PlayerDie,a2[2]);
    sound_control(InvaderDie,a2[3]);
    sound_control(ExtraLife,a2[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:16 a4 = (1 + (SPH,SPL)) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a2;
    B := F7;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump ((M[a4],M[(SPH,SPL)]));

155A:

    #instruction: CP   H
    let:16 a1 = addWithCarry(!false,A,~H) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~H & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    #155B
    #instruction: RET  NC
    if (!!a1[15:8][0]) {
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (11)
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump ((M[a5],M[(SPH,SPL)]));
    } else {
      advance (5)
      #155C
      #instruction: ADD  10
      let:16 a7 = addWithCarry(false,10,A) in
      let:8 a8 = (10 & 0F) in
      let:8 a9 = (A & 0F) in
      let:16 a10 = addWithCarry(false,a8,a9) in
      advance (7)
      #155E
      #instruction: INC  C
      let:16 a11 = addWithCarry(true,C,00) in
      let:8 a12 = (C & 0F) in
      let:8 a13 = (00 & 0F) in
      let:16 a14 = addWithCarry(true,a12,a13) in
      advance (5)
      #155F
      #instruction: JP   155A
      advance (10)
      A := a7[7:0];
      C := a11[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := a7[15:8][0];
      jump (155A);
    }

1569:

    #instruction: LD   B,C
    advance (5)
    #156A
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #156B
    #instruction: SBC  10
    let:16 a5 = addWithCarry(!FlagCY,A,~10) in
    let:8 a6 = (A & 0F) in
    let:8 a7 = (~10 & 0F) in
    let:16 a8 = addWithCarry(!FlagCY,a6,a7) in
    advance (7)
    #156D
    #instruction: LD   L,A
    advance (5)
    #156E
    #instruction: RET
    let:16 a9 = (1 + (SPH,SPL)) in
    let:16 a10 = (1 + a9) in
    advance (10)
    A := a5[7:0];
    B := a1[7:0];
    L := a5[7:0];
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := a5[7:0][7];
    FlagZ := is_zero(a5[7:0]);
    FlagA := a8[7:0][4];
    FlagP := parity(a5[7:0]);
    FlagCY := !a5[15:8][0];
    jump ((M[a9],M[(SPH,SPL)]));

1575:

    #instruction: SBC  10
    let:16 a1 = addWithCarry(!FlagCY,A,~10) in
    let:8 a2 = (A & 0F) in
    let:8 a3 = (~10 & 0F) in
    let:16 a4 = addWithCarry(!FlagCY,a2,a3) in
    advance (7)
    #1577
    #instruction: LD   H,A
    advance (5)
    #1578
    #instruction: RET
    let:16 a5 = (1 + (SPH,SPL)) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := a1[7:0];
    H := a1[7:0];
    SPH := a6[15:8];
    SPL := a6[7:0];
    FlagS := a1[7:0][7];
    FlagZ := is_zero(a1[7:0]);
    FlagA := a4[7:0][4];
    FlagP := parity(a1[7:0]);
    FlagCY := !a1[15:8][0];
    jump ((M[a5],M[(SPH,SPL)]));

15A4:

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #15A5
      #instruction: LD   B,FE
      advance (7)
      #15A7
      #instruction: LD   A,01
      advance (7)
      #15A9
      #instruction: LD   (200D),A
      M[200D] := 01;
      advance (13)
      #15AC
      #instruction: LD   A,B
      advance (5)
      #15AD
      #instruction: LD   (2008),A
      M[2008] := FE;
      advance (13)
      #15B0
      #instruction: LD   A,(200E)
      advance (13)
      #15B3
      #instruction: LD   (2007),A
      M[2007] := M[200E];
      advance (13)
      #15B6
      #instruction: RET
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (10)
      A := M[200E];
      B := FE;
      SPH := a4[15:8];
      SPL := a4[7:0];
      jump ((M[a3],M[(SPH,SPL)]));
    }

15BD:

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #15BE
      #instruction: CALL 18F1
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 15;
      let:16 a4 = (-1 + a3) in
      M[a4] := C1;
      #return-to: 15C1
      advance (17)
      #18F1
      #instruction: LD   B,02
      advance (7)
      #18F3
      #instruction: LD   A,(2082)
      advance (13)
      #18F6
      #instruction: DEC  A
      let:16 a5 = addWithCarry(!true,M[2082],~00) in
      let:8 a6 = (M[2082] & 0F) in
      let:8 a7 = (~00 & 0F) in
      let:16 a8 = addWithCarry(!true,a6,a7) in
      advance (5)
      #18F7
      #instruction: RET  NZ
      if (!is_zero(a5[7:0])) {
        let:16 a9 = (1 + a4) in
        let:16 a10 = (1 + a9) in
        advance (11)
        A := a5[7:0];
        B := 02;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        jump ((M[a9],M[a4]));
      } else {
        advance (5)
        #18F8
        #instruction: INC  B
        let:16 a11 = addWithCarry(true,02,00) in
        let:8 a12 = (02 & 0F) in
        let:8 a13 = (00 & 0F) in
        let:16 a14 = addWithCarry(true,a12,a13) in
        advance (5)
        #18F9
        #instruction: RET
        let:16 a15 = (1 + a4) in
        let:16 a16 = (1 + a15) in
        advance (10)
        A := a5[7:0];
        B := a11[7:0];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        jump ((M[a15],M[a4]));
      }
    }

15C1:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #15C2
    #instruction: JP   15A9
    advance (10)
    #15A9
    #instruction: LD   (200D),A
    M[200D] := a1;
    advance (13)
    #15AC
    #instruction: LD   A,B
    advance (5)
    #15AD
    #instruction: LD   (2008),A
    M[2008] := B;
    advance (13)
    #15B0
    #instruction: LD   A,(200E)
    advance (13)
    #15B3
    #instruction: LD   (2007),A
    M[2007] := M[200E];
    advance (13)
    #15B6
    #instruction: RET
    let:16 a2 = (1 + (SPH,SPL)) in
    let:16 a3 = (1 + a2) in
    advance (10)
    A := M[200E];
    SPH := a3[15:8];
    SPL := a3[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a2],M[(SPH,SPL)]));

15D6:

    #instruction: PUSH HL
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := H;
    let:16 a2 = (-1 + a1) in
    M[a2] := L;
    advance (11)
    #15D7
    #instruction: PUSH BC
    let:16 a3 = (-1 + a2) in
    M[a3] := B;
    let:16 a4 = (-1 + a3) in
    M[a4] := C;
    advance (11)
    #15D8
    #instruction: PUSH HL
    let:16 a5 = (-1 + a4) in
    M[a5] := H;
    let:16 a6 = (-1 + a5) in
    M[a6] := L;
    advance (11)
    #15D9
    #instruction: LD   A,(DE)
    advance (7)
    #15DA
    #instruction: OUT  04
    advance (10)
    #15DC
    #instruction: IN   03
    let:8 a7 = (Shifter_OFF & 07) in
    let:8 a8 = (~Shifter_OFF & 07) in
    let:8 a9 = ((M[(D,E)] << a7) | ((Shifter_HI >> a8) >> 01)) in
    advance (10)
    #15DE
    #instruction: LD   (HL),A
    M[(H,L)] := a9;
    advance (7)
    #15DF
    #instruction: INC  HL
    let:16 a10 = (1 + (H,L)) in
    advance (5)
    #15E0
    #instruction: INC  DE
    let:16 a11 = (1 + (D,E)) in
    advance (5)
    #15E1
    #instruction: XOR  A
    let:8 a12 = (a9 ^ a9) in
    advance (4)
    #15E2
    #instruction: OUT  04
    advance (10)
    #15E4
    #instruction: IN   03
    let:8 a13 = (Shifter_OFF & 07) in
    let:8 a14 = (~Shifter_OFF & 07) in
    let:8 a15 = ((a12 << a13) | ((M[(D,E)] >> a14) >> 01)) in
    advance (10)
    #15E6
    #instruction: LD   (HL),A
    M[a10] := a15;
    advance (7)
    #15E7
    #instruction: POP  HL
    let:16 a16 = (1 + a6) in
    let:16 a17 = (1 + a16) in
    advance (10)
    #15E8
    #instruction: LD   BC,0020
    advance (10)
    #15EB
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a16],M[a6])) in
    advance (10)
    #15EC
    #instruction: POP  BC
    let:16 a19 = (1 + a17) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #15ED
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #15EE
    #instruction: JP   NZ,15D7
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := a15;
      B := a21[7:0];
      C := M[a17];
      D := a11[15:8];
      E := a11[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      Shifter_HI := a12;
      Shifter_LO := M[(D,E)];
      jump (15D7);
    } else {
      advance (10)
      #15F1
      #instruction: POP  HL
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      #15F2
      #instruction: RET
      let:16 a27 = (1 + a26) in
      let:16 a28 = (1 + a27) in
      advance (10)
      A := a15;
      B := a21[7:0];
      C := M[a17];
      D := a11[15:8];
      E := a11[7:0];
      H := M[a25];
      L := M[a20];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      Shifter_HI := a12;
      Shifter_LO := M[(D,E)];
      jump ((M[a27],M[a26]));
    }

15F6:

    #instruction: LD   BC,3700
    advance (10)
    #15F9
    #instruction: LD   A,(HL)
    advance (7)
    #15FA
    #instruction: AND  A
    let:8 a1 = (M[(H,L)] & M[(H,L)]) in
    let:8 a2 = (M[(H,L)] | M[(H,L)]) in
    advance (4)
    #15FB
    #instruction: JP   Z,15FF
    if (is_zero(a1)) {
      advance (10)
      #15FF
      #instruction: INC  HL
      let:16 a3 = (1 + (H,L)) in
      advance (5)
      #1600
      #instruction: DEC  B
      let:16 a4 = addWithCarry(!true,37,~00) in
      let:8 a5 = (37 & 0F) in
      let:8 a6 = (~00 & 0F) in
      let:16 a7 = addWithCarry(!true,a5,a6) in
      advance (5)
      #1601
      #instruction: JP   NZ,15F9
      if (!is_zero(a4[7:0])) {
        advance (10)
        A := a1;
        B := a4[7:0];
        C := 00;
        H := a3[15:8];
        L := a3[7:0];
        FlagS := a4[7:0][7];
        FlagZ := is_zero(a4[7:0]);
        FlagA := a7[7:0][4];
        FlagP := parity(a4[7:0]);
        FlagCY := false;
        jump (15F9);
      } else {
        advance (10)
        #1604
        #instruction: LD   A,C
        advance (5)
        #1605
        #instruction: LD   (2082),A
        M[2082] := 00;
        advance (13)
        #1608
        #instruction: CP   01
        let:16 a8 = addWithCarry(!false,00,~01) in
        let:8 a9 = (00 & 0F) in
        let:8 a10 = (~01 & 0F) in
        let:16 a11 = addWithCarry(!false,a9,a10) in
        advance (7)
        #160A
        #instruction: RET  NZ
        if (!is_zero(a8[7:0])) {
          let:16 a12 = (1 + (SPH,SPL)) in
          let:16 a13 = (1 + a12) in
          advance (11)
          A := 00;
          B := a4[7:0];
          C := 00;
          H := a3[15:8];
          L := a3[7:0];
          SPH := a13[15:8];
          SPL := a13[7:0];
          FlagS := a8[7:0][7];
          FlagZ := is_zero(a8[7:0]);
          FlagA := a11[7:0][4];
          FlagP := parity(a8[7:0]);
          FlagCY := !a8[15:8][0];
          jump ((M[a12],M[(SPH,SPL)]));
        } else {
          advance (5)
          #160B
          #instruction: LD   HL,206B
          advance (10)
          #160E
          #instruction: LD   (HL),01
          M[206B] := 01;
          advance (10)
          #1610
          #instruction: RET
          let:16 a14 = (1 + (SPH,SPL)) in
          let:16 a15 = (1 + a14) in
          advance (10)
          A := 00;
          B := a4[7:0];
          C := 00;
          H := 20;
          L := 6B;
          SPH := a15[15:8];
          SPL := a15[7:0];
          FlagS := a8[7:0][7];
          FlagZ := is_zero(a8[7:0]);
          FlagA := a11[7:0][4];
          FlagP := parity(a8[7:0]);
          FlagCY := !a8[15:8][0];
          jump ((M[a14],M[(SPH,SPL)]));
        }
      }
    } else {
      advance (10)
      #15FE
      #instruction: INC  C
      let:16 a16 = addWithCarry(true,00,00) in
      let:8 a17 = (00 & 0F) in
      let:8 a18 = (00 & 0F) in
      let:16 a19 = addWithCarry(true,a17,a18) in
      advance (5)
      #15FF
      #instruction: INC  HL
      let:16 a20 = (1 + (H,L)) in
      advance (5)
      #1600
      #instruction: DEC  B
      let:16 a21 = addWithCarry(!true,37,~00) in
      let:8 a22 = (37 & 0F) in
      let:8 a23 = (~00 & 0F) in
      let:16 a24 = addWithCarry(!true,a22,a23) in
      advance (5)
      #1601
      #instruction: JP   NZ,15F9
      if (!is_zero(a21[7:0])) {
        advance (10)
        A := a1;
        B := a21[7:0];
        C := a16[7:0];
        H := a20[15:8];
        L := a20[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := false;
        jump (15F9);
      } else {
        advance (10)
        #1604
        #instruction: LD   A,C
        advance (5)
        #1605
        #instruction: LD   (2082),A
        M[2082] := a16[7:0];
        advance (13)
        #1608
        #instruction: CP   01
        let:16 a25 = addWithCarry(!false,a16[7:0],~01) in
        let:8 a26 = (a16[7:0] & 0F) in
        let:8 a27 = (~01 & 0F) in
        let:16 a28 = addWithCarry(!false,a26,a27) in
        advance (7)
        #160A
        #instruction: RET  NZ
        if (!is_zero(a25[7:0])) {
          let:16 a29 = (1 + (SPH,SPL)) in
          let:16 a30 = (1 + a29) in
          advance (11)
          A := a16[7:0];
          B := a21[7:0];
          C := a16[7:0];
          H := a20[15:8];
          L := a20[7:0];
          SPH := a30[15:8];
          SPL := a30[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := !a25[15:8][0];
          jump ((M[a29],M[(SPH,SPL)]));
        } else {
          advance (5)
          #160B
          #instruction: LD   HL,206B
          advance (10)
          #160E
          #instruction: LD   (HL),01
          M[206B] := 01;
          advance (10)
          #1610
          #instruction: RET
          let:16 a31 = (1 + (SPH,SPL)) in
          let:16 a32 = (1 + a31) in
          advance (10)
          A := a16[7:0];
          B := a21[7:0];
          C := a16[7:0];
          H := 20;
          L := 6B;
          SPH := a32[15:8];
          SPL := a32[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := !a25[15:8][0];
          jump ((M[a31],M[(SPH,SPL)]));
        }
      }
    }

163C:

    #instruction: AND  10
    let:8 a1 = (10 & A) in
    let:8 a2 = (10 | A) in
    advance (7)
    #163E
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #163F
      #instruction: LD   A,01
      advance (7)
      #1641
      #instruction: LD   (2025),A
      M[2025] := 01;
      advance (13)
      #1644
      #instruction: LD   (202D),A
      M[202D] := 01;
      advance (13)
      #1647
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a5],M[(SPH,SPL)]));
    }

164B:

    #instruction: AND  10
    let:8 a1 = (10 & A) in
    let:8 a2 = (10 | A) in
    advance (7)
    #164D
    #instruction: RET  NZ
    if (!is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #164E
      #instruction: LD   (202D),A
      M[202D] := a1;
      advance (13)
      #1651
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a1;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a5],M[(SPH,SPL)]));
    }

1671:

    #instruction: CALL 1910
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 74;
    #return-to: 1674
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    advance (13)
    #1916
    #instruction: RRCA 
    advance (4)
    #1917
    #instruction: RET  CY
    if (M[2067][0]) {
      let:16 a3 = (1 + a2) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E7;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagCY := M[2067][0];
      jump ((M[a3],M[a2]));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E8;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a2]));
    }

1674:

    #instruction: LD   (HL),00
    M[(H,L)] := 00;
    advance (10)
    #1676
    #instruction: CALL 09CA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := 79;
    #return-to: 1679
    advance (17)
    #09CA
    #instruction: LD   A,(2067)
    advance (13)
    #09CD
    #instruction: RRCA 
    advance (4)
    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    #09D1
    #instruction: RET  CY
    if (M[2067][0]) {
      let:16 a3 = (1 + a2) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := F8;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagCY := M[2067][0];
      jump ((M[a3],M[a2]));
    } else {
      advance (5)
      #09D2
      #instruction: LD   HL,20FC
      advance (10)
      #09D5
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := FC;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a2]));
    }

1679:

    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    #167A
    #instruction: LD   DE,20F5
    advance (10)
    #167D
    #instruction: LD   A,(DE)
    advance (7)
    #167E
    #instruction: CP   (HL)
    let:16 a2 = addWithCarry(!false,M[20F5],~M[a1]) in
    let:8 a3 = (M[20F5] & 0F) in
    let:8 a4 = (~M[a1] & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    #167F
    #instruction: DEC  DE
    advance (5)
    #1680
    #instruction: DEC  HL
    let:16 a6 = (-1 + a1) in
    advance (5)
    #1681
    #instruction: LD   A,(DE)
    advance (7)
    #1682
    #instruction: JP   Z,168B
    if (is_zero(a2[7:0])) {
      advance (10)
      #168B
      #instruction: CP   (HL)
      let:16 a7 = addWithCarry(!false,M[20F4],~M[a6]) in
      let:8 a8 = (M[20F4] & 0F) in
      let:8 a9 = (~M[a6] & 0F) in
      let:16 a10 = addWithCarry(!false,a8,a9) in
      advance (7)
      #168C
      #instruction: JP   NC,1698
      if (!!a7[15:8][0]) {
        advance (10)
        A := M[20F4];
        D := 20;
        E := F4;
        H := a6[15:8];
        L := a6[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := !a7[15:8][0];
        jump (1698);
      } else {
        advance (10)
        #168F
        #instruction: LD   A,(HL)
        advance (7)
        #1690
        #instruction: LD   (DE),A
        M[20F4] := M[a6];
        advance (7)
        #1691
        #instruction: INC  DE
        advance (5)
        #1692
        #instruction: INC  HL
        let:16 a11 = (1 + a6) in
        advance (5)
        #1693
        #instruction: LD   A,(HL)
        advance (7)
        #1694
        #instruction: LD   (DE),A
        M[20F5] := M[a11];
        advance (7)
        #1695
        #instruction: CALL 1950
        let:16 a12 = (-1 + (SPH,SPL)) in
        M[a12] := 16;
        let:16 a13 = (-1 + a12) in
        M[a13] := 98;
        #return-to: 1698
        advance (17)
        #1950
        #instruction: LD   HL,20F4
        advance (10)
        #1953
        #instruction: JP   1931
        advance (10)
        #1931
        #instruction: LD   E,(HL)
        advance (7)
        #1932
        #instruction: INC  HL
        advance (5)
        #1933
        #instruction: LD   D,(HL)
        advance (7)
        #1934
        #instruction: INC  HL
        advance (5)
        #1935
        #instruction: LD   A,(HL)
        advance (7)
        #1936
        #instruction: INC  HL
        advance (5)
        #1937
        #instruction: LD   H,(HL)
        advance (7)
        #1938
        #instruction: LD   L,A
        advance (5)
        #1939
        #instruction: JP   09AD
        advance (10)
        #09AD
        #instruction: LD   A,D
        advance (5)
        #09AE
        #instruction: CALL 09B2
        let:16 a14 = (-1 + a13) in
        M[a14] := 09;
        let:16 a15 = (-1 + a14) in
        M[a15] := B1;
        #return-to: 09B1
        advance (17)
        #09B2
        #instruction: PUSH DE
        let:16 a16 = (-1 + a15) in
        M[a16] := M[20F5];
        let:16 a17 = (-1 + a16) in
        M[a17] := M[20F4];
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:16 a18 = (-1 + a17) in
        M[a18] := M[20F5];
        let:16 a19 = (-1 + a18) in
        M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a7[7:0][7]),6,is_zero(a7[7:0])),4,a10[7:0][4]),2,parity(a7[7:0])),0,!a7[15:8][0]);
        advance (11)
        #09B4
        #instruction: RRCA 
        advance (4)
        #09B5
        #instruction: RRCA 
        advance (4)
        #09B6
        #instruction: RRCA 
        advance (4)
        #09B7
        #instruction: RRCA 
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a20 = (0F & updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
        let:8 a21 = (0F | updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:16 a22 = (-1 + a19) in
        M[a22] := 09;
        let:16 a23 = (-1 + a22) in
        M[a23] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:16 a24 = addWithCarry(false,1A,a20) in
        let:8 a25 = (1A & 0F) in
        let:8 a26 = (a20 & 0F) in
        let:16 a27 = addWithCarry(false,a25,a26) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a28 = (-1 + a23) in
        M[a28] := M[20F7];
        let:16 a29 = (-1 + a28) in
        M[a29] := M[20F6];
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a30 = add17((00,a24[7:0]),(00,a24[7:0])) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a31 = add17(a30[15:0],a30[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a32 = add17(a31[15:0],a31[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a33 = add17(1E00,a32[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a34 = (1 + a29) in
        let:16 a35 = (1 + a34) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a36 = (-1 + a35) in
        M[a36] := 08;
        let:16 a37 = (-1 + a36) in
        M[a37] := C;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a34],M[a29])] := M[a33[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a38 = (1 + a33[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a39 = add17(0020,(M[a34],M[a29])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a40 = (1 + a37) in
        let:16 a41 = (1 + a40) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a42 = addWithCarry(!true,M[a40],~00) in
        let:8 a43 = (M[a40] & 0F) in
        let:8 a44 = (~00 & 0F) in
        let:16 a45 = addWithCarry(!true,a43,a44) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a42[7:0])) {
          advance (10)
          A := M[a33[15:0]];
          B := a42[7:0];
          C := M[a37];
          D := a38[15:8];
          E := a38[7:0];
          H := a39[15:0][15:8];
          L := a39[15:0][7:0];
          SPH := a41[15:8];
          SPL := a41[7:0];
          FlagS := a42[7:0][7];
          FlagZ := is_zero(a42[7:0]);
          FlagA := a45[7:0][4];
          FlagP := parity(a42[7:0]);
          FlagCY := a39[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a46 = (1 + a41) in
          let:16 a47 = (1 + a46) in
          advance (10)
          A := M[a33[15:0]];
          B := a42[7:0];
          C := M[a37];
          D := a38[15:8];
          E := a38[7:0];
          H := a39[15:0][15:8];
          L := a39[15:0][7:0];
          SPH := a47[15:8];
          SPL := a47[7:0];
          FlagS := a42[7:0][7];
          FlagZ := is_zero(a42[7:0]);
          FlagA := a45[7:0][4];
          FlagP := parity(a42[7:0]);
          FlagCY := a39[16];
          jump ((M[a46],M[a41]));
        }
      }
    } else {
      advance (10)
      #1685
      #instruction: JP   NC,1698
      if (!!a2[15:8][0]) {
        advance (10)
        A := M[20F4];
        D := 20;
        E := F4;
        H := a6[15:8];
        L := a6[7:0];
        FlagS := a2[7:0][7];
        FlagZ := is_zero(a2[7:0]);
        FlagA := a5[7:0][4];
        FlagP := parity(a2[7:0]);
        FlagCY := !a2[15:8][0];
        jump (1698);
      } else {
        advance (10)
        #1688
        #instruction: JP   168F
        advance (10)
        #168F
        #instruction: LD   A,(HL)
        advance (7)
        #1690
        #instruction: LD   (DE),A
        M[20F4] := M[a6];
        advance (7)
        #1691
        #instruction: INC  DE
        advance (5)
        #1692
        #instruction: INC  HL
        let:16 a48 = (1 + a6) in
        advance (5)
        #1693
        #instruction: LD   A,(HL)
        advance (7)
        #1694
        #instruction: LD   (DE),A
        M[20F5] := M[a48];
        advance (7)
        #1695
        #instruction: CALL 1950
        let:16 a49 = (-1 + (SPH,SPL)) in
        M[a49] := 16;
        let:16 a50 = (-1 + a49) in
        M[a50] := 98;
        #return-to: 1698
        advance (17)
        #1950
        #instruction: LD   HL,20F4
        advance (10)
        #1953
        #instruction: JP   1931
        advance (10)
        #1931
        #instruction: LD   E,(HL)
        advance (7)
        #1932
        #instruction: INC  HL
        advance (5)
        #1933
        #instruction: LD   D,(HL)
        advance (7)
        #1934
        #instruction: INC  HL
        advance (5)
        #1935
        #instruction: LD   A,(HL)
        advance (7)
        #1936
        #instruction: INC  HL
        advance (5)
        #1937
        #instruction: LD   H,(HL)
        advance (7)
        #1938
        #instruction: LD   L,A
        advance (5)
        #1939
        #instruction: JP   09AD
        advance (10)
        #09AD
        #instruction: LD   A,D
        advance (5)
        #09AE
        #instruction: CALL 09B2
        let:16 a51 = (-1 + a50) in
        M[a51] := 09;
        let:16 a52 = (-1 + a51) in
        M[a52] := B1;
        #return-to: 09B1
        advance (17)
        #09B2
        #instruction: PUSH DE
        let:16 a53 = (-1 + a52) in
        M[a53] := M[20F5];
        let:16 a54 = (-1 + a53) in
        M[a54] := M[20F4];
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:16 a55 = (-1 + a54) in
        M[a55] := M[20F5];
        let:16 a56 = (-1 + a55) in
        M[a56] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a2[7:0][7]),6,is_zero(a2[7:0])),4,a5[7:0][4]),2,parity(a2[7:0])),0,!a2[15:8][0]);
        advance (11)
        #09B4
        #instruction: RRCA 
        advance (4)
        #09B5
        #instruction: RRCA 
        advance (4)
        #09B6
        #instruction: RRCA 
        advance (4)
        #09B7
        #instruction: RRCA 
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a57 = (0F & updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
        let:8 a58 = (0F | updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:16 a59 = (-1 + a56) in
        M[a59] := 09;
        let:16 a60 = (-1 + a59) in
        M[a60] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:16 a61 = addWithCarry(false,1A,a57) in
        let:8 a62 = (1A & 0F) in
        let:8 a63 = (a57 & 0F) in
        let:16 a64 = addWithCarry(false,a62,a63) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a65 = (-1 + a60) in
        M[a65] := M[20F7];
        let:16 a66 = (-1 + a65) in
        M[a66] := M[20F6];
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a67 = add17((00,a61[7:0]),(00,a61[7:0])) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a68 = add17(a67[15:0],a67[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a69 = add17(a68[15:0],a68[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a70 = add17(1E00,a69[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a71 = (1 + a66) in
        let:16 a72 = (1 + a71) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a73 = (-1 + a72) in
        M[a73] := 08;
        let:16 a74 = (-1 + a73) in
        M[a74] := C;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a71],M[a66])] := M[a70[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a75 = (1 + a70[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a76 = add17(0020,(M[a71],M[a66])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a77 = (1 + a74) in
        let:16 a78 = (1 + a77) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a79 = addWithCarry(!true,M[a77],~00) in
        let:8 a80 = (M[a77] & 0F) in
        let:8 a81 = (~00 & 0F) in
        let:16 a82 = addWithCarry(!true,a80,a81) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a79[7:0])) {
          advance (10)
          A := M[a70[15:0]];
          B := a79[7:0];
          C := M[a74];
          D := a75[15:8];
          E := a75[7:0];
          H := a76[15:0][15:8];
          L := a76[15:0][7:0];
          SPH := a78[15:8];
          SPL := a78[7:0];
          FlagS := a79[7:0][7];
          FlagZ := is_zero(a79[7:0]);
          FlagA := a82[7:0][4];
          FlagP := parity(a79[7:0]);
          FlagCY := a76[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a83 = (1 + a78) in
          let:16 a84 = (1 + a83) in
          advance (10)
          A := M[a70[15:0]];
          B := a79[7:0];
          C := M[a74];
          D := a75[15:8];
          E := a75[7:0];
          H := a76[15:0][15:8];
          L := a76[15:0][7:0];
          SPH := a84[15:8];
          SPL := a84[7:0];
          FlagS := a79[7:0][7];
          FlagZ := is_zero(a79[7:0]);
          FlagA := a82[7:0][4];
          FlagP := parity(a79[7:0]);
          FlagCY := a76[16];
          jump ((M[a83],M[a78]));
        }
      }
    }

1698:

    #instruction: LD   A,(20CE)
    advance (13)
    #169B
    #instruction: AND  A
    let:8 a1 = (M[20CE] & M[20CE]) in
    let:8 a2 = (M[20CE] | M[20CE]) in
    advance (4)
    #169C
    #instruction: JP   Z,16C9
    if (is_zero(a1)) {
      advance (10)
      #16C9
      #instruction: LD   HL,2D18
      advance (10)
      #16CC
      #instruction: LD   DE,1AA6
      advance (10)
      #16CF
      #instruction: LD   C,0A
      advance (7)
      #16D1
      #instruction: CALL 0A93
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 16;
      let:16 a4 = (-1 + a3) in
      M[a4] := D4;
      #return-to: 16D4
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a5 = (-1 + a4) in
      M[a5] := 1A;
      let:16 a6 = (-1 + a5) in
      M[a6] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a7 = (-1 + a6) in
      M[a7] := 0A;
      let:16 a8 = (-1 + a7) in
      M[a8] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a9 = (-1 + a8) in
      M[a9] := 2D;
      let:16 a10 = (-1 + a9) in
      M[a10] := 18;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a11 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a12 = add17(a11[15:0],a11[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a13 = add17(a12[15:0],a12[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a14 = add17(1E00,a13[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a15 = (1 + a10) in
      let:16 a16 = (1 + a15) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a17 = (-1 + a16) in
      M[a17] := 08;
      let:16 a18 = (-1 + a17) in
      M[a18] := 0A;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a15],M[a10])] := M[a14[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a19 = (1 + a14[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a20 = add17(0020,(M[a15],M[a10])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a21 = (1 + a18) in
      let:16 a22 = (1 + a21) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a23 = addWithCarry(!true,M[a21],~00) in
      let:8 a24 = (M[a21] & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a23[7:0])) {
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a27 = (1 + a22) in
        let:16 a28 = (1 + a27) in
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a28[15:8];
        SPL := a28[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump ((M[a27],M[a22]));
      }
    } else {
      advance (10)
      #169F
      #instruction: LD   HL,2803
      advance (10)
      #16A2
      #instruction: LD   DE,1AA6
      advance (10)
      #16A5
      #instruction: LD   C,14
      advance (7)
      #16A7
      #instruction: CALL 0A93
      let:16 a29 = (-1 + (SPH,SPL)) in
      M[a29] := 16;
      let:16 a30 = (-1 + a29) in
      M[a30] := AA;
      #return-to: 16AA
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a31 = (-1 + a30) in
      M[a31] := 1A;
      let:16 a32 = (-1 + a31) in
      M[a32] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a33 = (-1 + a32) in
      M[a33] := 0A;
      let:16 a34 = (-1 + a33) in
      M[a34] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a35 = (-1 + a34) in
      M[a35] := 28;
      let:16 a36 = (-1 + a35) in
      M[a36] := 03;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a37 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a38 = add17(a37[15:0],a37[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a39 = add17(a38[15:0],a38[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a40 = add17(1E00,a39[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a41 = (1 + a36) in
      let:16 a42 = (1 + a41) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a43 = (-1 + a42) in
      M[a43] := 08;
      let:16 a44 = (-1 + a43) in
      M[a44] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a41],M[a36])] := M[a40[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a45 = (1 + a40[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a46 = add17(0020,(M[a41],M[a36])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a47 = (1 + a44) in
      let:16 a48 = (1 + a47) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a49 = addWithCarry(!true,M[a47],~00) in
      let:8 a50 = (M[a47] & 0F) in
      let:8 a51 = (~00 & 0F) in
      let:16 a52 = addWithCarry(!true,a50,a51) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a49[7:0])) {
        advance (10)
        A := M[a40[15:0]];
        B := a49[7:0];
        C := M[a44];
        D := a45[15:8];
        E := a45[7:0];
        H := a46[15:0][15:8];
        L := a46[15:0][7:0];
        SPH := a48[15:8];
        SPL := a48[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a46[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a53 = (1 + a48) in
        let:16 a54 = (1 + a53) in
        advance (10)
        A := M[a40[15:0]];
        B := a49[7:0];
        C := M[a44];
        D := a45[15:8];
        E := a45[7:0];
        H := a46[15:0][15:8];
        L := a46[15:0][7:0];
        SPH := a54[15:8];
        SPL := a54[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a46[16];
        jump ((M[a53],M[a48]));
      }
    }

16AA:

    #instruction: DEC  H
    let:16 a1 = addWithCarry(!true,H,~00) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #16AB
    #instruction: DEC  H
    let:16 a5 = addWithCarry(!true,a1[7:0],~00) in
    let:8 a6 = (a1[7:0] & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #16AC
    #instruction: LD   B,1B
    advance (7)
    #16AE
    #instruction: LD   A,(2067)
    advance (13)
    #16B1
    #instruction: RRCA 
    advance (4)
    #16B2
    #instruction: JP   CY,16B7
    if (M[2067][0]) {
      advance (10)
      #16B7
      #instruction: LD   A,B
      advance (5)
      #16B8
      #instruction: CALL 08FF
      let:16 a9 = (-1 + (SPH,SPL)) in
      M[a9] := 16;
      let:16 a10 = (-1 + a9) in
      M[a10] := BB;
      #return-to: 16BB
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a11 = (-1 + a10) in
      M[a11] := a5[7:0];
      let:16 a12 = (-1 + a11) in
      M[a12] := L;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a13 = add17(001B,001B) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a14 = add17(a13[15:0],a13[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a15 = add17(a14[15:0],a14[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a16 = add17(1E00,a15[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a17 = (1 + a12) in
      let:16 a18 = (1 + a17) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a19 = (-1 + a18) in
      M[a19] := 08;
      let:16 a20 = (-1 + a19) in
      M[a20] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a17],M[a12])] := M[a16[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a21 = (1 + a16[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a22 = add17(0020,(M[a17],M[a12])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a23 = (1 + a20) in
      let:16 a24 = (1 + a23) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a25 = addWithCarry(!true,M[a23],~00) in
      let:8 a26 = (M[a23] & 0F) in
      let:8 a27 = (~00 & 0F) in
      let:16 a28 = addWithCarry(!true,a26,a27) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a25[7:0])) {
        advance (10)
        A := M[a16[15:0]];
        B := a25[7:0];
        C := M[a20];
        D := a21[15:8];
        E := a21[7:0];
        H := a22[15:0][15:8];
        L := a22[15:0][7:0];
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a25[7:0][7];
        FlagZ := is_zero(a25[7:0]);
        FlagA := a28[7:0][4];
        FlagP := parity(a25[7:0]);
        FlagCY := a22[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a29 = (1 + a24) in
        let:16 a30 = (1 + a29) in
        advance (10)
        A := M[a16[15:0]];
        B := a25[7:0];
        C := M[a20];
        D := a21[15:8];
        E := a21[7:0];
        H := a22[15:0][15:8];
        L := a22[15:0][7:0];
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a25[7:0][7];
        FlagZ := is_zero(a25[7:0]);
        FlagA := a28[7:0][4];
        FlagP := parity(a25[7:0]);
        FlagCY := a22[16];
        jump ((M[a29],M[a24]));
      }
    } else {
      advance (10)
      #16B5
      #instruction: LD   B,1C
      advance (7)
      #16B7
      #instruction: LD   A,B
      advance (5)
      #16B8
      #instruction: CALL 08FF
      let:16 a31 = (-1 + (SPH,SPL)) in
      M[a31] := 16;
      let:16 a32 = (-1 + a31) in
      M[a32] := BB;
      #return-to: 16BB
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a33 = (-1 + a32) in
      M[a33] := a5[7:0];
      let:16 a34 = (-1 + a33) in
      M[a34] := L;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a35 = add17(001C,001C) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a36 = add17(a35[15:0],a35[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a37 = add17(a36[15:0],a36[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a38 = add17(1E00,a37[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a39 = (1 + a34) in
      let:16 a40 = (1 + a39) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a41 = (-1 + a40) in
      M[a41] := 08;
      let:16 a42 = (-1 + a41) in
      M[a42] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a39],M[a34])] := M[a38[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a43 = (1 + a38[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a44 = add17(0020,(M[a39],M[a34])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a45 = (1 + a42) in
      let:16 a46 = (1 + a45) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a47 = addWithCarry(!true,M[a45],~00) in
      let:8 a48 = (M[a45] & 0F) in
      let:8 a49 = (~00 & 0F) in
      let:16 a50 = addWithCarry(!true,a48,a49) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a47[7:0])) {
        advance (10)
        A := M[a38[15:0]];
        B := a47[7:0];
        C := M[a42];
        D := a43[15:8];
        E := a43[7:0];
        H := a44[15:0][15:8];
        L := a44[15:0][7:0];
        SPH := a46[15:8];
        SPL := a46[7:0];
        FlagS := a47[7:0][7];
        FlagZ := is_zero(a47[7:0]);
        FlagA := a50[7:0][4];
        FlagP := parity(a47[7:0]);
        FlagCY := a44[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a51 = (1 + a46) in
        let:16 a52 = (1 + a51) in
        advance (10)
        A := M[a38[15:0]];
        B := a47[7:0];
        C := M[a42];
        D := a43[15:8];
        E := a43[7:0];
        H := a44[15:0][15:8];
        L := a44[15:0][7:0];
        SPH := a52[15:8];
        SPL := a52[7:0];
        FlagS := a47[7:0][7];
        FlagZ := is_zero(a47[7:0]);
        FlagA := a50[7:0][4];
        FlagP := parity(a47[7:0]);
        FlagCY := a44[16];
        jump ((M[a51],M[a46]));
      }
    }

16BB:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := BE;
    #return-to: 16BE
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

16BE:

    #instruction: CALL 18E7
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := C1;
    #return-to: 16C1
    advance (17)
    #18E7
    #instruction: LD   A,(2067)
    advance (13)
    #18EA
    #instruction: LD   HL,20E7
    advance (10)
    #18ED
    #instruction: RRCA 
    advance (4)
    #18EE
    #instruction: RET  NC
    if (!M[2067][0]) {
      let:16 a3 = (1 + a2) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E7;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagCY := M[2067][0];
      jump ((M[a3],M[a2]));
    } else {
      advance (5)
      #18EF
      #instruction: INC  HL
      advance (5)
      #18F0
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := updateBit((M[2067] >> 01),7,M[2067][0]);
      H := 20;
      L := E8;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagCY := M[2067][0];
      jump ((M[a5],M[a2]));
    }

16C1:

    #instruction: LD   A,(HL)
    advance (7)
    #16C2
    #instruction: AND  A
    let:8 a1 = (M[(H,L)] & M[(H,L)]) in
    let:8 a2 = (M[(H,L)] | M[(H,L)]) in
    advance (4)
    #16C3
    #instruction: JP   Z,16C9
    if (is_zero(a1)) {
      advance (10)
      #16C9
      #instruction: LD   HL,2D18
      advance (10)
      #16CC
      #instruction: LD   DE,1AA6
      advance (10)
      #16CF
      #instruction: LD   C,0A
      advance (7)
      #16D1
      #instruction: CALL 0A93
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 16;
      let:16 a4 = (-1 + a3) in
      M[a4] := D4;
      #return-to: 16D4
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a5 = (-1 + a4) in
      M[a5] := 1A;
      let:16 a6 = (-1 + a5) in
      M[a6] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a7 = (-1 + a6) in
      M[a7] := 0A;
      let:16 a8 = (-1 + a7) in
      M[a8] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a9 = (-1 + a8) in
      M[a9] := 2D;
      let:16 a10 = (-1 + a9) in
      M[a10] := 18;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a11 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a12 = add17(a11[15:0],a11[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a13 = add17(a12[15:0],a12[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a14 = add17(1E00,a13[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a15 = (1 + a10) in
      let:16 a16 = (1 + a15) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a17 = (-1 + a16) in
      M[a17] := 08;
      let:16 a18 = (-1 + a17) in
      M[a18] := 0A;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a15],M[a10])] := M[a14[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a19 = (1 + a14[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a20 = add17(0020,(M[a15],M[a10])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a21 = (1 + a18) in
      let:16 a22 = (1 + a21) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a23 = addWithCarry(!true,M[a21],~00) in
      let:8 a24 = (M[a21] & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a23[7:0])) {
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a27 = (1 + a22) in
        let:16 a28 = (1 + a27) in
        advance (10)
        A := M[a14[15:0]];
        B := a23[7:0];
        C := M[a18];
        D := a19[15:8];
        E := a19[7:0];
        H := a20[15:0][15:8];
        L := a20[15:0][7:0];
        SPH := a28[15:8];
        SPL := a28[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a20[16];
        jump ((M[a27],M[a22]));
      }
    } else {
      advance (10)
      #16C6
      #instruction: JP   02ED
      advance (10)
      #02ED
      #instruction: LD   A,(2067)
      advance (13)
      #02F0
      #instruction: PUSH PSW
      let:16 a29 = (-1 + (SPH,SPL)) in
      M[a29] := M[2067];
      let:16 a30 = (-1 + a29) in
      M[a30] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7]),6,is_zero(a1)),4,a2[3]),2,parity(a1)),0,false);
      advance (11)
      #02F1
      #instruction: RRCA 
      advance (4)
      #02F2
      #instruction: JP   CY,0332
      if (M[2067][0]) {
        advance (10)
        #0332
        #instruction: CALL 0209
        let:16 a31 = (-1 + a30) in
        M[a31] := 03;
        let:16 a32 = (-1 + a31) in
        M[a32] := 35;
        #return-to: 0335
        advance (17)
        #0209
        #instruction: LD   A,01
        advance (7)
        #020B
        #instruction: JP   021B
        advance (10)
        #021B
        #instruction: LD   DE,2142
        advance (10)
        #021E
        #instruction: LD   (2081),A
        M[2081] := 01;
        advance (13)
        #0221
        #instruction: LD   BC,1602
        advance (10)
        #0224
        #instruction: LD   HL,2806
        advance (10)
        #0227
        #instruction: LD   A,04
        advance (7)
        #0229
        #instruction: PUSH PSW
        let:16 a33 = (-1 + a32) in
        M[a33] := 04;
        let:16 a34 = (-1 + a33) in
        M[a34] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7]),6,is_zero(a1)),4,a2[3]),2,parity(a1)),0,M[2067][0]);
        advance (11)
        #022A
        #instruction: PUSH BC
        let:16 a35 = (-1 + a34) in
        M[a35] := 16;
        let:16 a36 = (-1 + a35) in
        M[a36] := 02;
        advance (11)
        #022B
        #instruction: LD   A,(2081)
        advance (13)
        #022E
        #instruction: AND  A
        let:8 a37 = (M[2081] & M[2081]) in
        let:8 a38 = (M[2081] | M[2081]) in
        advance (4)
        #022F
        #instruction: JP   NZ,0242
        if (!is_zero(a37)) {
          advance (10)
          #0242
          #instruction: CALL 147C
          let:16 a39 = (-1 + a36) in
          M[a39] := 02;
          let:16 a40 = (-1 + a39) in
          M[a40] := 45;
          #return-to: 0245
          advance (17)
          #147C
          #instruction: PUSH BC
          let:16 a41 = (-1 + a40) in
          M[a41] := 16;
          let:16 a42 = (-1 + a41) in
          M[a42] := 02;
          advance (11)
          #147D
          #instruction: PUSH HL
          let:16 a43 = (-1 + a42) in
          M[a43] := 28;
          let:16 a44 = (-1 + a43) in
          M[a44] := 06;
          advance (11)
          #147E
          #instruction: LD   A,(HL)
          advance (7)
          #147F
          #instruction: LD   (DE),A
          M[2142] := M[2806];
          advance (7)
          #1480
          #instruction: INC  DE
          advance (5)
          #1481
          #instruction: INC  HL
          advance (5)
          #1482
          #instruction: DEC  C
          let:16 a45 = addWithCarry(!true,02,~00) in
          let:8 a46 = (02 & 0F) in
          let:8 a47 = (~00 & 0F) in
          let:16 a48 = addWithCarry(!true,a46,a47) in
          advance (5)
          #1483
          #instruction: JP   NZ,147E
          if (!is_zero(a45[7:0])) {
            advance (10)
            A := M[2806];
            B := 16;
            C := a45[7:0];
            D := 21;
            E := 43;
            H := 28;
            L := 07;
            SPH := a44[15:8];
            SPL := a44[7:0];
            FlagS := a45[7:0][7];
            FlagZ := is_zero(a45[7:0]);
            FlagA := a48[7:0][4];
            FlagP := parity(a45[7:0]);
            FlagCY := false;
            jump (147E);
          } else {
            advance (10)
            #1486
            #instruction: POP  HL
            let:16 a49 = (1 + a44) in
            let:16 a50 = (1 + a49) in
            advance (10)
            #1487
            #instruction: LD   BC,0020
            advance (10)
            #148A
            #instruction: ADD  HL,BC
            let:17 a51 = add17(0020,(M[a49],M[a44])) in
            advance (10)
            #148B
            #instruction: POP  BC
            let:16 a52 = (1 + a50) in
            let:16 a53 = (1 + a52) in
            advance (10)
            #148C
            #instruction: DEC  B
            let:16 a54 = addWithCarry(!true,M[a52],~00) in
            let:8 a55 = (M[a52] & 0F) in
            let:8 a56 = (~00 & 0F) in
            let:16 a57 = addWithCarry(!true,a55,a56) in
            advance (5)
            #148D
            #instruction: JP   NZ,147C
            if (!is_zero(a54[7:0])) {
              advance (10)
              A := M[2806];
              B := a54[7:0];
              C := M[a50];
              D := 21;
              E := 43;
              H := a51[15:0][15:8];
              L := a51[15:0][7:0];
              SPH := a53[15:8];
              SPL := a53[7:0];
              FlagS := a54[7:0][7];
              FlagZ := is_zero(a54[7:0]);
              FlagA := a57[7:0][4];
              FlagP := parity(a54[7:0]);
              FlagCY := a51[16];
              jump (147C);
            } else {
              advance (10)
              #1490
              #instruction: RET
              let:16 a58 = (1 + a53) in
              let:16 a59 = (1 + a58) in
              advance (10)
              A := M[2806];
              B := a54[7:0];
              C := M[a50];
              D := 21;
              E := 43;
              H := a51[15:0][15:8];
              L := a51[15:0][7:0];
              SPH := a59[15:8];
              SPL := a59[7:0];
              FlagS := a54[7:0][7];
              FlagZ := is_zero(a54[7:0]);
              FlagA := a57[7:0][4];
              FlagP := parity(a54[7:0]);
              FlagCY := a51[16];
              jump ((M[a58],M[a53]));
            }
          }
        } else {
          advance (10)
          #0232
          #instruction: CALL 1A69
          let:16 a60 = (-1 + a36) in
          M[a60] := 02;
          let:16 a61 = (-1 + a60) in
          M[a61] := 35;
          #return-to: 0235
          advance (17)
          #1A69
          #instruction: PUSH BC
          let:16 a62 = (-1 + a61) in
          M[a62] := 16;
          let:16 a63 = (-1 + a62) in
          M[a63] := 02;
          advance (11)
          #1A6A
          #instruction: PUSH HL
          let:16 a64 = (-1 + a63) in
          M[a64] := 28;
          let:16 a65 = (-1 + a64) in
          M[a65] := 06;
          advance (11)
          #1A6B
          #instruction: LD   A,(DE)
          advance (7)
          #1A6C
          #instruction: OR   (HL)
          let:8 a66 = (M[2806] | M[2142]) in
          advance (7)
          #1A6D
          #instruction: LD   (HL),A
          M[2806] := a66;
          advance (7)
          #1A6E
          #instruction: INC  DE
          advance (5)
          #1A6F
          #instruction: INC  HL
          advance (5)
          #1A70
          #instruction: DEC  C
          let:16 a67 = addWithCarry(!true,02,~00) in
          let:8 a68 = (02 & 0F) in
          let:8 a69 = (~00 & 0F) in
          let:16 a70 = addWithCarry(!true,a68,a69) in
          advance (5)
          #1A71
          #instruction: JP   NZ,1A6B
          if (!is_zero(a67[7:0])) {
            advance (10)
            A := a66;
            B := 16;
            C := a67[7:0];
            D := 21;
            E := 43;
            H := 28;
            L := 07;
            SPH := a65[15:8];
            SPL := a65[7:0];
            FlagS := a67[7:0][7];
            FlagZ := is_zero(a67[7:0]);
            FlagA := a70[7:0][4];
            FlagP := parity(a67[7:0]);
            FlagCY := false;
            jump (1A6B);
          } else {
            advance (10)
            #1A74
            #instruction: POP  HL
            let:16 a71 = (1 + a65) in
            let:16 a72 = (1 + a71) in
            advance (10)
            #1A75
            #instruction: LD   BC,0020
            advance (10)
            #1A78
            #instruction: ADD  HL,BC
            let:17 a73 = add17(0020,(M[a71],M[a65])) in
            advance (10)
            #1A79
            #instruction: POP  BC
            let:16 a74 = (1 + a72) in
            let:16 a75 = (1 + a74) in
            advance (10)
            #1A7A
            #instruction: DEC  B
            let:16 a76 = addWithCarry(!true,M[a74],~00) in
            let:8 a77 = (M[a74] & 0F) in
            let:8 a78 = (~00 & 0F) in
            let:16 a79 = addWithCarry(!true,a77,a78) in
            advance (5)
            #1A7B
            #instruction: JP   NZ,1A69
            if (!is_zero(a76[7:0])) {
              advance (10)
              A := a66;
              B := a76[7:0];
              C := M[a72];
              D := 21;
              E := 43;
              H := a73[15:0][15:8];
              L := a73[15:0][7:0];
              SPH := a75[15:8];
              SPL := a75[7:0];
              FlagS := a76[7:0][7];
              FlagZ := is_zero(a76[7:0]);
              FlagA := a79[7:0][4];
              FlagP := parity(a76[7:0]);
              FlagCY := a73[16];
              jump (1A69);
            } else {
              advance (10)
              #1A7E
              #instruction: RET
              let:16 a80 = (1 + a75) in
              let:16 a81 = (1 + a80) in
              advance (10)
              A := a66;
              B := a76[7:0];
              C := M[a72];
              D := 21;
              E := 43;
              H := a73[15:0][15:8];
              L := a73[15:0][7:0];
              SPH := a81[15:8];
              SPL := a81[7:0];
              FlagS := a76[7:0][7];
              FlagZ := is_zero(a76[7:0]);
              FlagA := a79[7:0][4];
              FlagP := parity(a76[7:0]);
              FlagCY := a73[16];
              jump ((M[a80],M[a75]));
            }
          }
        }
      } else {
        advance (10)
        #02F5
        #instruction: CALL 020E
        let:16 a82 = (-1 + a30) in
        M[a82] := 02;
        let:16 a83 = (-1 + a82) in
        M[a83] := F8;
        #return-to: 02F8
        advance (17)
        #020E
        #instruction: LD   A,01
        advance (7)
        #0210
        #instruction: JP   0214
        advance (10)
        #0214
        #instruction: LD   DE,2242
        advance (10)
        #0217
        #instruction: JP   021E
        advance (10)
        #021E
        #instruction: LD   (2081),A
        M[2081] := 01;
        advance (13)
        #0221
        #instruction: LD   BC,1602
        advance (10)
        #0224
        #instruction: LD   HL,2806
        advance (10)
        #0227
        #instruction: LD   A,04
        advance (7)
        #0229
        #instruction: PUSH PSW
        let:16 a84 = (-1 + a83) in
        M[a84] := 04;
        let:16 a85 = (-1 + a84) in
        M[a85] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7]),6,is_zero(a1)),4,a2[3]),2,parity(a1)),0,M[2067][0]);
        advance (11)
        #022A
        #instruction: PUSH BC
        let:16 a86 = (-1 + a85) in
        M[a86] := 16;
        let:16 a87 = (-1 + a86) in
        M[a87] := 02;
        advance (11)
        #022B
        #instruction: LD   A,(2081)
        advance (13)
        #022E
        #instruction: AND  A
        let:8 a88 = (M[2081] & M[2081]) in
        let:8 a89 = (M[2081] | M[2081]) in
        advance (4)
        #022F
        #instruction: JP   NZ,0242
        if (!is_zero(a88)) {
          advance (10)
          #0242
          #instruction: CALL 147C
          let:16 a90 = (-1 + a87) in
          M[a90] := 02;
          let:16 a91 = (-1 + a90) in
          M[a91] := 45;
          #return-to: 0245
          advance (17)
          #147C
          #instruction: PUSH BC
          let:16 a92 = (-1 + a91) in
          M[a92] := 16;
          let:16 a93 = (-1 + a92) in
          M[a93] := 02;
          advance (11)
          #147D
          #instruction: PUSH HL
          let:16 a94 = (-1 + a93) in
          M[a94] := 28;
          let:16 a95 = (-1 + a94) in
          M[a95] := 06;
          advance (11)
          #147E
          #instruction: LD   A,(HL)
          advance (7)
          #147F
          #instruction: LD   (DE),A
          M[2242] := M[2806];
          advance (7)
          #1480
          #instruction: INC  DE
          advance (5)
          #1481
          #instruction: INC  HL
          advance (5)
          #1482
          #instruction: DEC  C
          let:16 a96 = addWithCarry(!true,02,~00) in
          let:8 a97 = (02 & 0F) in
          let:8 a98 = (~00 & 0F) in
          let:16 a99 = addWithCarry(!true,a97,a98) in
          advance (5)
          #1483
          #instruction: JP   NZ,147E
          if (!is_zero(a96[7:0])) {
            advance (10)
            A := M[2806];
            B := 16;
            C := a96[7:0];
            D := 22;
            E := 43;
            H := 28;
            L := 07;
            SPH := a95[15:8];
            SPL := a95[7:0];
            FlagS := a96[7:0][7];
            FlagZ := is_zero(a96[7:0]);
            FlagA := a99[7:0][4];
            FlagP := parity(a96[7:0]);
            FlagCY := false;
            jump (147E);
          } else {
            advance (10)
            #1486
            #instruction: POP  HL
            let:16 a100 = (1 + a95) in
            let:16 a101 = (1 + a100) in
            advance (10)
            #1487
            #instruction: LD   BC,0020
            advance (10)
            #148A
            #instruction: ADD  HL,BC
            let:17 a102 = add17(0020,(M[a100],M[a95])) in
            advance (10)
            #148B
            #instruction: POP  BC
            let:16 a103 = (1 + a101) in
            let:16 a104 = (1 + a103) in
            advance (10)
            #148C
            #instruction: DEC  B
            let:16 a105 = addWithCarry(!true,M[a103],~00) in
            let:8 a106 = (M[a103] & 0F) in
            let:8 a107 = (~00 & 0F) in
            let:16 a108 = addWithCarry(!true,a106,a107) in
            advance (5)
            #148D
            #instruction: JP   NZ,147C
            if (!is_zero(a105[7:0])) {
              advance (10)
              A := M[2806];
              B := a105[7:0];
              C := M[a101];
              D := 22;
              E := 43;
              H := a102[15:0][15:8];
              L := a102[15:0][7:0];
              SPH := a104[15:8];
              SPL := a104[7:0];
              FlagS := a105[7:0][7];
              FlagZ := is_zero(a105[7:0]);
              FlagA := a108[7:0][4];
              FlagP := parity(a105[7:0]);
              FlagCY := a102[16];
              jump (147C);
            } else {
              advance (10)
              #1490
              #instruction: RET
              let:16 a109 = (1 + a104) in
              let:16 a110 = (1 + a109) in
              advance (10)
              A := M[2806];
              B := a105[7:0];
              C := M[a101];
              D := 22;
              E := 43;
              H := a102[15:0][15:8];
              L := a102[15:0][7:0];
              SPH := a110[15:8];
              SPL := a110[7:0];
              FlagS := a105[7:0][7];
              FlagZ := is_zero(a105[7:0]);
              FlagA := a108[7:0][4];
              FlagP := parity(a105[7:0]);
              FlagCY := a102[16];
              jump ((M[a109],M[a104]));
            }
          }
        } else {
          advance (10)
          #0232
          #instruction: CALL 1A69
          let:16 a111 = (-1 + a87) in
          M[a111] := 02;
          let:16 a112 = (-1 + a111) in
          M[a112] := 35;
          #return-to: 0235
          advance (17)
          #1A69
          #instruction: PUSH BC
          let:16 a113 = (-1 + a112) in
          M[a113] := 16;
          let:16 a114 = (-1 + a113) in
          M[a114] := 02;
          advance (11)
          #1A6A
          #instruction: PUSH HL
          let:16 a115 = (-1 + a114) in
          M[a115] := 28;
          let:16 a116 = (-1 + a115) in
          M[a116] := 06;
          advance (11)
          #1A6B
          #instruction: LD   A,(DE)
          advance (7)
          #1A6C
          #instruction: OR   (HL)
          let:8 a117 = (M[2806] | M[2242]) in
          advance (7)
          #1A6D
          #instruction: LD   (HL),A
          M[2806] := a117;
          advance (7)
          #1A6E
          #instruction: INC  DE
          advance (5)
          #1A6F
          #instruction: INC  HL
          advance (5)
          #1A70
          #instruction: DEC  C
          let:16 a118 = addWithCarry(!true,02,~00) in
          let:8 a119 = (02 & 0F) in
          let:8 a120 = (~00 & 0F) in
          let:16 a121 = addWithCarry(!true,a119,a120) in
          advance (5)
          #1A71
          #instruction: JP   NZ,1A6B
          if (!is_zero(a118[7:0])) {
            advance (10)
            A := a117;
            B := 16;
            C := a118[7:0];
            D := 22;
            E := 43;
            H := 28;
            L := 07;
            SPH := a116[15:8];
            SPL := a116[7:0];
            FlagS := a118[7:0][7];
            FlagZ := is_zero(a118[7:0]);
            FlagA := a121[7:0][4];
            FlagP := parity(a118[7:0]);
            FlagCY := false;
            jump (1A6B);
          } else {
            advance (10)
            #1A74
            #instruction: POP  HL
            let:16 a122 = (1 + a116) in
            let:16 a123 = (1 + a122) in
            advance (10)
            #1A75
            #instruction: LD   BC,0020
            advance (10)
            #1A78
            #instruction: ADD  HL,BC
            let:17 a124 = add17(0020,(M[a122],M[a116])) in
            advance (10)
            #1A79
            #instruction: POP  BC
            let:16 a125 = (1 + a123) in
            let:16 a126 = (1 + a125) in
            advance (10)
            #1A7A
            #instruction: DEC  B
            let:16 a127 = addWithCarry(!true,M[a125],~00) in
            let:8 a128 = (M[a125] & 0F) in
            let:8 a129 = (~00 & 0F) in
            let:16 a130 = addWithCarry(!true,a128,a129) in
            advance (5)
            #1A7B
            #instruction: JP   NZ,1A69
            if (!is_zero(a127[7:0])) {
              advance (10)
              A := a117;
              B := a127[7:0];
              C := M[a123];
              D := 22;
              E := 43;
              H := a124[15:0][15:8];
              L := a124[15:0][7:0];
              SPH := a126[15:8];
              SPL := a126[7:0];
              FlagS := a127[7:0][7];
              FlagZ := is_zero(a127[7:0]);
              FlagA := a130[7:0][4];
              FlagP := parity(a127[7:0]);
              FlagCY := a124[16];
              jump (1A69);
            } else {
              advance (10)
              #1A7E
              #instruction: RET
              let:16 a131 = (1 + a126) in
              let:16 a132 = (1 + a131) in
              advance (10)
              A := a117;
              B := a127[7:0];
              C := M[a123];
              D := 22;
              E := 43;
              H := a124[15:0][15:8];
              L := a124[15:0][7:0];
              SPH := a132[15:8];
              SPL := a132[7:0];
              FlagS := a127[7:0][7];
              FlagZ := is_zero(a127[7:0]);
              FlagA := a130[7:0][4];
              FlagP := parity(a127[7:0]);
              FlagCY := a124[16];
              jump ((M[a131],M[a126]));
            }
          }
        }
      }
    }

16D4:

    #instruction: CALL 0AB6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := D7;
    #return-to: 16D7
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

16D7:

    #instruction: CALL 09D6
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := DA;
    #return-to: 16DA
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a3 = (1F & 03) in
    let:8 a4 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:16 a5 = addWithCarry(!false,a3,~1C) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~1C & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a5[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a9 = addWithCarry(!false,24,~40) in
      let:8 a10 = (24 & 0F) in
      let:8 a11 = (~40 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a9[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a13 = (1 + a2) in
        let:16 a14 = (1 + a13) in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((M[a13],M[a2]));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a15 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a16 = addWithCarry(!false,a15[15:0][15:8],~40) in
      let:8 a17 = (a15[15:0][15:8] & 0F) in
      let:8 a18 = (~40 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a16[15:8][0]) {
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a2[15:8];
        SPL := a2[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:16 a20 = (1 + a2) in
        let:16 a21 = (1 + a20) in
        advance (10)
        A := a15[15:0][15:8];
        D := 00;
        E := 06;
        H := a15[15:0][15:8];
        L := a15[15:0][7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((M[a20],M[a2]));
      }
    }

16DA:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #16DB
    #instruction: LD   (20EF),A
    M[20EF] := a1;
    advance (13)
    #16DE
    #instruction: OUT  05
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    #16E0
    #instruction: CALL 19D1
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := E3;
    #return-to: 16E3
    advance (17)
    #19D1
    #instruction: LD   A,01
    advance (7)
    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := 01;
    advance (13)
    #19D6
    #instruction: RET
    let:16 a4 = (1 + a3) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := 01;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a4],M[a3]));

16E3:

    #instruction: JP   0B89
    advance (10)
    #0B89
    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #0B8A
    #instruction: LD   (20C1),A
    M[20C1] := a1;
    advance (13)
    #0B8D
    #instruction: CALL 0AB1
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 90;
    #return-to: 0B90
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a4 = (M[20C0] & M[20C0]) in
    let:8 a5 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      SPH := a3[15:8];
      SPL := a3[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a6 = (1 + a3) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := a4;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((M[a6],M[a3]));
    }

16F1:

    #instruction: LD   B,04
    advance (7)
    #16F3
    #instruction: CALL 18FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := F6;
    #return-to: 16F6
    advance (17)
    #18FA
    #instruction: LD   A,(2094)
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a3 = (04 | M[2094]) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    M[2094] := a3;
    advance (13)
    #1901
    #instruction: OUT  03
    sound_control(Ufo,a3[0]);
    sound_control(Shot,a3[1]);
    sound_control(PlayerDie,a3[2]);
    sound_control(InvaderDie,a3[3]);
    sound_control(ExtraLife,a3[4]);
    advance (10)
    #1903
    #instruction: RET
    let:16 a4 = (1 + a2) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a3;
    B := 04;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a4],M[a2]));

16F6:

    #instruction: CALL 0A59
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 16;
    let:16 a2 = (-1 + a1) in
    M[a2] := F9;
    #return-to: 16F9
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[2015],~FF) in
    let:8 a4 = (M[2015] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0A5E
    #instruction: RET
    let:16 a7 = (1 + a2) in
    let:16 a8 = (1 + a7) in
    advance (10)
    A := M[2015];
    SPH := a8[15:8];
    SPL := a8[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((M[a7],M[a2]));

16F9:

    #instruction: JP   NZ,16EE
    if (!FlagZ) {
      advance (10)
      #16EE
      #instruction: CALL 14D8
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 16;
      let:16 a2 = (-1 + a1) in
      M[a2] := F1;
      #return-to: 16F1
      advance (17)
      #14D8
      #instruction: LD   A,(2025)
      advance (13)
      #14DB
      #instruction: CP   05
      let:16 a3 = addWithCarry(!false,M[2025],~05) in
      let:8 a4 = (M[2025] & 0F) in
      let:8 a5 = (~05 & 0F) in
      let:16 a6 = addWithCarry(!false,a4,a5) in
      advance (7)
      #14DD
      #instruction: RET  Z
      if (is_zero(a3[7:0])) {
        let:16 a7 = (1 + a2) in
        let:16 a8 = (1 + a7) in
        advance (11)
        A := M[2025];
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a3[7:0][7];
        FlagZ := is_zero(a3[7:0]);
        FlagA := a6[7:0][4];
        FlagP := parity(a3[7:0]);
        FlagCY := !a3[15:8][0];
        jump ((M[a7],M[a2]));
      } else {
        advance (5)
        #14DE
        #instruction: CP   02
        let:16 a9 = addWithCarry(!false,M[2025],~02) in
        let:8 a10 = (M[2025] & 0F) in
        let:8 a11 = (~02 & 0F) in
        let:16 a12 = addWithCarry(!false,a10,a11) in
        advance (7)
        #14E0
        #instruction: RET  NZ
        if (!is_zero(a9[7:0])) {
          let:16 a13 = (1 + a2) in
          let:16 a14 = (1 + a13) in
          advance (11)
          A := M[2025];
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a9[7:0][7];
          FlagZ := is_zero(a9[7:0]);
          FlagA := a12[7:0][4];
          FlagP := parity(a9[7:0]);
          FlagCY := !a9[15:8][0];
          jump ((M[a13],M[a2]));
        } else {
          advance (5)
          #14E1
          #instruction: LD   A,(2029)
          advance (13)
          #14E4
          #instruction: CP   D8
          let:16 a15 = addWithCarry(!false,M[2029],~D8) in
          let:8 a16 = (M[2029] & 0F) in
          let:8 a17 = (~D8 & 0F) in
          let:16 a18 = addWithCarry(!false,a16,a17) in
          advance (7)
          #14E6
          #instruction: LD   B,A
          advance (5)
          #14E7
          #instruction: JP   NC,1530
          if (!!a15[15:8][0]) {
            advance (10)
            #1530
            #instruction: LD   A,03
            advance (7)
            #1532
            #instruction: LD   (2025),A
            M[2025] := 03;
            advance (13)
            #1535
            #instruction: JP   154A
            advance (10)
            #154A
            #instruction: XOR  A
            let:8 a19 = (03 ^ 03) in
            advance (4)
            #154B
            #instruction: LD   (2002),A
            M[2002] := a19;
            advance (13)
            #154E
            #instruction: LD   B,F7
            advance (7)
            #1550
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a20 = (F7 & M[2094]) in
            let:8 a21 = (F7 | M[2094]) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            M[2094] := a20;
            advance (13)
            #19E3
            #instruction: OUT  03
            sound_control(Ufo,a20[0]);
            sound_control(Shot,a20[1]);
            sound_control(PlayerDie,a20[2]);
            sound_control(InvaderDie,a20[3]);
            sound_control(ExtraLife,a20[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:16 a22 = (1 + a2) in
            let:16 a23 = (1 + a22) in
            advance (10)
            A := a20;
            B := F7;
            SPH := a23[15:8];
            SPL := a23[7:0];
            FlagS := a20[7];
            FlagZ := is_zero(a20);
            FlagA := a21[3];
            FlagP := parity(a20);
            FlagCY := false;
            jump ((M[a22],M[a2]));
          } else {
            advance (10)
            #14EA
            #instruction: LD   A,(2002)
            advance (13)
            #14ED
            #instruction: AND  A
            let:8 a24 = (M[2002] & M[2002]) in
            let:8 a25 = (M[2002] | M[2002]) in
            advance (4)
            #14EE
            #instruction: RET  Z
            if (is_zero(a24)) {
              let:16 a26 = (1 + a2) in
              let:16 a27 = (1 + a26) in
              advance (11)
              A := a24;
              B := M[2029];
              SPH := a27[15:8];
              SPL := a27[7:0];
              FlagS := a24[7];
              FlagZ := is_zero(a24);
              FlagA := a25[3];
              FlagP := parity(a24);
              FlagCY := false;
              jump ((M[a26],M[a2]));
            } else {
              advance (5)
              #14EF
              #instruction: LD   A,B
              advance (5)
              #14F0
              #instruction: CP   CE
              let:16 a28 = addWithCarry(!false,M[2029],~CE) in
              let:8 a29 = (M[2029] & 0F) in
              let:8 a30 = (~CE & 0F) in
              let:16 a31 = addWithCarry(!false,a29,a30) in
              advance (7)
              #14F2
              #instruction: JP   NC,1579
              if (!!a28[15:8][0]) {
                advance (10)
                #1579
                #instruction: LD   A,01
                advance (7)
                #157B
                #instruction: LD   (2085),A
                M[2085] := 01;
                advance (13)
                #157E
                #instruction: JP   1545
                advance (10)
                A := 01;
                B := M[2029];
                SPH := a2[15:8];
                SPL := a2[7:0];
                FlagS := a28[7:0][7];
                FlagZ := is_zero(a28[7:0]);
                FlagA := a31[7:0][4];
                FlagP := parity(a28[7:0]);
                FlagCY := !a28[15:8][0];
                jump (1545);
              } else {
                advance (10)
                #14F5
                #instruction: ADD  06
                let:16 a32 = addWithCarry(false,06,M[2029]) in
                let:8 a33 = (06 & 0F) in
                let:8 a34 = (M[2029] & 0F) in
                let:16 a35 = addWithCarry(false,a33,a34) in
                advance (7)
                #14F7
                #instruction: LD   B,A
                advance (5)
                #14F8
                #instruction: LD   A,(2009)
                advance (13)
                #14FB
                #instruction: CP   90
                let:16 a36 = addWithCarry(!false,M[2009],~90) in
                let:8 a37 = (M[2009] & 0F) in
                let:8 a38 = (~90 & 0F) in
                let:16 a39 = addWithCarry(!false,a37,a38) in
                advance (7)
                #14FD
                #instruction: JP   NC,1504
                if (!!a36[15:8][0]) {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:16 a40 = (-1 + a2) in
                  M[a40] := 15;
                  let:16 a41 = (-1 + a40) in
                  M[a41] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:16 a42 = (-1 + a41) in
                  M[a42] := 15;
                  let:16 a43 = (-1 + a42) in
                  M[a43] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:16 a44 = addWithCarry(!false,M[2009],~a32[7:0]) in
                  let:8 a45 = (M[2009] & 0F) in
                  let:8 a46 = (~a32[7:0] & 0F) in
                  let:16 a47 = addWithCarry(!false,a45,a46) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a44[15:8][0]) {
                    let:16 a48 = (-1 + a43) in
                    M[a48] := 15;
                    let:16 a49 = (-1 + a48) in
                    M[a49] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a50 = addWithCarry(true,00,00) in
                    let:8 a51 = (00 & 0F) in
                    let:8 a52 = (00 & 0F) in
                    let:16 a53 = addWithCarry(true,a51,a52) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:16 a54 = addWithCarry(false,10,M[2009]) in
                    let:8 a55 = (10 & 0F) in
                    let:8 a56 = (M[2009] & 0F) in
                    let:16 a57 = addWithCarry(false,a55,a56) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a54[7:0][7]) {
                      advance (10)
                      A := a54[7:0];
                      B := a32[7:0];
                      C := a50[7:0];
                      H := a32[7:0];
                      L := a32[7:0];
                      SPH := a49[15:8];
                      SPL := a49[7:0];
                      FlagS := a54[7:0][7];
                      FlagZ := is_zero(a54[7:0]);
                      FlagA := a57[7:0][4];
                      FlagP := parity(a54[7:0]);
                      FlagCY := a54[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:16 a58 = (1 + a49) in
                      let:16 a59 = (1 + a58) in
                      advance (10)
                      A := a54[7:0];
                      B := a32[7:0];
                      C := a50[7:0];
                      H := a32[7:0];
                      L := a32[7:0];
                      SPH := a59[15:8];
                      SPL := a59[7:0];
                      FlagS := a54[7:0][7];
                      FlagZ := is_zero(a54[7:0]);
                      FlagA := a57[7:0][4];
                      FlagP := parity(a54[7:0]);
                      FlagCY := a54[15:8][0];
                      jump ((M[a58],M[a49]));
                    }
                  } else {
                    advance (11)
                    A := M[2009];
                    B := a32[7:0];
                    C := 00;
                    H := a32[7:0];
                    L := a32[7:0];
                    SPH := a43[15:8];
                    SPL := a43[7:0];
                    FlagS := a44[7:0][7];
                    FlagZ := is_zero(a44[7:0]);
                    FlagA := a47[7:0][4];
                    FlagP := parity(a44[7:0]);
                    FlagCY := !a44[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #1500
                  #instruction: CP   B
                  let:16 a60 = addWithCarry(!false,M[2009],~a32[7:0]) in
                  let:8 a61 = (M[2009] & 0F) in
                  let:8 a62 = (~a32[7:0] & 0F) in
                  let:16 a63 = addWithCarry(!false,a61,a62) in
                  advance (4)
                  #1501
                  #instruction: JP   NC,1530
                  if (!!a60[15:8][0]) {
                    advance (10)
                    #1530
                    #instruction: LD   A,03
                    advance (7)
                    #1532
                    #instruction: LD   (2025),A
                    M[2025] := 03;
                    advance (13)
                    #1535
                    #instruction: JP   154A
                    advance (10)
                    #154A
                    #instruction: XOR  A
                    let:8 a64 = (03 ^ 03) in
                    advance (4)
                    #154B
                    #instruction: LD   (2002),A
                    M[2002] := a64;
                    advance (13)
                    #154E
                    #instruction: LD   B,F7
                    advance (7)
                    #1550
                    #instruction: JP   19DC
                    advance (10)
                    #19DC
                    #instruction: LD   A,(2094)
                    advance (13)
                    #19DF
                    #instruction: AND  B
                    let:8 a65 = (F7 & M[2094]) in
                    let:8 a66 = (F7 | M[2094]) in
                    advance (4)
                    #19E0
                    #instruction: LD   (2094),A
                    M[2094] := a65;
                    advance (13)
                    #19E3
                    #instruction: OUT  03
                    sound_control(Ufo,a65[0]);
                    sound_control(Shot,a65[1]);
                    sound_control(PlayerDie,a65[2]);
                    sound_control(InvaderDie,a65[3]);
                    sound_control(ExtraLife,a65[4]);
                    advance (10)
                    #19E5
                    #instruction: RET
                    let:16 a67 = (1 + a2) in
                    let:16 a68 = (1 + a67) in
                    advance (10)
                    A := a65;
                    B := F7;
                    SPH := a68[15:8];
                    SPL := a68[7:0];
                    FlagS := a65[7];
                    FlagZ := is_zero(a65);
                    FlagA := a66[3];
                    FlagP := parity(a65);
                    FlagCY := false;
                    jump ((M[a67],M[a2]));
                  } else {
                    advance (10)
                    #1504
                    #instruction: LD   L,B
                    advance (5)
                    #1505
                    #instruction: CALL 1562
                    let:16 a69 = (-1 + a2) in
                    M[a69] := 15;
                    let:16 a70 = (-1 + a69) in
                    M[a70] := 08;
                    #return-to: 1508
                    advance (17)
                    #1562
                    #instruction: LD   A,(2009)
                    advance (13)
                    #1565
                    #instruction: LD   H,L
                    advance (5)
                    #1566
                    #instruction: CALL 1554
                    let:16 a71 = (-1 + a70) in
                    M[a71] := 15;
                    let:16 a72 = (-1 + a71) in
                    M[a72] := 69;
                    #return-to: 1569
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:16 a73 = addWithCarry(!false,M[2009],~a32[7:0]) in
                    let:8 a74 = (M[2009] & 0F) in
                    let:8 a75 = (~a32[7:0] & 0F) in
                    let:16 a76 = addWithCarry(!false,a74,a75) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a73[15:8][0]) {
                      let:16 a77 = (-1 + a72) in
                      M[a77] := 15;
                      let:16 a78 = (-1 + a77) in
                      M[a78] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a79 = addWithCarry(true,00,00) in
                      let:8 a80 = (00 & 0F) in
                      let:8 a81 = (00 & 0F) in
                      let:16 a82 = addWithCarry(true,a80,a81) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:16 a83 = addWithCarry(false,10,M[2009]) in
                      let:8 a84 = (10 & 0F) in
                      let:8 a85 = (M[2009] & 0F) in
                      let:16 a86 = addWithCarry(false,a84,a85) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a83[7:0][7]) {
                        advance (10)
                        A := a83[7:0];
                        B := a32[7:0];
                        C := a79[7:0];
                        H := a32[7:0];
                        L := a32[7:0];
                        SPH := a78[15:8];
                        SPL := a78[7:0];
                        FlagS := a83[7:0][7];
                        FlagZ := is_zero(a83[7:0]);
                        FlagA := a86[7:0][4];
                        FlagP := parity(a83[7:0]);
                        FlagCY := a83[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:16 a87 = (1 + a78) in
                        let:16 a88 = (1 + a87) in
                        advance (10)
                        A := a83[7:0];
                        B := a32[7:0];
                        C := a79[7:0];
                        H := a32[7:0];
                        L := a32[7:0];
                        SPH := a88[15:8];
                        SPL := a88[7:0];
                        FlagS := a83[7:0][7];
                        FlagZ := is_zero(a83[7:0]);
                        FlagA := a86[7:0][4];
                        FlagP := parity(a83[7:0]);
                        FlagCY := a83[15:8][0];
                        jump ((M[a87],M[a78]));
                      }
                    } else {
                      advance (11)
                      A := M[2009];
                      B := a32[7:0];
                      C := 00;
                      H := a32[7:0];
                      L := a32[7:0];
                      SPH := a72[15:8];
                      SPL := a72[7:0];
                      FlagS := a73[7:0][7];
                      FlagZ := is_zero(a73[7:0]);
                      FlagA := a76[7:0][4];
                      FlagP := parity(a73[7:0]);
                      FlagCY := !a73[15:8][0];
                      jump (155A);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #16FC
      #instruction: CALL 19D7
      let:16 a89 = (-1 + (SPH,SPL)) in
      M[a89] := 16;
      let:16 a90 = (-1 + a89) in
      M[a90] := FF;
      #return-to: 16FF
      advance (17)
      #19D7
      #instruction: XOR  A
      let:8 a91 = (A ^ A) in
      advance (4)
      #19D8
      #instruction: JP   19D3
      advance (10)
      #19D3
      #instruction: LD   (20E9),A
      M[20E9] := a91;
      advance (13)
      #19D6
      #instruction: RET
      let:16 a92 = (1 + a90) in
      let:16 a93 = (1 + a92) in
      advance (10)
      A := a91;
      SPH := a93[15:8];
      SPL := a93[7:0];
      FlagS := a91[7];
      FlagZ := is_zero(a91);
      FlagA := false;
      FlagP := parity(a91);
      FlagCY := false;
      jump ((M[a92],M[a90]));
    }

16FF:

    #instruction: LD   HL,2701
    advance (10)
    #1702
    #instruction: CALL 19FA
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    #return-to: 1705
    advance (17)
    #19FA
    #instruction: LD   B,10
    advance (7)
    #19FC
    #instruction: CALL 14CB
    let:16 a3 = (-1 + a2) in
    M[a3] := 19;
    let:16 a4 = (-1 + a3) in
    M[a4] := FF;
    #return-to: 19FF
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a5 = (A ^ A) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:16 a6 = (-1 + a4) in
    M[a6] := 10;
    let:16 a7 = (-1 + a6) in
    M[a7] := C;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2701] := a5;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a8 = add17(0020,2701) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:16 a9 = (1 + a7) in
    let:16 a10 = (1 + a9) in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:16 a11 = addWithCarry(!true,M[a9],~00) in
    let:8 a12 = (M[a9] & 0F) in
    let:8 a13 = (~00 & 0F) in
    let:16 a14 = addWithCarry(!true,a12,a13) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a11[7:0])) {
      advance (10)
      A := a5;
      B := a11[7:0];
      C := M[a7];
      H := a8[15:0][15:8];
      L := a8[15:0][7:0];
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := a8[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:16 a15 = (1 + a10) in
      let:16 a16 = (1 + a15) in
      advance (10)
      A := a5;
      B := a11[7:0];
      C := M[a7];
      H := a8[15:0][15:8];
      L := a8[15:0][7:0];
      SPH := a16[15:8];
      SPL := a16[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := a8[16];
      jump ((M[a15],M[a10]));
    }

1705:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #1706
    #instruction: CALL 1A8B
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    #return-to: 1709
    advance (17)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a4 = (0F & a1) in
    let:8 a5 = (0F | a1) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:16 a6 = addWithCarry(false,1A,a4) in
    let:8 a7 = (1A & 0F) in
    let:8 a8 = (a4 & 0F) in
    let:16 a9 = addWithCarry(false,a7,a8) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a10 = (-1 + a3) in
    M[a10] := 25;
    let:16 a11 = (-1 + a10) in
    M[a11] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a12 = add17((00,a6[7:0]),(00,a6[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a13 = add17(a12[15:0],a12[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a14 = add17(a13[15:0],a13[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a15 = add17(1E00,a14[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a16 = (1 + a11) in
    let:16 a17 = (1 + a16) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a18 = (-1 + a17) in
    M[a18] := 08;
    let:16 a19 = (-1 + a18) in
    M[a19] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a16],M[a11])] := M[a15[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a20 = (1 + a15[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a21 = add17(0020,(M[a16],M[a11])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a22 = (1 + a19) in
    let:16 a23 = (1 + a22) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a24 = addWithCarry(!true,M[a22],~00) in
    let:8 a25 = (M[a22] & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a24[7:0])) {
      advance (10)
      A := M[a15[15:0]];
      B := a24[7:0];
      C := M[a19];
      D := a20[15:8];
      E := a20[7:0];
      H := a21[15:0][15:8];
      L := a21[15:0][7:0];
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a21[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a28 = (1 + a23) in
      let:16 a29 = (1 + a28) in
      advance (10)
      A := M[a15[15:0]];
      B := a24[7:0];
      C := M[a19];
      D := a20[15:8];
      E := a20[7:0];
      H := a21[15:0][15:8];
      L := a21[15:0][7:0];
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a21[16];
      jump ((M[a28],M[a23]));
    }

1709:

    #instruction: LD   B,FB
    advance (7)
    #170B
    #instruction: JP   196B
    advance (10)
    #196B
    #instruction: CALL 19DC
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 6E;
    #return-to: 196E
    advance (17)
    #19DC
    #instruction: LD   A,(2094)
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a3 = (FB & M[2094]) in
    let:8 a4 = (FB | M[2094]) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    M[2094] := a3;
    advance (13)
    #19E3
    #instruction: OUT  03
    sound_control(Ufo,a3[0]);
    sound_control(Shot,a3[1]);
    sound_control(PlayerDie,a3[2]);
    sound_control(InvaderDie,a3[3]);
    sound_control(ExtraLife,a3[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:16 a5 = (1 + a2) in
    let:16 a6 = (1 + a5) in
    advance (10)
    A := a3;
    B := FB;
    SPH := a6[15:8];
    SPL := a6[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((M[a5],M[a2]));

1711:

    #instruction: INC  HL
    let:16 a1 = (1 + (H,L)) in
    advance (5)
    #1712
    #instruction: LD   A,(HL)
    advance (7)
    #1713
    #instruction: LD   DE,1CB8
    advance (10)
    #1716
    #instruction: LD   HL,1AA1
    advance (10)
    #1719
    #instruction: LD   C,04
    advance (7)
    #171B
    #instruction: LD   B,A
    advance (5)
    #171C
    #instruction: LD   A,(DE)
    advance (7)
    #171D
    #instruction: CP   B
    let:16 a2 = addWithCarry(!false,02,~M[a1]) in
    let:8 a3 = (02 & 0F) in
    let:8 a4 = (~M[a1] & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (4)
    #171E
    #instruction: JP   NC,1727
    if (!!a2[15:8][0]) {
      advance (10)
      #1727
      #instruction: LD   A,(HL)
      advance (7)
      #1728
      #instruction: LD   (20CF),A
      M[20CF] := 30;
      advance (13)
      #172B
      #instruction: RET
      let:16 a6 = (1 + (SPH,SPL)) in
      let:16 a7 = (1 + a6) in
      advance (10)
      A := 30;
      B := M[a1];
      C := 04;
      D := 1C;
      E := B8;
      H := 1A;
      L := A1;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      FlagCY := !a2[15:8][0];
      jump ((M[a6],M[(SPH,SPL)]));
    } else {
      advance (10)
      #1721
      #instruction: INC  HL
      advance (5)
      #1722
      #instruction: INC  DE
      advance (5)
      #1723
      #instruction: DEC  C
      let:16 a8 = addWithCarry(!true,04,~00) in
      let:8 a9 = (04 & 0F) in
      let:8 a10 = (~00 & 0F) in
      let:16 a11 = addWithCarry(!true,a9,a10) in
      advance (5)
      #1724
      #instruction: JP   NZ,171C
      if (!is_zero(a8[7:0])) {
        advance (10)
        A := 02;
        B := M[a1];
        C := a8[7:0];
        D := 1C;
        E := B9;
        H := 1A;
        L := A2;
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := !a2[15:8][0];
        jump (171C);
      } else {
        advance (10)
        #1727
        #instruction: LD   A,(HL)
        advance (7)
        #1728
        #instruction: LD   (20CF),A
        M[20CF] := 10;
        advance (13)
        #172B
        #instruction: RET
        let:16 a12 = (1 + (SPH,SPL)) in
        let:16 a13 = (1 + a12) in
        advance (10)
        A := 10;
        B := M[a1];
        C := a8[7:0];
        D := 1C;
        E := B9;
        H := 1A;
        L := A2;
        SPH := a13[15:8];
        SPL := a13[7:0];
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := !a2[15:8][0];
        jump ((M[a12],M[(SPH,SPL)]));
      }
    }

1747:

    #instruction: LD   A,(2068)
    advance (13)
    #174A
    #instruction: AND  A
    let:8 a1 = (M[2068] & M[2068]) in
    let:8 a2 = (M[2068] | M[2068]) in
    advance (4)
    #174B
    #instruction: JP   Z,176D
    if (is_zero(a1)) {
      advance (10)
      #176D
      #instruction: LD   A,(2098)
      advance (13)
      #1770
      #instruction: AND  30
      let:8 a3 = (30 & M[2098]) in
      let:8 a4 = (30 | M[2098]) in
      advance (7)
      #1772
      #instruction: OUT  05
      sound_control(FleetMovement1,a3[0]);
      sound_control(FleetMovement2,a3[1]);
      sound_control(FleetMovement3,a3[2]);
      sound_control(FleetMovement4,a3[3]);
      sound_control(UfoHit,a3[4]);
      advance (10)
      #1774
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[(SPH,SPL)]));
    } else {
      advance (10)
      #174E
      #instruction: LD   HL,2096
      advance (10)
      #1751
      #instruction: DEC  (HL)
      let:16 a7 = addWithCarry(!true,M[2096],~00) in
      let:8 a8 = (M[2096] & 0F) in
      let:8 a9 = (~00 & 0F) in
      let:16 a10 = addWithCarry(!true,a8,a9) in
      M[2096] := a7[7:0];
      advance (10)
      #1752
      #instruction: RET  NZ
      if (!is_zero(a7[7:0])) {
        let:16 a11 = (1 + (SPH,SPL)) in
        let:16 a12 = (1 + a11) in
        advance (11)
        A := a1;
        H := 20;
        L := 96;
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := false;
        jump ((M[a11],M[(SPH,SPL)]));
      } else {
        advance (5)
        #1753
        #instruction: LD   HL,2098
        advance (10)
        #1756
        #instruction: LD   A,(HL)
        advance (7)
        #1757
        #instruction: OUT  05
        sound_control(FleetMovement1,M[2098][0]);
        sound_control(FleetMovement2,M[2098][1]);
        sound_control(FleetMovement3,M[2098][2]);
        sound_control(FleetMovement4,M[2098][3]);
        sound_control(UfoHit,M[2098][4]);
        advance (10)
        #1759
        #instruction: LD   A,(2082)
        advance (13)
        #175C
        #instruction: AND  A
        let:8 a13 = (M[2082] & M[2082]) in
        let:8 a14 = (M[2082] | M[2082]) in
        advance (4)
        #175D
        #instruction: JP   Z,176D
        if (is_zero(a13)) {
          advance (10)
          #176D
          #instruction: LD   A,(2098)
          advance (13)
          #1770
          #instruction: AND  30
          let:8 a15 = (30 & M[2098]) in
          let:8 a16 = (30 | M[2098]) in
          advance (7)
          #1772
          #instruction: OUT  05
          sound_control(FleetMovement1,a15[0]);
          sound_control(FleetMovement2,a15[1]);
          sound_control(FleetMovement3,a15[2]);
          sound_control(FleetMovement4,a15[3]);
          sound_control(UfoHit,a15[4]);
          advance (10)
          #1774
          #instruction: RET
          let:16 a17 = (1 + (SPH,SPL)) in
          let:16 a18 = (1 + a17) in
          advance (10)
          A := a15;
          H := 20;
          L := 98;
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := false;
          jump ((M[a17],M[(SPH,SPL)]));
        } else {
          advance (10)
          #1760
          #instruction: DEC  HL
          advance (5)
          #1761
          #instruction: LD   A,(HL)
          advance (7)
          #1762
          #instruction: DEC  HL
          advance (5)
          #1763
          #instruction: LD   (HL),A
          M[2096] := M[2097];
          advance (7)
          #1764
          #instruction: DEC  HL
          advance (5)
          #1765
          #instruction: LD   (HL),01
          M[2095] := 01;
          advance (10)
          #1767
          #instruction: LD   A,04
          advance (7)
          #1769
          #instruction: LD   (209B),A
          M[209B] := 04;
          advance (13)
          #176C
          #instruction: RET
          let:16 a19 = (1 + (SPH,SPL)) in
          let:16 a20 = (1 + a19) in
          advance (10)
          A := 04;
          H := 20;
          L := 95;
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a13[7];
          FlagZ := is_zero(a13);
          FlagA := a14[3];
          FlagP := parity(a13);
          FlagCY := false;
          jump ((M[a19],M[(SPH,SPL)]));
        }
      }
    }

17B4:

    #instruction: LD   B,EF
    advance (7)
    #17B6
    #instruction: LD   HL,2098
    advance (10)
    #17B9
    #instruction: LD   A,(HL)
    advance (7)
    #17BA
    #instruction: AND  B
    let:8 a1 = (EF & M[2098]) in
    let:8 a2 = (EF | M[2098]) in
    advance (4)
    #17BB
    #instruction: LD   (HL),A
    M[2098] := a1;
    advance (7)
    #17BC
    #instruction: OUT  05
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    #17BE
    #instruction: RET
    let:16 a3 = (1 + (SPH,SPL)) in
    let:16 a4 = (1 + a3) in
    advance (10)
    A := a1;
    B := EF;
    H := 20;
    L := 98;
    SPH := a4[15:8];
    SPL := a4[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := a2[3];
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a3],M[(SPH,SPL)]));

17DF:

    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,B,~00) in
    let:8 a2 = (B & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #17E0
    #instruction: JP   NZ,17DC
    if (!is_zero(a1[7:0])) {
      advance (10)
      #17DC
      #instruction: CALL 09D6
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 17;
      let:16 a6 = (-1 + a5) in
      M[a6] := DF;
      #return-to: 17DF
      advance (17)
      #09D6
      #instruction: LD   HL,2402
      advance (10)
      #09D9
      #instruction: LD   (HL),00
      M[2402] := 00;
      advance (10)
      #09DB
      #instruction: INC  HL
      advance (5)
      #09DC
      #instruction: LD   A,L
      advance (5)
      #09DD
      #instruction: AND  1F
      let:8 a7 = (1F & 03) in
      let:8 a8 = (1F | 03) in
      advance (7)
      #09DF
      #instruction: CP   1C
      let:16 a9 = addWithCarry(!false,a7,~1C) in
      let:8 a10 = (a7 & 0F) in
      let:8 a11 = (~1C & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #09E1
      #instruction: JP   CY,09E8
      if (!a9[15:8][0]) {
        advance (10)
        #09E8
        #instruction: LD   A,H
        advance (5)
        #09E9
        #instruction: CP   40
        let:16 a13 = addWithCarry(!false,24,~40) in
        let:8 a14 = (24 & 0F) in
        let:8 a15 = (~40 & 0F) in
        let:16 a16 = addWithCarry(!false,a14,a15) in
        advance (7)
        #09EB
        #instruction: JP   CY,09D9
        if (!a13[15:8][0]) {
          advance (10)
          A := 24;
          B := a1[7:0];
          H := 24;
          L := 03;
          SPH := a6[15:8];
          SPL := a6[7:0];
          FlagS := a13[7:0][7];
          FlagZ := is_zero(a13[7:0]);
          FlagA := a16[7:0][4];
          FlagP := parity(a13[7:0]);
          FlagCY := !a13[15:8][0];
          jump (09D9);
        } else {
          advance (10)
          #09EE
          #instruction: RET
          let:16 a17 = (1 + a6) in
          let:16 a18 = (1 + a17) in
          advance (10)
          A := 24;
          B := a1[7:0];
          H := 24;
          L := 03;
          SPH := a18[15:8];
          SPL := a18[7:0];
          FlagS := a13[7:0][7];
          FlagZ := is_zero(a13[7:0]);
          FlagA := a16[7:0][4];
          FlagP := parity(a13[7:0]);
          FlagCY := !a13[15:8][0];
          jump ((M[a17],M[a6]));
        }
      } else {
        advance (10)
        #09E4
        #instruction: LD   DE,0006
        advance (10)
        #09E7
        #instruction: ADD  HL,DE
        let:17 a19 = add17(0006,2403) in
        advance (10)
        #09E8
        #instruction: LD   A,H
        advance (5)
        #09E9
        #instruction: CP   40
        let:16 a20 = addWithCarry(!false,a19[15:0][15:8],~40) in
        let:8 a21 = (a19[15:0][15:8] & 0F) in
        let:8 a22 = (~40 & 0F) in
        let:16 a23 = addWithCarry(!false,a21,a22) in
        advance (7)
        #09EB
        #instruction: JP   CY,09D9
        if (!a20[15:8][0]) {
          advance (10)
          A := a19[15:0][15:8];
          B := a1[7:0];
          D := 00;
          E := 06;
          H := a19[15:0][15:8];
          L := a19[15:0][7:0];
          SPH := a6[15:8];
          SPL := a6[7:0];
          FlagS := a20[7:0][7];
          FlagZ := is_zero(a20[7:0]);
          FlagA := a23[7:0][4];
          FlagP := parity(a20[7:0]);
          FlagCY := !a20[15:8][0];
          jump (09D9);
        } else {
          advance (10)
          #09EE
          #instruction: RET
          let:16 a24 = (1 + a6) in
          let:16 a25 = (1 + a24) in
          advance (10)
          A := a19[15:0][15:8];
          B := a1[7:0];
          D := 00;
          E := 06;
          H := a19[15:0][15:8];
          L := a19[15:0][7:0];
          SPH := a25[15:8];
          SPL := a25[7:0];
          FlagS := a20[7:0][7];
          FlagZ := is_zero(a20[7:0]);
          FlagA := a23[7:0][4];
          FlagP := parity(a20[7:0]);
          FlagCY := !a20[15:8][0];
          jump ((M[a24],M[a6]));
        }
      }
    } else {
      advance (10)
      #17E3
      #instruction: LD   A,01
      advance (7)
      #17E5
      #instruction: LD   (209A),A
      M[209A] := 01;
      advance (13)
      #17E8
      #instruction: CALL 19D7
      let:16 a26 = (-1 + (SPH,SPL)) in
      M[a26] := 17;
      let:16 a27 = (-1 + a26) in
      M[a27] := EB;
      #return-to: 17EB
      advance (17)
      #19D7
      #instruction: XOR  A
      let:8 a28 = (01 ^ 01) in
      advance (4)
      #19D8
      #instruction: JP   19D3
      advance (10)
      #19D3
      #instruction: LD   (20E9),A
      M[20E9] := a28;
      advance (13)
      #19D6
      #instruction: RET
      let:16 a29 = (1 + a27) in
      let:16 a30 = (1 + a29) in
      advance (10)
      A := a28;
      B := a1[7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a28[7];
      FlagZ := is_zero(a28);
      FlagA := false;
      FlagP := parity(a28);
      FlagCY := false;
      jump ((M[a29],M[a27]));
    }

17EB:

    #instruction: EI
    enable_interrupts()
    advance (4)
    #17EC
    #instruction: LD   DE,1CBC
    advance (10)
    #17EF
    #instruction: LD   HL,3016
    advance (10)
    #17F2
    #instruction: LD   C,04
    advance (7)
    #17F4
    #instruction: CALL 0A93
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := F7;
    #return-to: 17F7
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1C;
    let:16 a4 = (-1 + a3) in
    M[a4] := BC;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 0A;
    let:16 a6 = (-1 + a5) in
    M[a6] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 30;
    let:16 a8 = (-1 + a7) in
    M[a8] := 16;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(0013,0013) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 04;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

17F7:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 17;
    let:16 a2 = (-1 + a1) in
    M[a2] := FA;
    #return-to: 17FA
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

17FA:

    #instruction: XOR  A
    let:8 a1 = (A ^ A) in
    advance (4)
    #17FB
    #instruction: LD   (209A),A
    M[209A] := a1;
    advance (13)
    #17FE
    #instruction: LD   (2093),A
    M[2093] := a1;
    advance (13)
    #1801
    #instruction: JP   16C9
    advance (10)
    #16C9
    #instruction: LD   HL,2D18
    advance (10)
    #16CC
    #instruction: LD   DE,1AA6
    advance (10)
    #16CF
    #instruction: LD   C,0A
    advance (7)
    #16D1
    #instruction: CALL 0A93
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := D4;
    #return-to: 16D4
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:16 a4 = (-1 + a3) in
    M[a4] := 1A;
    let:16 a5 = (-1 + a4) in
    M[a5] := A6;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:16 a6 = (-1 + a5) in
    M[a6] := 0A;
    let:16 a7 = (-1 + a6) in
    M[a7] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a8 = (-1 + a7) in
    M[a8] := 2D;
    let:16 a9 = (-1 + a8) in
    M[a9] := 18;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a10 = add17(0006,0006) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a12 = add17(a11[15:0],a11[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a13 = add17(1E00,a12[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a14 = (1 + a9) in
    let:16 a15 = (1 + a14) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a16 = (-1 + a15) in
    M[a16] := 08;
    let:16 a17 = (-1 + a16) in
    M[a17] := 0A;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a14],M[a9])] := M[a13[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a18 = (1 + a13[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a19 = add17(0020,(M[a14],M[a9])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a20 = (1 + a17) in
    let:16 a21 = (1 + a20) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a22 = addWithCarry(!true,M[a20],~00) in
    let:8 a23 = (M[a20] & 0F) in
    let:8 a24 = (~00 & 0F) in
    let:16 a25 = addWithCarry(!true,a23,a24) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a22[7:0])) {
      advance (10)
      A := M[a13[15:0]];
      B := a22[7:0];
      C := M[a17];
      D := a18[15:8];
      E := a18[7:0];
      H := a19[15:0][15:8];
      L := a19[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a22[7:0][7];
      FlagZ := is_zero(a22[7:0]);
      FlagA := a25[7:0][4];
      FlagP := parity(a22[7:0]);
      FlagCY := a19[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a26 = (1 + a21) in
      let:16 a27 = (1 + a26) in
      advance (10)
      A := M[a13[15:0]];
      B := a22[7:0];
      C := M[a17];
      D := a18[15:8];
      E := a18[7:0];
      H := a19[15:0][15:8];
      L := a19[15:0][7:0];
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a22[7:0][7];
      FlagZ := is_zero(a22[7:0]);
      FlagA := a25[7:0][4];
      FlagP := parity(a22[7:0]);
      FlagCY := a19[16];
      jump ((M[a26],M[a21]));
    }

1820:

    #instruction: LD   A,0A
    advance (7)
    #1822
    #instruction: LD   (206C),A
    M[206C] := 0A;
    advance (13)
    #1825
    #instruction: LD   BC,1DBE
    advance (10)
    #1828
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2B;
    #return-to: 182B
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,0E,~FF) in
    let:8 a4 = (0E & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := 0E;
      B := 1D;
      C := BE;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := true;
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a9 = (1D & 1D) in
      let:8 a10 = (1D | 1D) in
      advance (4)
      #1867
      #instruction: RET
      let:16 a11 = (1 + a2) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := a9;
      B := 1D;
      C := C2;
      D := 1D;
      E := 68;
      H := 2C;
      L := 0E;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := a10[3];
      FlagP := parity(a9);
      FlagCY := false;
      jump ((M[a11],M[a2]));
    }

182B:

    #instruction: JP   CY,1837
    if (FlagCY) {
      advance (10)
      jump (1837);
    } else {
      advance (10)
      #182E
      #instruction: CALL 1844
      let:16 a1 = (-1 + (SPH,SPL)) in
      M[a1] := 18;
      let:16 a2 = (-1 + a1) in
      M[a2] := 31;
      #return-to: 1831
      advance (17)
      #1844
      #instruction: PUSH BC
      let:16 a3 = (-1 + a2) in
      M[a3] := B;
      let:16 a4 = (-1 + a3) in
      M[a4] := C;
      advance (11)
      #1845
      #instruction: LD   B,10
      advance (7)
      #1847
      #instruction: CALL 1439
      let:16 a5 = (-1 + a4) in
      M[a5] := 18;
      let:16 a6 = (-1 + a5) in
      M[a6] := 4A;
      #return-to: 184A
      advance (17)
      #1439
      #instruction: PUSH BC
      let:16 a7 = (-1 + a6) in
      M[a7] := 10;
      let:16 a8 = (-1 + a7) in
      M[a8] := C;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(H,L)] := M[(D,E)];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a9 = (1 + (D,E)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a10 = add17(0020,(H,L)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a11 = (1 + a8) in
      let:16 a12 = (1 + a11) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a13 = addWithCarry(!true,M[a11],~00) in
      let:8 a14 = (M[a11] & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a13[7:0])) {
        advance (10)
        A := M[(D,E)];
        B := a13[7:0];
        C := M[a8];
        D := a9[15:8];
        E := a9[7:0];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a17 = (1 + a12) in
        let:16 a18 = (1 + a17) in
        advance (10)
        A := M[(D,E)];
        B := a13[7:0];
        C := M[a8];
        D := a9[15:8];
        E := a9[7:0];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump ((M[a17],M[a12]));
      }
    }

1831:

    #instruction: JP   1828
    advance (10)
    #1828
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 2B;
    #return-to: 182B
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[(B,C)],~FF) in
    let:8 a4 = (M[(B,C)] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[(B,C)];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := true;
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      let:16 a9 = (1 + (B,C)) in
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      let:16 a10 = (1 + a9) in
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      let:16 a11 = (1 + a10) in
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      let:16 a12 = (1 + a11) in
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a13 = (M[a11] & M[a11]) in
      let:8 a14 = (M[a11] | M[a11]) in
      advance (4)
      #1867
      #instruction: RET
      let:16 a15 = (1 + a2) in
      let:16 a16 = (1 + a15) in
      advance (10)
      A := a13;
      B := a12[15:8];
      C := a12[7:0];
      D := M[a11];
      E := M[a10];
      H := M[a9];
      L := M[(B,C)];
      SPH := a16[15:8];
      SPL := a16[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := a14[3];
      FlagP := parity(a13);
      FlagCY := false;
      jump ((M[a15],M[a2]));
    }

1834:

    #instruction: CALL 0AB1
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 37;
    #return-to: 1837
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a3 = (M[20C0] & M[20C0]) in
    let:8 a4 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      SPH := a2[15:8];
      SPL := a2[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a5 = (1 + a2) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := a3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((M[a5],M[a2]));
    }

1837:

    #instruction: LD   BC,1DCF
    advance (10)
    #183A
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3D;
    #return-to: 183D
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,0E,~FF) in
    let:8 a4 = (0E & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := 0E;
      B := 1D;
      C := CF;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := true;
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a9 = (1D & 1D) in
      let:8 a10 = (1D | 1D) in
      advance (4)
      #1867
      #instruction: RET
      let:16 a11 = (1 + a2) in
      let:16 a12 = (1 + a11) in
      advance (10)
      A := a9;
      B := 1D;
      C := D3;
      D := 1D;
      E := E0;
      H := 2E;
      L := 0E;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := a10[3];
      FlagP := parity(a9);
      FlagCY := false;
      jump ((M[a11],M[a2]));
    }

183D:

    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = (1 + (SPH,SPL)) in
      let:16 a2 = (1 + a1) in
      advance (11)
      SPH := a2[15:8];
      SPL := a2[7:0];
      jump ((M[a1],M[(SPH,SPL)]));
    } else {
      advance (5)
      #183E
      #instruction: CALL 184C
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 18;
      let:16 a4 = (-1 + a3) in
      M[a4] := 41;
      #return-to: 1841
      advance (17)
      #184C
      #instruction: PUSH BC
      let:16 a5 = (-1 + a4) in
      M[a5] := B;
      let:16 a6 = (-1 + a5) in
      M[a6] := C;
      advance (11)
      #184D
      #instruction: LD   A,(206C)
      advance (13)
      #1850
      #instruction: LD   C,A
      advance (5)
      #1851
      #instruction: CALL 0A93
      let:16 a7 = (-1 + a6) in
      M[a7] := 18;
      let:16 a8 = (-1 + a7) in
      M[a8] := 54;
      #return-to: 1854
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:16 a9 = (-1 + a8) in
      M[a9] := D;
      let:16 a10 = (-1 + a9) in
      M[a10] := E;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:16 a11 = (-1 + a10) in
      M[a11] := 0A;
      let:16 a12 = (-1 + a11) in
      M[a12] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:16 a13 = (-1 + a12) in
      M[a13] := H;
      let:16 a14 = (-1 + a13) in
      M[a14] := L;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a15 = add17((00,M[(D,E)]),(00,M[(D,E)])) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:17 a16 = add17(a15[15:0],a15[15:0]) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:17 a17 = add17(a16[15:0],a16[15:0]) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:17 a18 = add17(1E00,a17[15:0]) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      advance (4)
      #090B
      #instruction: POP  HL
      let:16 a19 = (1 + a14) in
      let:16 a20 = (1 + a19) in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:16 a21 = (-1 + a20) in
      M[a21] := 08;
      let:16 a22 = (-1 + a21) in
      M[a22] := M[206C];
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(M[a19],M[a14])] := M[a18[15:0]];
      advance (7)
      #143C
      #instruction: INC  DE
      let:16 a23 = (1 + a18[15:0]) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a24 = add17(0020,(M[a19],M[a14])) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a25 = (1 + a22) in
      let:16 a26 = (1 + a25) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a27 = addWithCarry(!true,M[a25],~00) in
      let:8 a28 = (M[a25] & 0F) in
      let:8 a29 = (~00 & 0F) in
      let:16 a30 = addWithCarry(!true,a28,a29) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a27[7:0])) {
        advance (10)
        A := M[a18[15:0]];
        B := a27[7:0];
        C := M[a22];
        D := a23[15:8];
        E := a23[7:0];
        H := a24[15:0][15:8];
        L := a24[15:0][7:0];
        SPH := a26[15:8];
        SPL := a26[7:0];
        FlagS := a27[7:0][7];
        FlagZ := is_zero(a27[7:0]);
        FlagA := a30[7:0][4];
        FlagP := parity(a27[7:0]);
        FlagCY := a24[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a31 = (1 + a26) in
        let:16 a32 = (1 + a31) in
        advance (10)
        A := M[a18[15:0]];
        B := a27[7:0];
        C := M[a22];
        D := a23[15:8];
        E := a23[7:0];
        H := a24[15:0][15:8];
        L := a24[15:0][7:0];
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a27[7:0][7];
        FlagZ := is_zero(a27[7:0]);
        FlagA := a30[7:0][4];
        FlagP := parity(a27[7:0]);
        FlagCY := a24[16];
        jump ((M[a31],M[a26]));
      }
    }

1841:

    #instruction: JP   183A
    advance (10)
    #183A
    #instruction: CALL 1856
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := 3D;
    #return-to: 183D
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a3 = addWithCarry(!false,M[(B,C)],~FF) in
    let:8 a4 = (M[(B,C)] & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:16 a7 = (1 + a2) in
      let:16 a8 = (1 + a7) in
      advance (11)
      A := M[(B,C)];
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := true;
      jump ((M[a7],M[a2]));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      let:16 a9 = (1 + (B,C)) in
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      let:16 a10 = (1 + a9) in
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      let:16 a11 = (1 + a10) in
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      let:16 a12 = (1 + a11) in
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a13 = (M[a11] & M[a11]) in
      let:8 a14 = (M[a11] | M[a11]) in
      advance (4)
      #1867
      #instruction: RET
      let:16 a15 = (1 + a2) in
      let:16 a16 = (1 + a15) in
      advance (10)
      A := a13;
      B := a12[15:8];
      C := a12[7:0];
      D := M[a11];
      E := M[a10];
      H := M[a9];
      L := M[(B,C)];
      SPH := a16[15:8];
      SPL := a16[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := a14[3];
      FlagP := parity(a13);
      FlagCY := false;
      jump ((M[a15],M[a2]));
    }

184A:

    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #184B
    #instruction: RET
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a4[15:8];
    SPL := a4[7:0];
    jump ((M[a3],M[a2]));

1854:

    #instruction: POP  BC
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #1855
    #instruction: RET
    let:16 a3 = (1 + a2) in
    let:16 a4 = (1 + a3) in
    advance (10)
    B := M[a1];
    C := M[(SPH,SPL)];
    SPH := a4[15:8];
    SPL := a4[7:0];
    jump ((M[a3],M[a2]));

1871:

    #instruction: LD   B,A
    advance (5)
    #1872
    #instruction: LD   A,(20CA)
    advance (13)
    #1875
    #instruction: CP   B
    let:16 a1 = addWithCarry(!false,M[20CA],~A) in
    let:8 a2 = (M[20CA] & 0F) in
    let:8 a3 = (~A & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (4)
    #1876
    #instruction: JP   Z,1898
    if (is_zero(a1[7:0])) {
      advance (10)
      #1898
      #instruction: LD   A,01
      advance (7)
      #189A
      #instruction: LD   (20CB),A
      M[20CB] := 01;
      advance (13)
      #189D
      #instruction: RET
      let:16 a5 = (1 + (SPH,SPL)) in
      let:16 a6 = (1 + a5) in
      advance (10)
      A := 01;
      B := A;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump ((M[a5],M[(SPH,SPL)]));
    } else {
      advance (10)
      #1879
      #instruction: LD   A,(20C2)
      advance (13)
      #187C
      #instruction: AND  04
      let:8 a7 = (04 & M[20C2]) in
      let:8 a8 = (04 | M[20C2]) in
      advance (7)
      #187E
      #instruction: LD   HL,(20CC)
      advance (16)
      #1881
      #instruction: JP   NZ,1888
      if (!is_zero(a7)) {
        advance (10)
        #1888
        #instruction: LD   (20C7),HL
        M[20C7] := M[20CC];
        M[20C8] := M[20CD];
        advance (16)
        #188B
        #instruction: LD   HL,20C5
        advance (10)
        #188E
        #instruction: CALL 1A3B
        let:16 a9 = (-1 + (SPH,SPL)) in
        M[a9] := 18;
        let:16 a10 = (-1 + a9) in
        M[a10] := 91;
        #return-to: 1891
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a11 = (1 + a10) in
        let:16 a12 = (1 + a11) in
        advance (10)
        A := M[20C7];
        B := M[20C9];
        C := M[20C8];
        D := M[20C6];
        E := M[20C5];
        H := M[20C8];
        L := M[20C7];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a7[7];
        FlagZ := is_zero(a7);
        FlagA := a8[3];
        FlagP := parity(a7);
        FlagCY := false;
        jump ((M[a11],M[a10]));
      } else {
        advance (10)
        #1884
        #instruction: LD   DE,0030
        advance (10)
        #1887
        #instruction: ADD  HL,DE
        let:17 a13 = add17(0030,(M[20CD],M[20CC])) in
        advance (10)
        #1888
        #instruction: LD   (20C7),HL
        M[20C7] := a13[15:0][7:0];
        M[20C8] := a13[15:0][15:8];
        advance (16)
        #188B
        #instruction: LD   HL,20C5
        advance (10)
        #188E
        #instruction: CALL 1A3B
        let:16 a14 = (-1 + (SPH,SPL)) in
        M[a14] := 18;
        let:16 a15 = (-1 + a14) in
        M[a15] := 91;
        #return-to: 1891
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        advance (7)
        #1A44
        #instruction: LD   H,C
        advance (5)
        #1A45
        #instruction: LD   L,A
        advance (5)
        #1A46
        #instruction: RET
        let:16 a16 = (1 + a15) in
        let:16 a17 = (1 + a16) in
        advance (10)
        A := M[20C7];
        B := M[20C9];
        C := M[20C8];
        D := M[20C6];
        E := M[20C5];
        H := M[20C8];
        L := M[20C7];
        SPH := a17[15:8];
        SPL := a17[7:0];
        FlagS := a7[7];
        FlagZ := is_zero(a7);
        FlagA := a8[3];
        FlagP := parity(a7);
        FlagCY := a13[16];
        jump ((M[a16],M[a15]));
      }
    }

1891:

    #instruction: EX   DE,HL
    advance (4)
    #1892
    #instruction: JP   15D3
    advance (10)
    #15D3
    #instruction: CALL 1474
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 15;
    let:16 a2 = (-1 + a1) in
    M[a2] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a3 = (07 & E) in
    let:8 a4 = (07 | E) in
    advance (7)
    #1477
    #instruction: OUT  02
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:16 a5 = (-1 + a2) in
    M[a5] := B;
    let:16 a6 = (-1 + a5) in
    M[a6] := C;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    advance (5)
    #1A4B
    #instruction: RAR
    advance (4)
    #1A4C
    #instruction: LD   H,A
    advance (5)
    #1A4D
    #instruction: LD   A,L
    advance (5)
    #1A4E
    #instruction: RAR
    advance (4)
    #1A4F
    #instruction: LD   L,A
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,03,~00) in
    let:8 a8 = (03 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := updateBit((E >> 01),7,D[0]);
      B := a7[7:0];
      D := H;
      E := L;
      H := updateBit((D >> 01),7,false);
      L := updateBit((E >> 01),7,D[0]);
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := E[0];
      Shifter_OFF := a3;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a11 = (3F & updateBit((D >> 01),7,false)) in
      let:8 a12 = (3F | updateBit((D >> 01),7,false)) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a13 = (20 | a11) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:16 a14 = (1 + a6) in
      let:16 a15 = (1 + a14) in
      advance (10)
      #1A5B
      #instruction: RET
      let:16 a16 = (1 + a15) in
      let:16 a17 = (1 + a16) in
      advance (10)
      A := a13;
      B := M[a14];
      C := M[a6];
      D := H;
      E := L;
      H := a13;
      L := updateBit((E >> 01),7,D[0]);
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a13[7];
      FlagZ := is_zero(a13);
      FlagA := false;
      FlagP := parity(a13);
      FlagCY := false;
      Shifter_OFF := a3;
      jump ((M[a16],M[a15]));
    }

18A9:

    #instruction: LD   A,02
    advance (7)
    #18AB
    #instruction: LD   (2080),A
    M[2080] := 02;
    advance (13)
    #18AE
    #instruction: LD   A,FF
    advance (7)
    #18B0
    #instruction: LD   (207E),A
    M[207E] := FF;
    advance (13)
    #18B3
    #instruction: LD   A,04
    advance (7)
    #18B5
    #instruction: LD   (20C1),A
    M[20C1] := 04;
    advance (13)
    #18B8
    #instruction: LD   A,(2055)
    advance (13)
    #18BB
    #instruction: AND  01
    let:8 a1 = (01 & M[2055]) in
    let:8 a2 = (01 | M[2055]) in
    advance (7)
    #18BD
    #instruction: JP   Z,18B8
    if (is_zero(a1)) {
      advance (10)
      A := a1;
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump (18B8);
    } else {
      advance (10)
      #18C0
      #instruction: LD   A,(2055)
      advance (13)
      #18C3
      #instruction: AND  01
      let:8 a3 = (01 & M[2055]) in
      let:8 a4 = (01 | M[2055]) in
      advance (7)
      #18C5
      #instruction: JP   NZ,18C0
      if (!is_zero(a3)) {
        advance (10)
        A := a3;
        FlagS := a3[7];
        FlagZ := is_zero(a3);
        FlagA := a4[3];
        FlagP := parity(a3);
        FlagCY := false;
        jump (18C0);
      } else {
        advance (10)
        #18C8
        #instruction: LD   HL,3311
        advance (10)
        #18CB
        #instruction: LD   A,26
        advance (7)
        #18CD
        #instruction: NOP
        advance (4)
        #18CE
        #instruction: CALL 08FF
        let:16 a5 = (-1 + (SPH,SPL)) in
        M[a5] := 18;
        let:16 a6 = (-1 + a5) in
        M[a6] := D1;
        #return-to: 18D1
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:16 a7 = (-1 + a6) in
        M[a7] := 33;
        let:16 a8 = (-1 + a7) in
        M[a8] := 11;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a9 = add17(0026,0026) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:17 a10 = add17(a9[15:0],a9[15:0]) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:17 a11 = add17(a10[15:0],a10[15:0]) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:17 a12 = add17(1E00,a11[15:0]) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        advance (4)
        #090B
        #instruction: POP  HL
        let:16 a13 = (1 + a8) in
        let:16 a14 = (1 + a13) in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:16 a15 = (-1 + a14) in
        M[a15] := 08;
        let:16 a16 = (-1 + a15) in
        M[a16] := C;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[(M[a13],M[a8])] := M[a12[15:0]];
        advance (7)
        #143C
        #instruction: INC  DE
        let:16 a17 = (1 + a12[15:0]) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a18 = add17(0020,(M[a13],M[a8])) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a19 = (1 + a16) in
        let:16 a20 = (1 + a19) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a21 = addWithCarry(!true,M[a19],~00) in
        let:8 a22 = (M[a19] & 0F) in
        let:8 a23 = (~00 & 0F) in
        let:16 a24 = addWithCarry(!true,a22,a23) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a21[7:0])) {
          advance (10)
          A := M[a12[15:0]];
          B := a21[7:0];
          C := M[a16];
          D := a17[15:8];
          E := a17[7:0];
          H := a18[15:0][15:8];
          L := a18[15:0][7:0];
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := a18[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a25 = (1 + a20) in
          let:16 a26 = (1 + a25) in
          advance (10)
          A := M[a12[15:0]];
          B := a21[7:0];
          C := M[a16];
          D := a17[15:8];
          E := a17[7:0];
          H := a18[15:0][15:8];
          L := a18[15:0][7:0];
          SPH := a26[15:8];
          SPL := a26[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := a18[16];
          jump ((M[a25],M[a20]));
        }
      }
    }

18D1:

    #instruction: JP   0AB6
    advance (10)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a1 = (M[20C0] & M[20C0]) in
    let:8 a2 = (M[20C0] | M[20C0]) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a1)) {
      advance (10)
      A := a1;
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (10)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    }

18DC:

    #instruction: CALL 1956
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 18;
    let:16 a2 = (-1 + a1) in
    M[a2] := DF;
    #return-to: 18DF
    advance (17)
    #1956
    #instruction: CALL 1A5C
    let:16 a3 = (-1 + a2) in
    M[a3] := 19;
    let:16 a4 = (-1 + a3) in
    M[a4] := 59;
    #return-to: 1959
    advance (17)
    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    #1A5F
    #instruction: LD   (HL),00
    M[2400] := 00;
    advance (10)
    #1A61
    #instruction: INC  HL
    advance (5)
    #1A62
    #instruction: LD   A,H
    advance (5)
    #1A63
    #instruction: CP   40
    let:16 a5 = addWithCarry(!false,24,~40) in
    let:8 a6 = (24 & 0F) in
    let:8 a7 = (~40 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #1A65
    #instruction: JP   NZ,1A5F
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump (1A5F);
    } else {
      advance (10)
      #1A68
      #instruction: RET
      let:16 a9 = (1 + a4) in
      let:16 a10 = (1 + a9) in
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((M[a9],M[a4]));
    }

18DF:

    #instruction: LD   A,08
    advance (7)
    #18E1
    #instruction: LD   (20CF),A
    M[20CF] := 08;
    advance (13)
    #18E4
    #instruction: JP   0AEA
    advance (10)
    #0AEA
    #instruction: XOR  A
    let:8 a1 = (08 ^ 08) in
    advance (4)
    #0AEB
    #instruction: OUT  03
    sound_control(Ufo,a1[0]);
    sound_control(Shot,a1[1]);
    sound_control(PlayerDie,a1[2]);
    sound_control(InvaderDie,a1[3]);
    sound_control(ExtraLife,a1[4]);
    advance (10)
    #0AED
    #instruction: OUT  05
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    #0AEF
    #instruction: CALL 1982
    let:16 a2 = (-1 + (SPH,SPL)) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := F2;
    #return-to: 0AF2
    advance (17)
    #1982
    #instruction: LD   (20C1),A
    M[20C1] := a1;
    advance (13)
    #1985
    #instruction: RET
    let:16 a4 = (1 + a3) in
    let:16 a5 = (1 + a4) in
    advance (10)
    A := a1;
    SPH := a5[15:8];
    SPL := a5[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((M[a4],M[a3]));

190D:

    #instruction: JP   1597
    advance (10)
    #1597
    #instruction: LD   A,(200D)
    advance (13)
    #159A
    #instruction: AND  A
    let:8 a1 = (M[200D] & M[200D]) in
    let:8 a2 = (M[200D] | M[200D]) in
    advance (4)
    #159B
    #instruction: JP   NZ,15B7
    if (!is_zero(a1)) {
      advance (10)
      #15B7
      #instruction: LD   HL,2524
      advance (10)
      #15BA
      #instruction: CALL 15C5
      let:16 a3 = (-1 + (SPH,SPL)) in
      M[a3] := 15;
      let:16 a4 = (-1 + a3) in
      M[a4] := BD;
      #return-to: 15BD
      advance (17)
      #15C5
      #instruction: LD   B,17
      advance (7)
      #15C7
      #instruction: LD   A,(HL)
      advance (7)
      #15C8
      #instruction: AND  A
      let:8 a5 = (M[2524] & M[2524]) in
      let:8 a6 = (M[2524] | M[2524]) in
      advance (4)
      #15C9
      #instruction: JP   NZ,166B
      if (!is_zero(a5)) {
        advance (10)
        #166B
        #instruction: SCF
        advance (4)
        #166C
        #instruction: RET
        let:16 a7 = (1 + a4) in
        let:16 a8 = (1 + a7) in
        advance (10)
        A := a5;
        B := 17;
        H := 25;
        L := 24;
        SPH := a8[15:8];
        SPL := a8[7:0];
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := true;
        jump ((M[a7],M[a4]));
      } else {
        advance (10)
        #15CC
        #instruction: INC  HL
        advance (5)
        #15CD
        #instruction: DEC  B
        let:16 a9 = addWithCarry(!true,17,~00) in
        let:8 a10 = (17 & 0F) in
        let:8 a11 = (~00 & 0F) in
        let:16 a12 = addWithCarry(!true,a10,a11) in
        advance (5)
        #15CE
        #instruction: JP   NZ,15C7
        if (!is_zero(a9[7:0])) {
          advance (10)
          A := a5;
          B := a9[7:0];
          H := 25;
          L := 25;
          SPH := a4[15:8];
          SPL := a4[7:0];
          FlagS := a9[7:0][7];
          FlagZ := is_zero(a9[7:0]);
          FlagA := a12[7:0][4];
          FlagP := parity(a9[7:0]);
          FlagCY := false;
          jump (15C7);
        } else {
          advance (10)
          #15D1
          #instruction: RET
          let:16 a13 = (1 + a4) in
          let:16 a14 = (1 + a13) in
          advance (10)
          A := a5;
          B := a9[7:0];
          H := 25;
          L := 25;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a9[7:0][7];
          FlagZ := is_zero(a9[7:0]);
          FlagA := a12[7:0][4];
          FlagP := parity(a9[7:0]);
          FlagCY := false;
          jump ((M[a13],M[a4]));
        }
      }
    } else {
      advance (10)
      #159E
      #instruction: LD   HL,3EA4
      advance (10)
      #15A1
      #instruction: CALL 15C5
      let:16 a15 = (-1 + (SPH,SPL)) in
      M[a15] := 15;
      let:16 a16 = (-1 + a15) in
      M[a16] := A4;
      #return-to: 15A4
      advance (17)
      #15C5
      #instruction: LD   B,17
      advance (7)
      #15C7
      #instruction: LD   A,(HL)
      advance (7)
      #15C8
      #instruction: AND  A
      let:8 a17 = (M[3EA4] & M[3EA4]) in
      let:8 a18 = (M[3EA4] | M[3EA4]) in
      advance (4)
      #15C9
      #instruction: JP   NZ,166B
      if (!is_zero(a17)) {
        advance (10)
        #166B
        #instruction: SCF
        advance (4)
        #166C
        #instruction: RET
        let:16 a19 = (1 + a16) in
        let:16 a20 = (1 + a19) in
        advance (10)
        A := a17;
        B := 17;
        H := 3E;
        L := A4;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a17[7];
        FlagZ := is_zero(a17);
        FlagA := a18[3];
        FlagP := parity(a17);
        FlagCY := true;
        jump ((M[a19],M[a16]));
      } else {
        advance (10)
        #15CC
        #instruction: INC  HL
        advance (5)
        #15CD
        #instruction: DEC  B
        let:16 a21 = addWithCarry(!true,17,~00) in
        let:8 a22 = (17 & 0F) in
        let:8 a23 = (~00 & 0F) in
        let:16 a24 = addWithCarry(!true,a22,a23) in
        advance (5)
        #15CE
        #instruction: JP   NZ,15C7
        if (!is_zero(a21[7:0])) {
          advance (10)
          A := a17;
          B := a21[7:0];
          H := 3E;
          L := A5;
          SPH := a16[15:8];
          SPL := a16[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := false;
          jump (15C7);
        } else {
          advance (10)
          #15D1
          #instruction: RET
          let:16 a25 = (1 + a16) in
          let:16 a26 = (1 + a25) in
          advance (10)
          A := a17;
          B := a21[7:0];
          H := 3E;
          L := A5;
          SPH := a26[15:8];
          SPL := a26[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := false;
          jump ((M[a25],M[a16]));
        }
      }
    }

1959:

    #instruction: CALL 191A
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5C;
    #return-to: 195C
    advance (17)
    #191A
    #instruction: LD   C,1C
    advance (7)
    #191C
    #instruction: LD   HL,241E
    advance (10)
    #191F
    #instruction: LD   DE,1AE4
    advance (10)
    #1922
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    let:16 a4 = (-1 + a3) in
    M[a4] := E4;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 08;
    let:16 a6 = (-1 + a5) in
    M[a6] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 24;
    let:16 a8 = (-1 + a7) in
    M[a8] := 1E;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(0026,0026) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 1C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

195C:

    #instruction: CALL 1925
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 5F;
    #return-to: 195F
    advance (17)
    #1925
    #instruction: LD   HL,20F8
    advance (10)
    #1928
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20F9];
    let:16 a6 = (-1 + a5) in
    M[a6] := M[20F8];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a7 = (-1 + a6) in
    M[a7] := M[20F9];
    let:16 a8 = (-1 + a7) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a9 = (0F & updateBit((updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0])[0])) in
    let:8 a10 = (0F | updateBit((updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0]) >> 01),7,updateBit((updateBit((M[20F9] >> 01),7,M[20F9][0]) >> 01),7,updateBit((M[20F9] >> 01),7,M[20F9][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a11 = (-1 + a8) in
    M[a11] := 09;
    let:16 a12 = (-1 + a11) in
    M[a12] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a13 = addWithCarry(false,1A,a9) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a9 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a17 = (-1 + a12) in
    M[a17] := M[20FB];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[20FA];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17((00,a13[7:0]),(00,a13[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a20 = add17(a19[15:0],a19[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a21 = add17(a20[15:0],a20[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a22 = add17(1E00,a21[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a23 = (1 + a18) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a25 = (-1 + a24) in
    M[a25] := 08;
    let:16 a26 = (-1 + a25) in
    M[a26] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a23],M[a18])] := M[a22[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a27 = (1 + a22[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a28 = add17(0020,(M[a23],M[a18])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a29 = (1 + a26) in
    let:16 a30 = (1 + a29) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a31 = addWithCarry(!true,M[a29],~00) in
    let:8 a32 = (M[a29] & 0F) in
    let:8 a33 = (~00 & 0F) in
    let:16 a34 = addWithCarry(!true,a32,a33) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a31[7:0])) {
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a35 = (1 + a30) in
      let:16 a36 = (1 + a35) in
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump ((M[a35],M[a30]));
    }

195F:

    #instruction: CALL 192B
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 62;
    #return-to: 1962
    advance (17)
    #192B
    #instruction: LD   HL,20FC
    advance (10)
    #192E
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20FD];
    let:16 a6 = (-1 + a5) in
    M[a6] := M[20FC];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a7 = (-1 + a6) in
    M[a7] := M[20FD];
    let:16 a8 = (-1 + a7) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a9 = (0F & updateBit((updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0])[0])) in
    let:8 a10 = (0F | updateBit((updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0]) >> 01),7,updateBit((updateBit((M[20FD] >> 01),7,M[20FD][0]) >> 01),7,updateBit((M[20FD] >> 01),7,M[20FD][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a11 = (-1 + a8) in
    M[a11] := 09;
    let:16 a12 = (-1 + a11) in
    M[a12] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a13 = addWithCarry(false,1A,a9) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a9 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a17 = (-1 + a12) in
    M[a17] := M[20FF];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[20FE];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17((00,a13[7:0]),(00,a13[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a20 = add17(a19[15:0],a19[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a21 = add17(a20[15:0],a20[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a22 = add17(1E00,a21[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a23 = (1 + a18) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a25 = (-1 + a24) in
    M[a25] := 08;
    let:16 a26 = (-1 + a25) in
    M[a26] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a23],M[a18])] := M[a22[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a27 = (1 + a22[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a28 = add17(0020,(M[a23],M[a18])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a29 = (1 + a26) in
    let:16 a30 = (1 + a29) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a31 = addWithCarry(!true,M[a29],~00) in
    let:8 a32 = (M[a29] & 0F) in
    let:8 a33 = (~00 & 0F) in
    let:16 a34 = addWithCarry(!true,a32,a33) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a31[7:0])) {
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a35 = (1 + a30) in
      let:16 a36 = (1 + a35) in
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump ((M[a35],M[a30]));
    }

1962:

    #instruction: CALL 1950
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 65;
    #return-to: 1965
    advance (17)
    #1950
    #instruction: LD   HL,20F4
    advance (10)
    #1953
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    advance (7)
    #1938
    #instruction: LD   L,A
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    let:16 a4 = (-1 + a3) in
    M[a4] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20F5];
    let:16 a6 = (-1 + a5) in
    M[a6] := M[20F4];
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a7 = (-1 + a6) in
    M[a7] := M[20F5];
    let:16 a8 = (-1 + a7) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a9 = (0F & updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
    let:8 a10 = (0F | updateBit((updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0]) >> 01),7,updateBit((updateBit((M[20F5] >> 01),7,M[20F5][0]) >> 01),7,updateBit((M[20F5] >> 01),7,M[20F5][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a11 = (-1 + a8) in
    M[a11] := 09;
    let:16 a12 = (-1 + a11) in
    M[a12] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a13 = addWithCarry(false,1A,a9) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a9 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a17 = (-1 + a12) in
    M[a17] := M[20F7];
    let:16 a18 = (-1 + a17) in
    M[a18] := M[20F6];
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17((00,a13[7:0]),(00,a13[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a20 = add17(a19[15:0],a19[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a21 = add17(a20[15:0],a20[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a22 = add17(1E00,a21[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a23 = (1 + a18) in
    let:16 a24 = (1 + a23) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a25 = (-1 + a24) in
    M[a25] := 08;
    let:16 a26 = (-1 + a25) in
    M[a26] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a23],M[a18])] := M[a22[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a27 = (1 + a22[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a28 = add17(0020,(M[a23],M[a18])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a29 = (1 + a26) in
    let:16 a30 = (1 + a29) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a31 = addWithCarry(!true,M[a29],~00) in
    let:8 a32 = (M[a29] & 0F) in
    let:8 a33 = (~00 & 0F) in
    let:16 a34 = addWithCarry(!true,a32,a33) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a31[7:0])) {
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a35 = (1 + a30) in
      let:16 a36 = (1 + a35) in
      advance (10)
      A := M[a22[15:0]];
      B := a31[7:0];
      C := M[a26];
      D := a27[15:8];
      E := a27[7:0];
      H := a28[15:0][15:8];
      L := a28[15:0][7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a31[7:0][7];
      FlagZ := is_zero(a31[7:0]);
      FlagA := a34[7:0][4];
      FlagP := parity(a31[7:0]);
      FlagCY := a28[16];
      jump ((M[a35],M[a30]));
    }

1965:

    #instruction: CALL 193C
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 68;
    #return-to: 1968
    advance (17)
    #193C
    #instruction: LD   C,07
    advance (7)
    #193E
    #instruction: LD   HL,3501
    advance (10)
    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    #1944
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := 1F;
    let:16 a4 = (-1 + a3) in
    M[a4] := A9;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a5 = (-1 + a4) in
    M[a5] := 08;
    let:16 a6 = (-1 + a5) in
    M[a6] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a7 = (-1 + a6) in
    M[a7] := 35;
    let:16 a8 = (-1 + a7) in
    M[a8] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a9 = add17(0002,0002) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a10 = add17(a9[15:0],a9[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a11 = add17(a10[15:0],a10[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a12 = add17(1E00,a11[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a13 = (1 + a8) in
    let:16 a14 = (1 + a13) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a15 = (-1 + a14) in
    M[a15] := 08;
    let:16 a16 = (-1 + a15) in
    M[a16] := 07;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a13],M[a8])] := M[a12[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a17 = (1 + a12[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,(M[a13],M[a8])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a19 = (1 + a16) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,M[a19],~00) in
    let:8 a22 = (M[a19] & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a25 = (1 + a20) in
      let:16 a26 = (1 + a25) in
      advance (10)
      A := M[a12[15:0]];
      B := a21[7:0];
      C := M[a16];
      D := a17[15:8];
      E := a17[7:0];
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a18[16];
      jump ((M[a25],M[a20]));
    }

1968:

    #instruction: JP   1947
    advance (10)
    #1947
    #instruction: LD   A,(20EB)
    advance (13)
    #194A
    #instruction: LD   HL,3C01
    advance (10)
    #194D
    #instruction: JP   09B2
    advance (10)
    #09B2
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := D;
    let:16 a2 = (-1 + a1) in
    M[a2] := E;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a3 = (-1 + a2) in
    M[a3] := M[20EB];
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a5 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
    let:8 a6 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a7 = (-1 + a4) in
    M[a7] := 09;
    let:16 a8 = (-1 + a7) in
    M[a8] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a9 = addWithCarry(false,1A,a5) in
    let:8 a10 = (1A & 0F) in
    let:8 a11 = (a5 & 0F) in
    let:16 a12 = addWithCarry(false,a10,a11) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a13 = (-1 + a8) in
    M[a13] := 3C;
    let:16 a14 = (-1 + a13) in
    M[a14] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a15 = add17((00,a9[7:0]),(00,a9[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a16 = add17(a15[15:0],a15[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a17 = add17(a16[15:0],a16[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a18 = add17(1E00,a17[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a19 = (1 + a14) in
    let:16 a20 = (1 + a19) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a21 = (-1 + a20) in
    M[a21] := 08;
    let:16 a22 = (-1 + a21) in
    M[a22] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a19],M[a14])] := M[a18[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a23 = (1 + a18[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a24 = add17(0020,(M[a19],M[a14])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a25 = (1 + a22) in
    let:16 a26 = (1 + a25) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a27 = addWithCarry(!true,M[a25],~00) in
    let:8 a28 = (M[a25] & 0F) in
    let:8 a29 = (~00 & 0F) in
    let:16 a30 = addWithCarry(!true,a28,a29) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a27[7:0])) {
      advance (10)
      A := M[a18[15:0]];
      B := a27[7:0];
      C := M[a22];
      D := a23[15:8];
      E := a23[7:0];
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a27[7:0][7];
      FlagZ := is_zero(a27[7:0]);
      FlagA := a30[7:0][4];
      FlagP := parity(a27[7:0]);
      FlagCY := a24[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a31 = (1 + a26) in
      let:16 a32 = (1 + a31) in
      advance (10)
      A := M[a18[15:0]];
      B := a27[7:0];
      C := M[a22];
      D := a23[15:8];
      E := a23[7:0];
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a27[7:0][7];
      FlagZ := is_zero(a27[7:0]);
      FlagA := a30[7:0][4];
      FlagP := parity(a27[7:0]);
      FlagCY := a24[16];
      jump ((M[a31],M[a26]));
    }

196E:

    #instruction: JP   1671
    advance (10)
    jump (1671);

197C:

    #instruction: CALL 1947
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 19;
    let:16 a2 = (-1 + a1) in
    M[a2] := 7F;
    #return-to: 197F
    advance (17)
    #1947
    #instruction: LD   A,(20EB)
    advance (13)
    #194A
    #instruction: LD   HL,3C01
    advance (10)
    #194D
    #instruction: JP   09B2
    advance (10)
    #09B2
    #instruction: PUSH DE
    let:16 a3 = (-1 + a2) in
    M[a3] := D;
    let:16 a4 = (-1 + a3) in
    M[a4] := E;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:16 a5 = (-1 + a4) in
    M[a5] := M[20EB];
    let:16 a6 = (-1 + a5) in
    M[a6] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA 
    advance (4)
    #09B5
    #instruction: RRCA 
    advance (4)
    #09B6
    #instruction: RRCA 
    advance (4)
    #09B7
    #instruction: RRCA 
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a7 = (0F & updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
    let:8 a8 = (0F | updateBit((updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0]) >> 01),7,updateBit((updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0]) >> 01),7,updateBit((updateBit((M[20EB] >> 01),7,M[20EB][0]) >> 01),7,updateBit((M[20EB] >> 01),7,M[20EB][0])[0])[0])[0])) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:16 a9 = (-1 + a6) in
    M[a9] := 09;
    let:16 a10 = (-1 + a9) in
    M[a10] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:16 a11 = addWithCarry(false,1A,a7) in
    let:8 a12 = (1A & 0F) in
    let:8 a13 = (a7 & 0F) in
    let:16 a14 = addWithCarry(false,a12,a13) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a15 = (-1 + a10) in
    M[a15] := 3C;
    let:16 a16 = (-1 + a15) in
    M[a16] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a17 = add17((00,a11[7:0]),(00,a11[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a18 = add17(a17[15:0],a17[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a19 = add17(a18[15:0],a18[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a20 = add17(1E00,a19[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a21 = (1 + a16) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a23 = (-1 + a22) in
    M[a23] := 08;
    let:16 a24 = (-1 + a23) in
    M[a24] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a21],M[a16])] := M[a20[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a25 = (1 + a20[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a26 = add17(0020,(M[a21],M[a16])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a27 = (1 + a24) in
    let:16 a28 = (1 + a27) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a29 = addWithCarry(!true,M[a27],~00) in
    let:8 a30 = (M[a27] & 0F) in
    let:8 a31 = (~00 & 0F) in
    let:16 a32 = addWithCarry(!true,a30,a31) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a29[7:0])) {
      advance (10)
      A := M[a20[15:0]];
      B := a29[7:0];
      C := M[a24];
      D := a25[15:8];
      E := a25[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a29[7:0][7];
      FlagZ := is_zero(a29[7:0]);
      FlagA := a32[7:0][4];
      FlagP := parity(a29[7:0]);
      FlagCY := a26[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a33 = (1 + a28) in
      let:16 a34 = (1 + a33) in
      advance (10)
      A := M[a20[15:0]];
      B := a29[7:0];
      C := M[a24];
      D := a25[15:8];
      E := a25[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a29[7:0][7];
      FlagZ := is_zero(a29[7:0]);
      FlagA := a32[7:0][4];
      FlagP := parity(a29[7:0]);
      FlagCY := a26[16];
      jump ((M[a33],M[a28]));
    }

197F:

    #instruction: JP   193C
    advance (10)
    #193C
    #instruction: LD   C,07
    advance (7)
    #193E
    #instruction: LD   HL,3501
    advance (10)
    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    #1944
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:16 a1 = (-1 + (SPH,SPL)) in
    M[a1] := 1F;
    let:16 a2 = (-1 + a1) in
    M[a2] := A9;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:16 a3 = (-1 + a2) in
    M[a3] := 08;
    let:16 a4 = (-1 + a3) in
    M[a4] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a5 = (-1 + a4) in
    M[a5] := 35;
    let:16 a6 = (-1 + a5) in
    M[a6] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a7 = add17(0002,0002) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a8 = add17(a7[15:0],a7[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a9 = add17(a8[15:0],a8[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a10 = add17(1E00,a9[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a11 = (1 + a6) in
    let:16 a12 = (1 + a11) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a13 = (-1 + a12) in
    M[a13] := 08;
    let:16 a14 = (-1 + a13) in
    M[a14] := 07;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a11],M[a6])] := M[a10[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a15 = (1 + a10[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a16 = add17(0020,(M[a11],M[a6])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a17 = (1 + a14) in
    let:16 a18 = (1 + a17) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,M[a17],~00) in
    let:8 a20 = (M[a17] & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := M[a10[15:0]];
      B := a19[7:0];
      C := M[a14];
      D := a15[15:8];
      E := a15[7:0];
      H := a16[15:0][15:8];
      L := a16[15:0][7:0];
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a16[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a23 = (1 + a18) in
      let:16 a24 = (1 + a23) in
      advance (10)
      A := M[a10[15:0]];
      B := a19[7:0];
      C := M[a14];
      D := a15[15:8];
      E := a15[7:0];
      H := a16[15:0][15:8];
      L := a16[15:0][7:0];
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a16[16];
      jump ((M[a23],M[a18]));
    }

19F5:

    #instruction: LD   A,C
    advance (5)
    #19F6
    #instruction: DEC  A
    let:16 a1 = addWithCarry(!true,C,~00) in
    let:8 a2 = (C & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #19F7
    #instruction: JP   NZ,19EC
    if (!is_zero(a1[7:0])) {
      advance (10)
      #19EC
      #instruction: LD   DE,1C60
      advance (10)
      #19EF
      #instruction: LD   B,10
      advance (7)
      #19F1
      #instruction: LD   C,A
      advance (5)
      #19F2
      #instruction: CALL 1439
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 19;
      let:16 a6 = (-1 + a5) in
      M[a6] := F5;
      #return-to: 19F5
      advance (17)
      #1439
      #instruction: PUSH BC
      let:16 a7 = (-1 + a6) in
      M[a7] := 10;
      let:16 a8 = (-1 + a7) in
      M[a8] := a1[7:0];
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      M[(H,L)] := 00;
      advance (7)
      #143C
      #instruction: INC  DE
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:17 a9 = add17(0020,(H,L)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:16 a10 = (1 + a8) in
      let:16 a11 = (1 + a10) in
      advance (10)
      #1442
      #instruction: DEC  B
      let:16 a12 = addWithCarry(!true,M[a10],~00) in
      let:8 a13 = (M[a10] & 0F) in
      let:8 a14 = (~00 & 0F) in
      let:16 a15 = addWithCarry(!true,a13,a14) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a12[7:0])) {
        advance (10)
        A := 00;
        B := a12[7:0];
        C := M[a8];
        D := 1C;
        E := 61;
        H := a9[15:0][15:8];
        L := a9[15:0][7:0];
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := a9[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:16 a16 = (1 + a11) in
        let:16 a17 = (1 + a16) in
        advance (10)
        A := 00;
        B := a12[7:0];
        C := M[a8];
        D := 1C;
        E := 61;
        H := a9[15:0][15:8];
        L := a9[15:0][7:0];
        SPH := a17[15:8];
        SPL := a17[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := a9[16];
        jump ((M[a16],M[a11]));
      }
    } else {
      advance (10)
      #19FA
      #instruction: LD   B,10
      advance (7)
      #19FC
      #instruction: CALL 14CB
      let:16 a18 = (-1 + (SPH,SPL)) in
      M[a18] := 19;
      let:16 a19 = (-1 + a18) in
      M[a19] := FF;
      #return-to: 19FF
      advance (17)
      #14CB
      #instruction: XOR  A
      let:8 a20 = (a1[7:0] ^ a1[7:0]) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:16 a21 = (-1 + a19) in
      M[a21] := 10;
      let:16 a22 = (-1 + a21) in
      M[a22] := C;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      M[(H,L)] := a20;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:17 a23 = add17(0020,(H,L)) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:16 a24 = (1 + a22) in
      let:16 a25 = (1 + a24) in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:16 a26 = addWithCarry(!true,M[a24],~00) in
      let:8 a27 = (M[a24] & 0F) in
      let:8 a28 = (~00 & 0F) in
      let:16 a29 = addWithCarry(!true,a27,a28) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a26[7:0])) {
        advance (10)
        A := a20;
        B := a26[7:0];
        C := M[a22];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:16 a30 = (1 + a25) in
        let:16 a31 = (1 + a30) in
        advance (10)
        A := a20;
        B := a26[7:0];
        C := M[a22];
        H := a23[15:0][15:8];
        L := a23[15:0][7:0];
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := a23[16];
        jump ((M[a30],M[a25]));
      }
    }

19FF:

    #instruction: LD   A,H
    advance (5)
    #1A00
    #instruction: CP   35
    let:16 a1 = addWithCarry(!false,H,~35) in
    let:8 a2 = (H & 0F) in
    let:8 a3 = (~35 & 0F) in
    let:16 a4 = addWithCarry(!false,a2,a3) in
    advance (7)
    #1A02
    #instruction: JP   NZ,19FA
    if (!is_zero(a1[7:0])) {
      advance (10)
      #19FA
      #instruction: LD   B,10
      advance (7)
      #19FC
      #instruction: CALL 14CB
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := 19;
      let:16 a6 = (-1 + a5) in
      M[a6] := FF;
      #return-to: 19FF
      advance (17)
      #14CB
      #instruction: XOR  A
      let:8 a7 = (H ^ H) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:16 a8 = (-1 + a6) in
      M[a8] := 10;
      let:16 a9 = (-1 + a8) in
      M[a9] := C;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      M[(H,L)] := a7;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:17 a10 = add17(0020,(H,L)) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:16 a11 = (1 + a9) in
      let:16 a12 = (1 + a11) in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:16 a13 = addWithCarry(!true,M[a11],~00) in
      let:8 a14 = (M[a11] & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a13[7:0])) {
        advance (10)
        A := a7;
        B := a13[7:0];
        C := M[a9];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:16 a17 = (1 + a12) in
        let:16 a18 = (1 + a17) in
        advance (10)
        A := a7;
        B := a13[7:0];
        C := M[a9];
        H := a10[15:0][15:8];
        L := a10[15:0][7:0];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := a10[16];
        jump ((M[a17],M[a12]));
      }
    } else {
      advance (10)
      #1A05
      #instruction: RET
      let:16 a19 = (1 + (SPH,SPL)) in
      let:16 a20 = (1 + a19) in
      advance (10)
      A := H;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      FlagCY := !a1[15:8][0];
      jump ((M[a19],M[(SPH,SPL)]));
    }

1A82:

    #instruction: AND  A
    let:8 a1 = (A & A) in
    let:8 a2 = (A | A) in
    advance (4)
    #1A83
    #instruction: RET  Z
    if (is_zero(a1)) {
      let:16 a3 = (1 + (SPH,SPL)) in
      let:16 a4 = (1 + a3) in
      advance (11)
      A := a1;
      SPH := a4[15:8];
      SPL := a4[7:0];
      FlagS := a1[7];
      FlagZ := is_zero(a1);
      FlagA := a2[3];
      FlagP := parity(a1);
      FlagCY := false;
      jump ((M[a3],M[(SPH,SPL)]));
    } else {
      advance (5)
      #1A84
      #instruction: PUSH PSW
      let:16 a5 = (-1 + (SPH,SPL)) in
      M[a5] := a1;
      let:16 a6 = (-1 + a5) in
      M[a6] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a1[7]),6,is_zero(a1)),4,a2[3]),2,parity(a1)),0,false);
      advance (11)
      #1A85
      #instruction: DEC  A
      let:16 a7 = addWithCarry(!true,a1,~00) in
      let:8 a8 = (a1 & 0F) in
      let:8 a9 = (~00 & 0F) in
      let:16 a10 = addWithCarry(!true,a8,a9) in
      advance (5)
      #1A86
      #instruction: LD   (HL),A
      M[(H,L)] := a7[7:0];
      advance (7)
      #1A87
      #instruction: CALL 19E6
      let:16 a11 = (-1 + a6) in
      M[a11] := 1A;
      let:16 a12 = (-1 + a11) in
      M[a12] := 8A;
      #return-to: 1A8A
      advance (17)
      #19E6
      #instruction: LD   HL,2701
      advance (10)
      #19E9
      #instruction: JP   Z,19FA
      if (is_zero(a7[7:0])) {
        advance (10)
        #19FA
        #instruction: LD   B,10
        advance (7)
        #19FC
        #instruction: CALL 14CB
        let:16 a13 = (-1 + a12) in
        M[a13] := 19;
        let:16 a14 = (-1 + a13) in
        M[a14] := FF;
        #return-to: 19FF
        advance (17)
        #14CB
        #instruction: XOR  A
        let:8 a15 = (a7[7:0] ^ a7[7:0]) in
        advance (4)
        #14CC
        #instruction: PUSH BC
        let:16 a16 = (-1 + a14) in
        M[a16] := 10;
        let:16 a17 = (-1 + a16) in
        M[a17] := C;
        advance (11)
        #14CD
        #instruction: LD   (HL),A
        M[2701] := a15;
        advance (7)
        #14CE
        #instruction: LD   BC,0020
        advance (10)
        #14D1
        #instruction: ADD  HL,BC
        let:17 a18 = add17(0020,2701) in
        advance (10)
        #14D2
        #instruction: POP  BC
        let:16 a19 = (1 + a17) in
        let:16 a20 = (1 + a19) in
        advance (10)
        #14D3
        #instruction: DEC  B
        let:16 a21 = addWithCarry(!true,M[a19],~00) in
        let:8 a22 = (M[a19] & 0F) in
        let:8 a23 = (~00 & 0F) in
        let:16 a24 = addWithCarry(!true,a22,a23) in
        advance (5)
        #14D4
        #instruction: JP   NZ,14CC
        if (!is_zero(a21[7:0])) {
          advance (10)
          A := a15;
          B := a21[7:0];
          C := M[a17];
          H := a18[15:0][15:8];
          L := a18[15:0][7:0];
          SPH := a20[15:8];
          SPL := a20[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := a18[16];
          jump (14CC);
        } else {
          advance (10)
          #14D7
          #instruction: RET
          let:16 a25 = (1 + a20) in
          let:16 a26 = (1 + a25) in
          advance (10)
          A := a15;
          B := a21[7:0];
          C := M[a17];
          H := a18[15:0][15:8];
          L := a18[15:0][7:0];
          SPH := a26[15:8];
          SPL := a26[7:0];
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := a18[16];
          jump ((M[a25],M[a20]));
        }
      } else {
        advance (10)
        #19EC
        #instruction: LD   DE,1C60
        advance (10)
        #19EF
        #instruction: LD   B,10
        advance (7)
        #19F1
        #instruction: LD   C,A
        advance (5)
        #19F2
        #instruction: CALL 1439
        let:16 a27 = (-1 + a12) in
        M[a27] := 19;
        let:16 a28 = (-1 + a27) in
        M[a28] := F5;
        #return-to: 19F5
        advance (17)
        #1439
        #instruction: PUSH BC
        let:16 a29 = (-1 + a28) in
        M[a29] := 10;
        let:16 a30 = (-1 + a29) in
        M[a30] := a7[7:0];
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[2701] := 00;
        advance (7)
        #143C
        #instruction: INC  DE
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a31 = add17(0020,2701) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:16 a32 = (1 + a30) in
        let:16 a33 = (1 + a32) in
        advance (10)
        #1442
        #instruction: DEC  B
        let:16 a34 = addWithCarry(!true,M[a32],~00) in
        let:8 a35 = (M[a32] & 0F) in
        let:8 a36 = (~00 & 0F) in
        let:16 a37 = addWithCarry(!true,a35,a36) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a34[7:0])) {
          advance (10)
          A := 00;
          B := a34[7:0];
          C := M[a30];
          D := 1C;
          E := 61;
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a33[15:8];
          SPL := a33[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := a31[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:16 a38 = (1 + a33) in
          let:16 a39 = (1 + a38) in
          advance (10)
          A := 00;
          B := a34[7:0];
          C := M[a30];
          D := 1C;
          E := 61;
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a39[15:8];
          SPL := a39[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := a31[16];
          jump ((M[a38],M[a33]));
        }
      }
    }

1A8A:

    #instruction: POP  PSW
    let:16 a1 = (1 + (SPH,SPL)) in
    let:16 a2 = (1 + a1) in
    advance (10)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a3 = (0F & M[a1]) in
    let:8 a4 = (0F | M[a1]) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:16 a5 = addWithCarry(false,1A,a3) in
    let:8 a6 = (1A & 0F) in
    let:8 a7 = (a3 & 0F) in
    let:16 a8 = addWithCarry(false,a6,a7) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:16 a9 = (-1 + a2) in
    M[a9] := 25;
    let:16 a10 = (-1 + a9) in
    M[a10] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a11 = add17((00,a5[7:0]),(00,a5[7:0])) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:17 a12 = add17(a11[15:0],a11[15:0]) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:17 a13 = add17(a12[15:0],a12[15:0]) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:17 a14 = add17(1E00,a13[15:0]) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    advance (4)
    #090B
    #instruction: POP  HL
    let:16 a15 = (1 + a10) in
    let:16 a16 = (1 + a15) in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:16 a17 = (-1 + a16) in
    M[a17] := 08;
    let:16 a18 = (-1 + a17) in
    M[a18] := C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    advance (7)
    #143B
    #instruction: LD   (HL),A
    M[(M[a15],M[a10])] := M[a14[15:0]];
    advance (7)
    #143C
    #instruction: INC  DE
    let:16 a19 = (1 + a14[15:0]) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:17 a20 = add17(0020,(M[a15],M[a10])) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:16 a21 = (1 + a18) in
    let:16 a22 = (1 + a21) in
    advance (10)
    #1442
    #instruction: DEC  B
    let:16 a23 = addWithCarry(!true,M[a21],~00) in
    let:8 a24 = (M[a21] & 0F) in
    let:8 a25 = (~00 & 0F) in
    let:16 a26 = addWithCarry(!true,a24,a25) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a23[7:0])) {
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:16 a27 = (1 + a22) in
      let:16 a28 = (1 + a27) in
      advance (10)
      A := M[a14[15:0]];
      B := a23[7:0];
      C := M[a18];
      D := a19[15:8];
      E := a19[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a20[16];
      jump ((M[a27],M[a22]));
    }
