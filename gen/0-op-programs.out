
00 --> Op0 NOP

    #instruction: NOP
    advance (4)
    jump ((PCH,PCL));

01 --> Op2 (LXI BC)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   BC,a7a3
    advance (10)
    B := a7;
    C := a3;
    jump (a8);

02 --> Op0 (STAX BC)

    #instruction: LD   (BC),A
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = A in
    M[(a1,a2)] := a3;
    advance (7)
    jump ((PCH,PCL));

03 --> Op0 (INX BC)

    #instruction: INC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump ((PCH,PCL));

04 --> Op0 (INR B)

    #instruction: INC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

05 --> Op0 (DCR B)

    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

06 --> Op1 (MVI B)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   B,a3
    advance (7)
    B := a3;
    jump (a4);

07 --> Op0 RLC

    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump ((PCH,PCL));

08 --> Op0 (NOPx 1)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

09 --> Op0 (DAD BC)

    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump ((PCH,PCL));

0A --> Op0 (LDAX BC)

    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump ((PCH,PCL));

0B --> Op0 (DCX BC)

    #instruction: DEC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump ((PCH,PCL));

0C --> Op0 (INR C)

    #instruction: INC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

0D --> Op0 (DCR C)

    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

0E --> Op1 (MVI C)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   C,a3
    advance (7)
    C := a3;
    jump (a4);

0F --> Op0 RRC

    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump ((PCH,PCL));

10 --> Op0 (NOPx 2)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

11 --> Op2 (LXI DE)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   DE,a7a3
    advance (10)
    D := a7;
    E := a3;
    jump (a8);

12 --> Op0 (STAX DE)

    #instruction: LD   (DE),A
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = A in
    M[(a1,a2)] := a3;
    advance (7)
    jump ((PCH,PCL));

13 --> Op0 (INX DE)

    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump ((PCH,PCL));

14 --> Op0 (INR D)

    #instruction: INC  D
    let:8 a1 = D in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    D := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

15 --> Op0 (DCR D)

    #instruction: DEC  D
    let:8 a1 = D in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    D := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

16 --> Op1 (MVI D)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   D,a3
    advance (7)
    D := a3;
    jump (a4);

17 --> Op0 RAL

    #instruction: RAL
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,FlagCY);
    FlagCY := a1[7];
    jump ((PCH,PCL));

18 --> Op0 (NOPx 3)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

19 --> Op0 (DAD DE)

    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump ((PCH,PCL));

1A --> Op0 (LDAX DE)

    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump ((PCH,PCL));

1B --> Op0 (DCX DE)

    #instruction: DEC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump ((PCH,PCL));

1C --> Op0 (INR E)

    #instruction: INC  E
    let:8 a1 = E in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    E := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

1D --> Op0 (DCR E)

    #instruction: DEC  E
    let:8 a1 = E in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    E := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

1E --> Op1 (MVI E)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   E,a3
    advance (7)
    E := a3;
    jump (a4);

1F --> Op0 RAR

    #instruction: RAR
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,FlagCY);
    FlagCY := a1[0];
    jump ((PCH,PCL));

20 --> Op0 (NOPx 4)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

21 --> Op2 (LXI HL)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   HL,a7a3
    advance (10)
    HL := (a7,a3);
    jump (a8);

22 --> Op2 SHLD

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   (a7a3),HL
    let:16 a9 = HL in
    M[(a7,a3)] := a9[7:0];
    let:16 a10 = (1 + (a7,a3)) in
    let:16 a11 = HL in
    M[a10] := a11[15:8];
    advance (16)
    jump (a8);

23 --> Op0 (INX HL)

    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump ((PCH,PCL));

24 --> Op0 (INR H)

    #instruction: INC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[15:8],00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

25 --> Op0 (DCR H)

    #instruction: DEC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(!true,a1[15:8],~00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

26 --> Op1 (MVI H)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   H,a3
    let:16 a5 = HL in
    advance (7)
    HL := (a3,a5[7:0]);
    jump (a4);

27 --> Op0 DAA

    #instruction: DAA
    let:8 a1 = A in
    let:8 a2 = (a1 & 0F) in
    let:16 a3 = addWithCarry(false,a2,06) in
    let:16 a4 = addWithCarry(((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4],(a1 >> 04),00) in
    let:16 a5 = addWithCarry(false,a4[7:0],06) in
    let:8 a6 = (((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2) & 0F) in
    let:8 a7 = ((((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0]) << 04) | a6) in
    advance (4)
    A := a7;
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := ((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4];
    FlagP := parity(a7);
    FlagCY := (((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0])[4] || FlagCY);
    jump ((PCH,PCL));

28 --> Op0 (NOPx 5)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

29 --> Op0 (DAD HL)

    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump ((PCH,PCL));

2A --> Op2 LHLD

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   HL,(a7a3)
    let:8 a9 = M[(a7,a3)] in
    let:16 a10 = HL in
    let:16 a11 = (1 + (a7,a3)) in
    let:8 a12 = M[a11] in
    let:16 a13 = (a10[15:8],a9) in
    advance (16)
    HL := (a12,a13[7:0]);
    jump (a8);

2B --> Op0 (DCX HL)

    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump ((PCH,PCL));

2C --> Op0 (INR L)

    #instruction: INC  L
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[7:0],00) in
    let:8 a3 = (a1[7:0] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a6[15:8],a2[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

2D --> Op0 (DCR L)

    #instruction: DEC  L
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(!true,a1[7:0],~00) in
    let:8 a3 = (a1[7:0] & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a6[15:8],a2[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

2E --> Op1 (MVI L)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   L,a3
    let:16 a5 = HL in
    advance (7)
    HL := (a5[15:8],a3);
    jump (a4);

2F --> Op0 CMA

    #instruction: CPL
    let:8 a1 = A in
    advance (4)
    A := ~a1;
    jump ((PCH,PCL));

30 --> Op0 (NOPx 6)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

31 --> Op2 (LXI SP)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   SP,a7a3
    advance (10)
    SP := (a7,a3);
    jump (a8);

32 --> Op2 STA

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   (a7a3),A
    let:8 a9 = A in
    M[(a7,a3)] := a9;
    advance (13)
    jump (a8);

33 --> Op0 (INX SP)

    #instruction: INC  SP
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    advance (5)
    SP := a2;
    jump ((PCH,PCL));

34 --> Op0 (INR M)

    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump ((PCH,PCL));

35 --> Op0 (DCR M)

    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump ((PCH,PCL));

36 --> Op1 (MVI M)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   (HL),a3
    let:16 a5 = HL in
    M[a5] := a3;
    advance (10)
    jump (a4);

37 --> Op0 STC

    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump ((PCH,PCL));

38 --> Op0 (NOPx 7)

    #instruction: *NOP
    advance (4)
    jump ((PCH,PCL));

39 --> Op0 (DAD SP)

    #instruction: ADD  HL,SP
    let:16 a1 = SP in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump ((PCH,PCL));

3A --> Op2 LDA

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: LD   A,(a7a3)
    let:8 a9 = M[(a7,a3)] in
    advance (13)
    A := a9;
    jump (a8);

3B --> Op0 (DCX SP)

    #instruction: DEC  SP
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    advance (5)
    SP := a2;
    jump ((PCH,PCL));

3C --> Op0 (INR A)

    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

3D --> Op0 (DCR A)

    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump ((PCH,PCL));

3E --> Op1 (MVI A)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: LD   A,a3
    advance (7)
    A := a3;
    jump (a4);

3F --> Op0 CMC

    #instruction: CPC
    advance (4)
    FlagCY := !FlagCY;
    jump ((PCH,PCL));

40 --> Op0 (MOV {dest = B, src = B})

    #instruction: LD   B,B
    let:8 a1 = B in
    advance (5)
    B := a1;
    jump ((PCH,PCL));

41 --> Op0 (MOV {dest = B, src = C})

    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    B := a1;
    jump ((PCH,PCL));

42 --> Op0 (MOV {dest = B, src = D})

    #instruction: LD   B,D
    let:8 a1 = D in
    advance (5)
    B := a1;
    jump ((PCH,PCL));

43 --> Op0 (MOV {dest = B, src = E})

    #instruction: LD   B,E
    let:8 a1 = E in
    advance (5)
    B := a1;
    jump ((PCH,PCL));

44 --> Op0 (MOV {dest = B, src = H})

    #instruction: LD   B,H
    let:16 a1 = HL in
    advance (5)
    B := a1[15:8];
    jump ((PCH,PCL));

45 --> Op0 (MOV {dest = B, src = L})

    #instruction: LD   B,L
    let:16 a1 = HL in
    advance (5)
    B := a1[7:0];
    jump ((PCH,PCL));

46 --> Op0 (MOV {dest = B, src = M})

    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump ((PCH,PCL));

47 --> Op0 (MOV {dest = B, src = A})

    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump ((PCH,PCL));

48 --> Op0 (MOV {dest = C, src = B})

    #instruction: LD   C,B
    let:8 a1 = B in
    advance (5)
    C := a1;
    jump ((PCH,PCL));

49 --> Op0 (MOV {dest = C, src = C})

    #instruction: LD   C,C
    let:8 a1 = C in
    advance (5)
    C := a1;
    jump ((PCH,PCL));

4A --> Op0 (MOV {dest = C, src = D})

    #instruction: LD   C,D
    let:8 a1 = D in
    advance (5)
    C := a1;
    jump ((PCH,PCL));

4B --> Op0 (MOV {dest = C, src = E})

    #instruction: LD   C,E
    let:8 a1 = E in
    advance (5)
    C := a1;
    jump ((PCH,PCL));

4C --> Op0 (MOV {dest = C, src = H})

    #instruction: LD   C,H
    let:16 a1 = HL in
    advance (5)
    C := a1[15:8];
    jump ((PCH,PCL));

4D --> Op0 (MOV {dest = C, src = L})

    #instruction: LD   C,L
    let:16 a1 = HL in
    advance (5)
    C := a1[7:0];
    jump ((PCH,PCL));

4E --> Op0 (MOV {dest = C, src = M})

    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump ((PCH,PCL));

4F --> Op0 (MOV {dest = C, src = A})

    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    C := a1;
    jump ((PCH,PCL));

50 --> Op0 (MOV {dest = D, src = B})

    #instruction: LD   D,B
    let:8 a1 = B in
    advance (5)
    D := a1;
    jump ((PCH,PCL));

51 --> Op0 (MOV {dest = D, src = C})

    #instruction: LD   D,C
    let:8 a1 = C in
    advance (5)
    D := a1;
    jump ((PCH,PCL));

52 --> Op0 (MOV {dest = D, src = D})

    #instruction: LD   D,D
    let:8 a1 = D in
    advance (5)
    D := a1;
    jump ((PCH,PCL));

53 --> Op0 (MOV {dest = D, src = E})

    #instruction: LD   D,E
    let:8 a1 = E in
    advance (5)
    D := a1;
    jump ((PCH,PCL));

54 --> Op0 (MOV {dest = D, src = H})

    #instruction: LD   D,H
    let:16 a1 = HL in
    advance (5)
    D := a1[15:8];
    jump ((PCH,PCL));

55 --> Op0 (MOV {dest = D, src = L})

    #instruction: LD   D,L
    let:16 a1 = HL in
    advance (5)
    D := a1[7:0];
    jump ((PCH,PCL));

56 --> Op0 (MOV {dest = D, src = M})

    #instruction: LD   D,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    D := a2;
    jump ((PCH,PCL));

57 --> Op0 (MOV {dest = D, src = A})

    #instruction: LD   D,A
    let:8 a1 = A in
    advance (5)
    D := a1;
    jump ((PCH,PCL));

58 --> Op0 (MOV {dest = E, src = B})

    #instruction: LD   E,B
    let:8 a1 = B in
    advance (5)
    E := a1;
    jump ((PCH,PCL));

59 --> Op0 (MOV {dest = E, src = C})

    #instruction: LD   E,C
    let:8 a1 = C in
    advance (5)
    E := a1;
    jump ((PCH,PCL));

5A --> Op0 (MOV {dest = E, src = D})

    #instruction: LD   E,D
    let:8 a1 = D in
    advance (5)
    E := a1;
    jump ((PCH,PCL));

5B --> Op0 (MOV {dest = E, src = E})

    #instruction: LD   E,E
    let:8 a1 = E in
    advance (5)
    E := a1;
    jump ((PCH,PCL));

5C --> Op0 (MOV {dest = E, src = H})

    #instruction: LD   E,H
    let:16 a1 = HL in
    advance (5)
    E := a1[15:8];
    jump ((PCH,PCL));

5D --> Op0 (MOV {dest = E, src = L})

    #instruction: LD   E,L
    let:16 a1 = HL in
    advance (5)
    E := a1[7:0];
    jump ((PCH,PCL));

5E --> Op0 (MOV {dest = E, src = M})

    #instruction: LD   E,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    E := a2;
    jump ((PCH,PCL));

5F --> Op0 (MOV {dest = E, src = A})

    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump ((PCH,PCL));

60 --> Op0 (MOV {dest = H, src = B})

    #instruction: LD   H,B
    let:8 a1 = B in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump ((PCH,PCL));

61 --> Op0 (MOV {dest = H, src = C})

    #instruction: LD   H,C
    let:8 a1 = C in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump ((PCH,PCL));

62 --> Op0 (MOV {dest = H, src = D})

    #instruction: LD   H,D
    let:8 a1 = D in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump ((PCH,PCL));

63 --> Op0 (MOV {dest = H, src = E})

    #instruction: LD   H,E
    let:8 a1 = E in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump ((PCH,PCL));

64 --> Op0 (MOV {dest = H, src = H})

    #instruction: LD   H,H
    let:16 a1 = HL in
    let:16 a2 = HL in
    advance (5)
    HL := (a1[15:8],a2[7:0]);
    jump ((PCH,PCL));

65 --> Op0 (MOV {dest = H, src = L})

    #instruction: LD   H,L
    let:16 a1 = HL in
    let:16 a2 = HL in
    advance (5)
    HL := (a1[7:0],a2[7:0]);
    jump ((PCH,PCL));

66 --> Op0 (MOV {dest = H, src = M})

    #instruction: LD   H,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a2,a3[7:0]);
    jump ((PCH,PCL));

67 --> Op0 (MOV {dest = H, src = A})

    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump ((PCH,PCL));

68 --> Op0 (MOV {dest = L, src = B})

    #instruction: LD   L,B
    let:8 a1 = B in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump ((PCH,PCL));

69 --> Op0 (MOV {dest = L, src = C})

    #instruction: LD   L,C
    let:8 a1 = C in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump ((PCH,PCL));

6A --> Op0 (MOV {dest = L, src = D})

    #instruction: LD   L,D
    let:8 a1 = D in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump ((PCH,PCL));

6B --> Op0 (MOV {dest = L, src = E})

    #instruction: LD   L,E
    let:8 a1 = E in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump ((PCH,PCL));

6C --> Op0 (MOV {dest = L, src = H})

    #instruction: LD   L,H
    let:16 a1 = HL in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1[15:8]);
    jump ((PCH,PCL));

6D --> Op0 (MOV {dest = L, src = L})

    #instruction: LD   L,L
    let:16 a1 = HL in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1[7:0]);
    jump ((PCH,PCL));

6E --> Op0 (MOV {dest = L, src = M})

    #instruction: LD   L,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a3[15:8],a2);
    jump ((PCH,PCL));

6F --> Op0 (MOV {dest = L, src = A})

    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump ((PCH,PCL));

70 --> Op0 (MOV {dest = M, src = B})

    #instruction: LD   (HL),B
    let:8 a1 = B in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump ((PCH,PCL));

71 --> Op0 (MOV {dest = M, src = C})

    #instruction: LD   (HL),C
    let:8 a1 = C in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump ((PCH,PCL));

72 --> Op0 (MOV {dest = M, src = D})

    #instruction: LD   (HL),D
    let:8 a1 = D in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump ((PCH,PCL));

73 --> Op0 (MOV {dest = M, src = E})

    #instruction: LD   (HL),E
    let:8 a1 = E in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump ((PCH,PCL));

74 --> Op0 (MOV {dest = M, src = H})

    #instruction: LD   (HL),H
    let:16 a1 = HL in
    let:16 a2 = HL in
    M[a2] := a1[15:8];
    advance (7)
    jump ((PCH,PCL));

75 --> Op0 (MOV {dest = M, src = L})

    #instruction: LD   (HL),L
    let:16 a1 = HL in
    let:16 a2 = HL in
    M[a2] := a1[7:0];
    advance (7)
    jump ((PCH,PCL));

76 --> Op0 HLT

    #instruction: HLT
    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (7)
    jump (a3);

77 --> Op0 (MOV {dest = M, src = A})

    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump ((PCH,PCL));

78 --> Op0 (MOV {dest = A, src = B})

    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump ((PCH,PCL));

79 --> Op0 (MOV {dest = A, src = C})

    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump ((PCH,PCL));

7A --> Op0 (MOV {dest = A, src = D})

    #instruction: LD   A,D
    let:8 a1 = D in
    advance (5)
    A := a1;
    jump ((PCH,PCL));

7B --> Op0 (MOV {dest = A, src = E})

    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    A := a1;
    jump ((PCH,PCL));

7C --> Op0 (MOV {dest = A, src = H})

    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump ((PCH,PCL));

7D --> Op0 (MOV {dest = A, src = L})

    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump ((PCH,PCL));

7E --> Op0 (MOV {dest = A, src = M})

    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump ((PCH,PCL));

7F --> Op0 (MOV {dest = A, src = A})

    #instruction: LD   A,A
    let:8 a1 = A in
    advance (5)
    A := a1;
    jump ((PCH,PCL));

80 --> Op0 (ADD B)

    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

81 --> Op0 (ADD C)

    #instruction: ADD  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

82 --> Op0 (ADD D)

    #instruction: ADD  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

83 --> Op0 (ADD E)

    #instruction: ADD  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

84 --> Op0 (ADD H)

    #instruction: ADD  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1[15:8],a2) in
    let:8 a4 = (a1[15:8] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

85 --> Op0 (ADD L)

    #instruction: ADD  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1[7:0],a2) in
    let:8 a4 = (a1[7:0] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

86 --> Op0 (ADD M)

    #instruction: ADD  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(false,a2,a3) in
    let:8 a5 = (a2 & 0F) in
    let:8 a6 = (a3 & 0F) in
    let:16 a7 = addWithCarry(false,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := a4[15:8][0];
    jump ((PCH,PCL));

87 --> Op0 (ADD A)

    #instruction: ADD  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

88 --> Op0 (ADC B)

    #instruction: ADC  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

89 --> Op0 (ADC C)

    #instruction: ADC  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

8A --> Op0 (ADC D)

    #instruction: ADC  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

8B --> Op0 (ADC E)

    #instruction: ADC  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

8C --> Op0 (ADC H)

    #instruction: ADC  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1[15:8],a2) in
    let:8 a4 = (a1[15:8] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

8D --> Op0 (ADC L)

    #instruction: ADC  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1[7:0],a2) in
    let:8 a4 = (a1[7:0] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

8E --> Op0 (ADC M)

    #instruction: ADC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(FlagCY,a2,a3) in
    let:8 a5 = (a2 & 0F) in
    let:8 a6 = (a3 & 0F) in
    let:16 a7 = addWithCarry(FlagCY,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := a4[15:8][0];
    jump ((PCH,PCL));

8F --> Op0 (ADC A)

    #instruction: ADC  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump ((PCH,PCL));

90 --> Op0 (SUB B)

    #instruction: SUB  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

91 --> Op0 (SUB C)

    #instruction: SUB  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

92 --> Op0 (SUB D)

    #instruction: SUB  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

93 --> Op0 (SUB E)

    #instruction: SUB  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

94 --> Op0 (SUB H)

    #instruction: SUB  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1[15:8]) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1[15:8] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

95 --> Op0 (SUB L)

    #instruction: SUB  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1[7:0]) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1[7:0] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

96 --> Op0 (SUB M)

    #instruction: SUB  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(!false,a3,~a2) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (~a2 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump ((PCH,PCL));

97 --> Op0 (SUB A)

    #instruction: SUB  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

98 --> Op0 (SBB B)

    #instruction: SBC  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

99 --> Op0 (SBB C)

    #instruction: SBC  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

9A --> Op0 (SBB D)

    #instruction: SBC  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

9B --> Op0 (SBB E)

    #instruction: SBC  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

9C --> Op0 (SBB H)

    #instruction: SBC  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1[15:8]) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1[15:8] & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

9D --> Op0 (SBB L)

    #instruction: SBC  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1[7:0]) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1[7:0] & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

9E --> Op0 (SBB M)

    #instruction: SBC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(!FlagCY,a3,~a2) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (~a2 & 0F) in
    let:16 a7 = addWithCarry(!FlagCY,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump ((PCH,PCL));

9F --> Op0 (SBB A)

    #instruction: SBC  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!FlagCY,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

A0 --> Op0 (ANA B)

    #instruction: AND  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A1 --> Op0 (ANA C)

    #instruction: AND  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A2 --> Op0 (ANA D)

    #instruction: AND  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A3 --> Op0 (ANA E)

    #instruction: AND  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A4 --> Op0 (ANA H)

    #instruction: AND  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[15:8] & a2) in
    let:8 a4 = (a1[15:8] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A5 --> Op0 (ANA L)

    #instruction: AND  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[7:0] & a2) in
    let:8 a4 = (a1[7:0] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A6 --> Op0 (ANA M)

    #instruction: AND  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump ((PCH,PCL));

A7 --> Op0 (ANA A)

    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A8 --> Op0 (XRA B)

    #instruction: XOR  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

A9 --> Op0 (XRA C)

    #instruction: XOR  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

AA --> Op0 (XRA D)

    #instruction: XOR  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

AB --> Op0 (XRA E)

    #instruction: XOR  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

AC --> Op0 (XRA H)

    #instruction: XOR  H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[15:8] ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

AD --> Op0 (XRA L)

    #instruction: XOR  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[7:0] ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

AE --> Op0 (XRA M)

    #instruction: XOR  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 ^ a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump ((PCH,PCL));

AF --> Op0 (XRA A)

    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B0 --> Op0 (ORA B)

    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B1 --> Op0 (ORA C)

    #instruction: OR   C
    let:8 a1 = C in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B2 --> Op0 (ORA D)

    #instruction: OR   D
    let:8 a1 = D in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B3 --> Op0 (ORA E)

    #instruction: OR   E
    let:8 a1 = E in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B4 --> Op0 (ORA H)

    #instruction: OR   H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[15:8] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B5 --> Op0 (ORA L)

    #instruction: OR   L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[7:0] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B6 --> Op0 (ORA M)

    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump ((PCH,PCL));

B7 --> Op0 (ORA A)

    #instruction: OR   A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((PCH,PCL));

B8 --> Op0 (CMP B)

    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

B9 --> Op0 (CMP C)

    #instruction: CP   C
    let:8 a1 = A in
    let:8 a2 = C in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

BA --> Op0 (CMP D)

    #instruction: CP   D
    let:8 a1 = A in
    let:8 a2 = D in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

BB --> Op0 (CMP E)

    #instruction: CP   E
    let:8 a1 = A in
    let:8 a2 = E in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

BC --> Op0 (CMP H)

    #instruction: CP   H
    let:8 a1 = A in
    let:16 a2 = HL in
    let:16 a3 = addWithCarry(!false,a1,~a2[15:8]) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2[15:8] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

BD --> Op0 (CMP L)

    #instruction: CP   L
    let:8 a1 = A in
    let:16 a2 = HL in
    let:16 a3 = addWithCarry(!false,a1,~a2[7:0]) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2[7:0] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

BE --> Op0 (CMP M)

    #instruction: CP   (HL)
    let:8 a1 = A in
    let:16 a2 = HL in
    let:8 a3 = M[a2] in
    let:16 a4 = addWithCarry(!false,a1,~a3) in
    let:8 a5 = (a1 & 0F) in
    let:8 a6 = (~a3 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump ((PCH,PCL));

BF --> Op0 (CMP A)

    #instruction: CP   A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((PCH,PCL));

C0 --> Op0 (RCond NZ)

    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

C1 --> Op0 (POP BC)

    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump ((PCH,PCL));

C2 --> Op2 (JCond NZ)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   NZ,a7a3
    if (!FlagZ) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

C3 --> Op2 JMP

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   a7a3
    advance (10)
    jump ((a7,a3));

C4 --> Op2 (CCond NZ)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL NZ,a7a3
    if (!FlagZ) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

C5 --> Op0 (PUSH BC)

    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump ((PCH,PCL));

C6 --> Op1 ADI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: ADD  a3
    let:8 a5 = A in
    let:16 a6 = addWithCarry(false,a3,a5) in
    let:8 a7 = (a3 & 0F) in
    let:8 a8 = (a5 & 0F) in
    let:16 a9 = addWithCarry(false,a7,a8) in
    advance (7)
    A := a6[7:0];
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := a6[15:8][0];
    jump (a4);

C7 --> Op0 (RST 0)

    #instruction: RST  0
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0000);

C8 --> Op0 (RCond Z)

    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

C9 --> Op0 RET

    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

CA --> Op2 (JCond Z)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   Z,a7a3
    if (FlagZ) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

CB --> Op2 JMPx

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: *JP  a7a3
    advance (10)
    jump ((a7,a3));

CC --> Op2 (CCond Z)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL Z,a7a3
    if (FlagZ) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

CD --> Op2 CALL

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL a7a3
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = SP in
    let:16 a12 = (-1 + a11) in
    M[a12] := a9;
    let:16 a13 = (-1 + a12) in
    M[a13] := a10;
    #return-to: (a9,a10)
    advance (17)
    SP := a13;
    jump ((a7,a3));

CE --> Op1 ACI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: ADC  a3
    let:8 a5 = A in
    let:16 a6 = addWithCarry(FlagCY,a3,a5) in
    let:8 a7 = (a3 & 0F) in
    let:8 a8 = (a5 & 0F) in
    let:16 a9 = addWithCarry(FlagCY,a7,a8) in
    advance (7)
    A := a6[7:0];
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := a6[15:8][0];
    jump (a4);

CF --> Op0 (RST 1)

    #instruction: RST  1
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0008);

D0 --> Op0 (RCond NC)

    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

D1 --> Op0 (POP DE)

    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump ((PCH,PCL));

D2 --> Op2 (JCond NC)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   NC,a7a3
    if (!FlagCY) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

D3 --> Op1 OUT

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: OUT  a3
    let:8 a5 = A in
    switch (a3) {
      case 2 : {
        advance (10)
        Shifter_OFF := a5;
        jump (a4);
      }
      case 3 : {
        sound_control(Ufo,a5[0]);
        sound_control(Shot,a5[1]);
        sound_control(PlayerDie,a5[2]);
        sound_control(InvaderDie,a5[3]);
        sound_control(ExtraLife,a5[4]);
        advance (10)
        jump (a4);
      }
      case 4 : {
        advance (10)
        Shifter_HI := a5;
        Shifter_LO := Shifter_HI;
        jump (a4);
      }
      case 5 : {
        sound_control(FleetMovement1,a5[0]);
        sound_control(FleetMovement2,a5[1]);
        sound_control(FleetMovement3,a5[2]);
        sound_control(FleetMovement4,a5[3]);
        sound_control(UfoHit,a5[4]);
        advance (10)
        jump (a4);
      }
      case 6 : {
        unknown_output(6,a5);
        advance (10)
        jump (a4);
      }
    }

D4 --> Op2 (CCond NC)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL NC,a7a3
    if (!FlagCY) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

D5 --> Op0 (PUSH DE)

    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump ((PCH,PCL));

D6 --> Op1 SUI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: SUB  a3
    let:8 a5 = A in
    let:16 a6 = addWithCarry(!false,a5,~a3) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~a3 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    A := a6[7:0];
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := !a6[15:8][0];
    jump (a4);

D7 --> Op0 (RST 2)

    #instruction: RST  2
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0010);

D8 --> Op0 (RCond CY)

    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

D9 --> Op0 RETx

    #instruction: *RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

DA --> Op2 (JCond CY)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   CY,a7a3
    if (FlagCY) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

DB --> Op1 IN

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: IN   a3
    switch (a3) {
      case 1 : {
        advance (10)
        A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
        jump (a4);
      }
      case 2 : {
        advance (10)
        A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
        jump (a4);
      }
      case 3 : {
        let:8 a5 = (Shifter_OFF & 07) in
        let:8 a6 = (~Shifter_OFF & 07) in
        let:8 a7 = ((Shifter_HI << a5) | ((Shifter_LO >> a6) >> 01)) in
        advance (10)
        A := a7;
        jump (a4);
      }
    }

DC --> Op2 (CCond CY)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL CY,a7a3
    if (FlagCY) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

DD --> Op2 (CALLx 1)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: *CAL a7a3
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = SP in
    let:16 a12 = (-1 + a11) in
    M[a12] := a9;
    let:16 a13 = (-1 + a12) in
    M[a13] := a10;
    #return-to: (a9,a10)
    advance (17)
    SP := a13;
    jump ((a7,a3));

DE --> Op1 SBI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: SBC  a3
    let:8 a5 = A in
    let:16 a6 = addWithCarry(!FlagCY,a5,~a3) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~a3 & 0F) in
    let:16 a9 = addWithCarry(!FlagCY,a7,a8) in
    advance (7)
    A := a6[7:0];
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := !a6[15:8][0];
    jump (a4);

DF --> Op0 (RST 3)

    #instruction: RST  3
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0018);

E0 --> Op0 (RCond PO)

    #instruction: RET  PO
    if (!FlagP) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

E1 --> Op0 (POP HL)

    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump ((PCH,PCL));

E2 --> Op2 (JCond PO)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   PO,a7a3
    if (!FlagP) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

E3 --> Op0 XTHL

    #instruction: EX   (SP),HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:8 a4 = M[a2] in
    let:16 a5 = HL in
    let:16 a6 = HL in
    M[a1] := a5[7:0];
    M[a2] := a6[15:8];
    let:16 a7 = HL in
    let:16 a8 = (a7[15:8],a3) in
    advance (18)
    HL := (a4,a8[7:0]);
    jump ((PCH,PCL));

E4 --> Op2 (CCond PO)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL PO,a7a3
    if (!FlagP) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

E5 --> Op0 (PUSH HL)

    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump ((PCH,PCL));

E6 --> Op1 ANI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: AND  a3
    let:8 a5 = A in
    let:8 a6 = (a3 & a5) in
    let:8 a7 = (a3 | a5) in
    advance (7)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := a7[3];
    FlagP := parity(a6);
    FlagCY := false;
    jump (a4);

E7 --> Op0 (RST 4)

    #instruction: RST  4
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0020);

E8 --> Op0 (RCond PE)

    #instruction: RET  PE
    if (FlagP) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

E9 --> Op0 PCHL

    #instruction: JP   (HL)
    let:16 a1 = HL in
    advance (5)
    jump (a1);

EA --> Op2 (JCond PE)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   PE,a7a3
    if (FlagP) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

EB --> Op0 XCHG

    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump ((PCH,PCL));

EC --> Op2 (CCond PE)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL PE,a7a3
    if (FlagP) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

ED --> Op2 (CALLx 2)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: *CAL a7a3
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = SP in
    let:16 a12 = (-1 + a11) in
    M[a12] := a9;
    let:16 a13 = (-1 + a12) in
    M[a13] := a10;
    #return-to: (a9,a10)
    advance (17)
    SP := a13;
    jump ((a7,a3));

EE --> Op1 XRI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: XOR  a3
    let:8 a5 = A in
    let:8 a6 = (a3 ^ a5) in
    advance (7)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := false;
    FlagP := parity(a6);
    FlagCY := false;
    jump (a4);

EF --> Op0 (RST 5)

    #instruction: RST  5
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0028);

F0 --> Op0 (RCond P)

    #instruction: RET  P
    if (!FlagS) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

F1 --> Op0 (POP PSW)

    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump ((PCH,PCL));

F2 --> Op2 (JCond P)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   P,a7a3
    if (!FlagS) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

F3 --> Op0 DI

    #instruction: DI
    disable_interrupts()
    advance (4)
    jump ((PCH,PCL));

F4 --> Op2 (CCond P)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL P,a7a3
    if (!FlagS) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

F5 --> Op0 (PUSH PSW)

    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump ((PCH,PCL));

F6 --> Op1 ORI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: OR   a3
    let:8 a5 = A in
    let:8 a6 = (a3 | a5) in
    advance (7)
    A := a6;
    FlagS := a6[7];
    FlagZ := is_zero(a6);
    FlagA := false;
    FlagP := parity(a6);
    FlagCY := false;
    jump (a4);

F7 --> Op0 (RST 6)

    #instruction: RST  6
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0030);

F8 --> Op0 (RCond MI)

    #instruction: RET  MI
    if (FlagS) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump ((PCH,PCL));
    }

F9 --> Op0 SPHL

    #instruction: LD   SP,HL
    let:16 a1 = HL in
    advance (5)
    SP := a1;
    jump ((PCH,PCL));

FA --> Op2 (JCond MI)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: JP   MI,a7a3
    if (FlagS) {
      advance (10)
      jump ((a7,a3));
    } else {
      advance (10)
      jump (a8);
    }

FB --> Op0 EI

    #instruction: EI
    enable_interrupts()
    advance (4)
    jump ((PCH,PCL));

FC --> Op2 (CCond MI)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: CALL MI,a7a3
    if (FlagS) {
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = SP in
      let:16 a12 = (-1 + a11) in
      M[a12] := a9;
      let:16 a13 = (-1 + a12) in
      M[a13] := a10;
      #return-to: (a9,a10)
      advance (17)
      SP := a13;
      jump ((a7,a3));
    } else {
      advance (11)
      jump (a8);
    }

FD --> Op2 (CALLx 3)

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:8 a7 = M[(a5,a6)] in
    let:16 a8 = (1 + (a5,a6)) in
    #instruction: *CAL a7a3
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = SP in
    let:16 a12 = (-1 + a11) in
    M[a12] := a9;
    let:16 a13 = (-1 + a12) in
    M[a13] := a10;
    #return-to: (a9,a10)
    advance (17)
    SP := a13;
    jump ((a7,a3));

FE --> Op1 CPI

    let:8 a1 = PCH in
    let:8 a2 = PCL in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = (1 + (a1,a2)) in
    #instruction: CP   a3
    let:8 a5 = A in
    let:16 a6 = addWithCarry(!false,a5,~a3) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~a3 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := !a6[15:8][0];
    jump (a4);

FF --> Op0 (RST 7)

    #instruction: RST  7
    let:8 a1 = PCH in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:8 a4 = PCL in
    let:16 a5 = (-1 + a3) in
    M[a5] := a4;
    advance (4)
    SP := a5;
    jump (0038);
