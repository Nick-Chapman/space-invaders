
0000:

    #0000
    #instruction: NOP
    advance (4)
    #0001
    #instruction: NOP
    advance (4)
    #0002
    #instruction: NOP
    advance (4)
    #0003
    #instruction: JP   18D4
    advance (10)
    #18D4
    #instruction: LD   SP,2400
    advance (10)
    #18D7
    #instruction: LD   B,00
    advance (7)
    #18D9
    #instruction: CALL 01E6
    M[23FF] := 18;
    M[23FE] := DC;
    #return-to: 18DC
    advance (17)
    B := 00;
    SPH := 23;
    SPL := FE;
    jump (01E6);

0008:

    #0008
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := a1;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0009
    #instruction: PUSH BC
    let:8 a8 = B in
    let:8 a9 = C in
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #000A
    #instruction: PUSH DE
    let:8 a16 = D in
    let:8 a17 = E in
    let:8 a18 = a15[15:8] in
    let:8 a19 = a15[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a16;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a17;
    advance (11)
    #000B
    #instruction: PUSH HL
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = a23[15:8] in
    let:8 a27 = a23[7:0] in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := a24;
    let:8 a29 = a28[15:8] in
    let:8 a30 = a28[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := a25;
    advance (11)
    #000C
    #instruction: JP   008C
    advance (10)
    #008C
    #instruction: XOR  A
    let:8 a32 = A in
    let:8 a33 = A in
    let:8 a34 = (a32 ^ a33) in
    advance (4)
    #008D
    #instruction: LD   (2072),A
    let:8 a35 = a34 in
    M[2072] := a35;
    advance (13)
    #0090
    #instruction: LD   A,(20E9)
    let:8 a36 = M[20E9] in
    advance (13)
    #0093
    #instruction: AND  A
    let:8 a37 = a36 in
    let:8 a38 = a36 in
    let:8 a39 = (a37 & a38) in
    let:8 a40 = (a37 | a38) in
    advance (4)
    #0094
    #instruction: JP   Z,0082
    if (is_zero(a39)) {
      advance (10)
      A := a39;
      SPH := a31[15:8];
      SPL := a31[7:0];
      FlagS := a39[7];
      FlagZ := is_zero(a39);
      FlagA := a40[3];
      FlagP := parity(a39);
      FlagCY := false;
      jump (0082);
    } else {
      advance (10)
      #0097
      #instruction: LD   A,(20EF)
      let:8 a41 = M[20EF] in
      advance (13)
      #009A
      #instruction: AND  A
      let:8 a42 = a41 in
      let:8 a43 = a41 in
      let:8 a44 = (a42 & a43) in
      let:8 a45 = (a42 | a43) in
      advance (4)
      #009B
      #instruction: JP   NZ,00A5
      if (!is_zero(a44)) {
        advance (10)
        A := a44;
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a44[7];
        FlagZ := is_zero(a44);
        FlagA := a45[3];
        FlagP := parity(a44);
        FlagCY := false;
        jump (00A5);
      } else {
        advance (10)
        #009E
        #instruction: LD   A,(20C1)
        let:8 a46 = M[20C1] in
        advance (13)
        #00A1
        #instruction: RRCA
        let:8 a47 = a46 in
        advance (4)
        #00A2
        #instruction: JP   NC,0082
        if (!a47[0]) {
          advance (10)
          A := updateBit((a47 >> 01),7,a47[0]);
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a44[7];
          FlagZ := is_zero(a44);
          FlagA := a45[3];
          FlagP := parity(a44);
          FlagCY := a47[0];
          jump (0082);
        } else {
          advance (10)
          A := updateBit((a47 >> 01),7,a47[0]);
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a44[7];
          FlagZ := is_zero(a44);
          FlagA := a45[3];
          FlagP := parity(a44);
          FlagCY := a47[0];
          jump (00A5);
        }
      }
    }

0010:

    #0010
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := a1;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0011
    #instruction: PUSH BC
    let:8 a8 = B in
    let:8 a9 = C in
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #0012
    #instruction: PUSH DE
    let:8 a16 = D in
    let:8 a17 = E in
    let:8 a18 = a15[15:8] in
    let:8 a19 = a15[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a16;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a17;
    advance (11)
    #0013
    #instruction: PUSH HL
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = a23[15:8] in
    let:8 a27 = a23[7:0] in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := a24;
    let:8 a29 = a28[15:8] in
    let:8 a30 = a28[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := a25;
    advance (11)
    #0014
    #instruction: LD   A,80
    advance (7)
    #0016
    #instruction: LD   (2072),A
    M[2072] := 80;
    advance (13)
    #0019
    #instruction: LD   HL,20C0
    advance (10)
    #001C
    #instruction: DEC  (HL)
    let:8 a32 = M[20C0] in
    let:16 a33 = addWithCarry(!true,a32,~00) in
    let:8 a34 = (a32 & 0F) in
    let:8 a35 = (~00 & 0F) in
    let:16 a36 = addWithCarry(!true,a34,a35) in
    M[20C0] := a33[7:0];
    advance (10)
    #001D
    #instruction: CALL 17CD
    let:8 a37 = a31[15:8] in
    let:8 a38 = a31[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := 00;
    let:8 a40 = a39[15:8] in
    let:8 a41 = a39[7:0] in
    let:16 a42 = (-1 + (a40,a41)) in
    M[a42] := 20;
    #return-to: 0020
    advance (17)
    #17CD
    #instruction: IN   02
    advance (10)
    #17CF
    #instruction: AND  04
    let:8 a43 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    let:8 a44 = (04 & a43) in
    let:8 a45 = (04 | a43) in
    advance (7)
    #17D1
    #instruction: RET  Z
    if (is_zero(a44)) {
      let:8 a46 = a42[15:8] in
      let:8 a47 = a42[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (11)
      A := a44;
      H := 20;
      L := C0;
      SPH := a52[15:8];
      SPL := a52[7:0];
      FlagS := a44[7];
      FlagZ := is_zero(a44);
      FlagA := a45[3];
      FlagP := parity(a44);
      FlagCY := false;
      jump ((a53,a49));
    } else {
      advance (5)
      #17D2
      #instruction: LD   A,(209A)
      let:8 a54 = M[209A] in
      advance (13)
      #17D5
      #instruction: AND  A
      let:8 a55 = a54 in
      let:8 a56 = a54 in
      let:8 a57 = (a55 & a56) in
      let:8 a58 = (a55 | a56) in
      advance (4)
      #17D6
      #instruction: RET  NZ
      if (!is_zero(a57)) {
        let:8 a59 = a42[15:8] in
        let:8 a60 = a42[7:0] in
        let:16 a61 = (1 + (a59,a60)) in
        let:8 a62 = M[(a59,a60)] in
        let:8 a63 = a61[15:8] in
        let:8 a64 = a61[7:0] in
        let:16 a65 = (1 + (a63,a64)) in
        let:8 a66 = M[(a63,a64)] in
        advance (11)
        A := a57;
        H := 20;
        L := C0;
        SPH := a65[15:8];
        SPL := a65[7:0];
        FlagS := a57[7];
        FlagZ := is_zero(a57);
        FlagA := a58[3];
        FlagP := parity(a57);
        FlagCY := false;
        jump ((a66,a62));
      } else {
        advance (5)
        #17D7
        #instruction: LD   SP,2400
        advance (10)
        #17DA
        #instruction: LD   B,04
        advance (7)
        A := a57;
        B := 04;
        H := 20;
        L := C0;
        SPH := 24;
        SPL := 00;
        FlagS := a57[7];
        FlagZ := is_zero(a57);
        FlagA := a58[3];
        FlagP := parity(a57);
        FlagCY := false;
        jump (17DC);
      }
    }

0020:

    #0020
    #instruction: IN   01
    advance (10)
    #0022
    #instruction: RRCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    advance (4)
    #0023
    #instruction: JP   CY,0067
    if (a1[0]) {
      advance (10)
      #0067
      #instruction: LD   A,01
      advance (7)
      #0069
      #instruction: LD   (20EA),A
      M[20EA] := 01;
      advance (13)
      #006C
      #instruction: JP   003F
      advance (10)
      A := 01;
      FlagCY := a1[0];
      jump (003F);
    } else {
      advance (10)
      #0026
      #instruction: LD   A,(20EA)
      let:8 a2 = M[20EA] in
      advance (13)
      #0029
      #instruction: AND  A
      let:8 a3 = a2 in
      let:8 a4 = a2 in
      let:8 a5 = (a3 & a4) in
      let:8 a6 = (a3 | a4) in
      advance (4)
      #002A
      #instruction: JP   Z,0042
      if (is_zero(a5)) {
        advance (10)
        A := a5;
        FlagS := a5[7];
        FlagZ := is_zero(a5);
        FlagA := a6[3];
        FlagP := parity(a5);
        FlagCY := false;
        jump (0042);
      } else {
        advance (10)
        #002D
        #instruction: LD   A,(20EB)
        let:8 a7 = M[20EB] in
        advance (13)
        #0030
        #instruction: CP   99
        let:8 a8 = a7 in
        let:16 a9 = addWithCarry(!false,a8,~99) in
        let:8 a10 = (a8 & 0F) in
        let:8 a11 = (~99 & 0F) in
        let:16 a12 = addWithCarry(!false,a10,a11) in
        advance (7)
        #0032
        #instruction: JP   Z,003E
        if (is_zero(a9[7:0])) {
          advance (10)
          A := a7;
          FlagS := a9[7:0][7];
          FlagZ := is_zero(a9[7:0]);
          FlagA := a12[7:0][4];
          FlagP := parity(a9[7:0]);
          FlagCY := !a9[15:8][0];
          jump (003E);
        } else {
          advance (10)
          #0035
          #instruction: ADD  01
          let:8 a13 = a7 in
          let:16 a14 = addWithCarry(false,01,a13) in
          let:8 a15 = (01 & 0F) in
          let:8 a16 = (a13 & 0F) in
          let:16 a17 = addWithCarry(false,a15,a16) in
          advance (7)
          #0037
          #instruction: DAA
          let:8 a18 = a14[7:0] in
          let:8 a19 = (a18 & 0F) in
          let:16 a20 = addWithCarry(false,a19,06) in
          let:16 a21 = addWithCarry(((((a19[1] || a19[2]) && a19[3]) || a17[7:0][4]) ? a20[7:0] : a19)[4],(a18 >> 04),00) in
          let:16 a22 = addWithCarry(false,a21[7:0],06) in
          let:8 a23 = (((((a19[1] || a19[2]) && a19[3]) || a17[7:0][4]) ? a20[7:0] : a19) & 0F) in
          let:8 a24 = ((((((a21[7:0][1] || a21[7:0][2]) && a21[7:0][3]) || a14[15:8][0]) ? a22[7:0] : a21[7:0]) << 04) | a23) in
          advance (4)
          #0038
          #instruction: LD   (20EB),A
          let:8 a25 = a24 in
          M[20EB] := a25;
          advance (13)
          #003B
          #instruction: CALL 1947
          let:8 a26 = SPH in
          let:8 a27 = SPL in
          let:16 a28 = (-1 + (a26,a27)) in
          M[a28] := 00;
          let:8 a29 = a28[15:8] in
          let:8 a30 = a28[7:0] in
          let:16 a31 = (-1 + (a29,a30)) in
          M[a31] := 3E;
          #return-to: 003E
          advance (17)
          A := a24;
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a24[7];
          FlagZ := is_zero(a24);
          FlagA := ((((a19[1] || a19[2]) && a19[3]) || a17[7:0][4]) ? a20[7:0] : a19)[4];
          FlagP := parity(a24);
          FlagCY := (((((a21[7:0][1] || a21[7:0][2]) && a21[7:0][3]) || a14[15:8][0]) ? a22[7:0] : a21[7:0])[4] || a14[15:8][0]);
          jump (1947);
        }
      }
    }

003E:

    #003E
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (003F);

003F:

    #003F
    #instruction: LD   (20EA),A
    let:8 a1 = A in
    M[20EA] := a1;
    advance (13)
    jump (0042);

0042:

    #0042
    #instruction: LD   A,(20E9)
    let:8 a1 = M[20E9] in
    advance (13)
    #0045
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0046
    #instruction: JP   Z,0082
    if (is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0082);
    } else {
      advance (10)
      #0049
      #instruction: LD   A,(20EF)
      let:8 a6 = M[20EF] in
      advance (13)
      #004C
      #instruction: AND  A
      let:8 a7 = a6 in
      let:8 a8 = a6 in
      let:8 a9 = (a7 & a8) in
      let:8 a10 = (a7 | a8) in
      advance (4)
      #004D
      #instruction: JP   NZ,006F
      if (!is_zero(a9)) {
        advance (10)
        #006F
        #instruction: CALL 1740
        let:8 a11 = SPH in
        let:8 a12 = SPL in
        let:16 a13 = (-1 + (a11,a12)) in
        M[a13] := 00;
        let:8 a14 = a13[15:8] in
        let:8 a15 = a13[7:0] in
        let:16 a16 = (-1 + (a14,a15)) in
        M[a16] := 72;
        #return-to: 0072
        advance (17)
        #1740
        #instruction: LD   HL,209B
        advance (10)
        #1743
        #instruction: DEC  (HL)
        let:8 a17 = M[209B] in
        let:16 a18 = addWithCarry(!true,a17,~00) in
        let:8 a19 = (a17 & 0F) in
        let:8 a20 = (~00 & 0F) in
        let:16 a21 = addWithCarry(!true,a19,a20) in
        M[209B] := a18[7:0];
        advance (10)
        #1744
        #instruction: CALL Z,176D
        if (is_zero(a18[7:0])) {
          let:8 a22 = a16[15:8] in
          let:8 a23 = a16[7:0] in
          let:16 a24 = (-1 + (a22,a23)) in
          M[a24] := 17;
          let:8 a25 = a24[15:8] in
          let:8 a26 = a24[7:0] in
          let:16 a27 = (-1 + (a25,a26)) in
          M[a27] := 47;
          #return-to: 1747
          advance (17)
          A := a9;
          H := 20;
          L := 9B;
          SPH := a27[15:8];
          SPL := a27[7:0];
          FlagS := a18[7:0][7];
          FlagZ := is_zero(a18[7:0]);
          FlagA := a21[7:0][4];
          FlagP := parity(a18[7:0]);
          FlagCY := false;
          jump (176D);
        } else {
          advance (11)
          A := a9;
          H := 20;
          L := 9B;
          SPH := a16[15:8];
          SPL := a16[7:0];
          FlagS := a18[7:0][7];
          FlagZ := is_zero(a18[7:0]);
          FlagA := a21[7:0][4];
          FlagP := parity(a18[7:0]);
          FlagCY := false;
          jump (1747);
        }
      } else {
        advance (10)
        #0050
        #instruction: LD   A,(20EB)
        let:8 a28 = M[20EB] in
        advance (13)
        #0053
        #instruction: AND  A
        let:8 a29 = a28 in
        let:8 a30 = a28 in
        let:8 a31 = (a29 & a30) in
        let:8 a32 = (a29 | a30) in
        advance (4)
        #0054
        #instruction: JP   NZ,005D
        if (!is_zero(a31)) {
          advance (10)
          #005D
          #instruction: LD   A,(2093)
          let:8 a33 = M[2093] in
          advance (13)
          #0060
          #instruction: AND  A
          let:8 a34 = a33 in
          let:8 a35 = a33 in
          let:8 a36 = (a34 & a35) in
          let:8 a37 = (a34 | a35) in
          advance (4)
          #0061
          #instruction: JP   NZ,0082
          if (!is_zero(a36)) {
            advance (10)
            A := a36;
            FlagS := a36[7];
            FlagZ := is_zero(a36);
            FlagA := a37[3];
            FlagP := parity(a36);
            FlagCY := false;
            jump (0082);
          } else {
            advance (10)
            #0064
            #instruction: JP   0765
            advance (10)
            #0765
            #instruction: LD   A,01
            advance (7)
            #0767
            #instruction: LD   (2093),A
            M[2093] := 01;
            advance (13)
            #076A
            #instruction: LD   SP,2400
            advance (10)
            #076D
            #instruction: EI
            enable_interrupts()
            advance (4)
            #076E
            #instruction: CALL 1979
            M[23FF] := 07;
            M[23FE] := 71;
            #return-to: 0771
            advance (17)
            #1979
            #instruction: CALL 19D7
            M[23FD] := 19;
            M[23FC] := 7C;
            #return-to: 197C
            advance (17)
            A := 01;
            SPH := 23;
            SPL := FC;
            FlagS := a36[7];
            FlagZ := is_zero(a36);
            FlagA := a37[3];
            FlagP := parity(a36);
            FlagCY := false;
            jump (19D7);
          }
        } else {
          advance (10)
          #0057
          #instruction: CALL 0ABF
          let:8 a38 = SPH in
          let:8 a39 = SPL in
          let:16 a40 = (-1 + (a38,a39)) in
          M[a40] := 00;
          let:8 a41 = a40[15:8] in
          let:8 a42 = a40[7:0] in
          let:16 a43 = (-1 + (a41,a42)) in
          M[a43] := 5A;
          #return-to: 005A
          advance (17)
          #0ABF
          #instruction: LD   A,(20C1)
          let:8 a44 = M[20C1] in
          advance (13)
          #0AC2
          #instruction: RRCA
          let:8 a45 = a44 in
          advance (4)
          #0AC3
          #instruction: JP   CY,0ABB
          if (a45[0]) {
            advance (10)
            #0ABB
            #instruction: POP  HL
            let:8 a46 = a43[15:8] in
            let:8 a47 = a43[7:0] in
            let:16 a48 = (1 + (a46,a47)) in
            let:8 a49 = M[(a46,a47)] in
            let:8 a50 = a48[15:8] in
            let:8 a51 = a48[7:0] in
            let:16 a52 = (1 + (a50,a51)) in
            let:8 a53 = M[(a50,a51)] in
            advance (10)
            #0ABC
            #instruction: JP   0072
            advance (10)
            A := updateBit((a45 >> 01),7,a45[0]);
            H := a53;
            L := a49;
            SPH := a52[15:8];
            SPL := a52[7:0];
            FlagS := a31[7];
            FlagZ := is_zero(a31);
            FlagA := a32[3];
            FlagP := parity(a31);
            FlagCY := a45[0];
            jump (0072);
          } else {
            advance (10)
            #0AC6
            #instruction: RRCA
            let:8 a54 = updateBit((a45 >> 01),7,a45[0]) in
            advance (4)
            #0AC7
            #instruction: JP   CY,1868
            if (a54[0]) {
              advance (10)
              #1868
              #instruction: LD   HL,20C2
              advance (10)
              #186B
              #instruction: INC  (HL)
              let:8 a55 = M[20C2] in
              let:16 a56 = addWithCarry(true,a55,00) in
              let:8 a57 = (a55 & 0F) in
              let:8 a58 = (00 & 0F) in
              let:16 a59 = addWithCarry(true,a57,a58) in
              M[20C2] := a56[7:0];
              advance (10)
              #186C
              #instruction: INC  HL
              advance (5)
              #186D
              #instruction: LD   C,(HL)
              let:8 a60 = M[20C3] in
              advance (7)
              #186E
              #instruction: CALL 01D9
              let:8 a61 = a43[15:8] in
              let:8 a62 = a43[7:0] in
              let:16 a63 = (-1 + (a61,a62)) in
              M[a63] := 18;
              let:8 a64 = a63[15:8] in
              let:8 a65 = a63[7:0] in
              let:16 a66 = (-1 + (a64,a65)) in
              M[a66] := 71;
              #return-to: 1871
              advance (17)
              A := updateBit((a54 >> 01),7,a54[0]);
              C := a60;
              H := 20;
              L := C3;
              SPH := a66[15:8];
              SPL := a66[7:0];
              FlagS := a56[7:0][7];
              FlagZ := is_zero(a56[7:0]);
              FlagA := a59[7:0][4];
              FlagP := parity(a56[7:0]);
              FlagCY := a54[0];
              jump (01D9);
            } else {
              advance (10)
              #0ACA
              #instruction: RRCA
              let:8 a67 = updateBit((a54 >> 01),7,a54[0]) in
              advance (4)
              #0ACB
              #instruction: JP   CY,0AAB
              if (a67[0]) {
                advance (10)
                #0AAB
                #instruction: LD   HL,2050
                advance (10)
                #0AAE
                #instruction: JP   024B
                advance (10)
                A := updateBit((a67 >> 01),7,a67[0]);
                H := 20;
                L := 50;
                SPH := a43[15:8];
                SPL := a43[7:0];
                FlagS := a31[7];
                FlagZ := is_zero(a31);
                FlagA := a32[3];
                FlagP := parity(a31);
                FlagCY := a67[0];
                jump (024B);
              } else {
                advance (10)
                #0ACE
                #instruction: RET
                let:8 a68 = a43[15:8] in
                let:8 a69 = a43[7:0] in
                let:16 a70 = (1 + (a68,a69)) in
                let:8 a71 = M[(a68,a69)] in
                let:8 a72 = a70[15:8] in
                let:8 a73 = a70[7:0] in
                let:16 a74 = (1 + (a72,a73)) in
                let:8 a75 = M[(a72,a73)] in
                advance (10)
                A := updateBit((a67 >> 01),7,a67[0]);
                SPH := a74[15:8];
                SPL := a74[7:0];
                FlagS := a31[7];
                FlagZ := is_zero(a31);
                FlagA := a32[3];
                FlagP := parity(a31);
                FlagCY := a67[0];
                jump ((a75,a71));
              }
            }
          }
        }
      }
    }

005A:

    #005A
    #instruction: JP   0082
    advance (10)
    jump (0082);

0072:

    #0072
    #instruction: LD   A,(2032)
    let:8 a1 = M[2032] in
    advance (13)
    #0075
    #instruction: LD   (2080),A
    let:8 a2 = a1 in
    M[2080] := a2;
    advance (13)
    #0078
    #instruction: CALL 0100
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 00;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 7B;
    #return-to: 007B
    advance (17)
    #0100
    #instruction: LD   HL,2002
    advance (10)
    #0103
    #instruction: LD   A,(HL)
    let:8 a9 = M[2002] in
    advance (7)
    #0104
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #0105
    #instruction: JP   NZ,1538
    if (!is_zero(a12)) {
      advance (10)
      #1538
      #instruction: LD   HL,2003
      advance (10)
      #153B
      #instruction: DEC  (HL)
      let:8 a14 = M[2003] in
      let:16 a15 = addWithCarry(!true,a14,~00) in
      let:8 a16 = (a14 & 0F) in
      let:8 a17 = (~00 & 0F) in
      let:16 a18 = addWithCarry(!true,a16,a17) in
      M[2003] := a15[7:0];
      advance (10)
      #153C
      #instruction: RET  NZ
      if (!is_zero(a15[7:0])) {
        let:8 a19 = a8[15:8] in
        let:8 a20 = a8[7:0] in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        let:8 a23 = a21[15:8] in
        let:8 a24 = a21[7:0] in
        let:16 a25 = (1 + (a23,a24)) in
        let:8 a26 = M[(a23,a24)] in
        advance (11)
        A := a12;
        H := 20;
        L := 03;
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := false;
        jump ((a26,a22));
      } else {
        advance (5)
        #153D
        #instruction: LD   HL,(2064)
        let:8 a27 = M[2064] in
        let:8 a28 = M[2065] in
        advance (16)
        #1540
        #instruction: LD   B,10
        advance (7)
        #1542
        #instruction: CALL 1424
        let:8 a29 = a8[15:8] in
        let:8 a30 = a8[7:0] in
        let:16 a31 = (-1 + (a29,a30)) in
        M[a31] := 15;
        let:8 a32 = a31[15:8] in
        let:8 a33 = a31[7:0] in
        let:16 a34 = (-1 + (a32,a33)) in
        M[a34] := 45;
        #return-to: 1545
        advance (17)
        A := a12;
        B := 10;
        H := a28;
        L := a27;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := false;
        jump (1424);
      }
    } else {
      advance (10)
      #0108
      #instruction: PUSH HL
      let:8 a35 = a8[15:8] in
      let:8 a36 = a8[7:0] in
      let:16 a37 = (-1 + (a35,a36)) in
      M[a37] := 20;
      let:8 a38 = a37[15:8] in
      let:8 a39 = a37[7:0] in
      let:16 a40 = (-1 + (a38,a39)) in
      M[a40] := 02;
      advance (11)
      #0109
      #instruction: LD   A,(2006)
      let:8 a41 = M[2006] in
      advance (13)
      #010C
      #instruction: LD   L,A
      let:8 a42 = a41 in
      advance (5)
      #010D
      #instruction: LD   A,(2067)
      let:8 a43 = M[2067] in
      advance (13)
      #0110
      #instruction: LD   H,A
      let:8 a44 = a43 in
      advance (5)
      #0111
      #instruction: LD   A,(HL)
      let:8 a45 = a44 in
      let:8 a46 = a42 in
      let:8 a47 = M[(a45,a46)] in
      advance (7)
      #0112
      #instruction: AND  A
      let:8 a48 = a47 in
      let:8 a49 = a47 in
      let:8 a50 = (a48 & a49) in
      let:8 a51 = (a48 | a49) in
      advance (4)
      #0113
      #instruction: POP  HL
      let:8 a52 = a40[15:8] in
      let:8 a53 = a40[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      advance (10)
      #0114
      #instruction: JP   Z,0136
      if (is_zero(a50)) {
        advance (10)
        A := a50;
        H := a59;
        L := a55;
        SPH := a58[15:8];
        SPL := a58[7:0];
        FlagS := a50[7];
        FlagZ := is_zero(a50);
        FlagA := a51[3];
        FlagP := parity(a50);
        FlagCY := false;
        jump (0136);
      } else {
        advance (10)
        #0117
        #instruction: INC  HL
        let:8 a60 = a59 in
        let:8 a61 = a55 in
        let:16 a62 = (1 + (a60,a61)) in
        advance (5)
        #0118
        #instruction: INC  HL
        let:8 a63 = a62[15:8] in
        let:8 a64 = a62[7:0] in
        let:16 a65 = (1 + (a63,a64)) in
        advance (5)
        #0119
        #instruction: LD   A,(HL)
        let:8 a66 = a65[15:8] in
        let:8 a67 = a65[7:0] in
        let:8 a68 = M[(a66,a67)] in
        advance (7)
        #011A
        #instruction: INC  HL
        let:8 a69 = a65[15:8] in
        let:8 a70 = a65[7:0] in
        let:16 a71 = (1 + (a69,a70)) in
        advance (5)
        #011B
        #instruction: LD   B,(HL)
        let:8 a72 = a71[15:8] in
        let:8 a73 = a71[7:0] in
        let:8 a74 = M[(a72,a73)] in
        advance (7)
        #011C
        #instruction: AND  FE
        let:8 a75 = a68 in
        let:8 a76 = (FE & a75) in
        let:8 a77 = (FE | a75) in
        advance (7)
        #011E
        #instruction: RLCA
        let:8 a78 = a76 in
        advance (4)
        #011F
        #instruction: RLCA
        let:8 a79 = updateBit((a78 << 01),0,a78[7]) in
        advance (4)
        #0120
        #instruction: RLCA
        let:8 a80 = updateBit((a79 << 01),0,a79[7]) in
        advance (4)
        #0121
        #instruction: LD   E,A
        let:8 a81 = updateBit((a80 << 01),0,a80[7]) in
        advance (5)
        #0122
        #instruction: LD   D,00
        advance (7)
        #0124
        #instruction: LD   HL,1C00
        advance (10)
        #0127
        #instruction: ADD  HL,DE
        let:8 a82 = a81 in
        let:17 a83 = add17((00,a82),1C00) in
        advance (10)
        #0128
        #instruction: EX   DE,HL
        let:8 a84 = a81 in
        let:8 a85 = a83[15:0][15:8] in
        let:8 a86 = a83[15:0][7:0] in
        advance (4)
        #0129
        #instruction: LD   A,B
        let:8 a87 = a74 in
        advance (5)
        #012A
        #instruction: AND  A
        let:8 a88 = a87 in
        let:8 a89 = a87 in
        let:8 a90 = (a88 & a89) in
        let:8 a91 = (a88 | a89) in
        advance (4)
        #012B
        #instruction: CALL NZ,013B
        if (!is_zero(a90)) {
          let:8 a92 = a58[15:8] in
          let:8 a93 = a58[7:0] in
          let:16 a94 = (-1 + (a92,a93)) in
          M[a94] := 01;
          let:8 a95 = a94[15:8] in
          let:8 a96 = a94[7:0] in
          let:16 a97 = (-1 + (a95,a96)) in
          M[a97] := 2E;
          #return-to: 012E
          advance (17)
          #013B
          #instruction: LD   HL,0030
          advance (10)
          #013E
          #instruction: ADD  HL,DE
          let:8 a98 = a85 in
          let:8 a99 = a86 in
          let:17 a100 = add17((a98,a99),0030) in
          advance (10)
          #013F
          #instruction: EX   DE,HL
          let:8 a101 = a85 in
          let:8 a102 = a86 in
          let:8 a103 = a100[15:0][15:8] in
          let:8 a104 = a100[15:0][7:0] in
          advance (4)
          #0140
          #instruction: RET
          let:8 a105 = a97[15:8] in
          let:8 a106 = a97[7:0] in
          let:16 a107 = (1 + (a105,a106)) in
          let:8 a108 = M[(a105,a106)] in
          let:8 a109 = a107[15:8] in
          let:8 a110 = a107[7:0] in
          let:16 a111 = (1 + (a109,a110)) in
          let:8 a112 = M[(a109,a110)] in
          advance (10)
          A := a90;
          B := a74;
          D := a103;
          E := a104;
          H := a101;
          L := a102;
          SPH := a111[15:8];
          SPL := a111[7:0];
          FlagS := a90[7];
          FlagZ := is_zero(a90);
          FlagA := a91[3];
          FlagP := parity(a90);
          FlagCY := a100[16];
          jump ((a112,a108));
        } else {
          advance (11)
          A := a90;
          B := a74;
          D := a85;
          E := a86;
          H := 00;
          L := a84;
          SPH := a58[15:8];
          SPL := a58[7:0];
          FlagS := a90[7];
          FlagZ := is_zero(a90);
          FlagA := a91[3];
          FlagP := parity(a90);
          FlagCY := false;
          jump (012E);
        }
      }
    }

007B:

    #007B
    #instruction: CALL 0248
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7E;
    #return-to: 007E
    advance (17)
    #0248
    #instruction: LD   HL,2010
    advance (10)
    H := 20;
    L := 10;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (024B);

007E:

    #007E
    #instruction: CALL 0913
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 81;
    #return-to: 0081
    advance (17)
    #0913
    #instruction: LD   A,(2009)
    let:8 a7 = M[2009] in
    advance (13)
    #0916
    #instruction: CP   78
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~78) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~78 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #0918
    #instruction: RET  NC
    if (!!a9[15:8][0]) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #0919
      #instruction: LD   HL,(2091)
      let:8 a21 = M[2091] in
      let:8 a22 = M[2092] in
      advance (16)
      #091C
      #instruction: LD   A,L
      let:8 a23 = a21 in
      advance (5)
      #091D
      #instruction: OR   H
      let:8 a24 = a22 in
      let:8 a25 = a23 in
      let:8 a26 = (a24 | a25) in
      advance (4)
      #091E
      #instruction: JP   NZ,0929
      if (!is_zero(a26)) {
        advance (10)
        A := a26;
        H := a22;
        L := a21;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := false;
        FlagP := parity(a26);
        FlagCY := false;
        jump (0929);
      } else {
        advance (10)
        #0921
        #instruction: LD   HL,0600
        advance (10)
        #0924
        #instruction: LD   A,01
        advance (7)
        #0926
        #instruction: LD   (2083),A
        M[2083] := 01;
        advance (13)
        A := 01;
        H := 06;
        L := 00;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := false;
        FlagP := parity(a26);
        FlagCY := false;
        jump (0929);
      }
    }

0081:

    #0081
    #instruction: NOP
    advance (4)
    jump (0082);

0082:

    #0082
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0083
    #instruction: POP  DE
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0084
    #instruction: POP  BC
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    let:8 a29 = a27[15:8] in
    let:8 a30 = a27[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    let:8 a32 = M[(a29,a30)] in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:8 a33 = a31[15:8] in
    let:8 a34 = a31[7:0] in
    let:16 a35 = (1 + (a33,a34)) in
    let:8 a36 = M[(a33,a34)] in
    let:8 a37 = a35[15:8] in
    let:8 a38 = a35[7:0] in
    let:16 a39 = (1 + (a37,a38)) in
    let:8 a40 = M[(a37,a38)] in
    advance (10)
    A := a32;
    B := a24;
    C := a20;
    D := a16;
    E := a12;
    H := a8;
    L := a4;
    SPH := a39[15:8];
    SPL := a39[7:0];
    FlagS := a28[7];
    FlagZ := a28[6];
    FlagA := a28[4];
    FlagP := a28[2];
    FlagCY := a28[0];
    jump ((a40,a36));

00A5:

    #00A5
    #instruction: LD   HL,2020
    advance (10)
    #00A8
    #instruction: CALL 024B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := AB;
    #return-to: 00AB
    advance (17)
    H := 20;
    L := 20;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (024B);

00AB:

    #00AB
    #instruction: CALL 0141
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := AE;
    #return-to: 00AE
    advance (17)
    #0141
    #instruction: LD   A,(2068)
    let:8 a7 = M[2068] in
    advance (13)
    #0144
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0145
    #instruction: RET  Z
    if (is_zero(a10)) {
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (11)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    } else {
      advance (5)
      #0146
      #instruction: LD   A,(2000)
      let:8 a20 = M[2000] in
      advance (13)
      #0149
      #instruction: AND  A
      let:8 a21 = a20 in
      let:8 a22 = a20 in
      let:8 a23 = (a21 & a22) in
      let:8 a24 = (a21 | a22) in
      advance (4)
      #014A
      #instruction: RET  NZ
      if (!is_zero(a23)) {
        let:8 a25 = a6[15:8] in
        let:8 a26 = a6[7:0] in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        let:8 a29 = a27[15:8] in
        let:8 a30 = a27[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        advance (11)
        A := a23;
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump ((a32,a28));
      } else {
        advance (5)
        #014B
        #instruction: LD   A,(2067)
        let:8 a33 = M[2067] in
        advance (13)
        #014E
        #instruction: LD   H,A
        let:8 a34 = a33 in
        advance (5)
        #014F
        #instruction: LD   A,(2006)
        let:8 a35 = M[2006] in
        advance (13)
        #0152
        #instruction: LD   D,02
        advance (7)
        A := a35;
        D := 02;
        H := a34;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump (0154);
      }
    }

00AE:

    #00AE
    #instruction: JP   0082
    advance (10)
    jump (0082);

00B4:

    #00B4
    #instruction: PUSH HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #00B5
    #instruction: LD   A,(HL)
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = M[(a9,a10)] in
    advance (7)
    #00B6
    #instruction: INC  HL
    let:8 a12 = H in
    let:8 a13 = L in
    let:16 a14 = (1 + (a12,a13)) in
    advance (5)
    #00B7
    #instruction: LD   H,(HL)
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:8 a17 = M[(a15,a16)] in
    advance (7)
    #00B8
    #instruction: LD   L,A
    let:8 a18 = a11 in
    advance (5)
    #00B9
    #instruction: LD   (2009),HL
    let:8 a19 = a18 in
    M[2009] := a19;
    let:8 a20 = a17 in
    M[200A] := a20;
    advance (16)
    #00BC
    #instruction: LD   (200B),HL
    let:8 a21 = a18 in
    M[200B] := a21;
    let:8 a22 = a17 in
    M[200C] := a22;
    advance (16)
    #00BF
    #instruction: POP  HL
    let:8 a23 = a8[15:8] in
    let:8 a24 = a8[7:0] in
    let:16 a25 = (1 + (a23,a24)) in
    let:8 a26 = M[(a23,a24)] in
    let:8 a27 = a25[15:8] in
    let:8 a28 = a25[7:0] in
    let:16 a29 = (1 + (a27,a28)) in
    let:8 a30 = M[(a27,a28)] in
    advance (10)
    #00C0
    #instruction: DEC  HL
    let:8 a31 = a30 in
    let:8 a32 = a26 in
    let:16 a33 = (-1 + (a31,a32)) in
    advance (5)
    #00C1
    #instruction: LD   A,(HL)
    let:8 a34 = a33[15:8] in
    let:8 a35 = a33[7:0] in
    let:8 a36 = M[(a34,a35)] in
    advance (7)
    #00C2
    #instruction: CP   03
    let:8 a37 = a36 in
    let:16 a38 = addWithCarry(!false,a37,~03) in
    let:8 a39 = (a37 & 0F) in
    let:8 a40 = (~03 & 0F) in
    let:16 a41 = addWithCarry(!false,a39,a40) in
    advance (7)
    #00C4
    #instruction: JP   NZ,00C8
    if (!is_zero(a38[7:0])) {
      advance (10)
      A := a36;
      H := a33[15:8];
      L := a33[7:0];
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a38[7:0][7];
      FlagZ := is_zero(a38[7:0]);
      FlagA := a41[7:0][4];
      FlagP := parity(a38[7:0]);
      FlagCY := !a38[15:8][0];
      jump (00C8);
    } else {
      advance (10)
      #00C7
      #instruction: DEC  A
      let:8 a42 = a36 in
      let:16 a43 = addWithCarry(!true,a42,~00) in
      let:8 a44 = (a42 & 0F) in
      let:8 a45 = (~00 & 0F) in
      let:16 a46 = addWithCarry(!true,a44,a45) in
      advance (5)
      A := a43[7:0];
      H := a33[15:8];
      L := a33[7:0];
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a43[7:0][7];
      FlagZ := is_zero(a43[7:0]);
      FlagA := a46[7:0][4];
      FlagP := parity(a43[7:0]);
      FlagCY := !a38[15:8][0];
      jump (00C8);
    }

00C8:

    #00C8
    #instruction: LD   (2008),A
    let:8 a1 = A in
    M[2008] := a1;
    advance (13)
    #00CB
    #instruction: CP   FE
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~FE) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~FE & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #00CD
    #instruction: LD   A,00
    advance (7)
    #00CF
    #instruction: JP   NZ,00D3
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := 00;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (00D3);
    } else {
      advance (10)
      #00D2
      #instruction: INC  A
      let:16 a7 = addWithCarry(true,00,00) in
      let:8 a8 = (00 & 0F) in
      let:8 a9 = (00 & 0F) in
      let:16 a10 = addWithCarry(true,a8,a9) in
      advance (5)
      A := a7[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := !a3[15:8][0];
      jump (00D3);
    }

00D3:

    #00D3
    #instruction: LD   (200D),A
    let:8 a1 = A in
    M[200D] := a1;
    advance (13)
    #00D6
    #instruction: RET
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (1 + (a2,a3)) in
    let:8 a5 = M[(a2,a3)] in
    let:8 a6 = a4[15:8] in
    let:8 a7 = a4[7:0] in
    let:16 a8 = (1 + (a6,a7)) in
    let:8 a9 = M[(a6,a7)] in
    advance (10)
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((a9,a5));

012E:

    #012E
    #instruction: LD   HL,(200B)
    let:8 a1 = M[200B] in
    let:8 a2 = M[200C] in
    advance (16)
    #0131
    #instruction: LD   B,10
    advance (7)
    #0133
    #instruction: CALL 15D3
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 01;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 36;
    #return-to: 0136
    advance (17)
    B := 10;
    H := a2;
    L := a1;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (15D3);

0136:

    #0136
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0137
    #instruction: LD   (2000),A
    let:8 a4 = a3 in
    M[2000] := a4;
    advance (13)
    #013A
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a12,a8));

0154:

    #0154
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    #0155
    #instruction: CP   37
    let:8 a6 = a2[7:0] in
    let:16 a7 = addWithCarry(!false,a6,~37) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~37 & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #0157
    #instruction: CALL Z,01A1
    if (is_zero(a7[7:0])) {
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 01;
      let:8 a14 = a13[15:8] in
      let:8 a15 = a13[7:0] in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 5A;
      #return-to: 015A
      advance (17)
      #01A1
      #instruction: DEC  D
      let:8 a17 = D in
      let:16 a18 = addWithCarry(!true,a17,~00) in
      let:8 a19 = (a17 & 0F) in
      let:8 a20 = (~00 & 0F) in
      let:16 a21 = addWithCarry(!true,a19,a20) in
      advance (5)
      #01A2
      #instruction: JP   Z,01CD
      if (is_zero(a18[7:0])) {
        advance (10)
        #01CD
        #instruction: POP  HL
        let:8 a22 = a16[15:8] in
        let:8 a23 = a16[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        let:8 a26 = a24[15:8] in
        let:8 a27 = a24[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        advance (10)
        #01CE
        #instruction: RET
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        let:8 a34 = a32[15:8] in
        let:8 a35 = a32[7:0] in
        let:16 a36 = (1 + (a34,a35)) in
        let:8 a37 = M[(a34,a35)] in
        advance (10)
        A := a2[7:0];
        D := a18[7:0];
        H := a29;
        L := a25;
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagS := a18[7:0][7];
        FlagZ := is_zero(a18[7:0]);
        FlagA := a21[7:0][4];
        FlagP := parity(a18[7:0]);
        FlagCY := !a7[15:8][0];
        jump ((a37,a33));
      } else {
        advance (10)
        #01A5
        #instruction: LD   HL,2006
        advance (10)
        #01A8
        #instruction: LD   (HL),00
        M[2006] := 00;
        advance (10)
        #01AA
        #instruction: INC  HL
        advance (5)
        #01AB
        #instruction: LD   C,(HL)
        let:8 a38 = M[2007] in
        advance (7)
        #01AC
        #instruction: LD   (HL),00
        M[2007] := 00;
        advance (10)
        #01AE
        #instruction: CALL 01D9
        let:8 a39 = a16[15:8] in
        let:8 a40 = a16[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := 01;
        let:8 a42 = a41[15:8] in
        let:8 a43 = a41[7:0] in
        let:16 a44 = (-1 + (a42,a43)) in
        M[a44] := B1;
        #return-to: 01B1
        advance (17)
        A := a2[7:0];
        C := a38;
        D := a18[7:0];
        H := 20;
        L := 07;
        SPH := a44[15:8];
        SPL := a44[7:0];
        FlagS := a18[7:0][7];
        FlagZ := is_zero(a18[7:0]);
        FlagA := a21[7:0][4];
        FlagP := parity(a18[7:0]);
        FlagCY := !a7[15:8][0];
        jump (01D9);
      }
    } else {
      advance (11)
      A := a2[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := !a7[15:8][0];
      jump (015A);
    }

015A:

    #015A
    #instruction: LD   L,A
    let:8 a1 = A in
    advance (5)
    #015B
    #instruction: LD   B,(HL)
    let:8 a2 = H in
    let:8 a3 = a1 in
    let:8 a4 = M[(a2,a3)] in
    advance (7)
    #015C
    #instruction: DEC  B
    let:8 a5 = a4 in
    let:16 a6 = addWithCarry(!true,a5,~00) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~00 & 0F) in
    let:16 a9 = addWithCarry(!true,a7,a8) in
    advance (5)
    #015D
    #instruction: JP   NZ,0154
    if (!is_zero(a6[7:0])) {
      advance (10)
      B := a6[7:0];
      L := a1;
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      jump (0154);
    } else {
      advance (10)
      #0160
      #instruction: LD   (2006),A
      let:8 a10 = A in
      M[2006] := a10;
      advance (13)
      #0163
      #instruction: CALL 017A
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 01;
      let:8 a14 = a13[15:8] in
      let:8 a15 = a13[7:0] in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 66;
      #return-to: 0166
      advance (17)
      B := a6[7:0];
      L := a1;
      SPH := a16[15:8];
      SPL := a16[7:0];
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      jump (017A);
    }

0166:

    #0166
    #instruction: LD   H,C
    let:8 a1 = C in
    advance (5)
    #0167
    #instruction: LD   (200B),HL
    let:8 a2 = L in
    M[200B] := a2;
    let:8 a3 = a1 in
    M[200C] := a3;
    advance (16)
    #016A
    #instruction: LD   A,L
    let:8 a4 = L in
    advance (5)
    #016B
    #instruction: CP   28
    let:8 a5 = a4 in
    let:16 a6 = addWithCarry(!false,a5,~28) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~28 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    #016D
    #instruction: JP   CY,1971
    if (!a6[15:8][0]) {
      advance (10)
      #1971
      #instruction: LD   A,01
      advance (7)
      #1973
      #instruction: LD   (206D),A
      M[206D] := 01;
      advance (13)
      #1976
      #instruction: JP   16E6
      advance (10)
      #16E6
      #instruction: LD   SP,2400
      advance (10)
      #16E9
      #instruction: EI
      enable_interrupts()
      advance (4)
      #16EA
      #instruction: XOR  A
      let:8 a10 = (01 ^ 01) in
      advance (4)
      #16EB
      #instruction: LD   (2015),A
      let:8 a11 = a10 in
      M[2015] := a11;
      advance (13)
      A := a10;
      H := a1;
      SPH := 24;
      SPL := 00;
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := false;
      FlagP := parity(a10);
      FlagCY := false;
      jump (16EE);
    } else {
      advance (10)
      #0170
      #instruction: LD   A,D
      let:8 a12 = D in
      advance (5)
      #0171
      #instruction: LD   (2004),A
      let:8 a13 = a12 in
      M[2004] := a13;
      advance (13)
      #0174
      #instruction: LD   A,01
      advance (7)
      #0176
      #instruction: LD   (2000),A
      M[2000] := 01;
      advance (13)
      #0179
      #instruction: RET
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (10)
      A := 01;
      H := a1;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      FlagCY := !a6[15:8][0];
      jump ((a21,a17));
    }

017A:

    #017A
    #instruction: LD   D,00
    advance (7)
    #017C
    #instruction: LD   A,L
    let:8 a1 = L in
    advance (5)
    #017D
    #instruction: LD   HL,2009
    advance (10)
    #0180
    #instruction: LD   B,(HL)
    let:8 a2 = M[2009] in
    advance (7)
    #0181
    #instruction: INC  HL
    advance (5)
    #0182
    #instruction: LD   C,(HL)
    let:8 a3 = M[200A] in
    advance (7)
    A := a1;
    B := a2;
    C := a3;
    D := 00;
    H := 20;
    L := 0A;
    jump (0183);

0183:

    #0183
    #instruction: CP   0B
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0B) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0B & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    #0185
    #instruction: JP   MI,0194
    if (a2[7:0][7]) {
      advance (10)
      #0194
      #instruction: LD   L,B
      let:8 a6 = B in
      advance (5)
      L := a6;
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      FlagCY := !a2[15:8][0];
      jump (0195);
    } else {
      advance (10)
      #0188
      #instruction: SBC  0B
      let:8 a7 = A in
      let:16 a8 = addWithCarry(!!a2[15:8][0],a7,~0B) in
      let:8 a9 = (a7 & 0F) in
      let:8 a10 = (~0B & 0F) in
      let:16 a11 = addWithCarry(!!a2[15:8][0],a9,a10) in
      advance (7)
      #018A
      #instruction: LD   E,A
      let:8 a12 = a8[7:0] in
      advance (5)
      #018B
      #instruction: LD   A,B
      let:8 a13 = B in
      advance (5)
      #018C
      #instruction: ADD  10
      let:8 a14 = a13 in
      let:16 a15 = addWithCarry(false,10,a14) in
      let:8 a16 = (10 & 0F) in
      let:8 a17 = (a14 & 0F) in
      let:16 a18 = addWithCarry(false,a16,a17) in
      advance (7)
      #018E
      #instruction: LD   B,A
      let:8 a19 = a15[7:0] in
      advance (5)
      #018F
      #instruction: LD   A,E
      let:8 a20 = a12 in
      advance (5)
      #0190
      #instruction: INC  D
      let:8 a21 = D in
      let:16 a22 = addWithCarry(true,a21,00) in
      let:8 a23 = (a21 & 0F) in
      let:8 a24 = (00 & 0F) in
      let:16 a25 = addWithCarry(true,a23,a24) in
      advance (5)
      #0191
      #instruction: JP   0183
      advance (10)
      A := a20;
      B := a19;
      D := a22[7:0];
      E := a12;
      FlagS := a22[7:0][7];
      FlagZ := is_zero(a22[7:0]);
      FlagA := a25[7:0][4];
      FlagP := parity(a22[7:0]);
      FlagCY := a15[15:8][0];
      jump (0183);
    }

0195:

    #0195
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    #0196
    #instruction: RET  Z
    if (is_zero(a3)) {
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      let:8 a9 = a7[15:8] in
      let:8 a10 = a7[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      advance (11)
      A := a3;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((a12,a8));
    } else {
      advance (5)
      #0197
      #instruction: LD   E,A
      let:8 a13 = a3 in
      advance (5)
      #0198
      #instruction: LD   A,C
      let:8 a14 = C in
      advance (5)
      #0199
      #instruction: ADD  10
      let:8 a15 = a14 in
      let:16 a16 = addWithCarry(false,10,a15) in
      let:8 a17 = (10 & 0F) in
      let:8 a18 = (a15 & 0F) in
      let:16 a19 = addWithCarry(false,a17,a18) in
      advance (7)
      #019B
      #instruction: LD   C,A
      let:8 a20 = a16[7:0] in
      advance (5)
      #019C
      #instruction: LD   A,E
      let:8 a21 = a13 in
      advance (5)
      #019D
      #instruction: DEC  A
      let:8 a22 = a21 in
      let:16 a23 = addWithCarry(!true,a22,~00) in
      let:8 a24 = (a22 & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #019E
      #instruction: JP   0195
      advance (10)
      A := a23[7:0];
      C := a20;
      E := a13;
      FlagS := a23[7:0][7];
      FlagZ := is_zero(a23[7:0]);
      FlagA := a26[7:0][4];
      FlagP := parity(a23[7:0]);
      FlagCY := a16[15:8][0];
      jump (0195);
    }

01B1:

    #01B1
    #instruction: LD   HL,2005
    advance (10)
    #01B4
    #instruction: LD   A,(HL)
    let:8 a1 = M[2005] in
    advance (7)
    #01B5
    #instruction: INC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    advance (5)
    #01B6
    #instruction: AND  01
    let:8 a7 = a3[7:0] in
    let:8 a8 = (01 & a7) in
    let:8 a9 = (01 | a7) in
    advance (7)
    #01B8
    #instruction: LD   (HL),A
    let:8 a10 = a8 in
    M[2005] := a10;
    advance (7)
    #01B9
    #instruction: XOR  A
    let:8 a11 = a8 in
    let:8 a12 = a8 in
    let:8 a13 = (a11 ^ a12) in
    advance (4)
    #01BA
    #instruction: LD   HL,2067
    advance (10)
    #01BD
    #instruction: LD   H,(HL)
    let:8 a14 = M[2067] in
    advance (7)
    #01BE
    #instruction: RET
    let:8 a15 = SPH in
    let:8 a16 = SPL in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a13;
    H := a14;
    L := 67;
    SPH := a21[15:8];
    SPL := a21[7:0];
    FlagS := a13[7];
    FlagZ := is_zero(a13);
    FlagA := false;
    FlagP := parity(a13);
    FlagCY := false;
    jump ((a22,a18));

01C0:

    #01C0
    #instruction: LD   HL,2100
    advance (10)
    H := 21;
    L := 00;
    jump (01C3);

01C3:

    #01C3
    #instruction: LD   B,37
    advance (7)
    B := 37;
    jump (01C5);

01C5:

    #01C5
    #instruction: LD   (HL),01
    let:8 a1 = H in
    let:8 a2 = L in
    M[(a1,a2)] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    let:8 a3 = H in
    let:8 a4 = L in
    let:16 a5 = (1 + (a3,a4)) in
    advance (5)
    #01C8
    #instruction: DEC  B
    let:8 a6 = B in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a7[7:0])) {
      advance (10)
      B := a7[7:0];
      H := a5[15:8];
      L := a5[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      B := a7[7:0];
      H := a5[15:8];
      L := a5[7:0];
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

01CF:

    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    A := 01;
    B := E0;
    H := 24;
    L := 02;
    jump (14CC);

01D9:

    #01D9
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #01DA
    #instruction: LD   B,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #01DB
    #instruction: INC  HL
    let:8 a7 = a3[15:8] in
    let:8 a8 = a3[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    advance (5)
    #01DC
    #instruction: LD   A,C
    let:8 a10 = C in
    advance (5)
    #01DD
    #instruction: ADD  (HL)
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:8 a13 = M[(a11,a12)] in
    let:8 a14 = a10 in
    let:16 a15 = addWithCarry(false,a13,a14) in
    let:8 a16 = (a13 & 0F) in
    let:8 a17 = (a14 & 0F) in
    let:16 a18 = addWithCarry(false,a16,a17) in
    advance (7)
    #01DE
    #instruction: LD   (HL),A
    let:8 a19 = a15[7:0] in
    let:8 a20 = a9[15:8] in
    let:8 a21 = a9[7:0] in
    M[(a20,a21)] := a19;
    advance (7)
    #01DF
    #instruction: INC  HL
    let:8 a22 = a9[15:8] in
    let:8 a23 = a9[7:0] in
    let:16 a24 = (1 + (a22,a23)) in
    advance (5)
    #01E0
    #instruction: LD   A,B
    let:8 a25 = a6 in
    advance (5)
    #01E1
    #instruction: ADD  (HL)
    let:8 a26 = a24[15:8] in
    let:8 a27 = a24[7:0] in
    let:8 a28 = M[(a26,a27)] in
    let:8 a29 = a25 in
    let:16 a30 = addWithCarry(false,a28,a29) in
    let:8 a31 = (a28 & 0F) in
    let:8 a32 = (a29 & 0F) in
    let:16 a33 = addWithCarry(false,a31,a32) in
    advance (7)
    #01E2
    #instruction: LD   (HL),A
    let:8 a34 = a30[7:0] in
    let:8 a35 = a24[15:8] in
    let:8 a36 = a24[7:0] in
    M[(a35,a36)] := a34;
    advance (7)
    #01E3
    #instruction: RET
    let:8 a37 = SPH in
    let:8 a38 = SPL in
    let:16 a39 = (1 + (a37,a38)) in
    let:8 a40 = M[(a37,a38)] in
    let:8 a41 = a39[15:8] in
    let:8 a42 = a39[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    advance (10)
    A := a30[7:0];
    B := a6;
    H := a24[15:8];
    L := a24[7:0];
    SPH := a43[15:8];
    SPL := a43[7:0];
    FlagS := a30[7:0][7];
    FlagZ := is_zero(a30[7:0]);
    FlagA := a33[7:0][4];
    FlagP := parity(a30[7:0]);
    FlagCY := a30[15:8][0];
    jump ((a44,a40));

01E4:

    #01E4
    #instruction: LD   B,C0
    advance (7)
    B := C0;
    jump (01E6);

01E6:

    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    D := 1B;
    E := 00;
    H := 20;
    L := 00;
    jump (1A32);

01EF:

    #01EF
    #instruction: LD   HL,2142
    advance (10)
    #01F2
    #instruction: JP   01F8
    advance (10)
    H := 21;
    L := 42;
    jump (01F8);

01F5:

    #01F5
    #instruction: LD   HL,2242
    advance (10)
    H := 22;
    L := 42;
    jump (01F8);

01F8:

    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    C := 04;
    D := 1D;
    E := 20;
    jump (01FD);

01FD:

    #01FD
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := 02;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 03;
    #return-to: 0203
    advance (17)
    B := 2C;
    SPH := a14[15:8];
    SPL := a14[7:0];
    jump (1A32);

0203:

    #0203
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0204
    #instruction: DEC  C
    let:8 a9 = C in
    let:16 a10 = addWithCarry(!true,a9,~00) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~00 & 0F) in
    let:16 a13 = addWithCarry(!true,a11,a12) in
    advance (5)
    #0205
    #instruction: JP   NZ,01FD
    if (!is_zero(a10[7:0])) {
      advance (10)
      C := a10[7:0];
      D := a8;
      E := a4;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      jump (01FD);
    } else {
      advance (10)
      #0208
      #instruction: RET
      let:8 a14 = a7[15:8] in
      let:8 a15 = a7[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (10)
      C := a10[7:0];
      D := a8;
      E := a4;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      jump ((a21,a17));
    }

0214:

    #0214
    #instruction: LD   DE,2242
    advance (10)
    #0217
    #instruction: JP   021E
    advance (10)
    D := 22;
    E := 42;
    jump (021E);

021A:

    #021A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (021B);

021B:

    #021B
    #instruction: LD   DE,2142
    advance (10)
    D := 21;
    E := 42;
    jump (021E);

021E:

    #021E
    #instruction: LD   (2081),A
    let:8 a1 = A in
    M[2081] := a1;
    advance (13)
    #0221
    #instruction: LD   BC,1602
    advance (10)
    #0224
    #instruction: LD   HL,2806
    advance (10)
    #0227
    #instruction: LD   A,04
    advance (7)
    A := 04;
    B := 16;
    C := 02;
    H := 28;
    L := 06;
    jump (0229);

0229:

    #0229
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := a1;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #022A
    #instruction: PUSH BC
    let:8 a8 = B in
    let:8 a9 = C in
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #022B
    #instruction: LD   A,(2081)
    let:8 a16 = M[2081] in
    advance (13)
    #022E
    #instruction: AND  A
    let:8 a17 = a16 in
    let:8 a18 = a16 in
    let:8 a19 = (a17 & a18) in
    let:8 a20 = (a17 | a18) in
    advance (4)
    #022F
    #instruction: JP   NZ,0242
    if (!is_zero(a19)) {
      advance (10)
      #0242
      #instruction: CALL 147C
      let:8 a21 = a15[15:8] in
      let:8 a22 = a15[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 02;
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 45;
      #return-to: 0245
      advance (17)
      A := a19;
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a19[7];
      FlagZ := is_zero(a19);
      FlagA := a20[3];
      FlagP := parity(a19);
      FlagCY := false;
      jump (147C);
    } else {
      advance (10)
      #0232
      #instruction: CALL 1A69
      let:8 a27 = a15[15:8] in
      let:8 a28 = a15[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := 02;
      let:8 a30 = a29[15:8] in
      let:8 a31 = a29[7:0] in
      let:16 a32 = (-1 + (a30,a31)) in
      M[a32] := 35;
      #return-to: 0235
      advance (17)
      A := a19;
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a19[7];
      FlagZ := is_zero(a19);
      FlagA := a20[3];
      FlagP := parity(a19);
      FlagCY := false;
      jump (1A69);
    }

0235:

    #0235
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0236
    #instruction: POP  PSW
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0237
    #instruction: DEC  A
    let:8 a17 = a16 in
    let:16 a18 = addWithCarry(!true,a17,~00) in
    let:8 a19 = (a17 & 0F) in
    let:8 a20 = (~00 & 0F) in
    let:16 a21 = addWithCarry(!true,a19,a20) in
    advance (5)
    #0238
    #instruction: RET  Z
    if (is_zero(a18[7:0])) {
      let:8 a22 = a15[15:8] in
      let:8 a23 = a15[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      let:8 a26 = a24[15:8] in
      let:8 a27 = a24[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      advance (11)
      A := a18[7:0];
      B := a8;
      C := a4;
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a18[7:0][7];
      FlagZ := is_zero(a18[7:0]);
      FlagA := a21[7:0][4];
      FlagP := parity(a18[7:0]);
      FlagCY := a12[0];
      jump ((a29,a25));
    } else {
      advance (5)
      #0239
      #instruction: PUSH DE
      let:8 a30 = D in
      let:8 a31 = E in
      let:8 a32 = a15[15:8] in
      let:8 a33 = a15[7:0] in
      let:16 a34 = (-1 + (a32,a33)) in
      M[a34] := a30;
      let:8 a35 = a34[15:8] in
      let:8 a36 = a34[7:0] in
      let:16 a37 = (-1 + (a35,a36)) in
      M[a37] := a31;
      advance (11)
      #023A
      #instruction: LD   DE,02E0
      advance (10)
      #023D
      #instruction: ADD  HL,DE
      let:8 a38 = H in
      let:8 a39 = L in
      let:17 a40 = add17(02E0,(a38,a39)) in
      advance (10)
      #023E
      #instruction: POP  DE
      let:8 a41 = a37[15:8] in
      let:8 a42 = a37[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      #023F
      #instruction: JP   0229
      advance (10)
      A := a18[7:0];
      B := a8;
      C := a4;
      D := a48;
      E := a44;
      H := a40[15:0][15:8];
      L := a40[15:0][7:0];
      SPH := a47[15:8];
      SPL := a47[7:0];
      FlagS := a18[7:0][7];
      FlagZ := is_zero(a18[7:0]);
      FlagA := a21[7:0][4];
      FlagP := parity(a18[7:0]);
      FlagCY := a40[16];
      jump (0229);
    }

0245:

    #0245
    #instruction: JP   0235
    advance (10)
    jump (0235);

024B:

    #024B
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #024C
    #instruction: CP   FF
    let:8 a4 = a3 in
    let:16 a5 = addWithCarry(!false,a4,~FF) in
    let:8 a6 = (a4 & 0F) in
    let:8 a7 = (~FF & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #024E
    #instruction: RET  Z
    if (is_zero(a5[7:0])) {
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := a3;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((a16,a12));
    } else {
      advance (5)
      #024F
      #instruction: CP   FE
      let:8 a17 = a3 in
      let:16 a18 = addWithCarry(!false,a17,~FE) in
      let:8 a19 = (a17 & 0F) in
      let:8 a20 = (~FE & 0F) in
      let:16 a21 = addWithCarry(!false,a19,a20) in
      advance (7)
      #0251
      #instruction: JP   Z,0281
      if (is_zero(a18[7:0])) {
        advance (10)
        A := a3;
        FlagS := a18[7:0][7];
        FlagZ := is_zero(a18[7:0]);
        FlagA := a21[7:0][4];
        FlagP := parity(a18[7:0]);
        FlagCY := !a18[15:8][0];
        jump (0281);
      } else {
        advance (10)
        #0254
        #instruction: INC  HL
        let:8 a22 = H in
        let:8 a23 = L in
        let:16 a24 = (1 + (a22,a23)) in
        advance (5)
        #0255
        #instruction: LD   B,(HL)
        let:8 a25 = a24[15:8] in
        let:8 a26 = a24[7:0] in
        let:8 a27 = M[(a25,a26)] in
        advance (7)
        #0256
        #instruction: LD   C,A
        let:8 a28 = a3 in
        advance (5)
        #0257
        #instruction: OR   B
        let:8 a29 = a27 in
        let:8 a30 = a3 in
        let:8 a31 = (a29 | a30) in
        advance (4)
        #0258
        #instruction: LD   A,C
        let:8 a32 = a28 in
        advance (5)
        #0259
        #instruction: JP   NZ,0277
        if (!is_zero(a31)) {
          advance (10)
          #0277
          #instruction: DEC  B
          let:8 a33 = a27 in
          let:16 a34 = addWithCarry(!true,a33,~00) in
          let:8 a35 = (a33 & 0F) in
          let:8 a36 = (~00 & 0F) in
          let:16 a37 = addWithCarry(!true,a35,a36) in
          advance (5)
          #0278
          #instruction: INC  B
          let:8 a38 = a34[7:0] in
          let:16 a39 = addWithCarry(true,a38,00) in
          let:8 a40 = (a38 & 0F) in
          let:8 a41 = (00 & 0F) in
          let:16 a42 = addWithCarry(true,a40,a41) in
          advance (5)
          #0279
          #instruction: JP   NZ,027D
          if (!is_zero(a39[7:0])) {
            advance (10)
            A := a32;
            B := a39[7:0];
            C := a28;
            H := a24[15:8];
            L := a24[7:0];
            FlagS := a39[7:0][7];
            FlagZ := is_zero(a39[7:0]);
            FlagA := a42[7:0][4];
            FlagP := parity(a39[7:0]);
            FlagCY := false;
            jump (027D);
          } else {
            advance (10)
            #027C
            #instruction: DEC  A
            let:8 a43 = a32 in
            let:16 a44 = addWithCarry(!true,a43,~00) in
            let:8 a45 = (a43 & 0F) in
            let:8 a46 = (~00 & 0F) in
            let:16 a47 = addWithCarry(!true,a45,a46) in
            advance (5)
            A := a44[7:0];
            B := a39[7:0];
            C := a28;
            H := a24[15:8];
            L := a24[7:0];
            FlagS := a44[7:0][7];
            FlagZ := is_zero(a44[7:0]);
            FlagA := a47[7:0][4];
            FlagP := parity(a44[7:0]);
            FlagCY := false;
            jump (027D);
          }
        } else {
          advance (10)
          #025C
          #instruction: INC  HL
          let:8 a48 = a24[15:8] in
          let:8 a49 = a24[7:0] in
          let:16 a50 = (1 + (a48,a49)) in
          advance (5)
          #025D
          #instruction: LD   A,(HL)
          let:8 a51 = a50[15:8] in
          let:8 a52 = a50[7:0] in
          let:8 a53 = M[(a51,a52)] in
          advance (7)
          #025E
          #instruction: AND  A
          let:8 a54 = a53 in
          let:8 a55 = a53 in
          let:8 a56 = (a54 & a55) in
          let:8 a57 = (a54 | a55) in
          advance (4)
          #025F
          #instruction: JP   NZ,0288
          if (!is_zero(a56)) {
            advance (10)
            #0288
            #instruction: DEC  (HL)
            let:8 a58 = a50[15:8] in
            let:8 a59 = a50[7:0] in
            let:8 a60 = M[(a58,a59)] in
            let:16 a61 = addWithCarry(!true,a60,~00) in
            let:8 a62 = (a60 & 0F) in
            let:8 a63 = (~00 & 0F) in
            let:16 a64 = addWithCarry(!true,a62,a63) in
            let:8 a65 = a50[15:8] in
            let:8 a66 = a50[7:0] in
            M[(a65,a66)] := a61[7:0];
            advance (10)
            #0289
            #instruction: DEC  HL
            let:8 a67 = a50[15:8] in
            let:8 a68 = a50[7:0] in
            let:16 a69 = (-1 + (a67,a68)) in
            advance (5)
            #028A
            #instruction: DEC  HL
            let:8 a70 = a69[15:8] in
            let:8 a71 = a69[7:0] in
            let:16 a72 = (-1 + (a70,a71)) in
            advance (5)
            #028B
            #instruction: JP   0281
            advance (10)
            A := a56;
            B := a27;
            C := a28;
            H := a72[15:8];
            L := a72[7:0];
            FlagS := a61[7:0][7];
            FlagZ := is_zero(a61[7:0]);
            FlagA := a64[7:0][4];
            FlagP := parity(a61[7:0]);
            FlagCY := false;
            jump (0281);
          } else {
            advance (10)
            #0262
            #instruction: INC  HL
            let:8 a73 = a50[15:8] in
            let:8 a74 = a50[7:0] in
            let:16 a75 = (1 + (a73,a74)) in
            advance (5)
            #0263
            #instruction: LD   E,(HL)
            let:8 a76 = a75[15:8] in
            let:8 a77 = a75[7:0] in
            let:8 a78 = M[(a76,a77)] in
            advance (7)
            #0264
            #instruction: INC  HL
            let:8 a79 = a75[15:8] in
            let:8 a80 = a75[7:0] in
            let:16 a81 = (1 + (a79,a80)) in
            advance (5)
            #0265
            #instruction: LD   D,(HL)
            let:8 a82 = a81[15:8] in
            let:8 a83 = a81[7:0] in
            let:8 a84 = M[(a82,a83)] in
            advance (7)
            #0266
            #instruction: PUSH HL
            let:8 a85 = a81[15:8] in
            let:8 a86 = a81[7:0] in
            let:8 a87 = SPH in
            let:8 a88 = SPL in
            let:16 a89 = (-1 + (a87,a88)) in
            M[a89] := a85;
            let:8 a90 = a89[15:8] in
            let:8 a91 = a89[7:0] in
            let:16 a92 = (-1 + (a90,a91)) in
            M[a92] := a86;
            advance (11)
            #0267
            #instruction: EX   DE,HL
            let:8 a93 = a84 in
            let:8 a94 = a78 in
            let:8 a95 = a81[15:8] in
            let:8 a96 = a81[7:0] in
            advance (4)
            #0268
            #instruction: PUSH HL
            let:8 a97 = a93 in
            let:8 a98 = a94 in
            let:8 a99 = a92[15:8] in
            let:8 a100 = a92[7:0] in
            let:16 a101 = (-1 + (a99,a100)) in
            M[a101] := a97;
            let:8 a102 = a101[15:8] in
            let:8 a103 = a101[7:0] in
            let:16 a104 = (-1 + (a102,a103)) in
            M[a104] := a98;
            advance (11)
            #0269
            #instruction: LD   HL,026F
            advance (10)
            #026C
            #instruction: EX   (SP),HL
            let:8 a105 = a104[15:8] in
            let:8 a106 = a104[7:0] in
            let:16 a107 = (1 + (a105,a106)) in
            let:8 a108 = M[(a105,a106)] in
            let:8 a109 = M[a107] in
            M[(a105,a106)] := 6F;
            M[a107] := 02;
            advance (18)
            #026D
            #instruction: PUSH DE
            let:8 a110 = a95 in
            let:8 a111 = a96 in
            let:8 a112 = a104[15:8] in
            let:8 a113 = a104[7:0] in
            let:16 a114 = (-1 + (a112,a113)) in
            M[a114] := a110;
            let:8 a115 = a114[15:8] in
            let:8 a116 = a114[7:0] in
            let:16 a117 = (-1 + (a115,a116)) in
            M[a117] := a111;
            advance (11)
            #026E
            #instruction: JP   (HL)
            let:8 a118 = a109 in
            let:8 a119 = a108 in
            advance (5)
            A := a56;
            B := a27;
            C := a28;
            D := a95;
            E := a96;
            H := a109;
            L := a108;
            SPH := a117[15:8];
            SPL := a117[7:0];
            FlagS := a56[7];
            FlagZ := is_zero(a56);
            FlagA := a57[3];
            FlagP := parity(a56);
            FlagCY := false;
            jump ((a118,a119));
          }
        }
      }
    }

026F:

    #026F
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0270
    #instruction: LD   DE,000C
    advance (10)
    #0273
    #instruction: ADD  HL,DE
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:17 a11 = add17(000C,(a9,a10)) in
    advance (10)
    #0274
    #instruction: JP   024B
    advance (10)
    D := 00;
    E := 0C;
    H := a11[15:0][15:8];
    L := a11[15:0][7:0];
    SPH := a7[15:8];
    SPL := a7[7:0];
    FlagCY := a11[16];
    jump (024B);

027D:

    #027D
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    #027E
    #instruction: LD   (HL),B
    let:8 a6 = a2[7:0] in
    let:8 a7 = H in
    let:8 a8 = L in
    M[(a7,a8)] := a6;
    advance (7)
    #027F
    #instruction: DEC  HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:16 a11 = (-1 + (a9,a10)) in
    advance (5)
    #0280
    #instruction: LD   (HL),A
    let:8 a12 = A in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    M[(a13,a14)] := a12;
    advance (7)
    B := a2[7:0];
    H := a11[15:8];
    L := a11[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0281);

0281:

    #0281
    #instruction: LD   DE,0010
    advance (10)
    #0284
    #instruction: ADD  HL,DE
    let:8 a1 = H in
    let:8 a2 = L in
    let:17 a3 = add17(0010,(a1,a2)) in
    advance (10)
    #0285
    #instruction: JP   024B
    advance (10)
    D := 00;
    E := 10;
    H := a3[15:0][15:8];
    L := a3[15:0][7:0];
    FlagCY := a3[16];
    jump (024B);

028E:

    #028E
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #028F
    #instruction: INC  HL
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #0290
    #instruction: LD   A,(HL)
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:8 a14 = M[(a12,a13)] in
    advance (7)
    #0291
    #instruction: CP   FF
    let:8 a15 = a14 in
    let:16 a16 = addWithCarry(!false,a15,~FF) in
    let:8 a17 = (a15 & 0F) in
    let:8 a18 = (~FF & 0F) in
    let:16 a19 = addWithCarry(!false,a17,a18) in
    advance (7)
    #0293
    #instruction: JP   Z,033B
    if (is_zero(a16[7:0])) {
      advance (10)
      #033B
      #instruction: LD   HL,2068
      advance (10)
      #033E
      #instruction: LD   (HL),01
      M[2068] := 01;
      advance (10)
      #0340
      #instruction: INC  HL
      advance (5)
      #0341
      #instruction: LD   A,(HL)
      let:8 a20 = M[2069] in
      advance (7)
      #0342
      #instruction: AND  A
      let:8 a21 = a20 in
      let:8 a22 = a20 in
      let:8 a23 = (a21 & a22) in
      let:8 a24 = (a21 | a22) in
      advance (4)
      #0343
      #instruction: JP   03B0
      advance (10)
      #03B0
      #instruction: JP   NZ,034A
      if (!is_zero(a23)) {
        advance (10)
        A := a23;
        H := 20;
        L := 69;
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump (034A);
      } else {
        advance (10)
        #03B3
        #instruction: INC  HL
        advance (5)
        #03B4
        #instruction: DEC  (HL)
        let:8 a25 = M[206A] in
        let:16 a26 = addWithCarry(!true,a25,~00) in
        let:8 a27 = (a25 & 0F) in
        let:8 a28 = (~00 & 0F) in
        let:16 a29 = addWithCarry(!true,a27,a28) in
        M[206A] := a26[7:0];
        advance (10)
        #03B5
        #instruction: JP   NZ,034A
        if (!is_zero(a26[7:0])) {
          advance (10)
          A := a23;
          H := 20;
          L := 6A;
          SPH := a7[15:8];
          SPL := a7[7:0];
          FlagS := a26[7:0][7];
          FlagZ := is_zero(a26[7:0]);
          FlagA := a29[7:0][4];
          FlagP := parity(a26[7:0]);
          FlagCY := false;
          jump (034A);
        } else {
          advance (10)
          #03B8
          #instruction: JP   0346
          advance (10)
          #0346
          #instruction: NOP
          advance (4)
          #0347
          #instruction: DEC  HL
          advance (5)
          #0348
          #instruction: LD   (HL),01
          M[2069] := 01;
          advance (10)
          A := a23;
          H := 20;
          L := 69;
          SPH := a7[15:8];
          SPL := a7[7:0];
          FlagS := a26[7:0][7];
          FlagZ := is_zero(a26[7:0]);
          FlagA := a29[7:0][4];
          FlagP := parity(a26[7:0]);
          FlagCY := false;
          jump (034A);
        }
      }
    } else {
      advance (10)
      #0296
      #instruction: INC  HL
      let:8 a30 = a11[15:8] in
      let:8 a31 = a11[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      advance (5)
      #0297
      #instruction: DEC  (HL)
      let:8 a33 = a32[15:8] in
      let:8 a34 = a32[7:0] in
      let:8 a35 = M[(a33,a34)] in
      let:16 a36 = addWithCarry(!true,a35,~00) in
      let:8 a37 = (a35 & 0F) in
      let:8 a38 = (~00 & 0F) in
      let:16 a39 = addWithCarry(!true,a37,a38) in
      let:8 a40 = a32[15:8] in
      let:8 a41 = a32[7:0] in
      M[(a40,a41)] := a36[7:0];
      advance (10)
      #0298
      #instruction: RET  NZ
      if (!is_zero(a36[7:0])) {
        let:8 a42 = a7[15:8] in
        let:8 a43 = a7[7:0] in
        let:16 a44 = (1 + (a42,a43)) in
        let:8 a45 = M[(a42,a43)] in
        let:8 a46 = a44[15:8] in
        let:8 a47 = a44[7:0] in
        let:16 a48 = (1 + (a46,a47)) in
        let:8 a49 = M[(a46,a47)] in
        advance (11)
        A := a14;
        H := a32[15:8];
        L := a32[7:0];
        SPH := a48[15:8];
        SPL := a48[7:0];
        FlagS := a36[7:0][7];
        FlagZ := is_zero(a36[7:0]);
        FlagA := a39[7:0][4];
        FlagP := parity(a36[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((a49,a45));
      } else {
        advance (5)
        #0299
        #instruction: LD   B,A
        let:8 a50 = a14 in
        advance (5)
        #029A
        #instruction: XOR  A
        let:8 a51 = a14 in
        let:8 a52 = a14 in
        let:8 a53 = (a51 ^ a52) in
        advance (4)
        #029B
        #instruction: LD   (2068),A
        let:8 a54 = a53 in
        M[2068] := a54;
        advance (13)
        #029E
        #instruction: LD   (2069),A
        let:8 a55 = a53 in
        M[2069] := a55;
        advance (13)
        #02A1
        #instruction: LD   A,30
        advance (7)
        #02A3
        #instruction: LD   (206A),A
        M[206A] := 30;
        advance (13)
        #02A6
        #instruction: LD   A,B
        let:8 a56 = a50 in
        advance (5)
        #02A7
        #instruction: LD   (HL),05
        let:8 a57 = a32[15:8] in
        let:8 a58 = a32[7:0] in
        M[(a57,a58)] := 05;
        advance (10)
        #02A9
        #instruction: INC  HL
        let:8 a59 = a32[15:8] in
        let:8 a60 = a32[7:0] in
        let:16 a61 = (1 + (a59,a60)) in
        advance (5)
        #02AA
        #instruction: DEC  (HL)
        let:8 a62 = a61[15:8] in
        let:8 a63 = a61[7:0] in
        let:8 a64 = M[(a62,a63)] in
        let:16 a65 = addWithCarry(!true,a64,~00) in
        let:8 a66 = (a64 & 0F) in
        let:8 a67 = (~00 & 0F) in
        let:16 a68 = addWithCarry(!true,a66,a67) in
        let:8 a69 = a61[15:8] in
        let:8 a70 = a61[7:0] in
        M[(a69,a70)] := a65[7:0];
        advance (10)
        #02AB
        #instruction: JP   NZ,039B
        if (!is_zero(a65[7:0])) {
          advance (10)
          #039B
          #instruction: INC  A
          let:8 a71 = a56 in
          let:16 a72 = addWithCarry(true,a71,00) in
          let:8 a73 = (a71 & 0F) in
          let:8 a74 = (00 & 0F) in
          let:16 a75 = addWithCarry(true,a73,a74) in
          advance (5)
          #039C
          #instruction: AND  01
          let:8 a76 = a72[7:0] in
          let:8 a77 = (01 & a76) in
          let:8 a78 = (01 | a76) in
          advance (7)
          #039E
          #instruction: LD   (2015),A
          let:8 a79 = a77 in
          M[2015] := a79;
          advance (13)
          #03A1
          #instruction: RLCA
          let:8 a80 = a77 in
          advance (4)
          #03A2
          #instruction: RLCA
          let:8 a81 = updateBit((a80 << 01),0,a80[7]) in
          advance (4)
          #03A3
          #instruction: RLCA
          let:8 a82 = updateBit((a81 << 01),0,a81[7]) in
          advance (4)
          #03A4
          #instruction: RLCA
          let:8 a83 = updateBit((a82 << 01),0,a82[7]) in
          advance (4)
          #03A5
          #instruction: LD   HL,1C70
          advance (10)
          #03A8
          #instruction: ADD  L
          let:8 a84 = updateBit((a83 << 01),0,a83[7]) in
          let:16 a85 = addWithCarry(false,70,a84) in
          let:8 a86 = (70 & 0F) in
          let:8 a87 = (a84 & 0F) in
          let:16 a88 = addWithCarry(false,a86,a87) in
          advance (4)
          #03A9
          #instruction: LD   L,A
          let:8 a89 = a85[7:0] in
          advance (5)
          #03AA
          #instruction: LD   (2018),HL
          let:8 a90 = a89 in
          M[2018] := a90;
          M[2019] := 1C;
          advance (16)
          #03AD
          #instruction: JP   036F
          advance (10)
          A := a85[7:0];
          B := a50;
          H := 1C;
          L := a89;
          SPH := a7[15:8];
          SPL := a7[7:0];
          FlagS := a85[7:0][7];
          FlagZ := is_zero(a85[7:0]);
          FlagA := a88[7:0][4];
          FlagP := parity(a85[7:0]);
          FlagCY := a85[15:8][0];
          jump (036F);
        } else {
          advance (10)
          #02AE
          #instruction: LD   HL,(201A)
          let:8 a91 = M[201A] in
          let:8 a92 = M[201B] in
          advance (16)
          #02B1
          #instruction: LD   B,10
          advance (7)
          #02B3
          #instruction: CALL 1424
          let:8 a93 = a7[15:8] in
          let:8 a94 = a7[7:0] in
          let:16 a95 = (-1 + (a93,a94)) in
          M[a95] := 02;
          let:8 a96 = a95[15:8] in
          let:8 a97 = a95[7:0] in
          let:16 a98 = (-1 + (a96,a97)) in
          M[a98] := B6;
          #return-to: 02B6
          advance (17)
          A := a56;
          B := 10;
          H := a92;
          L := a91;
          SPH := a98[15:8];
          SPL := a98[7:0];
          FlagS := a65[7:0][7];
          FlagZ := is_zero(a65[7:0]);
          FlagA := a68[7:0][4];
          FlagP := parity(a65[7:0]);
          FlagCY := false;
          jump (1424);
        }
      }
    }

02B6:

    #02B6
    #instruction: LD   HL,2010
    advance (10)
    #02B9
    #instruction: LD   DE,1B10
    advance (10)
    #02BC
    #instruction: LD   B,10
    advance (7)
    #02BE
    #instruction: CALL 1A32
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 02C1
    advance (17)
    B := 10;
    D := 1B;
    E := 10;
    H := 20;
    L := 10;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A32);

02C1:

    #02C1
    #instruction: LD   B,00
    advance (7)
    #02C3
    #instruction: CALL 19DC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C6;
    #return-to: 02C6
    advance (17)
    B := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (19DC);

02C6:

    #02C6
    #instruction: LD   A,(206D)
    let:8 a1 = M[206D] in
    advance (13)
    #02C9
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #02CA
    #instruction: RET  NZ
    if (!is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #02CB
      #instruction: LD   A,(20EF)
      let:8 a14 = M[20EF] in
      advance (13)
      #02CE
      #instruction: AND  A
      let:8 a15 = a14 in
      let:8 a16 = a14 in
      let:8 a17 = (a15 & a16) in
      let:8 a18 = (a15 | a16) in
      advance (4)
      #02CF
      #instruction: RET  Z
      if (is_zero(a17)) {
        let:8 a19 = SPH in
        let:8 a20 = SPL in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        let:8 a23 = a21[15:8] in
        let:8 a24 = a21[7:0] in
        let:16 a25 = (1 + (a23,a24)) in
        let:8 a26 = M[(a23,a24)] in
        advance (11)
        A := a17;
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a17[7];
        FlagZ := is_zero(a17);
        FlagA := a18[3];
        FlagP := parity(a17);
        FlagCY := false;
        jump ((a26,a22));
      } else {
        advance (5)
        #02D0
        #instruction: LD   SP,2400
        advance (10)
        #02D3
        #instruction: EI
        enable_interrupts()
        advance (4)
        #02D4
        #instruction: CALL 19D7
        M[23FF] := 02;
        M[23FE] := D7;
        #return-to: 02D7
        advance (17)
        A := a17;
        SPH := 23;
        SPL := FE;
        FlagS := a17[7];
        FlagZ := is_zero(a17);
        FlagA := a18[3];
        FlagP := parity(a17);
        FlagCY := false;
        jump (19D7);
      }
    }

02D7:

    #02D7
    #instruction: CALL 092E
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 02DA
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (092E);

02DA:

    #02DA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    #02DB
    #instruction: JP   Z,166D
    if (is_zero(a3)) {
      advance (10)
      #166D
      #instruction: XOR  A
      let:8 a5 = a3 in
      let:8 a6 = a3 in
      let:8 a7 = (a5 ^ a6) in
      advance (4)
      #166E
      #instruction: CALL 1A8B
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 16;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 71;
      #return-to: 1671
      advance (17)
      A := a7;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a7[7];
      FlagZ := is_zero(a7);
      FlagA := false;
      FlagP := parity(a7);
      FlagCY := false;
      jump (1A8B);
    } else {
      advance (10)
      #02DE
      #instruction: CALL 18E7
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 02;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := E1;
      #return-to: 02E1
      advance (17)
      A := a3;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (18E7);
    }

02E1:

    #02E1
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #02E2
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #02E3
    #instruction: JP   Z,032C
    if (is_zero(a6)) {
      advance (10)
      A := a6;
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (032C);
    } else {
      advance (10)
      #02E6
      #instruction: LD   A,(20CE)
      let:8 a8 = M[20CE] in
      advance (13)
      #02E9
      #instruction: AND  A
      let:8 a9 = a8 in
      let:8 a10 = a8 in
      let:8 a11 = (a9 & a10) in
      let:8 a12 = (a9 | a10) in
      advance (4)
      #02EA
      #instruction: JP   Z,032C
      if (is_zero(a11)) {
        advance (10)
        A := a11;
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump (032C);
      } else {
        advance (10)
        A := a11;
        FlagS := a11[7];
        FlagZ := is_zero(a11);
        FlagA := a12[3];
        FlagP := parity(a11);
        FlagCY := false;
        jump (02ED);
      }
    }

02ED:

    #02ED
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #02F0
    #instruction: PUSH PSW
    let:8 a2 = a1 in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a2;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #02F1
    #instruction: RRCA
    let:8 a9 = a1 in
    advance (4)
    #02F2
    #instruction: JP   CY,0332
    if (a9[0]) {
      advance (10)
      #0332
      #instruction: CALL 0209
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 03;
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 35;
      #return-to: 0335
      advance (17)
      #0209
      #instruction: LD   A,01
      advance (7)
      #020B
      #instruction: JP   021B
      advance (10)
      A := 01;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagCY := a9[0];
      jump (021B);
    } else {
      advance (10)
      #02F5
      #instruction: CALL 020E
      let:8 a16 = a8[15:8] in
      let:8 a17 = a8[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := 02;
      let:8 a19 = a18[15:8] in
      let:8 a20 = a18[7:0] in
      let:16 a21 = (-1 + (a19,a20)) in
      M[a21] := F8;
      #return-to: 02F8
      advance (17)
      #020E
      #instruction: LD   A,01
      advance (7)
      #0210
      #instruction: JP   0214
      advance (10)
      A := 01;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagCY := a9[0];
      jump (0214);
    }

02F8:

    #02F8
    #instruction: CALL 0878
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FB;
    #return-to: 02FB
    advance (17)
    #0878
    #instruction: LD   A,(2008)
    let:8 a7 = M[2008] in
    advance (13)
    #087B
    #instruction: LD   B,A
    let:8 a8 = a7 in
    advance (5)
    #087C
    #instruction: LD   HL,(2009)
    let:8 a9 = M[2009] in
    let:8 a10 = M[200A] in
    advance (16)
    #087F
    #instruction: EX   DE,HL
    let:8 a11 = D in
    let:8 a12 = E in
    let:8 a13 = a10 in
    let:8 a14 = a9 in
    advance (4)
    #0880
    #instruction: JP   0886
    advance (10)
    A := a7;
    B := a8;
    D := a13;
    E := a14;
    H := a11;
    L := a12;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0886);

02FB:

    #02FB
    #instruction: LD   (HL),E
    let:8 a1 = E in
    let:8 a2 = H in
    let:8 a3 = L in
    M[(a2,a3)] := a1;
    advance (7)
    #02FC
    #instruction: INC  HL
    let:8 a4 = H in
    let:8 a5 = L in
    let:16 a6 = (1 + (a4,a5)) in
    advance (5)
    #02FD
    #instruction: LD   (HL),D
    let:8 a7 = D in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    M[(a8,a9)] := a7;
    advance (7)
    #02FE
    #instruction: DEC  HL
    let:8 a10 = a6[15:8] in
    let:8 a11 = a6[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    advance (5)
    #02FF
    #instruction: DEC  HL
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    advance (5)
    #0300
    #instruction: LD   (HL),B
    let:8 a16 = B in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    M[(a17,a18)] := a16;
    advance (7)
    #0301
    #instruction: NOP
    advance (4)
    #0302
    #instruction: CALL 01E4
    let:8 a19 = SPH in
    let:8 a20 = SPL in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 03;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 05;
    #return-to: 0305
    advance (17)
    H := a15[15:8];
    L := a15[7:0];
    SPH := a24[15:8];
    SPL := a24[7:0];
    jump (01E4);

0305:

    #0305
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0306
    #instruction: RRCA
    let:8 a9 = a8 in
    advance (4)
    #0307
    #instruction: LD   A,21
    advance (7)
    #0309
    #instruction: LD   B,00
    advance (7)
    #030B
    #instruction: JP   NC,0312
    if (!a9[0]) {
      advance (10)
      A := 21;
      B := 00;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a4[7];
      FlagZ := a4[6];
      FlagA := a4[4];
      FlagP := a4[2];
      FlagCY := a9[0];
      jump (0312);
    } else {
      advance (10)
      #030E
      #instruction: LD   B,20
      advance (7)
      #0310
      #instruction: LD   A,22
      advance (7)
      A := 22;
      B := 20;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a4[7];
      FlagZ := a4[6];
      FlagA := a4[4];
      FlagP := a4[2];
      FlagCY := a9[0];
      jump (0312);
    }

0312:

    #0312
    #instruction: LD   (2067),A
    let:8 a1 = A in
    M[2067] := a1;
    advance (13)
    #0315
    #instruction: CALL 0AB6
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 03;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 18;
    #return-to: 0318
    advance (17)
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (0AB6);

0318:

    #0318
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0319
    #instruction: LD   (2011),A
    let:8 a4 = a3 in
    M[2011] := a4;
    advance (13)
    #031C
    #instruction: LD   A,B
    let:8 a5 = B in
    advance (5)
    #031D
    #instruction: OUT  05
    let:8 a6 = a5 in
    sound_control(FleetMovement1,a6[0]);
    sound_control(FleetMovement2,a6[1]);
    sound_control(FleetMovement3,a6[2]);
    sound_control(FleetMovement4,a6[3]);
    sound_control(UfoHit,a6[4]);
    advance (10)
    #031F
    #instruction: INC  A
    let:8 a7 = a5 in
    let:16 a8 = addWithCarry(true,a7,00) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (00 & 0F) in
    let:16 a11 = addWithCarry(true,a9,a10) in
    advance (5)
    #0320
    #instruction: LD   (2098),A
    let:8 a12 = a8[7:0] in
    M[2098] := a12;
    advance (13)
    #0323
    #instruction: CALL 09D6
    let:8 a13 = SPH in
    let:8 a14 = SPL in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 03;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 26;
    #return-to: 0326
    advance (17)
    A := a8[7:0];
    SPH := a18[15:8];
    SPL := a18[7:0];
    FlagS := a8[7:0][7];
    FlagZ := is_zero(a8[7:0]);
    FlagA := a11[7:0][4];
    FlagP := parity(a8[7:0]);
    FlagCY := false;
    jump (09D6);

0326:

    #0326
    #instruction: CALL 1A7F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 29;
    #return-to: 0329
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A7F);

0329:

    #0329
    #instruction: JP   07F9
    advance (10)
    jump (07F9);

032C:

    #032C
    #instruction: CALL 1A7F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2F;
    #return-to: 032F
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A7F);

032F:

    #032F
    #instruction: JP   0817
    advance (10)
    jump (0817);

0335:

    #0335
    #instruction: JP   02F8
    advance (10)
    jump (02F8);

034A:

    #034A
    #instruction: LD   A,(201B)
    let:8 a1 = M[201B] in
    advance (13)
    #034D
    #instruction: LD   B,A
    let:8 a2 = a1 in
    advance (5)
    #034E
    #instruction: LD   A,(20EF)
    let:8 a3 = M[20EF] in
    advance (13)
    #0351
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #0352
    #instruction: JP   NZ,0363
    if (!is_zero(a6)) {
      advance (10)
      #0363
      #instruction: CALL 17C0
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 03;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 66;
      #return-to: 0366
      advance (17)
      A := a6;
      B := a2;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (17C0);
    } else {
      advance (10)
      #0355
      #instruction: LD   A,(201D)
      let:8 a14 = M[201D] in
      advance (13)
      #0358
      #instruction: RRCA
      let:8 a15 = a14 in
      advance (4)
      #0359
      #instruction: JP   CY,0381
      if (a15[0]) {
        advance (10)
        A := updateBit((a15 >> 01),7,a15[0]);
        B := a2;
        FlagS := a6[7];
        FlagZ := is_zero(a6);
        FlagA := a7[3];
        FlagP := parity(a6);
        FlagCY := a15[0];
        jump (0381);
      } else {
        advance (10)
        #035C
        #instruction: RRCA
        let:8 a16 = updateBit((a15 >> 01),7,a15[0]) in
        advance (4)
        #035D
        #instruction: JP   CY,038E
        if (a16[0]) {
          advance (10)
          A := updateBit((a16 >> 01),7,a16[0]);
          B := a2;
          FlagS := a6[7];
          FlagZ := is_zero(a6);
          FlagA := a7[3];
          FlagP := parity(a6);
          FlagCY := a16[0];
          jump (038E);
        } else {
          advance (10)
          #0360
          #instruction: JP   036F
          advance (10)
          A := updateBit((a16 >> 01),7,a16[0]);
          B := a2;
          FlagS := a6[7];
          FlagZ := is_zero(a6);
          FlagA := a7[3];
          FlagP := parity(a6);
          FlagCY := a16[0];
          jump (036F);
        }
      }
    }

0366:

    #0366
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    #0367
    #instruction: RLCA
    let:8 a2 = updateBit((a1 << 01),0,a1[7]) in
    advance (4)
    #0368
    #instruction: JP   CY,0381
    if (a2[7]) {
      advance (10)
      A := updateBit((a2 << 01),0,a2[7]);
      FlagCY := a2[7];
      jump (0381);
    } else {
      advance (10)
      #036B
      #instruction: RLCA
      let:8 a3 = updateBit((a2 << 01),0,a2[7]) in
      advance (4)
      #036C
      #instruction: JP   CY,038E
      if (a3[7]) {
        advance (10)
        A := updateBit((a3 << 01),0,a3[7]);
        FlagCY := a3[7];
        jump (038E);
      } else {
        advance (10)
        A := updateBit((a3 << 01),0,a3[7]);
        FlagCY := a3[7];
        jump (036F);
      }
    }

036F:

    #036F
    #instruction: LD   HL,2018
    advance (10)
    #0372
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 75;
    #return-to: 0375
    advance (17)
    H := 20;
    L := 18;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A3B);

0375:

    #0375
    #instruction: CALL 1A47
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 78;
    #return-to: 0378
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A47);

0378:

    #0378
    #instruction: CALL 1439
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7B;
    #return-to: 037B
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1439);

037B:

    #037B
    #instruction: LD   A,00
    advance (7)
    #037D
    #instruction: LD   (2012),A
    M[2012] := 00;
    advance (13)
    #0380
    #instruction: RET
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    A := 00;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump ((a8,a4));

0381:

    #0381
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    #0382
    #instruction: CP   D9
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~D9) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~D9 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0384
    #instruction: JP   Z,036F
    if (is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (036F);
    } else {
      advance (10)
      #0387
      #instruction: INC  A
      let:8 a7 = a1 in
      let:16 a8 = addWithCarry(true,a7,00) in
      let:8 a9 = (a7 & 0F) in
      let:8 a10 = (00 & 0F) in
      let:16 a11 = addWithCarry(true,a9,a10) in
      advance (5)
      #0388
      #instruction: LD   (201B),A
      let:8 a12 = a8[7:0] in
      M[201B] := a12;
      advance (13)
      #038B
      #instruction: JP   036F
      advance (10)
      A := a8[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := !a3[15:8][0];
      jump (036F);
    }

038E:

    #038E
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    #038F
    #instruction: CP   30
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~30) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~30 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0391
    #instruction: JP   Z,036F
    if (is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (036F);
    } else {
      advance (10)
      #0394
      #instruction: DEC  A
      let:8 a7 = a1 in
      let:16 a8 = addWithCarry(!true,a7,~00) in
      let:8 a9 = (a7 & 0F) in
      let:8 a10 = (~00 & 0F) in
      let:16 a11 = addWithCarry(!true,a9,a10) in
      advance (5)
      #0395
      #instruction: LD   (201B),A
      let:8 a12 = a8[7:0] in
      M[201B] := a12;
      advance (13)
      #0398
      #instruction: JP   036F
      advance (10)
      A := a8[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := !a3[15:8][0];
      jump (036F);
    }

03BB:

    #03BB
    #instruction: LD   DE,202A
    advance (10)
    #03BE
    #instruction: CALL 1A06
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 03C1
    advance (17)
    D := 20;
    E := 2A;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A06);

03C1:

    #03C1
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #03C2
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a9 = a7[15:8] in
      let:8 a10 = a7[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      H := a8;
      L := a4;
      SPH := a15[15:8];
      SPL := a15[7:0];
      jump ((a16,a12));
    } else {
      advance (5)
      #03C3
      #instruction: INC  HL
      let:8 a17 = a8 in
      let:8 a18 = a4 in
      let:16 a19 = (1 + (a17,a18)) in
      advance (5)
      #03C4
      #instruction: LD   A,(HL)
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:8 a22 = M[(a20,a21)] in
      advance (7)
      #03C5
      #instruction: AND  A
      let:8 a23 = a22 in
      let:8 a24 = a22 in
      let:8 a25 = (a23 & a24) in
      let:8 a26 = (a23 | a24) in
      advance (4)
      #03C6
      #instruction: RET  Z
      if (is_zero(a25)) {
        let:8 a27 = a7[15:8] in
        let:8 a28 = a7[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        advance (11)
        A := a25;
        H := a19[15:8];
        L := a19[7:0];
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a25[7];
        FlagZ := is_zero(a25);
        FlagA := a26[3];
        FlagP := parity(a25);
        FlagCY := false;
        jump ((a34,a30));
      } else {
        advance (5)
        #03C7
        #instruction: CP   01
        let:8 a35 = a25 in
        let:16 a36 = addWithCarry(!false,a35,~01) in
        let:8 a37 = (a35 & 0F) in
        let:8 a38 = (~01 & 0F) in
        let:16 a39 = addWithCarry(!false,a37,a38) in
        advance (7)
        #03C9
        #instruction: JP   Z,03FA
        if (is_zero(a36[7:0])) {
          advance (10)
          #03FA
          #instruction: INC  A
          let:8 a40 = a25 in
          let:16 a41 = addWithCarry(true,a40,00) in
          let:8 a42 = (a40 & 0F) in
          let:8 a43 = (00 & 0F) in
          let:16 a44 = addWithCarry(true,a42,a43) in
          advance (5)
          #03FB
          #instruction: LD   (HL),A
          let:8 a45 = a41[7:0] in
          let:8 a46 = a19[15:8] in
          let:8 a47 = a19[7:0] in
          M[(a46,a47)] := a45;
          advance (7)
          #03FC
          #instruction: LD   A,(201B)
          let:8 a48 = M[201B] in
          advance (13)
          #03FF
          #instruction: ADD  08
          let:8 a49 = a48 in
          let:16 a50 = addWithCarry(false,08,a49) in
          let:8 a51 = (08 & 0F) in
          let:8 a52 = (a49 & 0F) in
          let:16 a53 = addWithCarry(false,a51,a52) in
          advance (7)
          #0401
          #instruction: LD   (202A),A
          let:8 a54 = a50[7:0] in
          M[202A] := a54;
          advance (13)
          #0404
          #instruction: CALL 0430
          let:8 a55 = a7[15:8] in
          let:8 a56 = a7[7:0] in
          let:16 a57 = (-1 + (a55,a56)) in
          M[a57] := 04;
          let:8 a58 = a57[15:8] in
          let:8 a59 = a57[7:0] in
          let:16 a60 = (-1 + (a58,a59)) in
          M[a60] := 07;
          #return-to: 0407
          advance (17)
          A := a50[7:0];
          H := a19[15:8];
          L := a19[7:0];
          SPH := a60[15:8];
          SPL := a60[7:0];
          FlagS := a50[7:0][7];
          FlagZ := is_zero(a50[7:0]);
          FlagA := a53[7:0][4];
          FlagP := parity(a50[7:0]);
          FlagCY := a50[15:8][0];
          jump (0430);
        } else {
          advance (10)
          #03CC
          #instruction: CP   02
          let:8 a61 = a25 in
          let:16 a62 = addWithCarry(!false,a61,~02) in
          let:8 a63 = (a61 & 0F) in
          let:8 a64 = (~02 & 0F) in
          let:16 a65 = addWithCarry(!false,a63,a64) in
          advance (7)
          #03CE
          #instruction: JP   Z,040A
          if (is_zero(a62[7:0])) {
            advance (10)
            #040A
            #instruction: CALL 0430
            let:8 a66 = a7[15:8] in
            let:8 a67 = a7[7:0] in
            let:16 a68 = (-1 + (a66,a67)) in
            M[a68] := 04;
            let:8 a69 = a68[15:8] in
            let:8 a70 = a68[7:0] in
            let:16 a71 = (-1 + (a69,a70)) in
            M[a71] := 0D;
            #return-to: 040D
            advance (17)
            A := a25;
            H := a19[15:8];
            L := a19[7:0];
            SPH := a71[15:8];
            SPL := a71[7:0];
            FlagS := a62[7:0][7];
            FlagZ := is_zero(a62[7:0]);
            FlagA := a65[7:0][4];
            FlagP := parity(a62[7:0]);
            FlagCY := !a62[15:8][0];
            jump (0430);
          } else {
            advance (10)
            #03D1
            #instruction: INC  HL
            let:8 a72 = a19[15:8] in
            let:8 a73 = a19[7:0] in
            let:16 a74 = (1 + (a72,a73)) in
            advance (5)
            #03D2
            #instruction: CP   03
            let:8 a75 = a25 in
            let:16 a76 = addWithCarry(!false,a75,~03) in
            let:8 a77 = (a75 & 0F) in
            let:8 a78 = (~03 & 0F) in
            let:16 a79 = addWithCarry(!false,a77,a78) in
            advance (7)
            #03D4
            #instruction: JP   NZ,042A
            if (!is_zero(a76[7:0])) {
              advance (10)
              #042A
              #instruction: CP   05
              let:8 a80 = a25 in
              let:16 a81 = addWithCarry(!false,a80,~05) in
              let:8 a82 = (a80 & 0F) in
              let:8 a83 = (~05 & 0F) in
              let:16 a84 = addWithCarry(!false,a82,a83) in
              advance (7)
              #042C
              #instruction: RET  Z
              if (is_zero(a81[7:0])) {
                let:8 a85 = a7[15:8] in
                let:8 a86 = a7[7:0] in
                let:16 a87 = (1 + (a85,a86)) in
                let:8 a88 = M[(a85,a86)] in
                let:8 a89 = a87[15:8] in
                let:8 a90 = a87[7:0] in
                let:16 a91 = (1 + (a89,a90)) in
                let:8 a92 = M[(a89,a90)] in
                advance (11)
                A := a25;
                H := a74[15:8];
                L := a74[7:0];
                SPH := a91[15:8];
                SPL := a91[7:0];
                FlagS := a81[7:0][7];
                FlagZ := is_zero(a81[7:0]);
                FlagA := a84[7:0][4];
                FlagP := parity(a81[7:0]);
                FlagCY := !a81[15:8][0];
                jump ((a92,a88));
              } else {
                advance (5)
                #042D
                #instruction: JP   0436
                advance (10)
                A := a25;
                H := a74[15:8];
                L := a74[7:0];
                SPH := a7[15:8];
                SPL := a7[7:0];
                FlagS := a81[7:0][7];
                FlagZ := is_zero(a81[7:0]);
                FlagA := a84[7:0][4];
                FlagP := parity(a81[7:0]);
                FlagCY := !a81[15:8][0];
                jump (0436);
              }
            } else {
              advance (10)
              #03D7
              #instruction: DEC  (HL)
              let:8 a93 = a74[15:8] in
              let:8 a94 = a74[7:0] in
              let:8 a95 = M[(a93,a94)] in
              let:16 a96 = addWithCarry(!true,a95,~00) in
              let:8 a97 = (a95 & 0F) in
              let:8 a98 = (~00 & 0F) in
              let:16 a99 = addWithCarry(!true,a97,a98) in
              let:8 a100 = a74[15:8] in
              let:8 a101 = a74[7:0] in
              M[(a100,a101)] := a96[7:0];
              advance (10)
              #03D8
              #instruction: JP   Z,0436
              if (is_zero(a96[7:0])) {
                advance (10)
                A := a25;
                H := a74[15:8];
                L := a74[7:0];
                SPH := a7[15:8];
                SPL := a7[7:0];
                FlagS := a96[7:0][7];
                FlagZ := is_zero(a96[7:0]);
                FlagA := a99[7:0][4];
                FlagP := parity(a96[7:0]);
                FlagCY := !a76[15:8][0];
                jump (0436);
              } else {
                advance (10)
                #03DB
                #instruction: LD   A,(HL)
                let:8 a102 = a74[15:8] in
                let:8 a103 = a74[7:0] in
                let:8 a104 = M[(a102,a103)] in
                advance (7)
                #03DC
                #instruction: CP   0F
                let:8 a105 = a104 in
                let:16 a106 = addWithCarry(!false,a105,~0F) in
                let:8 a107 = (a105 & 0F) in
                let:8 a108 = (~0F & 0F) in
                let:16 a109 = addWithCarry(!false,a107,a108) in
                advance (7)
                #03DE
                #instruction: RET  NZ
                if (!is_zero(a106[7:0])) {
                  let:8 a110 = a7[15:8] in
                  let:8 a111 = a7[7:0] in
                  let:16 a112 = (1 + (a110,a111)) in
                  let:8 a113 = M[(a110,a111)] in
                  let:8 a114 = a112[15:8] in
                  let:8 a115 = a112[7:0] in
                  let:16 a116 = (1 + (a114,a115)) in
                  let:8 a117 = M[(a114,a115)] in
                  advance (11)
                  A := a104;
                  H := a74[15:8];
                  L := a74[7:0];
                  SPH := a116[15:8];
                  SPL := a116[7:0];
                  FlagS := a106[7:0][7];
                  FlagZ := is_zero(a106[7:0]);
                  FlagA := a109[7:0][4];
                  FlagP := parity(a106[7:0]);
                  FlagCY := !a106[15:8][0];
                  jump ((a117,a113));
                } else {
                  advance (5)
                  #03DF
                  #instruction: PUSH HL
                  let:8 a118 = a74[15:8] in
                  let:8 a119 = a74[7:0] in
                  let:8 a120 = a7[15:8] in
                  let:8 a121 = a7[7:0] in
                  let:16 a122 = (-1 + (a120,a121)) in
                  M[a122] := a118;
                  let:8 a123 = a122[15:8] in
                  let:8 a124 = a122[7:0] in
                  let:16 a125 = (-1 + (a123,a124)) in
                  M[a125] := a119;
                  advance (11)
                  #03E0
                  #instruction: CALL 0430
                  let:8 a126 = a125[15:8] in
                  let:8 a127 = a125[7:0] in
                  let:16 a128 = (-1 + (a126,a127)) in
                  M[a128] := 03;
                  let:8 a129 = a128[15:8] in
                  let:8 a130 = a128[7:0] in
                  let:16 a131 = (-1 + (a129,a130)) in
                  M[a131] := E3;
                  #return-to: 03E3
                  advance (17)
                  A := a104;
                  H := a74[15:8];
                  L := a74[7:0];
                  SPH := a131[15:8];
                  SPL := a131[7:0];
                  FlagS := a106[7:0][7];
                  FlagZ := is_zero(a106[7:0]);
                  FlagA := a109[7:0][4];
                  FlagP := parity(a106[7:0]);
                  FlagCY := !a106[15:8][0];
                  jump (0430);
                }
              }
            }
          }
        }
      }
    }

03E3:

    #03E3
    #instruction: CALL 1452
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := E6;
    #return-to: 03E6
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1452);

03E6:

    #03E6
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #03E7
    #instruction: INC  HL
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #03E8
    #instruction: INC  (HL)
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:8 a14 = M[(a12,a13)] in
    let:16 a15 = addWithCarry(true,a14,00) in
    let:8 a16 = (a14 & 0F) in
    let:8 a17 = (00 & 0F) in
    let:16 a18 = addWithCarry(true,a16,a17) in
    let:8 a19 = a11[15:8] in
    let:8 a20 = a11[7:0] in
    M[(a19,a20)] := a15[7:0];
    advance (10)
    #03E9
    #instruction: INC  HL
    let:8 a21 = a11[15:8] in
    let:8 a22 = a11[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    advance (5)
    #03EA
    #instruction: INC  HL
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (1 + (a24,a25)) in
    advance (5)
    #03EB
    #instruction: DEC  (HL)
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:8 a29 = M[(a27,a28)] in
    let:16 a30 = addWithCarry(!true,a29,~00) in
    let:8 a31 = (a29 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    let:8 a34 = a26[15:8] in
    let:8 a35 = a26[7:0] in
    M[(a34,a35)] := a30[7:0];
    advance (10)
    #03EC
    #instruction: DEC  (HL)
    let:8 a36 = a26[15:8] in
    let:8 a37 = a26[7:0] in
    let:8 a38 = M[(a36,a37)] in
    let:16 a39 = addWithCarry(!true,a38,~00) in
    let:8 a40 = (a38 & 0F) in
    let:8 a41 = (~00 & 0F) in
    let:16 a42 = addWithCarry(!true,a40,a41) in
    let:8 a43 = a26[15:8] in
    let:8 a44 = a26[7:0] in
    M[(a43,a44)] := a39[7:0];
    advance (10)
    #03ED
    #instruction: INC  HL
    let:8 a45 = a26[15:8] in
    let:8 a46 = a26[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    advance (5)
    #03EE
    #instruction: DEC  (HL)
    let:8 a48 = a47[15:8] in
    let:8 a49 = a47[7:0] in
    let:8 a50 = M[(a48,a49)] in
    let:16 a51 = addWithCarry(!true,a50,~00) in
    let:8 a52 = (a50 & 0F) in
    let:8 a53 = (~00 & 0F) in
    let:16 a54 = addWithCarry(!true,a52,a53) in
    let:8 a55 = a47[15:8] in
    let:8 a56 = a47[7:0] in
    M[(a55,a56)] := a51[7:0];
    advance (10)
    #03EF
    #instruction: DEC  (HL)
    let:8 a57 = a47[15:8] in
    let:8 a58 = a47[7:0] in
    let:8 a59 = M[(a57,a58)] in
    let:16 a60 = addWithCarry(!true,a59,~00) in
    let:8 a61 = (a59 & 0F) in
    let:8 a62 = (~00 & 0F) in
    let:16 a63 = addWithCarry(!true,a61,a62) in
    let:8 a64 = a47[15:8] in
    let:8 a65 = a47[7:0] in
    M[(a64,a65)] := a60[7:0];
    advance (10)
    #03F0
    #instruction: DEC  (HL)
    let:8 a66 = a47[15:8] in
    let:8 a67 = a47[7:0] in
    let:8 a68 = M[(a66,a67)] in
    let:16 a69 = addWithCarry(!true,a68,~00) in
    let:8 a70 = (a68 & 0F) in
    let:8 a71 = (~00 & 0F) in
    let:16 a72 = addWithCarry(!true,a70,a71) in
    let:8 a73 = a47[15:8] in
    let:8 a74 = a47[7:0] in
    M[(a73,a74)] := a69[7:0];
    advance (10)
    #03F1
    #instruction: INC  HL
    let:8 a75 = a47[15:8] in
    let:8 a76 = a47[7:0] in
    let:16 a77 = (1 + (a75,a76)) in
    advance (5)
    #03F2
    #instruction: LD   (HL),08
    let:8 a78 = a77[15:8] in
    let:8 a79 = a77[7:0] in
    M[(a78,a79)] := 08;
    advance (10)
    #03F4
    #instruction: CALL 0430
    let:8 a80 = a7[15:8] in
    let:8 a81 = a7[7:0] in
    let:16 a82 = (-1 + (a80,a81)) in
    M[a82] := 03;
    let:8 a83 = a82[15:8] in
    let:8 a84 = a82[7:0] in
    let:16 a85 = (-1 + (a83,a84)) in
    M[a85] := F7;
    #return-to: 03F7
    advance (17)
    H := a77[15:8];
    L := a77[7:0];
    SPH := a85[15:8];
    SPL := a85[7:0];
    FlagS := a69[7:0][7];
    FlagZ := is_zero(a69[7:0]);
    FlagA := a72[7:0][4];
    FlagP := parity(a69[7:0]);
    jump (0430);

03F7:

    #03F7
    #instruction: JP   1400
    advance (10)
    jump (1400);

0407:

    #0407
    #instruction: JP   1400
    advance (10)
    jump (1400);

040D:

    #040D
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #040E
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #040F
    #instruction: PUSH BC
    let:8 a17 = B in
    let:8 a18 = C in
    let:8 a19 = a16[15:8] in
    let:8 a20 = a16[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := a17;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := a18;
    advance (11)
    #0410
    #instruction: CALL 1452
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := 04;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := 13;
    #return-to: 0413
    advance (17)
    SPH := a30[15:8];
    SPL := a30[7:0];
    jump (1452);

0413:

    #0413
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0414
    #instruction: POP  HL
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0415
    #instruction: POP  DE
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0416
    #instruction: LD   A,(202C)
    let:8 a25 = M[202C] in
    advance (13)
    #0419
    #instruction: ADD  L
    let:8 a26 = a12 in
    let:8 a27 = a25 in
    let:16 a28 = addWithCarry(false,a26,a27) in
    let:8 a29 = (a26 & 0F) in
    let:8 a30 = (a27 & 0F) in
    let:16 a31 = addWithCarry(false,a29,a30) in
    advance (4)
    #041A
    #instruction: LD   L,A
    let:8 a32 = a28[7:0] in
    advance (5)
    #041B
    #instruction: LD   (2029),A
    let:8 a33 = a28[7:0] in
    M[2029] := a33;
    advance (13)
    #041E
    #instruction: CALL 1491
    let:8 a34 = a23[15:8] in
    let:8 a35 = a23[7:0] in
    let:16 a36 = (-1 + (a34,a35)) in
    M[a36] := 04;
    let:8 a37 = a36[15:8] in
    let:8 a38 = a36[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := 21;
    #return-to: 0421
    advance (17)
    A := a28[7:0];
    B := a8;
    C := a4;
    D := a24;
    E := a20;
    H := a16;
    L := a32;
    SPH := a39[15:8];
    SPL := a39[7:0];
    FlagS := a28[7:0][7];
    FlagZ := is_zero(a28[7:0]);
    FlagA := a31[7:0][4];
    FlagP := parity(a28[7:0]);
    FlagCY := a28[15:8][0];
    jump (1491);

0421:

    #0421
    #instruction: LD   A,(2061)
    let:8 a1 = M[2061] in
    advance (13)
    #0424
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0425
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #0426
      #instruction: LD   (2002),A
      let:8 a14 = a4 in
      M[2002] := a14;
      advance (13)
      #0429
      #instruction: RET
      let:8 a15 = SPH in
      let:8 a16 = SPL in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (10)
      A := a4;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a22,a18));
    }

0430:

    #0430
    #instruction: LD   HL,2027
    advance (10)
    #0433
    #instruction: JP   1A3B
    advance (10)
    H := 20;
    L := 27;
    jump (1A3B);

0436:

    #0436
    #instruction: CALL 0430
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 04;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 39;
    #return-to: 0439
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0430);

0439:

    #0439
    #instruction: CALL 1452
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 04;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3C;
    #return-to: 043C
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1452);

043C:

    #043C
    #instruction: LD   HL,2025
    advance (10)
    #043F
    #instruction: LD   DE,1B25
    advance (10)
    #0442
    #instruction: LD   B,07
    advance (7)
    #0444
    #instruction: CALL 1A32
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 04;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 47;
    #return-to: 0447
    advance (17)
    B := 07;
    D := 1B;
    E := 25;
    H := 20;
    L := 25;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A32);

0447:

    #0447
    #instruction: LD   HL,(208D)
    let:8 a1 = M[208D] in
    let:8 a2 = M[208E] in
    advance (16)
    #044A
    #instruction: INC  L
    let:8 a3 = a1 in
    let:16 a4 = addWithCarry(true,a3,00) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (00 & 0F) in
    let:16 a7 = addWithCarry(true,a5,a6) in
    advance (5)
    #044B
    #instruction: LD   A,L
    let:8 a8 = a4[7:0] in
    advance (5)
    #044C
    #instruction: CP   63
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(!false,a9,~63) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~63 & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #044E
    #instruction: JP   CY,0453
    if (!a10[15:8][0]) {
      advance (10)
      A := a8;
      H := a2;
      L := a4[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      FlagCY := !a10[15:8][0];
      jump (0453);
    } else {
      advance (10)
      #0451
      #instruction: LD   L,54
      advance (7)
      A := a8;
      H := a2;
      L := 54;
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      FlagCY := !a10[15:8][0];
      jump (0453);
    }

0453:

    #0453
    #instruction: LD   (208D),HL
    let:8 a1 = L in
    M[208D] := a1;
    let:8 a2 = H in
    M[208E] := a2;
    advance (16)
    #0456
    #instruction: LD   HL,(208F)
    let:8 a3 = M[208F] in
    let:8 a4 = M[2090] in
    advance (16)
    #0459
    #instruction: INC  L
    let:8 a5 = a3 in
    let:16 a6 = addWithCarry(true,a5,00) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (00 & 0F) in
    let:16 a9 = addWithCarry(true,a7,a8) in
    advance (5)
    #045A
    #instruction: LD   (208F),HL
    let:8 a10 = a6[7:0] in
    M[208F] := a10;
    let:8 a11 = a4 in
    M[2090] := a11;
    advance (16)
    #045D
    #instruction: LD   A,(2084)
    let:8 a12 = M[2084] in
    advance (13)
    #0460
    #instruction: AND  A
    let:8 a13 = a12 in
    let:8 a14 = a12 in
    let:8 a15 = (a13 & a14) in
    let:8 a16 = (a13 | a14) in
    advance (4)
    #0461
    #instruction: RET  NZ
    if (!is_zero(a15)) {
      let:8 a17 = SPH in
      let:8 a18 = SPL in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (11)
      A := a15;
      H := a4;
      L := a6[7:0];
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := a16[3];
      FlagP := parity(a15);
      FlagCY := false;
      jump ((a24,a20));
    } else {
      advance (5)
      #0462
      #instruction: LD   A,(HL)
      let:8 a25 = a4 in
      let:8 a26 = a6[7:0] in
      let:8 a27 = M[(a25,a26)] in
      advance (7)
      #0463
      #instruction: AND  01
      let:8 a28 = a27 in
      let:8 a29 = (01 & a28) in
      let:8 a30 = (01 | a28) in
      advance (7)
      #0465
      #instruction: LD   BC,0229
      advance (10)
      #0468
      #instruction: JP   NZ,046E
      if (!is_zero(a29)) {
        advance (10)
        A := a29;
        B := 02;
        C := 29;
        H := a4;
        L := a6[7:0];
        FlagS := a29[7];
        FlagZ := is_zero(a29);
        FlagA := a30[3];
        FlagP := parity(a29);
        FlagCY := false;
        jump (046E);
      } else {
        advance (10)
        #046B
        #instruction: LD   BC,FEE0
        advance (10)
        A := a29;
        B := FE;
        C := E0;
        H := a4;
        L := a6[7:0];
        FlagS := a29[7];
        FlagZ := is_zero(a29);
        FlagA := a30[3];
        FlagP := parity(a29);
        FlagCY := false;
        jump (046E);
      }
    }

046E:

    #046E
    #instruction: LD   HL,208A
    advance (10)
    #0471
    #instruction: LD   (HL),C
    let:8 a1 = C in
    M[208A] := a1;
    advance (7)
    #0472
    #instruction: INC  HL
    advance (5)
    #0473
    #instruction: INC  HL
    advance (5)
    #0474
    #instruction: LD   (HL),B
    let:8 a2 = B in
    M[208C] := a2;
    advance (7)
    #0475
    #instruction: RET
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (1 + (a3,a4)) in
    let:8 a6 = M[(a3,a4)] in
    let:8 a7 = a5[15:8] in
    let:8 a8 = a5[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    advance (10)
    H := 20;
    L := 8C;
    SPH := a9[15:8];
    SPL := a9[7:0];
    jump ((a10,a6));

0476:

    #0476
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0477
    #instruction: LD   A,(1B32)
    advance (13)
    #047A
    #instruction: LD   (2032),A
    M[2032] := 02;
    advance (13)
    #047D
    #instruction: LD   HL,(2038)
    let:8 a9 = M[2038] in
    let:8 a10 = M[2039] in
    advance (16)
    #0480
    #instruction: LD   A,L
    let:8 a11 = a9 in
    advance (5)
    #0481
    #instruction: OR   H
    let:8 a12 = a10 in
    let:8 a13 = a11 in
    let:8 a14 = (a12 | a13) in
    advance (4)
    #0482
    #instruction: JP   NZ,048A
    if (!is_zero(a14)) {
      advance (10)
      #048A
      #instruction: LD   DE,2035
      advance (10)
      #048D
      #instruction: LD   A,F9
      advance (7)
      #048F
      #instruction: CALL 0550
      let:8 a15 = a7[15:8] in
      let:8 a16 = a7[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 04;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 92;
      #return-to: 0492
      advance (17)
      A := F9;
      D := 20;
      E := 35;
      H := a10;
      L := a9;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump (0550);
    } else {
      advance (10)
      #0485
      #instruction: DEC  HL
      let:8 a21 = a10 in
      let:8 a22 = a9 in
      let:16 a23 = (-1 + (a21,a22)) in
      advance (5)
      #0486
      #instruction: LD   (2038),HL
      let:8 a24 = a23[7:0] in
      M[2038] := a24;
      let:8 a25 = a23[15:8] in
      M[2039] := a25;
      advance (16)
      #0489
      #instruction: RET
      let:8 a26 = a7[15:8] in
      let:8 a27 = a7[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      let:8 a30 = a28[15:8] in
      let:8 a31 = a28[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      let:8 a33 = M[(a30,a31)] in
      advance (10)
      A := a14;
      H := a23[15:8];
      L := a23[7:0];
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a33,a29));
    }

0492:

    #0492
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    #0495
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #0498
    #instruction: LD   A,(2056)
    let:8 a3 = M[2056] in
    advance (13)
    #049B
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #049E
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 04;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := A1;
    #return-to: 04A1
    advance (17)
    A := a3;
    SPH := a10[15:8];
    SPL := a10[7:0];
    jump (0563);

04A1:

    #04A1
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    #04A4
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #04A5
    #instruction: LD   HL,2035
    advance (10)
    #04A8
    #instruction: JP   NZ,055B
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      H := 20;
      L := 35;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (055B);
    } else {
      advance (10)
      #04AB
      #instruction: LD   DE,1B30
      advance (10)
      #04AE
      #instruction: LD   HL,2030
      advance (10)
      #04B1
      #instruction: LD   B,10
      advance (7)
      #04B3
      #instruction: JP   1A32
      advance (10)
      A := a4;
      B := 10;
      D := 1B;
      E := 30;
      H := 20;
      L := 30;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (1A32);
    }

04B6:

    #04B6
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #04B7
    #instruction: LD   A,(206E)
    let:8 a9 = M[206E] in
    advance (13)
    #04BA
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #04BB
    #instruction: RET  NZ
    if (!is_zero(a12)) {
      let:8 a14 = a7[15:8] in
      let:8 a15 = a7[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      H := a8;
      L := a4;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #04BC
      #instruction: LD   A,(2080)
      let:8 a22 = M[2080] in
      advance (13)
      #04BF
      #instruction: CP   01
      let:8 a23 = a22 in
      let:16 a24 = addWithCarry(!false,a23,~01) in
      let:8 a25 = (a23 & 0F) in
      let:8 a26 = (~01 & 0F) in
      let:16 a27 = addWithCarry(!false,a25,a26) in
      advance (7)
      #04C1
      #instruction: RET  NZ
      if (!is_zero(a24[7:0])) {
        let:8 a28 = a7[15:8] in
        let:8 a29 = a7[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (11)
        A := a22;
        H := a8;
        L := a4;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump ((a35,a31));
      } else {
        advance (5)
        #04C2
        #instruction: LD   DE,2045
        advance (10)
        #04C5
        #instruction: LD   A,ED
        advance (7)
        #04C7
        #instruction: CALL 0550
        let:8 a36 = a7[15:8] in
        let:8 a37 = a7[7:0] in
        let:16 a38 = (-1 + (a36,a37)) in
        M[a38] := 04;
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := CA;
        #return-to: 04CA
        advance (17)
        A := ED;
        D := 20;
        E := 45;
        H := a8;
        L := a4;
        SPH := a41[15:8];
        SPL := a41[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump (0550);
      }
    }

04CA:

    #04CA
    #instruction: LD   A,(2036)
    let:8 a1 = M[2036] in
    advance (13)
    #04CD
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #04D0
    #instruction: LD   A,(2056)
    let:8 a3 = M[2056] in
    advance (13)
    #04D3
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #04D6
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 04;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := D9;
    #return-to: 04D9
    advance (17)
    A := a3;
    SPH := a10[15:8];
    SPL := a10[7:0];
    jump (0563);

04D9:

    #04D9
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    #04DC
    #instruction: CP   10
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~10) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~10 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #04DE
    #instruction: JP   CY,04E7
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (04E7);
    } else {
      advance (10)
      #04E1
      #instruction: LD   A,(1B48)
      advance (13)
      #04E4
      #instruction: LD   (2076),A
      M[2076] := 00;
      advance (13)
      A := 00;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (04E7);
    }

04E7:

    #04E7
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    #04EA
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #04EB
    #instruction: LD   HL,2045
    advance (10)
    #04EE
    #instruction: JP   NZ,055B
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      H := 20;
      L := 45;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (055B);
    } else {
      advance (10)
      #04F1
      #instruction: LD   DE,1B40
      advance (10)
      #04F4
      #instruction: LD   HL,2040
      advance (10)
      #04F7
      #instruction: LD   B,10
      advance (7)
      #04F9
      #instruction: CALL 1A32
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 04;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := FC;
      #return-to: 04FC
      advance (17)
      A := a4;
      B := 10;
      D := 1B;
      E := 40;
      H := 20;
      L := 40;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (1A32);
    }

04FC:

    #04FC
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    #04FF
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0500
    #instruction: JP   NZ,0508
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a3[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (0508);
    } else {
      advance (10)
      #0503
      #instruction: LD   A,01
      advance (7)
      #0505
      #instruction: LD   (206E),A
      M[206E] := 01;
      advance (13)
      A := 01;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (0508);
    }

0508:

    #0508
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:8 a2 = M[2077] in
    advance (16)
    #050B
    #instruction: JP   067E
    advance (10)
    #067E
    #instruction: LD   (2048),HL
    let:8 a3 = a1 in
    M[2048] := a3;
    let:8 a4 = a2 in
    M[2049] := a4;
    advance (16)
    #0681
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    H := a2;
    L := a1;
    SPH := a11[15:8];
    SPL := a11[7:0];
    jump ((a12,a8));

050E:

    #050E
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    H := a8;
    L := a4;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (050F);

050F:

    #050F
    #instruction: LD   DE,2055
    advance (10)
    #0512
    #instruction: LD   A,DB
    advance (7)
    #0514
    #instruction: CALL 0550
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 05;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    #return-to: 0517
    advance (17)
    A := DB;
    D := 20;
    E := 55;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0550);

0517:

    #0517
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    #051A
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #051D
    #instruction: LD   A,(2036)
    let:8 a3 = M[2036] in
    advance (13)
    #0520
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #0523
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 05;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 26;
    #return-to: 0526
    advance (17)
    A := a3;
    SPH := a10[15:8];
    SPL := a10[7:0];
    jump (0563);

0526:

    #0526
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    #0529
    #instruction: CP   15
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~15) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~15 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #052B
    #instruction: JP   CY,0534
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0534);
    } else {
      advance (10)
      #052E
      #instruction: LD   A,(1B58)
      advance (13)
      #0531
      #instruction: LD   (2076),A
      M[2076] := 06;
      advance (13)
      A := 06;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0534);
    }

0534:

    #0534
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    #0537
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0538
    #instruction: LD   HL,2055
    advance (10)
    #053B
    #instruction: JP   NZ,055B
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      H := 20;
      L := 55;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (055B);
    } else {
      advance (10)
      #053E
      #instruction: LD   DE,1B50
      advance (10)
      #0541
      #instruction: LD   HL,2050
      advance (10)
      #0544
      #instruction: LD   B,10
      advance (7)
      #0546
      #instruction: CALL 1A32
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 05;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 49;
      #return-to: 0549
      advance (17)
      A := a4;
      B := 10;
      D := 1B;
      E := 50;
      H := 20;
      L := 50;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (1A32);
    }

0549:

    #0549
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:8 a2 = M[2077] in
    advance (16)
    #054C
    #instruction: LD   (2058),HL
    let:8 a3 = a1 in
    M[2058] := a3;
    let:8 a4 = a2 in
    M[2059] := a4;
    advance (16)
    #054F
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    H := a2;
    L := a1;
    SPH := a11[15:8];
    SPL := a11[7:0];
    jump ((a12,a8));

0550:

    #0550
    #instruction: LD   (207F),A
    let:8 a1 = A in
    M[207F] := a1;
    advance (13)
    #0553
    #instruction: LD   HL,2073
    advance (10)
    #0556
    #instruction: LD   B,0B
    advance (7)
    #0558
    #instruction: JP   1A32
    advance (10)
    B := 0B;
    H := 20;
    L := 73;
    jump (1A32);

055B:

    #055B
    #instruction: LD   DE,2073
    advance (10)
    #055E
    #instruction: LD   B,0B
    advance (7)
    #0560
    #instruction: JP   1A32
    advance (10)
    B := 0B;
    D := 20;
    E := 73;
    jump (1A32);

0563:

    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    let:8 a1 = M[2073] in
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a2 = a1 in
    let:8 a3 = (80 & a2) in
    let:8 a4 = (80 | a2) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a3)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (-1 + (a5,a6)) in
      M[a7] := 05;
      let:8 a8 = a7[15:8] in
      let:8 a9 = a7[7:0] in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := C7;
      #return-to: 05C7
      advance (17)
      A := a3;
      D := 20;
      E := 7C;
      H := 20;
      L := 73;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (1A06);
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      let:8 a11 = M[20C1] in
      advance (13)
      #056F
      #instruction: CP   04
      let:8 a12 = a11 in
      let:16 a13 = addWithCarry(!false,a12,~04) in
      let:8 a14 = (a12 & 0F) in
      let:8 a15 = (~04 & 0F) in
      let:16 a16 = addWithCarry(!false,a14,a15) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      let:8 a17 = M[2069] in
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a13[7:0])) {
        advance (10)
        A := a17;
        H := 20;
        L := 73;
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := !a13[15:8][0];
        jump (05B7);
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a18 = a17 in
        let:8 a19 = a17 in
        let:8 a20 = (a18 & a19) in
        let:8 a21 = (a18 | a19) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a20)) {
          let:8 a22 = SPH in
          let:8 a23 = SPL in
          let:16 a24 = (1 + (a22,a23)) in
          let:8 a25 = M[(a22,a23)] in
          let:8 a26 = a24[15:8] in
          let:8 a27 = a24[7:0] in
          let:16 a28 = (1 + (a26,a27)) in
          let:8 a29 = M[(a26,a27)] in
          advance (11)
          A := a20;
          H := 20;
          L := 73;
          SPH := a28[15:8];
          SPL := a28[7:0];
          FlagS := a20[7];
          FlagZ := is_zero(a20);
          FlagA := a21[3];
          FlagP := parity(a20);
          FlagCY := false;
          jump ((a29,a25));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          let:8 a30 = M[2070] in
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a31 = a30 in
          let:8 a32 = a30 in
          let:8 a33 = (a31 & a32) in
          let:8 a34 = (a31 | a32) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a33)) {
            advance (10)
            A := a33;
            H := 20;
            L := 74;
            FlagS := a33[7];
            FlagZ := is_zero(a33);
            FlagA := a34[3];
            FlagP := parity(a33);
            FlagCY := false;
            jump (0589);
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            let:8 a35 = a33 in
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            let:8 a36 = M[20CF] in
            advance (13)
            #0587
            #instruction: CP   B
            let:8 a37 = a36 in
            let:8 a38 = a35 in
            let:16 a39 = addWithCarry(!false,a37,~a38) in
            let:8 a40 = (a37 & 0F) in
            let:8 a41 = (~a38 & 0F) in
            let:16 a42 = addWithCarry(!false,a40,a41) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a39[15:8][0]) {
              let:8 a43 = SPH in
              let:8 a44 = SPL in
              let:16 a45 = (1 + (a43,a44)) in
              let:8 a46 = M[(a43,a44)] in
              let:8 a47 = a45[15:8] in
              let:8 a48 = a45[7:0] in
              let:16 a49 = (1 + (a47,a48)) in
              let:8 a50 = M[(a47,a48)] in
              advance (11)
              A := a36;
              B := a35;
              H := 20;
              L := 74;
              SPH := a49[15:8];
              SPL := a49[7:0];
              FlagS := a39[7:0][7];
              FlagZ := is_zero(a39[7:0]);
              FlagA := a42[7:0][4];
              FlagP := parity(a39[7:0]);
              FlagCY := !a39[15:8][0];
              jump ((a50,a46));
            } else {
              advance (5)
              A := a36;
              B := a35;
              H := 20;
              L := 74;
              FlagS := a39[7:0][7];
              FlagZ := is_zero(a39[7:0]);
              FlagA := a42[7:0][4];
              FlagP := parity(a39[7:0]);
              FlagCY := !a39[15:8][0];
              jump (0589);
            }
          }
        }
      }
    }

0589:

    #0589
    #instruction: LD   A,(2071)
    let:8 a1 = M[2071] in
    advance (13)
    #058C
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #058D
    #instruction: JP   Z,0596
    if (is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0596);
    } else {
      advance (10)
      #0590
      #instruction: LD   B,A
      let:8 a6 = a4 in
      advance (5)
      #0591
      #instruction: LD   A,(20CF)
      let:8 a7 = M[20CF] in
      advance (13)
      #0594
      #instruction: CP   B
      let:8 a8 = a7 in
      let:8 a9 = a6 in
      let:16 a10 = addWithCarry(!false,a8,~a9) in
      let:8 a11 = (a8 & 0F) in
      let:8 a12 = (~a9 & 0F) in
      let:16 a13 = addWithCarry(!false,a11,a12) in
      advance (4)
      #0595
      #instruction: RET  NC
      if (!!a10[15:8][0]) {
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (1 + (a14,a15)) in
        let:8 a17 = M[(a14,a15)] in
        let:8 a18 = a16[15:8] in
        let:8 a19 = a16[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        advance (11)
        A := a7;
        B := a6;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump ((a21,a17));
      } else {
        advance (5)
        A := a7;
        B := a6;
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump (0596);
      }
    }

0596:

    #0596
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #0597
    #instruction: LD   A,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #0598
    #instruction: AND  A
    let:8 a7 = a6 in
    let:8 a8 = a6 in
    let:8 a9 = (a7 & a8) in
    let:8 a10 = (a7 | a8) in
    advance (4)
    #0599
    #instruction: JP   Z,061B
    if (is_zero(a9)) {
      advance (10)
      #061B
      #instruction: LD   A,(201B)
      let:8 a11 = M[201B] in
      advance (13)
      #061E
      #instruction: ADD  08
      let:8 a12 = a11 in
      let:16 a13 = addWithCarry(false,08,a12) in
      let:8 a14 = (08 & 0F) in
      let:8 a15 = (a12 & 0F) in
      let:16 a16 = addWithCarry(false,a14,a15) in
      advance (7)
      #0620
      #instruction: LD   H,A
      let:8 a17 = a13[7:0] in
      advance (5)
      #0621
      #instruction: CALL 156F
      let:8 a18 = SPH in
      let:8 a19 = SPL in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 06;
      let:8 a21 = a20[15:8] in
      let:8 a22 = a20[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 24;
      #return-to: 0624
      advance (17)
      A := a13[7:0];
      H := a17;
      L := a3[7:0];
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := a13[15:8][0];
      jump (156F);
    } else {
      advance (10)
      #059C
      #instruction: LD   HL,(2076)
      let:8 a24 = M[2076] in
      let:8 a25 = M[2077] in
      advance (16)
      #059F
      #instruction: LD   C,(HL)
      let:8 a26 = a25 in
      let:8 a27 = a24 in
      let:8 a28 = M[(a26,a27)] in
      advance (7)
      #05A0
      #instruction: INC  HL
      let:8 a29 = a25 in
      let:8 a30 = a24 in
      let:16 a31 = (1 + (a29,a30)) in
      advance (5)
      #05A1
      #instruction: NOP
      advance (4)
      #05A2
      #instruction: LD   (2076),HL
      let:8 a32 = a31[7:0] in
      M[2076] := a32;
      let:8 a33 = a31[15:8] in
      M[2077] := a33;
      advance (16)
      A := a9;
      C := a28;
      H := a31[15:8];
      L := a31[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := a10[3];
      FlagP := parity(a9);
      FlagCY := false;
      jump (05A5);
    }

05A5:

    #05A5
    #instruction: CALL 062F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 05;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := A8;
    #return-to: 05A8
    advance (17)
    #062F
    #instruction: DEC  C
    let:8 a7 = C in
    let:16 a8 = addWithCarry(!true,a7,~00) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #0630
    #instruction: LD   A,(2067)
    let:8 a12 = M[2067] in
    advance (13)
    #0633
    #instruction: LD   H,A
    let:8 a13 = a12 in
    advance (5)
    #0634
    #instruction: LD   L,C
    let:8 a14 = a8[7:0] in
    advance (5)
    #0635
    #instruction: LD   D,05
    advance (7)
    A := a12;
    C := a8[7:0];
    D := 05;
    H := a13;
    L := a14;
    SPH := a6[15:8];
    SPL := a6[7:0];
    FlagS := a8[7:0][7];
    FlagZ := is_zero(a8[7:0]);
    FlagA := a11[7:0][4];
    FlagP := parity(a8[7:0]);
    jump (0637);

05A8:

    #05A8
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #05A9
      #instruction: CALL 017A
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 05;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := AC;
      #return-to: 05AC
      advance (17)
      SPH := a14[15:8];
      SPL := a14[7:0];
      jump (017A);
    }

05AC:

    #05AC
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #05AD
    #instruction: ADD  07
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(false,07,a2) in
    let:8 a4 = (07 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (7)
    #05AF
    #instruction: LD   H,A
    let:8 a7 = a3[7:0] in
    advance (5)
    #05B0
    #instruction: LD   A,L
    let:8 a8 = L in
    advance (5)
    #05B1
    #instruction: SUB  0A
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(!false,a9,~0A) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~0A & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #05B3
    #instruction: LD   L,A
    let:8 a14 = a10[7:0] in
    advance (5)
    #05B4
    #instruction: LD   (207B),HL
    let:8 a15 = a14 in
    M[207B] := a15;
    let:8 a16 = a7 in
    M[207C] := a16;
    advance (16)
    A := a10[7:0];
    H := a7;
    L := a14;
    FlagS := a10[7:0][7];
    FlagZ := is_zero(a10[7:0]);
    FlagA := a13[7:0][4];
    FlagP := parity(a10[7:0]);
    FlagCY := !a10[15:8][0];
    jump (05B7);

05B7:

    #05B7
    #instruction: LD   HL,2073
    advance (10)
    #05BA
    #instruction: LD   A,(HL)
    let:8 a1 = M[2073] in
    advance (7)
    #05BB
    #instruction: OR   80
    let:8 a2 = a1 in
    let:8 a3 = (80 | a2) in
    advance (7)
    #05BD
    #instruction: LD   (HL),A
    let:8 a4 = a3 in
    M[2073] := a4;
    advance (7)
    #05BE
    #instruction: INC  HL
    advance (5)
    #05BF
    #instruction: INC  (HL)
    let:8 a5 = M[2074] in
    let:16 a6 = addWithCarry(true,a5,00) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (00 & 0F) in
    let:16 a9 = addWithCarry(true,a7,a8) in
    M[2074] := a6[7:0];
    advance (10)
    #05C0
    #instruction: RET
    let:8 a10 = SPH in
    let:8 a11 = SPL in
    let:16 a12 = (1 + (a10,a11)) in
    let:8 a13 = M[(a10,a11)] in
    let:8 a14 = a12[15:8] in
    let:8 a15 = a12[7:0] in
    let:16 a16 = (1 + (a14,a15)) in
    let:8 a17 = M[(a14,a15)] in
    advance (10)
    A := a3;
    H := 20;
    L := 74;
    SPH := a16[15:8];
    SPL := a16[7:0];
    FlagS := a6[7:0][7];
    FlagZ := is_zero(a6[7:0]);
    FlagA := a9[7:0][4];
    FlagP := parity(a6[7:0]);
    FlagCY := false;
    jump ((a17,a13));

05C7:

    #05C7
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #05C8
      #instruction: INC  HL
      let:8 a9 = H in
      let:8 a10 = L in
      let:16 a11 = (1 + (a9,a10)) in
      advance (5)
      #05C9
      #instruction: LD   A,(HL)
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:8 a14 = M[(a12,a13)] in
      advance (7)
      #05CA
      #instruction: AND  01
      let:8 a15 = a14 in
      let:8 a16 = (01 & a15) in
      let:8 a17 = (01 | a15) in
      advance (7)
      #05CC
      #instruction: JP   NZ,0644
      if (!is_zero(a16)) {
        advance (10)
        #0644
        #instruction: LD   HL,2078
        advance (10)
        #0647
        #instruction: DEC  (HL)
        let:8 a18 = M[2078] in
        let:16 a19 = addWithCarry(!true,a18,~00) in
        let:8 a20 = (a18 & 0F) in
        let:8 a21 = (~00 & 0F) in
        let:16 a22 = addWithCarry(!true,a20,a21) in
        M[2078] := a19[7:0];
        advance (10)
        #0648
        #instruction: LD   A,(HL)
        let:8 a23 = M[2078] in
        advance (7)
        #0649
        #instruction: CP   03
        let:8 a24 = a23 in
        let:16 a25 = addWithCarry(!false,a24,~03) in
        let:8 a26 = (a24 & 0F) in
        let:8 a27 = (~03 & 0F) in
        let:16 a28 = addWithCarry(!false,a26,a27) in
        advance (7)
        #064B
        #instruction: JP   NZ,0667
        if (!is_zero(a25[7:0])) {
          advance (10)
          #0667
          #instruction: AND  A
          let:8 a29 = a23 in
          let:8 a30 = a23 in
          let:8 a31 = (a29 & a30) in
          let:8 a32 = (a29 | a30) in
          advance (4)
          #0668
          #instruction: RET  NZ
          if (!is_zero(a31)) {
            let:8 a33 = SPH in
            let:8 a34 = SPL in
            let:16 a35 = (1 + (a33,a34)) in
            let:8 a36 = M[(a33,a34)] in
            let:8 a37 = a35[15:8] in
            let:8 a38 = a35[7:0] in
            let:16 a39 = (1 + (a37,a38)) in
            let:8 a40 = M[(a37,a38)] in
            advance (11)
            A := a31;
            H := 20;
            L := 78;
            SPH := a39[15:8];
            SPL := a39[7:0];
            FlagS := a31[7];
            FlagZ := is_zero(a31);
            FlagA := a32[3];
            FlagP := parity(a31);
            FlagCY := false;
            jump ((a40,a36));
          } else {
            advance (5)
            #0669
            #instruction: JP   0675
            advance (10)
            A := a31;
            H := 20;
            L := 78;
            FlagS := a31[7];
            FlagZ := is_zero(a31);
            FlagA := a32[3];
            FlagP := parity(a31);
            FlagCY := false;
            jump (0675);
          }
        } else {
          advance (10)
          #064E
          #instruction: CALL 0675
          let:8 a41 = SPH in
          let:8 a42 = SPL in
          let:16 a43 = (-1 + (a41,a42)) in
          M[a43] := 06;
          let:8 a44 = a43[15:8] in
          let:8 a45 = a43[7:0] in
          let:16 a46 = (-1 + (a44,a45)) in
          M[a46] := 51;
          #return-to: 0651
          advance (17)
          A := a23;
          H := 20;
          L := 78;
          SPH := a46[15:8];
          SPL := a46[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := !a25[15:8][0];
          jump (0675);
        }
      } else {
        advance (10)
        #05CF
        #instruction: INC  HL
        let:8 a47 = a11[15:8] in
        let:8 a48 = a11[7:0] in
        let:16 a49 = (1 + (a47,a48)) in
        advance (5)
        #05D0
        #instruction: INC  (HL)
        let:8 a50 = a49[15:8] in
        let:8 a51 = a49[7:0] in
        let:8 a52 = M[(a50,a51)] in
        let:16 a53 = addWithCarry(true,a52,00) in
        let:8 a54 = (a52 & 0F) in
        let:8 a55 = (00 & 0F) in
        let:16 a56 = addWithCarry(true,a54,a55) in
        let:8 a57 = a49[15:8] in
        let:8 a58 = a49[7:0] in
        M[(a57,a58)] := a53[7:0];
        advance (10)
        #05D1
        #instruction: CALL 0675
        let:8 a59 = SPH in
        let:8 a60 = SPL in
        let:16 a61 = (-1 + (a59,a60)) in
        M[a61] := 05;
        let:8 a62 = a61[15:8] in
        let:8 a63 = a61[7:0] in
        let:16 a64 = (-1 + (a62,a63)) in
        M[a64] := D4;
        #return-to: 05D4
        advance (17)
        A := a16;
        H := a49[15:8];
        L := a49[7:0];
        SPH := a64[15:8];
        SPL := a64[7:0];
        FlagS := a53[7:0][7];
        FlagZ := is_zero(a53[7:0]);
        FlagA := a56[7:0][4];
        FlagP := parity(a53[7:0]);
        FlagCY := false;
        jump (0675);
      }
    }

05D4:

    #05D4
    #instruction: LD   A,(2079)
    let:8 a1 = M[2079] in
    advance (13)
    #05D7
    #instruction: ADD  03
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(false,03,a2) in
    let:8 a4 = (03 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (7)
    #05D9
    #instruction: LD   HL,207F
    advance (10)
    #05DC
    #instruction: CP   (HL)
    let:8 a7 = a3[7:0] in
    let:8 a8 = M[207F] in
    let:16 a9 = addWithCarry(!false,a7,~a8) in
    let:8 a10 = (a7 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #05DD
    #instruction: JP   CY,05E2
    if (!a9[15:8][0]) {
      advance (10)
      A := a3[7:0];
      H := 20;
      L := 7F;
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump (05E2);
    } else {
      advance (10)
      #05E0
      #instruction: SUB  0C
      let:8 a13 = a3[7:0] in
      let:16 a14 = addWithCarry(!false,a13,~0C) in
      let:8 a15 = (a13 & 0F) in
      let:8 a16 = (~0C & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      A := a14[7:0];
      H := 20;
      L := 7F;
      FlagS := a14[7:0][7];
      FlagZ := is_zero(a14[7:0]);
      FlagA := a17[7:0][4];
      FlagP := parity(a14[7:0]);
      FlagCY := !a14[15:8][0];
      jump (05E2);
    }

05E2:

    #05E2
    #instruction: LD   (2079),A
    let:8 a1 = A in
    M[2079] := a1;
    advance (13)
    #05E5
    #instruction: LD   A,(207B)
    let:8 a2 = M[207B] in
    advance (13)
    #05E8
    #instruction: LD   B,A
    let:8 a3 = a2 in
    advance (5)
    #05E9
    #instruction: LD   A,(207E)
    let:8 a4 = M[207E] in
    advance (13)
    #05EC
    #instruction: ADD  B
    let:8 a5 = a3 in
    let:8 a6 = a4 in
    let:16 a7 = addWithCarry(false,a5,a6) in
    let:8 a8 = (a5 & 0F) in
    let:8 a9 = (a6 & 0F) in
    let:16 a10 = addWithCarry(false,a8,a9) in
    advance (4)
    #05ED
    #instruction: LD   (207B),A
    let:8 a11 = a7[7:0] in
    M[207B] := a11;
    advance (13)
    #05F0
    #instruction: CALL 066C
    let:8 a12 = SPH in
    let:8 a13 = SPL in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 05;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := F3;
    #return-to: 05F3
    advance (17)
    A := a7[7:0];
    B := a3;
    SPH := a17[15:8];
    SPL := a17[7:0];
    FlagS := a7[7:0][7];
    FlagZ := is_zero(a7[7:0]);
    FlagA := a10[7:0][4];
    FlagP := parity(a7[7:0]);
    FlagCY := a7[15:8][0];
    jump (066C);

05F3:

    #05F3
    #instruction: LD   A,(207B)
    let:8 a1 = M[207B] in
    advance (13)
    #05F6
    #instruction: CP   15
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~15) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~15 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #05F8
    #instruction: JP   CY,0612
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0612);
    } else {
      advance (10)
      #05FB
      #instruction: LD   A,(2061)
      let:8 a7 = M[2061] in
      advance (13)
      #05FE
      #instruction: AND  A
      let:8 a8 = a7 in
      let:8 a9 = a7 in
      let:8 a10 = (a8 & a9) in
      let:8 a11 = (a8 | a9) in
      advance (4)
      #05FF
      #instruction: RET  Z
      if (is_zero(a10)) {
        let:8 a12 = SPH in
        let:8 a13 = SPL in
        let:16 a14 = (1 + (a12,a13)) in
        let:8 a15 = M[(a12,a13)] in
        let:8 a16 = a14[15:8] in
        let:8 a17 = a14[7:0] in
        let:16 a18 = (1 + (a16,a17)) in
        let:8 a19 = M[(a16,a17)] in
        advance (11)
        A := a10;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a10[7];
        FlagZ := is_zero(a10);
        FlagA := a11[3];
        FlagP := parity(a10);
        FlagCY := false;
        jump ((a19,a15));
      } else {
        advance (5)
        #0600
        #instruction: LD   A,(207B)
        let:8 a20 = M[207B] in
        advance (13)
        #0603
        #instruction: CP   1E
        let:8 a21 = a20 in
        let:16 a22 = addWithCarry(!false,a21,~1E) in
        let:8 a23 = (a21 & 0F) in
        let:8 a24 = (~1E & 0F) in
        let:16 a25 = addWithCarry(!false,a23,a24) in
        advance (7)
        #0605
        #instruction: JP   CY,0612
        if (!a22[15:8][0]) {
          advance (10)
          A := a20;
          FlagS := a22[7:0][7];
          FlagZ := is_zero(a22[7:0]);
          FlagA := a25[7:0][4];
          FlagP := parity(a22[7:0]);
          FlagCY := !a22[15:8][0];
          jump (0612);
        } else {
          advance (10)
          #0608
          #instruction: CP   27
          let:8 a26 = a20 in
          let:16 a27 = addWithCarry(!false,a26,~27) in
          let:8 a28 = (a26 & 0F) in
          let:8 a29 = (~27 & 0F) in
          let:16 a30 = addWithCarry(!false,a28,a29) in
          advance (7)
          #060A
          #instruction: NOP
          advance (4)
          #060B
          #instruction: JP   NC,0612
          if (!!a27[15:8][0]) {
            advance (10)
            A := a20;
            FlagS := a27[7:0][7];
            FlagZ := is_zero(a27[7:0]);
            FlagA := a30[7:0][4];
            FlagP := parity(a27[7:0]);
            FlagCY := !a27[15:8][0];
            jump (0612);
          } else {
            advance (10)
            #060E
            #instruction: SUB  A
            let:8 a31 = a20 in
            let:8 a32 = a20 in
            let:16 a33 = addWithCarry(!false,a32,~a31) in
            let:8 a34 = (a32 & 0F) in
            let:8 a35 = (~a31 & 0F) in
            let:16 a36 = addWithCarry(!false,a34,a35) in
            advance (4)
            #060F
            #instruction: LD   (2015),A
            let:8 a37 = a33[7:0] in
            M[2015] := a37;
            advance (13)
            A := a33[7:0];
            FlagS := a33[7:0][7];
            FlagZ := is_zero(a33[7:0]);
            FlagA := a36[7:0][4];
            FlagP := parity(a33[7:0]);
            FlagCY := !a33[15:8][0];
            jump (0612);
          }
        }
      }
    }

0612:

    #0612
    #instruction: LD   A,(2073)
    let:8 a1 = M[2073] in
    advance (13)
    #0615
    #instruction: OR   01
    let:8 a2 = a1 in
    let:8 a3 = (01 | a2) in
    advance (7)
    #0617
    #instruction: LD   (2073),A
    let:8 a4 = a3 in
    M[2073] := a4;
    advance (13)
    #061A
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a12,a8));

0624:

    #0624
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #0625
    #instruction: CP   0C
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~0C) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~0C & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0627
    #instruction: JP   CY,05A5
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (05A5);
    } else {
      advance (10)
      #062A
      #instruction: LD   C,0B
      advance (7)
      #062C
      #instruction: JP   05A5
      advance (10)
      A := a1;
      C := 0B;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (05A5);
    }

0637:

    #0637
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #0638
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #0639
    #instruction: SCF
    advance (4)
    #063A
    #instruction: RET  NZ
    if (!is_zero(a6)) {
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      let:8 a12 = a10[15:8] in
      let:8 a13 = a10[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      advance (11)
      A := a6;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := true;
      jump ((a15,a11));
    } else {
      advance (5)
      #063B
      #instruction: LD   A,L
      let:8 a16 = L in
      advance (5)
      #063C
      #instruction: ADD  0B
      let:8 a17 = a16 in
      let:16 a18 = addWithCarry(false,0B,a17) in
      let:8 a19 = (0B & 0F) in
      let:8 a20 = (a17 & 0F) in
      let:16 a21 = addWithCarry(false,a19,a20) in
      advance (7)
      #063E
      #instruction: LD   L,A
      let:8 a22 = a18[7:0] in
      advance (5)
      #063F
      #instruction: DEC  D
      let:8 a23 = D in
      let:16 a24 = addWithCarry(!true,a23,~00) in
      let:8 a25 = (a23 & 0F) in
      let:8 a26 = (~00 & 0F) in
      let:16 a27 = addWithCarry(!true,a25,a26) in
      advance (5)
      #0640
      #instruction: JP   NZ,0637
      if (!is_zero(a24[7:0])) {
        advance (10)
        A := a18[7:0];
        D := a24[7:0];
        L := a22;
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := a18[15:8][0];
        jump (0637);
      } else {
        advance (10)
        #0643
        #instruction: RET
        let:8 a28 = SPH in
        let:8 a29 = SPL in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (10)
        A := a18[7:0];
        D := a24[7:0];
        L := a22;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := a18[15:8][0];
        jump ((a35,a31));
      }
    }

0651:

    #0651
    #instruction: LD   HL,1CDC
    advance (10)
    #0654
    #instruction: LD   (2079),HL
    M[2079] := DC;
    M[207A] := 1C;
    advance (16)
    #0657
    #instruction: LD   HL,207C
    advance (10)
    #065A
    #instruction: DEC  (HL)
    let:8 a1 = M[207C] in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    M[207C] := a2[7:0];
    advance (10)
    #065B
    #instruction: DEC  (HL)
    let:8 a6 = M[207C] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    M[207C] := a7[7:0];
    advance (10)
    #065C
    #instruction: DEC  HL
    advance (5)
    #065D
    #instruction: DEC  (HL)
    let:8 a11 = M[207B] in
    let:16 a12 = addWithCarry(!true,a11,~00) in
    let:8 a13 = (a11 & 0F) in
    let:8 a14 = (~00 & 0F) in
    let:16 a15 = addWithCarry(!true,a13,a14) in
    M[207B] := a12[7:0];
    advance (10)
    #065E
    #instruction: DEC  (HL)
    let:8 a16 = M[207B] in
    let:16 a17 = addWithCarry(!true,a16,~00) in
    let:8 a18 = (a16 & 0F) in
    let:8 a19 = (~00 & 0F) in
    let:16 a20 = addWithCarry(!true,a18,a19) in
    M[207B] := a17[7:0];
    advance (10)
    #065F
    #instruction: LD   A,06
    advance (7)
    #0661
    #instruction: LD   (207D),A
    M[207D] := 06;
    advance (13)
    #0664
    #instruction: JP   066C
    advance (10)
    A := 06;
    H := 20;
    L := 7B;
    FlagS := a17[7:0][7];
    FlagZ := is_zero(a17[7:0]);
    FlagA := a20[7:0][4];
    FlagP := parity(a17[7:0]);
    jump (066C);

066C:

    #066C
    #instruction: LD   HL,2079
    advance (10)
    #066F
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 72;
    #return-to: 0672
    advance (17)
    H := 20;
    L := 79;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A3B);

0672:

    #0672
    #instruction: JP   1491
    advance (10)
    jump (1491);

0675:

    #0675
    #instruction: LD   HL,2079
    advance (10)
    #0678
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7B;
    #return-to: 067B
    advance (17)
    H := 20;
    L := 79;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A3B);

067B:

    #067B
    #instruction: JP   1452
    advance (10)
    jump (1452);

0682:

    #0682
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0683
    #instruction: LD   A,(2080)
    let:8 a9 = M[2080] in
    advance (13)
    #0686
    #instruction: CP   02
    let:8 a10 = a9 in
    let:16 a11 = addWithCarry(!false,a10,~02) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~02 & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #0688
    #instruction: RET  NZ
    if (!is_zero(a11[7:0])) {
      let:8 a15 = a7[15:8] in
      let:8 a16 = a7[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a9;
      H := a8;
      L := a4;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := !a11[15:8][0];
      jump ((a22,a18));
    } else {
      advance (5)
      #0689
      #instruction: LD   HL,2083
      advance (10)
      #068C
      #instruction: LD   A,(HL)
      let:8 a23 = M[2083] in
      advance (7)
      #068D
      #instruction: AND  A
      let:8 a24 = a23 in
      let:8 a25 = a23 in
      let:8 a26 = (a24 & a25) in
      let:8 a27 = (a24 | a25) in
      advance (4)
      #068E
      #instruction: JP   Z,050F
      if (is_zero(a26)) {
        advance (10)
        A := a26;
        H := 20;
        L := 83;
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := a27[3];
        FlagP := parity(a26);
        FlagCY := false;
        jump (050F);
      } else {
        advance (10)
        #0691
        #instruction: LD   A,(2056)
        let:8 a28 = M[2056] in
        advance (13)
        #0694
        #instruction: AND  A
        let:8 a29 = a28 in
        let:8 a30 = a28 in
        let:8 a31 = (a29 & a30) in
        let:8 a32 = (a29 | a30) in
        advance (4)
        #0695
        #instruction: JP   NZ,050F
        if (!is_zero(a31)) {
          advance (10)
          A := a31;
          H := 20;
          L := 83;
          SPH := a7[15:8];
          SPL := a7[7:0];
          FlagS := a31[7];
          FlagZ := is_zero(a31);
          FlagA := a32[3];
          FlagP := parity(a31);
          FlagCY := false;
          jump (050F);
        } else {
          advance (10)
          #0698
          #instruction: INC  HL
          advance (5)
          #0699
          #instruction: LD   A,(HL)
          let:8 a33 = M[2084] in
          advance (7)
          #069A
          #instruction: AND  A
          let:8 a34 = a33 in
          let:8 a35 = a33 in
          let:8 a36 = (a34 & a35) in
          let:8 a37 = (a34 | a35) in
          advance (4)
          #069B
          #instruction: JP   NZ,06AB
          if (!is_zero(a36)) {
            advance (10)
            A := a36;
            H := 20;
            L := 84;
            SPH := a7[15:8];
            SPL := a7[7:0];
            FlagS := a36[7];
            FlagZ := is_zero(a36);
            FlagA := a37[3];
            FlagP := parity(a36);
            FlagCY := false;
            jump (06AB);
          } else {
            advance (10)
            #069E
            #instruction: LD   A,(2082)
            let:8 a38 = M[2082] in
            advance (13)
            #06A1
            #instruction: CP   08
            let:8 a39 = a38 in
            let:16 a40 = addWithCarry(!false,a39,~08) in
            let:8 a41 = (a39 & 0F) in
            let:8 a42 = (~08 & 0F) in
            let:16 a43 = addWithCarry(!false,a41,a42) in
            advance (7)
            #06A3
            #instruction: JP   CY,050F
            if (!a40[15:8][0]) {
              advance (10)
              A := a38;
              H := 20;
              L := 84;
              SPH := a7[15:8];
              SPL := a7[7:0];
              FlagS := a40[7:0][7];
              FlagZ := is_zero(a40[7:0]);
              FlagA := a43[7:0][4];
              FlagP := parity(a40[7:0]);
              FlagCY := !a40[15:8][0];
              jump (050F);
            } else {
              advance (10)
              #06A6
              #instruction: LD   (HL),01
              M[2084] := 01;
              advance (10)
              #06A8
              #instruction: CALL 073C
              let:8 a44 = a7[15:8] in
              let:8 a45 = a7[7:0] in
              let:16 a46 = (-1 + (a44,a45)) in
              M[a46] := 06;
              let:8 a47 = a46[15:8] in
              let:8 a48 = a46[7:0] in
              let:16 a49 = (-1 + (a47,a48)) in
              M[a49] := AB;
              #return-to: 06AB
              advance (17)
              A := a38;
              H := 20;
              L := 84;
              SPH := a49[15:8];
              SPL := a49[7:0];
              FlagS := a40[7:0][7];
              FlagZ := is_zero(a40[7:0]);
              FlagA := a43[7:0][4];
              FlagP := parity(a40[7:0]);
              FlagCY := !a40[15:8][0];
              jump (073C);
            }
          }
        }
      }
    }

06AB:

    #06AB
    #instruction: LD   DE,208A
    advance (10)
    #06AE
    #instruction: CALL 1A06
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B1;
    #return-to: 06B1
    advance (17)
    D := 20;
    E := 8A;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A06);

06B1:

    #06B1
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #06B2
      #instruction: LD   HL,2085
      advance (10)
      #06B5
      #instruction: LD   A,(HL)
      let:8 a9 = M[2085] in
      advance (7)
      #06B6
      #instruction: AND  A
      let:8 a10 = a9 in
      let:8 a11 = a9 in
      let:8 a12 = (a10 & a11) in
      let:8 a13 = (a10 | a11) in
      advance (4)
      #06B7
      #instruction: JP   NZ,06D6
      if (!is_zero(a12)) {
        advance (10)
        #06D6
        #instruction: LD   B,FE
        advance (7)
        #06D8
        #instruction: CALL 19DC
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (-1 + (a14,a15)) in
        M[a16] := 06;
        let:8 a17 = a16[15:8] in
        let:8 a18 = a16[7:0] in
        let:16 a19 = (-1 + (a17,a18)) in
        M[a19] := DB;
        #return-to: 06DB
        advance (17)
        A := a12;
        B := FE;
        H := 20;
        L := 85;
        SPH := a19[15:8];
        SPL := a19[7:0];
        FlagS := a12[7];
        FlagZ := is_zero(a12);
        FlagA := a13[3];
        FlagP := parity(a12);
        FlagCY := false;
        jump (19DC);
      } else {
        advance (10)
        #06BA
        #instruction: LD   HL,208A
        advance (10)
        #06BD
        #instruction: LD   A,(HL)
        let:8 a20 = M[208A] in
        advance (7)
        #06BE
        #instruction: INC  HL
        advance (5)
        #06BF
        #instruction: INC  HL
        advance (5)
        #06C0
        #instruction: ADD  (HL)
        let:8 a21 = M[208C] in
        let:8 a22 = a20 in
        let:16 a23 = addWithCarry(false,a21,a22) in
        let:8 a24 = (a21 & 0F) in
        let:8 a25 = (a22 & 0F) in
        let:16 a26 = addWithCarry(false,a24,a25) in
        advance (7)
        #06C1
        #instruction: LD   (208A),A
        let:8 a27 = a23[7:0] in
        M[208A] := a27;
        advance (13)
        #06C4
        #instruction: CALL 073C
        let:8 a28 = SPH in
        let:8 a29 = SPL in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 06;
        let:8 a31 = a30[15:8] in
        let:8 a32 = a30[7:0] in
        let:16 a33 = (-1 + (a31,a32)) in
        M[a33] := C7;
        #return-to: 06C7
        advance (17)
        A := a23[7:0];
        H := 20;
        L := 8C;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := a23[15:8][0];
        jump (073C);
      }
    }

06C7:

    #06C7
    #instruction: LD   HL,208A
    advance (10)
    #06CA
    #instruction: LD   A,(HL)
    let:8 a1 = M[208A] in
    advance (7)
    #06CB
    #instruction: CP   28
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~28) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~28 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #06CD
    #instruction: JP   CY,06F9
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      H := 20;
      L := 8A;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (06F9);
    } else {
      advance (10)
      #06D0
      #instruction: CP   E1
      let:8 a7 = a1 in
      let:16 a8 = addWithCarry(!false,a7,~E1) in
      let:8 a9 = (a7 & 0F) in
      let:8 a10 = (~E1 & 0F) in
      let:16 a11 = addWithCarry(!false,a9,a10) in
      advance (7)
      #06D2
      #instruction: JP   NC,06F9
      if (!!a8[15:8][0]) {
        advance (10)
        A := a1;
        H := 20;
        L := 8A;
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := !a8[15:8][0];
        jump (06F9);
      } else {
        advance (10)
        #06D5
        #instruction: RET
        let:8 a12 = SPH in
        let:8 a13 = SPL in
        let:16 a14 = (1 + (a12,a13)) in
        let:8 a15 = M[(a12,a13)] in
        let:8 a16 = a14[15:8] in
        let:8 a17 = a14[7:0] in
        let:16 a18 = (1 + (a16,a17)) in
        let:8 a19 = M[(a16,a17)] in
        advance (10)
        A := a1;
        H := 20;
        L := 8A;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := !a8[15:8][0];
        jump ((a19,a15));
      }
    }

06DB:

    #06DB
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #06DC
    #instruction: DEC  (HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    let:8 a11 = a3[15:8] in
    let:8 a12 = a3[7:0] in
    M[(a11,a12)] := a7[7:0];
    advance (10)
    #06DD
    #instruction: LD   A,(HL)
    let:8 a13 = a3[15:8] in
    let:8 a14 = a3[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #06DE
    #instruction: CP   1F
    let:8 a16 = a15 in
    let:16 a17 = addWithCarry(!false,a16,~1F) in
    let:8 a18 = (a16 & 0F) in
    let:8 a19 = (~1F & 0F) in
    let:16 a20 = addWithCarry(!false,a18,a19) in
    advance (7)
    #06E0
    #instruction: JP   Z,074B
    if (is_zero(a17[7:0])) {
      advance (10)
      #074B
      #instruction: LD   B,10
      advance (7)
      #074D
      #instruction: LD   HL,2098
      advance (10)
      #0750
      #instruction: LD   A,(HL)
      let:8 a21 = M[2098] in
      advance (7)
      #0751
      #instruction: OR   B
      let:8 a22 = a21 in
      let:8 a23 = (10 | a22) in
      advance (4)
      #0752
      #instruction: LD   (HL),A
      let:8 a24 = a23 in
      M[2098] := a24;
      advance (7)
      #0753
      #instruction: CALL 1770
      let:8 a25 = SPH in
      let:8 a26 = SPL in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 07;
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 56;
      #return-to: 0756
      advance (17)
      A := a23;
      B := 10;
      H := 20;
      L := 98;
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a23[7];
      FlagZ := is_zero(a23);
      FlagA := false;
      FlagP := parity(a23);
      FlagCY := false;
      jump (1770);
    } else {
      advance (10)
      #06E3
      #instruction: CP   18
      let:8 a31 = a15 in
      let:16 a32 = addWithCarry(!false,a31,~18) in
      let:8 a33 = (a31 & 0F) in
      let:8 a34 = (~18 & 0F) in
      let:16 a35 = addWithCarry(!false,a33,a34) in
      advance (7)
      #06E5
      #instruction: JP   Z,070C
      if (is_zero(a32[7:0])) {
        advance (10)
        #070C
        #instruction: LD   A,01
        advance (7)
        #070E
        #instruction: LD   (20F1),A
        M[20F1] := 01;
        advance (13)
        #0711
        #instruction: LD   HL,(208D)
        let:8 a36 = M[208D] in
        let:8 a37 = M[208E] in
        advance (16)
        #0714
        #instruction: LD   B,(HL)
        let:8 a38 = a37 in
        let:8 a39 = a36 in
        let:8 a40 = M[(a38,a39)] in
        advance (7)
        #0715
        #instruction: LD   C,04
        advance (7)
        #0717
        #instruction: LD   HL,1D50
        advance (10)
        #071A
        #instruction: LD   DE,1D4C
        advance (10)
        A := 01;
        B := a40;
        C := 04;
        D := 1D;
        E := 4C;
        H := 1D;
        L := 50;
        FlagS := a32[7:0][7];
        FlagZ := is_zero(a32[7:0]);
        FlagA := a35[7:0][4];
        FlagP := parity(a32[7:0]);
        FlagCY := !a32[15:8][0];
        jump (071D);
      } else {
        advance (10)
        #06E8
        #instruction: AND  A
        let:8 a41 = a15 in
        let:8 a42 = a15 in
        let:8 a43 = (a41 & a42) in
        let:8 a44 = (a41 | a42) in
        advance (4)
        #06E9
        #instruction: RET  NZ
        if (!is_zero(a43)) {
          let:8 a45 = SPH in
          let:8 a46 = SPL in
          let:16 a47 = (1 + (a45,a46)) in
          let:8 a48 = M[(a45,a46)] in
          let:8 a49 = a47[15:8] in
          let:8 a50 = a47[7:0] in
          let:16 a51 = (1 + (a49,a50)) in
          let:8 a52 = M[(a49,a50)] in
          advance (11)
          A := a43;
          H := a3[15:8];
          L := a3[7:0];
          SPH := a51[15:8];
          SPL := a51[7:0];
          FlagS := a43[7];
          FlagZ := is_zero(a43);
          FlagA := a44[3];
          FlagP := parity(a43);
          FlagCY := false;
          jump ((a52,a48));
        } else {
          advance (5)
          #06EA
          #instruction: LD   B,EF
          advance (7)
          #06EC
          #instruction: LD   HL,2098
          advance (10)
          #06EF
          #instruction: LD   A,(HL)
          let:8 a53 = M[2098] in
          advance (7)
          #06F0
          #instruction: AND  B
          let:8 a54 = a53 in
          let:8 a55 = (EF & a54) in
          let:8 a56 = (EF | a54) in
          advance (4)
          #06F1
          #instruction: LD   (HL),A
          let:8 a57 = a55 in
          M[2098] := a57;
          advance (7)
          #06F2
          #instruction: AND  20
          let:8 a58 = a55 in
          let:8 a59 = (20 & a58) in
          let:8 a60 = (20 | a58) in
          advance (7)
          #06F4
          #instruction: OUT  05
          let:8 a61 = a59 in
          sound_control(FleetMovement1,a61[0]);
          sound_control(FleetMovement2,a61[1]);
          sound_control(FleetMovement3,a61[2]);
          sound_control(FleetMovement4,a61[3]);
          sound_control(UfoHit,a61[4]);
          advance (10)
          #06F6
          #instruction: NOP
          advance (4)
          #06F7
          #instruction: NOP
          advance (4)
          #06F8
          #instruction: NOP
          advance (4)
          A := a59;
          B := EF;
          H := 20;
          L := 98;
          FlagS := a59[7];
          FlagZ := is_zero(a59);
          FlagA := a60[3];
          FlagP := parity(a59);
          FlagCY := false;
          jump (06F9);
        }
      }
    }

06F9:

    #06F9
    #instruction: CALL 0742
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FC;
    #return-to: 06FC
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0742);

06FC:

    #06FC
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FF;
    #return-to: 06FF
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14CB);

06FF:

    #06FF
    #instruction: LD   HL,2083
    advance (10)
    #0702
    #instruction: LD   B,0A
    advance (7)
    #0704
    #instruction: CALL 075F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 07;
    #return-to: 0707
    advance (17)
    #075F
    #instruction: LD   DE,1B83
    advance (10)
    #0762
    #instruction: JP   1A32
    advance (10)
    B := 0A;
    D := 1B;
    E := 83;
    H := 20;
    L := 83;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A32);

0707:

    #0707
    #instruction: LD   B,FE
    advance (7)
    #0709
    #instruction: JP   19DC
    advance (10)
    B := FE;
    jump (19DC);

071D:

    #071D
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #071E
    #instruction: CP   B
    let:8 a4 = a3 in
    let:8 a5 = B in
    let:16 a6 = addWithCarry(!false,a4,~a5) in
    let:8 a7 = (a4 & 0F) in
    let:8 a8 = (~a5 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (4)
    #071F
    #instruction: JP   Z,0728
    if (is_zero(a6[7:0])) {
      advance (10)
      A := a3;
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      FlagCY := !a6[15:8][0];
      jump (0728);
    } else {
      advance (10)
      #0722
      #instruction: INC  HL
      let:8 a10 = H in
      let:8 a11 = L in
      let:16 a12 = (1 + (a10,a11)) in
      advance (5)
      #0723
      #instruction: INC  DE
      let:8 a13 = D in
      let:8 a14 = E in
      let:16 a15 = (1 + (a13,a14)) in
      advance (5)
      #0724
      #instruction: DEC  C
      let:8 a16 = C in
      let:16 a17 = addWithCarry(!true,a16,~00) in
      let:8 a18 = (a16 & 0F) in
      let:8 a19 = (~00 & 0F) in
      let:16 a20 = addWithCarry(!true,a18,a19) in
      advance (5)
      #0725
      #instruction: JP   NZ,071D
      if (!is_zero(a17[7:0])) {
        advance (10)
        A := a3;
        C := a17[7:0];
        D := a15[15:8];
        E := a15[7:0];
        H := a12[15:8];
        L := a12[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a6[15:8][0];
        jump (071D);
      } else {
        advance (10)
        A := a3;
        C := a17[7:0];
        D := a15[15:8];
        E := a15[7:0];
        H := a12[15:8];
        L := a12[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a6[15:8][0];
        jump (0728);
      }
    }

0728:

    #0728
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #0729
    #instruction: LD   (2087),A
    let:8 a4 = a3 in
    M[2087] := a4;
    advance (13)
    #072C
    #instruction: LD   H,00
    advance (7)
    #072E
    #instruction: LD   L,B
    let:8 a5 = B in
    advance (5)
    #072F
    #instruction: ADD  HL,HL
    let:8 a6 = a5 in
    let:8 a7 = a5 in
    let:17 a8 = add17((00,a6),(00,a7)) in
    advance (10)
    #0730
    #instruction: ADD  HL,HL
    let:8 a9 = a8[15:0][15:8] in
    let:8 a10 = a8[15:0][7:0] in
    let:8 a11 = a8[15:0][15:8] in
    let:8 a12 = a8[15:0][7:0] in
    let:17 a13 = add17((a9,a10),(a11,a12)) in
    advance (10)
    #0731
    #instruction: ADD  HL,HL
    let:8 a14 = a13[15:0][15:8] in
    let:8 a15 = a13[15:0][7:0] in
    let:8 a16 = a13[15:0][15:8] in
    let:8 a17 = a13[15:0][7:0] in
    let:17 a18 = add17((a14,a15),(a16,a17)) in
    advance (10)
    #0732
    #instruction: ADD  HL,HL
    let:8 a19 = a18[15:0][15:8] in
    let:8 a20 = a18[15:0][7:0] in
    let:8 a21 = a18[15:0][15:8] in
    let:8 a22 = a18[15:0][7:0] in
    let:17 a23 = add17((a19,a20),(a21,a22)) in
    advance (10)
    #0733
    #instruction: LD   (20F2),HL
    let:8 a24 = a23[15:0][7:0] in
    M[20F2] := a24;
    let:8 a25 = a23[15:0][15:8] in
    M[20F3] := a25;
    advance (16)
    #0736
    #instruction: CALL 0742
    let:8 a26 = SPH in
    let:8 a27 = SPL in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := 07;
    let:8 a29 = a28[15:8] in
    let:8 a30 = a28[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := 39;
    #return-to: 0739
    advance (17)
    A := a3;
    H := a23[15:0][15:8];
    L := a23[15:0][7:0];
    SPH := a31[15:8];
    SPL := a31[7:0];
    FlagCY := a23[16];
    jump (0742);

0739:

    #0739
    #instruction: JP   08F1
    advance (10)
    #08F1
    #instruction: LD   C,03
    advance (7)
    C := 03;
    jump (08F3);

073C:

    #073C
    #instruction: CALL 0742
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3F;
    #return-to: 073F
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0742);

073F:

    #073F
    #instruction: JP   1439
    advance (10)
    jump (1439);

0742:

    #0742
    #instruction: LD   HL,2087
    advance (10)
    #0745
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 48;
    #return-to: 0748
    advance (17)
    H := 20;
    L := 87;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A3B);

0748:

    #0748
    #instruction: JP   1A47
    advance (10)
    jump (1A47);

0756:

    #0756
    #instruction: LD   HL,1D7C
    advance (10)
    #0759
    #instruction: LD   (2087),HL
    M[2087] := 7C;
    M[2088] := 1D;
    advance (16)
    #075C
    #instruction: JP   073C
    advance (10)
    H := 1D;
    L := 7C;
    jump (073C);

0771:

    #0771
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 0774
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

0774:

    #0774
    #instruction: LD   HL,3013
    advance (10)
    #0777
    #instruction: LD   DE,1FF3
    advance (10)
    #077A
    #instruction: LD   C,04
    advance (7)
    #077C
    #instruction: CALL 08F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7F;
    #return-to: 077F
    advance (17)
    C := 04;
    D := 1F;
    E := F3;
    H := 30;
    L := 13;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (08F3);

077F:

    #077F
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    #0782
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0783
    #instruction: LD   HL,2810
    advance (10)
    #0786
    #instruction: LD   C,14
    advance (7)
    #0788
    #instruction: JP   NZ,0857
    if (!is_zero(a3[7:0])) {
      advance (10)
      #0857
      #instruction: LD   DE,1ABA
      advance (10)
      #085A
      #instruction: CALL 08F3
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 08;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 5D;
      #return-to: 085D
      advance (17)
      A := a3[7:0];
      C := 14;
      D := 1A;
      E := BA;
      H := 28;
      L := 10;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (08F3);
    } else {
      advance (10)
      #078B
      #instruction: LD   DE,1ACF
      advance (10)
      #078E
      #instruction: CALL 08F3
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 07;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := 91;
      #return-to: 0791
      advance (17)
      A := a3[7:0];
      C := 14;
      D := 1A;
      E := CF;
      H := 28;
      L := 10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (08F3);
    }

0791:

    #0791
    #instruction: IN   01
    advance (10)
    #0793
    #instruction: AND  04
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    #0795
    #instruction: JP   Z,077F
    if (is_zero(a2)) {
      advance (10)
      A := a2;
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump (077F);
    } else {
      advance (10)
      A := a2;
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump (0798);
    }

0798:

    #0798
    #instruction: LD   B,99
    advance (7)
    #079A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    B := 99;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (079B);

079B:

    #079B
    #instruction: LD   (20CE),A
    let:8 a1 = A in
    M[20CE] := a1;
    advance (13)
    #079E
    #instruction: LD   A,(20EB)
    let:8 a2 = M[20EB] in
    advance (13)
    #07A1
    #instruction: ADD  B
    let:8 a3 = B in
    let:8 a4 = a2 in
    let:16 a5 = addWithCarry(false,a3,a4) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (a4 & 0F) in
    let:16 a8 = addWithCarry(false,a6,a7) in
    advance (4)
    #07A2
    #instruction: DAA
    let:8 a9 = a5[7:0] in
    let:8 a10 = (a9 & 0F) in
    let:16 a11 = addWithCarry(false,a10,06) in
    let:16 a12 = addWithCarry(((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10)[4],(a9 >> 04),00) in
    let:16 a13 = addWithCarry(false,a12[7:0],06) in
    let:8 a14 = (((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10) & 0F) in
    let:8 a15 = ((((((a12[7:0][1] || a12[7:0][2]) && a12[7:0][3]) || a5[15:8][0]) ? a13[7:0] : a12[7:0]) << 04) | a14) in
    advance (4)
    #07A3
    #instruction: LD   (20EB),A
    let:8 a16 = a15 in
    M[20EB] := a16;
    advance (13)
    #07A6
    #instruction: CALL 1947
    let:8 a17 = SPH in
    let:8 a18 = SPL in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 07;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := A9;
    #return-to: 07A9
    advance (17)
    A := a15;
    SPH := a22[15:8];
    SPL := a22[7:0];
    FlagS := a15[7];
    FlagZ := is_zero(a15);
    FlagA := ((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10)[4];
    FlagP := parity(a15);
    FlagCY := (((((a12[7:0][1] || a12[7:0][2]) && a12[7:0][3]) || a5[15:8][0]) ? a13[7:0] : a12[7:0])[4] || a5[15:8][0]);
    jump (1947);

07A9:

    #07A9
    #instruction: LD   HL,0000
    advance (10)
    #07AC
    #instruction: LD   (20F8),HL
    M[20F8] := 00;
    M[20F9] := 00;
    advance (16)
    #07AF
    #instruction: LD   (20FC),HL
    M[20FC] := 00;
    M[20FD] := 00;
    advance (16)
    #07B2
    #instruction: CALL 1925
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B5;
    #return-to: 07B5
    advance (17)
    H := 00;
    L := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1925);

07B5:

    #07B5
    #instruction: CALL 192B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B8;
    #return-to: 07B8
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (192B);

07B8:

    #07B8
    #instruction: CALL 19D7
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := BB;
    #return-to: 07BB
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (19D7);

07BB:

    #07BB
    #instruction: LD   HL,0101
    advance (10)
    #07BE
    #instruction: LD   A,H
    advance (5)
    #07BF
    #instruction: LD   (20EF),A
    M[20EF] := 01;
    advance (13)
    #07C2
    #instruction: LD   (20E7),HL
    M[20E7] := 01;
    M[20E8] := 01;
    advance (16)
    #07C5
    #instruction: LD   (20E5),HL
    M[20E5] := 01;
    M[20E6] := 01;
    advance (16)
    #07C8
    #instruction: CALL 1956
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := CB;
    #return-to: 07CB
    advance (17)
    A := 01;
    H := 01;
    L := 01;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1956);

07CB:

    #07CB
    #instruction: CALL 01EF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := CE;
    #return-to: 07CE
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01EF);

07CE:

    #07CE
    #instruction: CALL 01F5
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D1;
    #return-to: 07D1
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01F5);

07D1:

    #07D1
    #instruction: CALL 08D1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D4;
    #return-to: 07D4
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (08D1);

07D4:

    #07D4
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    #07D7
    #instruction: LD   (22FF),A
    let:8 a2 = A in
    M[22FF] := a2;
    advance (13)
    #07DA
    #instruction: CALL 00D7
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 07;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := DD;
    #return-to: 07DD
    advance (17)
    #00D7
    #instruction: LD   A,02
    advance (7)
    #00D9
    #instruction: LD   (21FB),A
    M[21FB] := 02;
    advance (13)
    #00DC
    #instruction: LD   (22FB),A
    M[22FB] := 02;
    advance (13)
    #00DF
    #instruction: JP   08E4
    advance (10)
    #08E4
    #instruction: LD   A,(20CE)
    let:8 a9 = M[20CE] in
    advance (13)
    #08E7
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #08E8
    #instruction: RET  NZ
    if (!is_zero(a12)) {
      let:8 a14 = a8[15:8] in
      let:8 a15 = a8[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #08E9
      #instruction: LD   HL,391C
      advance (10)
      #08EC
      #instruction: LD   B,20
      advance (7)
      #08EE
      #instruction: JP   14CB
      advance (10)
      A := a12;
      B := 20;
      H := 39;
      L := 1C;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump (14CB);
    }

07DD:

    #07DD
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #07DE
    #instruction: LD   (21FE),A
    let:8 a4 = a3 in
    M[21FE] := a4;
    advance (13)
    #07E1
    #instruction: LD   (22FE),A
    let:8 a5 = a3 in
    M[22FE] := a5;
    advance (13)
    #07E4
    #instruction: CALL 01C0
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 07;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := E7;
    #return-to: 07E7
    advance (17)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (01C0);

07E7:

    #07E7
    #instruction: CALL 1904
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := EA;
    #return-to: 07EA
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1904);

07EA:

    #07EA
    #instruction: LD   HL,3878
    advance (10)
    #07ED
    #instruction: LD   (21FC),HL
    M[21FC] := 78;
    M[21FD] := 38;
    advance (16)
    #07F0
    #instruction: LD   (22FC),HL
    M[22FC] := 78;
    M[22FD] := 38;
    advance (16)
    #07F3
    #instruction: CALL 01E4
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 07F6
    advance (17)
    H := 38;
    L := 78;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01E4);

07F6:

    #07F6
    #instruction: CALL 1A7F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F9;
    #return-to: 07F9
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A7F);

07F9:

    #07F9
    #instruction: CALL 088D
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FC;
    #return-to: 07FC
    advance (17)
    #088D
    #instruction: LD   HL,2B11
    advance (10)
    #0890
    #instruction: LD   DE,1B70
    advance (10)
    #0893
    #instruction: LD   C,0E
    advance (7)
    #0895
    #instruction: CALL 08F3
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 08;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 98;
    #return-to: 0898
    advance (17)
    C := 0E;
    D := 1B;
    E := 70;
    H := 2B;
    L := 11;
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (08F3);

07FC:

    #07FC
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FF;
    #return-to: 07FF
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

07FF:

    #07FF
    #instruction: NOP
    advance (4)
    #0800
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0801
    #instruction: LD   (20C1),A
    let:8 a4 = a3 in
    M[20C1] := a4;
    advance (13)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0804);

0804:

    #0804
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 07;
    #return-to: 0807
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01CF);

0807:

    #0807
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #080A
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #080B
    #instruction: JP   CY,0872
    if (a2[0]) {
      advance (10)
      #0872
      #instruction: CALL 021A
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (-1 + (a3,a4)) in
      M[a5] := 08;
      let:8 a6 = a5[15:8] in
      let:8 a7 = a5[7:0] in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 75;
      #return-to: 0875
      advance (17)
      A := updateBit((a2 >> 01),7,a2[0]);
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagCY := a2[0];
      jump (021A);
    } else {
      advance (10)
      #080E
      #instruction: CALL 0213
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 08;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 11;
      #return-to: 0811
      advance (17)
      #0213
      #instruction: XOR  A
      let:8 a15 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a16 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a17 = (a15 ^ a16) in
      advance (4)
      A := a17;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a17[7];
      FlagZ := is_zero(a17);
      FlagA := false;
      FlagP := parity(a17);
      FlagCY := false;
      jump (0214);
    }

0811:

    #0811
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 14;
    #return-to: 0814
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01CF);

0814:

    #0814
    #instruction: CALL 00B1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    #return-to: 0817
    advance (17)
    #00B1
    #instruction: CALL 0886
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 00;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := B4;
    #return-to: 00B4
    advance (17)
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (0886);

0817:

    #0817
    #instruction: CALL 19D1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 1A;
    #return-to: 081A
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (19D1);

081A:

    #081A
    #instruction: LD   B,20
    advance (7)
    #081C
    #instruction: CALL 18FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 1F;
    #return-to: 081F
    advance (17)
    B := 20;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (18FA);

081F:

    #081F
    #instruction: CALL 1618
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 22;
    #return-to: 0822
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1618);

0822:

    #0822
    #instruction: CALL 190A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 25;
    #return-to: 0825
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (190A);

0825:

    #0825
    #instruction: CALL 15F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 28;
    #return-to: 0828
    advance (17)
    #15F3
    #instruction: CALL 1611
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 15;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F6;
    #return-to: 15F6
    advance (17)
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (1611);

0828:

    #0828
    #instruction: CALL 0988
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2B;
    #return-to: 082B
    advance (17)
    #0988
    #instruction: CALL 09CA
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 8B;
    #return-to: 098B
    advance (17)
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (09CA);

082B:

    #082B
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    #082E
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #082F
    #instruction: JP   Z,09EF
    if (is_zero(a4)) {
      advance (10)
      #09EF
      #instruction: CALL 0A3C
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 09;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := F2;
      #return-to: 09F2
      advance (17)
      #0A3C
      #instruction: CALL 0A59
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 0A;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 3F;
      #return-to: 0A3F
      advance (17)
      A := a4;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0A59);
    } else {
      advance (10)
      #0832
      #instruction: CALL 170E
      let:8 a18 = SPH in
      let:8 a19 = SPL in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 08;
      let:8 a21 = a20[15:8] in
      let:8 a22 = a20[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 35;
      #return-to: 0835
      advance (17)
      #170E
      #instruction: CALL 09CA
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 17;
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := 11;
      #return-to: 1711
      advance (17)
      A := a4;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (09CA);
    }

0835:

    #0835
    #instruction: CALL 0935
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 38;
    #return-to: 0838
    advance (17)
    #0935
    #instruction: CALL 1910
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 38;
    #return-to: 0938
    advance (17)
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (1910);

0838:

    #0838
    #instruction: CALL 08D8
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3B;
    #return-to: 083B
    advance (17)
    #08D8
    #instruction: LD   A,(2082)
    let:8 a7 = M[2082] in
    advance (13)
    #08DB
    #instruction: CP   09
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~09) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~09 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #08DD
    #instruction: RET  NC
    if (!!a9[15:8][0]) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #08DE
      #instruction: LD   A,FB
      advance (7)
      #08E0
      #instruction: LD   (207E),A
      M[207E] := FB;
      advance (13)
      #08E3
      #instruction: RET
      let:8 a21 = a6[15:8] in
      let:8 a22 = a6[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := FB;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a28,a24));
    }

083B:

    #083B
    #instruction: CALL 172C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3E;
    #return-to: 083E
    advance (17)
    #172C
    #instruction: LD   A,(2025)
    let:8 a7 = M[2025] in
    advance (13)
    #172F
    #instruction: CP   00
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~00) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #1731
    #instruction: JP   NZ,1739
    if (!is_zero(a9[7:0])) {
      advance (10)
      #1739
      #instruction: LD   B,02
      advance (7)
      #173B
      #instruction: JP   18FA
      advance (10)
      A := a7;
      B := 02;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump (18FA);
    } else {
      advance (10)
      #1734
      #instruction: LD   B,FD
      advance (7)
      #1736
      #instruction: JP   19DC
      advance (10)
      A := a7;
      B := FD;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump (19DC);
    }

083E:

    #083E
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 41;
    #return-to: 0841
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A59);

0841:

    #0841
    #instruction: JP   Z,0849
    if (FlagZ) {
      advance (10)
      jump (0849);
    } else {
      advance (10)
      #0844
      #instruction: LD   B,04
      advance (7)
      #0846
      #instruction: CALL 18FA
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 08;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 49;
      #return-to: 0849
      advance (17)
      B := 04;
      SPH := a6[15:8];
      SPL := a6[7:0];
      jump (18FA);
    }

0849:

    #0849
    #instruction: CALL 1775
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4C;
    #return-to: 084C
    advance (17)
    #1775
    #instruction: LD   A,(2095)
    let:8 a7 = M[2095] in
    advance (13)
    #1778
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #1779
    #instruction: JP   Z,17AA
    if (is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (17AA);
    } else {
      advance (10)
      #177C
      #instruction: LD   HL,1A11
      advance (10)
      #177F
      #instruction: LD   DE,1A21
      advance (10)
      #1782
      #instruction: LD   A,(2082)
      let:8 a12 = M[2082] in
      advance (13)
      A := a12;
      D := 1A;
      E := 21;
      H := 1A;
      L := 11;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (1785);
    }

084C:

    #084C
    #instruction: OUT  06
    let:8 a1 = A in
    advance (10)
    #084E
    #instruction: CALL 1804
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 08;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 51;
    #return-to: 0851
    advance (17)
    #1804
    #instruction: LD   HL,2084
    advance (10)
    #1807
    #instruction: LD   A,(HL)
    let:8 a8 = M[2084] in
    advance (7)
    #1808
    #instruction: AND  A
    let:8 a9 = a8 in
    let:8 a10 = a8 in
    let:8 a11 = (a9 & a10) in
    let:8 a12 = (a9 | a10) in
    advance (4)
    #1809
    #instruction: JP   Z,0707
    if (is_zero(a11)) {
      advance (10)
      A := a11;
      H := 20;
      L := 84;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a11[7];
      FlagZ := is_zero(a11);
      FlagA := a12[3];
      FlagP := parity(a11);
      FlagCY := false;
      jump (0707);
    } else {
      advance (10)
      #180C
      #instruction: INC  HL
      advance (5)
      #180D
      #instruction: LD   A,(HL)
      let:8 a13 = M[2085] in
      advance (7)
      #180E
      #instruction: AND  A
      let:8 a14 = a13 in
      let:8 a15 = a13 in
      let:8 a16 = (a14 & a15) in
      let:8 a17 = (a14 | a15) in
      advance (4)
      #180F
      #instruction: RET  NZ
      if (!is_zero(a16)) {
        let:8 a18 = a7[15:8] in
        let:8 a19 = a7[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (11)
        A := a16;
        H := 20;
        L := 85;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a16[7];
        FlagZ := is_zero(a16);
        FlagA := a17[3];
        FlagP := parity(a16);
        FlagCY := false;
        jump ((a25,a21));
      } else {
        advance (5)
        #1810
        #instruction: LD   B,01
        advance (7)
        #1812
        #instruction: JP   18FA
        advance (10)
        A := a16;
        B := 01;
        H := 20;
        L := 85;
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a16[7];
        FlagZ := is_zero(a16);
        FlagA := a17[3];
        FlagP := parity(a16);
        FlagCY := false;
        jump (18FA);
      }
    }

0851:

    #0851
    #instruction: JP   081F
    advance (10)
    jump (081F);

085D:

    #085D
    #instruction: LD   B,98
    advance (7)
    #085F
    #instruction: IN   01
    advance (10)
    #0861
    #instruction: RRCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    advance (4)
    #0862
    #instruction: RRCA
    let:8 a2 = updateBit((a1 >> 01),7,a1[0]) in
    advance (4)
    #0863
    #instruction: JP   CY,086D
    if (a2[0]) {
      advance (10)
      #086D
      #instruction: LD   A,01
      advance (7)
      #086F
      #instruction: JP   079B
      advance (10)
      A := 01;
      B := 98;
      FlagCY := a2[0];
      jump (079B);
    } else {
      advance (10)
      #0866
      #instruction: RRCA
      let:8 a3 = updateBit((a2 >> 01),7,a2[0]) in
      advance (4)
      #0867
      #instruction: JP   CY,0798
      if (a3[0]) {
        advance (10)
        A := updateBit((a3 >> 01),7,a3[0]);
        B := 98;
        FlagCY := a3[0];
        jump (0798);
      } else {
        advance (10)
        #086A
        #instruction: JP   077F
        advance (10)
        A := updateBit((a3 >> 01),7,a3[0]);
        B := 98;
        FlagCY := a3[0];
        jump (077F);
      }
    }

0875:

    #0875
    #instruction: JP   0814
    advance (10)
    jump (0814);

0886:

    #0886
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #0889
    #instruction: LD   H,A
    let:8 a2 = a1 in
    advance (5)
    #088A
    #instruction: LD   L,FC
    advance (7)
    #088C
    #instruction: RET
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (1 + (a3,a4)) in
    let:8 a6 = M[(a3,a4)] in
    let:8 a7 = a5[15:8] in
    let:8 a8 = a5[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    advance (10)
    A := a1;
    H := a2;
    L := FC;
    SPH := a9[15:8];
    SPL := a9[7:0];
    jump ((a10,a6));

0898:

    #0898
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #089B
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #089C
    #instruction: LD   A,1C
    advance (7)
    #089E
    #instruction: LD   HL,3711
    advance (10)
    #08A1
    #instruction: CALL NC,08FF
    if (!a2[0]) {
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (-1 + (a3,a4)) in
      M[a5] := 08;
      let:8 a6 = a5[15:8] in
      let:8 a7 = a5[7:0] in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := A4;
      #return-to: 08A4
      advance (17)
      A := 1C;
      H := 37;
      L := 11;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagCY := a2[0];
      jump (08FF);
    } else {
      advance (11)
      A := 1C;
      H := 37;
      L := 11;
      FlagCY := a2[0];
      jump (08A4);
    }

08A4:

    #08A4
    #instruction: LD   A,B0
    advance (7)
    #08A6
    #instruction: LD   (20C0),A
    M[20C0] := B0;
    advance (13)
    A := B0;
    jump (08A9);

08A9:

    #08A9
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a14 = a4 in
      let:8 a15 = (04 & a14) in
      let:8 a16 = (04 | a14) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a15)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        let:8 a17 = M[2067] in
        advance (13)
        #08C4
        #instruction: RRCA
        let:8 a18 = a17 in
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (a18[0]) {
          advance (10)
          A := updateBit((a18 >> 01),7,a18[0]);
          B := 20;
          H := 27;
          L := 1C;
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a18[0];
          jump (08CB);
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          A := updateBit((a18 >> 01),7,a18[0]);
          B := 20;
          H := 39;
          L := 1C;
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a18[0];
          jump (08CB);
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:8 a19 = SPH in
        let:8 a20 = SPL in
        let:16 a21 = (-1 + (a19,a20)) in
        M[a21] := 08;
        let:8 a22 = a21[15:8] in
        let:8 a23 = a21[7:0] in
        let:16 a24 = (-1 + (a22,a23)) in
        M[a24] := B6;
        #return-to: 08B6
        advance (17)
        A := a15;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a15[7];
        FlagZ := is_zero(a15);
        FlagA := a16[3];
        FlagP := parity(a15);
        FlagCY := false;
        jump (09CA);
      }
    }

08B6:

    #08B6
    #instruction: CALL 1931
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B9;
    #return-to: 08B9
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1931);

08B9:

    #08B9
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08CB:

    #08CB
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := CE;
    #return-to: 08CE
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14CB);

08CE:

    #08CE
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08D1:

    #08D1
    #instruction: IN   02
    advance (10)
    #08D3
    #instruction: AND  03
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    let:8 a2 = (03 & a1) in
    let:8 a3 = (03 | a1) in
    advance (7)
    #08D5
    #instruction: ADD  03
    let:8 a4 = a2 in
    let:16 a5 = addWithCarry(false,03,a4) in
    let:8 a6 = (03 & 0F) in
    let:8 a7 = (a4 & 0F) in
    let:16 a8 = addWithCarry(false,a6,a7) in
    advance (7)
    #08D7
    #instruction: RET
    let:8 a9 = SPH in
    let:8 a10 = SPL in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    A := a5[7:0];
    SPH := a15[15:8];
    SPL := a15[7:0];
    FlagS := a5[7:0][7];
    FlagZ := is_zero(a5[7:0]);
    FlagA := a8[7:0][4];
    FlagP := parity(a5[7:0]);
    FlagCY := a5[15:8][0];
    jump ((a16,a12));

08F3:

    #08F3
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a4 = D in
    let:8 a5 = E in
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a4;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a5;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 08;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := F8;
    #return-to: 08F8
    advance (17)
    A := a3;
    SPH := a17[15:8];
    SPL := a17[7:0];
    jump (08FF);

08F8:

    #08F8
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #08F9
    #instruction: INC  DE
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #08FA
    #instruction: DEC  C
    let:8 a12 = C in
    let:16 a13 = addWithCarry(!true,a12,~00) in
    let:8 a14 = (a12 & 0F) in
    let:8 a15 = (~00 & 0F) in
    let:16 a16 = addWithCarry(!true,a14,a15) in
    advance (5)
    #08FB
    #instruction: JP   NZ,08F3
    if (!is_zero(a13[7:0])) {
      advance (10)
      C := a13[7:0];
      D := a11[15:8];
      E := a11[7:0];
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      jump (08F3);
    } else {
      advance (10)
      #08FE
      #instruction: RET
      let:8 a17 = a7[15:8] in
      let:8 a18 = a7[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      C := a13[7:0];
      D := a11[15:8];
      E := a11[7:0];
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      jump ((a24,a20));
    }

08FF:

    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a9 = A in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:17 a12 = add17((00,a10),(00,a11)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a13 = a12[15:0][15:8] in
    let:8 a14 = a12[15:0][7:0] in
    let:8 a15 = a12[15:0][15:8] in
    let:8 a16 = a12[15:0][7:0] in
    let:17 a17 = add17((a13,a14),(a15,a16)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a18 = a17[15:0][15:8] in
    let:8 a19 = a17[15:0][7:0] in
    let:8 a20 = a17[15:0][15:8] in
    let:8 a21 = a17[15:0][7:0] in
    let:17 a22 = add17((a18,a19),(a20,a21)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a23 = a22[15:0][15:8] in
    let:8 a24 = a22[15:0][7:0] in
    let:17 a25 = add17(1E00,(a23,a24)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a28 = a8[15:8] in
    let:8 a29 = a8[7:0] in
    let:16 a30 = (1 + (a28,a29)) in
    let:8 a31 = M[(a28,a29)] in
    let:8 a32 = a30[15:8] in
    let:8 a33 = a30[7:0] in
    let:16 a34 = (1 + (a32,a33)) in
    let:8 a35 = M[(a32,a33)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a36 = A in
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    B := 08;
    D := a26;
    E := a27;
    H := a35;
    L := a31;
    SPH := a34[15:8];
    SPL := a34[7:0];
    FlagCY := a25[16];
    jump (1439);

0929:

    #0929
    #instruction: DEC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    #092A
    #instruction: LD   (2091),HL
    let:8 a4 = a3[7:0] in
    M[2091] := a4;
    let:8 a5 = a3[15:8] in
    M[2092] := a5;
    advance (16)
    #092D
    #instruction: RET
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (1 + (a6,a7)) in
    let:8 a9 = M[(a6,a7)] in
    let:8 a10 = a8[15:8] in
    let:8 a11 = a8[7:0] in
    let:16 a12 = (1 + (a10,a11)) in
    let:8 a13 = M[(a10,a11)] in
    advance (10)
    H := a3[15:8];
    L := a3[7:0];
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump ((a13,a9));

092E:

    #092E
    #instruction: CALL 1611
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 09;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 31;
    #return-to: 0931
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1611);

0931:

    #0931
    #instruction: LD   L,FF
    advance (7)
    #0933
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = M[(a1,FF)] in
    advance (7)
    #0934
    #instruction: RET
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (1 + (a3,a4)) in
    let:8 a6 = M[(a3,a4)] in
    let:8 a7 = a5[15:8] in
    let:8 a8 = a5[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    advance (10)
    A := a2;
    L := FF;
    SPH := a9[15:8];
    SPL := a9[7:0];
    jump ((a10,a6));

0938:

    #0938
    #instruction: DEC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    #0939
    #instruction: DEC  HL
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    advance (5)
    #093A
    #instruction: LD   A,(HL)
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #093B
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #093C
    #instruction: RET  Z
    if (is_zero(a12)) {
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      H := a6[15:8];
      L := a6[7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #093D
      #instruction: LD   B,15
      advance (7)
      #093F
      #instruction: IN   02
      advance (10)
      #0941
      #instruction: AND  08
      let:8 a22 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
      let:8 a23 = (08 & a22) in
      let:8 a24 = (08 | a22) in
      advance (7)
      #0943
      #instruction: JP   Z,0948
      if (is_zero(a23)) {
        advance (10)
        A := a23;
        B := 15;
        H := a6[15:8];
        L := a6[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump (0948);
      } else {
        advance (10)
        #0946
        #instruction: LD   B,10
        advance (7)
        A := a23;
        B := 10;
        H := a6[15:8];
        L := a6[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump (0948);
      }
    }

0948:

    #0948
    #instruction: CALL 09CA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 09;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4B;
    #return-to: 094B
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09CA);

094B:

    #094B
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #094C
    #instruction: LD   A,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #094D
    #instruction: CP   B
    let:8 a7 = a6 in
    let:8 a8 = B in
    let:16 a9 = addWithCarry(!false,a7,~a8) in
    let:8 a10 = (a7 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (4)
    #094E
    #instruction: RET  CY
    if (!a9[15:8][0]) {
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a6;
      H := a3[15:8];
      L := a3[7:0];
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #094F
      #instruction: CALL 092E
      let:8 a21 = SPH in
      let:8 a22 = SPL in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 09;
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 52;
      #return-to: 0952
      advance (17)
      A := a6;
      H := a3[15:8];
      L := a3[7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump (092E);
    }

0952:

    #0952
    #instruction: INC  (HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = addWithCarry(true,a3,00) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (00 & 0F) in
    let:16 a7 = addWithCarry(true,a5,a6) in
    let:8 a8 = H in
    let:8 a9 = L in
    M[(a8,a9)] := a4[7:0];
    advance (10)
    #0953
    #instruction: LD   A,(HL)
    let:8 a10 = H in
    let:8 a11 = L in
    let:8 a12 = M[(a10,a11)] in
    advance (7)
    #0954
    #instruction: PUSH PSW
    let:8 a13 = a12 in
    let:8 a14 = SPH in
    let:8 a15 = SPL in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a13;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a4[7:0][7]),6,is_zero(a4[7:0])),4,a7[7:0][4]),2,parity(a4[7:0])),0,FlagCY);
    advance (11)
    #0955
    #instruction: LD   HL,2501
    advance (10)
    A := a12;
    H := 25;
    L := 01;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    jump (0958);

0958:

    #0958
    #instruction: INC  H
    let:8 a1 = H in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    #0959
    #instruction: INC  H
    let:8 a6 = a2[7:0] in
    let:16 a7 = addWithCarry(true,a6,00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (00 & 0F) in
    let:16 a10 = addWithCarry(true,a8,a9) in
    advance (5)
    #095A
    #instruction: DEC  A
    let:8 a11 = A in
    let:16 a12 = addWithCarry(!true,a11,~00) in
    let:8 a13 = (a11 & 0F) in
    let:8 a14 = (~00 & 0F) in
    let:16 a15 = addWithCarry(!true,a13,a14) in
    advance (5)
    #095B
    #instruction: JP   NZ,0958
    if (!is_zero(a12[7:0])) {
      advance (10)
      A := a12[7:0];
      H := a7[7:0];
      FlagS := a12[7:0][7];
      FlagZ := is_zero(a12[7:0]);
      FlagA := a15[7:0][4];
      FlagP := parity(a12[7:0]);
      jump (0958);
    } else {
      advance (10)
      #095E
      #instruction: LD   B,10
      advance (7)
      #0960
      #instruction: LD   DE,1C60
      advance (10)
      #0963
      #instruction: CALL 1439
      let:8 a16 = SPH in
      let:8 a17 = SPL in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := 09;
      let:8 a19 = a18[15:8] in
      let:8 a20 = a18[7:0] in
      let:16 a21 = (-1 + (a19,a20)) in
      M[a21] := 66;
      #return-to: 0966
      advance (17)
      A := a12[7:0];
      B := 10;
      D := 1C;
      E := 60;
      H := a7[7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a12[7:0][7];
      FlagZ := is_zero(a12[7:0]);
      FlagA := a15[7:0][4];
      FlagP := parity(a12[7:0]);
      jump (1439);
    }

0966:

    #0966
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0967
    #instruction: INC  A
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(true,a9,00) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (00 & 0F) in
    let:16 a13 = addWithCarry(true,a11,a12) in
    advance (5)
    #0968
    #instruction: CALL 1A8B
    let:8 a14 = a7[15:8] in
    let:8 a15 = a7[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := 09;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 6B;
    #return-to: 096B
    advance (17)
    A := a10[7:0];
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a10[7:0][7];
    FlagZ := is_zero(a10[7:0]);
    FlagA := a13[7:0][4];
    FlagP := parity(a10[7:0]);
    FlagCY := a4[0];
    jump (1A8B);

096B:

    #096B
    #instruction: CALL 1910
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 09;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 6E;
    #return-to: 096E
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1910);

096E:

    #096E
    #instruction: DEC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    #096F
    #instruction: DEC  HL
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    advance (5)
    #0970
    #instruction: LD   (HL),00
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    M[(a7,a8)] := 00;
    advance (10)
    #0972
    #instruction: LD   A,FF
    advance (7)
    #0974
    #instruction: LD   (2099),A
    M[2099] := FF;
    advance (13)
    #0977
    #instruction: LD   B,10
    advance (7)
    #0979
    #instruction: JP   18FA
    advance (10)
    A := FF;
    B := 10;
    H := a6[15:8];
    L := a6[7:0];
    jump (18FA);

098B:

    #098B
    #instruction: LD   A,(20F1)
    let:8 a1 = M[20F1] in
    advance (13)
    #098E
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #098F
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #0990
      #instruction: XOR  A
      let:8 a14 = a4 in
      let:8 a15 = a4 in
      let:8 a16 = (a14 ^ a15) in
      advance (4)
      #0991
      #instruction: LD   (20F1),A
      let:8 a17 = a16 in
      M[20F1] := a17;
      advance (13)
      #0994
      #instruction: PUSH HL
      let:8 a18 = H in
      let:8 a19 = L in
      let:8 a20 = SPH in
      let:8 a21 = SPL in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := a18;
      let:8 a23 = a22[15:8] in
      let:8 a24 = a22[7:0] in
      let:16 a25 = (-1 + (a23,a24)) in
      M[a25] := a19;
      advance (11)
      #0995
      #instruction: LD   HL,(20F2)
      let:8 a26 = M[20F2] in
      let:8 a27 = M[20F3] in
      advance (16)
      #0998
      #instruction: EX   DE,HL
      let:8 a28 = D in
      let:8 a29 = E in
      let:8 a30 = a27 in
      let:8 a31 = a26 in
      advance (4)
      #0999
      #instruction: POP  HL
      let:8 a32 = a25[15:8] in
      let:8 a33 = a25[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      #099A
      #instruction: LD   A,(HL)
      let:8 a40 = a39 in
      let:8 a41 = a35 in
      let:8 a42 = M[(a40,a41)] in
      advance (7)
      #099B
      #instruction: ADD  E
      let:8 a43 = a31 in
      let:8 a44 = a42 in
      let:16 a45 = addWithCarry(false,a43,a44) in
      let:8 a46 = (a43 & 0F) in
      let:8 a47 = (a44 & 0F) in
      let:16 a48 = addWithCarry(false,a46,a47) in
      advance (4)
      #099C
      #instruction: DAA
      let:8 a49 = a45[7:0] in
      let:8 a50 = (a49 & 0F) in
      let:16 a51 = addWithCarry(false,a50,06) in
      let:16 a52 = addWithCarry(((((a50[1] || a50[2]) && a50[3]) || a48[7:0][4]) ? a51[7:0] : a50)[4],(a49 >> 04),00) in
      let:16 a53 = addWithCarry(false,a52[7:0],06) in
      let:8 a54 = (((((a50[1] || a50[2]) && a50[3]) || a48[7:0][4]) ? a51[7:0] : a50) & 0F) in
      let:8 a55 = ((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0]) << 04) | a54) in
      advance (4)
      #099D
      #instruction: LD   (HL),A
      let:8 a56 = a55 in
      let:8 a57 = a39 in
      let:8 a58 = a35 in
      M[(a57,a58)] := a56;
      advance (7)
      #099E
      #instruction: LD   E,A
      let:8 a59 = a55 in
      advance (5)
      #099F
      #instruction: INC  HL
      let:8 a60 = a39 in
      let:8 a61 = a35 in
      let:16 a62 = (1 + (a60,a61)) in
      advance (5)
      #09A0
      #instruction: LD   A,(HL)
      let:8 a63 = a62[15:8] in
      let:8 a64 = a62[7:0] in
      let:8 a65 = M[(a63,a64)] in
      advance (7)
      #09A1
      #instruction: ADC  D
      let:8 a66 = a30 in
      let:8 a67 = a65 in
      let:16 a68 = addWithCarry((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0])[4] || a45[15:8][0]),a66,a67) in
      let:8 a69 = (a66 & 0F) in
      let:8 a70 = (a67 & 0F) in
      let:16 a71 = addWithCarry((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0])[4] || a45[15:8][0]),a69,a70) in
      advance (4)
      #09A2
      #instruction: DAA
      let:8 a72 = a68[7:0] in
      let:8 a73 = (a72 & 0F) in
      let:16 a74 = addWithCarry(false,a73,06) in
      let:16 a75 = addWithCarry(((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73)[4],(a72 >> 04),00) in
      let:16 a76 = addWithCarry(false,a75[7:0],06) in
      let:8 a77 = (((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73) & 0F) in
      let:8 a78 = ((((((a75[7:0][1] || a75[7:0][2]) && a75[7:0][3]) || a68[15:8][0]) ? a76[7:0] : a75[7:0]) << 04) | a77) in
      advance (4)
      #09A3
      #instruction: LD   (HL),A
      let:8 a79 = a78 in
      let:8 a80 = a62[15:8] in
      let:8 a81 = a62[7:0] in
      M[(a80,a81)] := a79;
      advance (7)
      #09A4
      #instruction: LD   D,A
      let:8 a82 = a78 in
      advance (5)
      #09A5
      #instruction: INC  HL
      let:8 a83 = a62[15:8] in
      let:8 a84 = a62[7:0] in
      let:16 a85 = (1 + (a83,a84)) in
      advance (5)
      #09A6
      #instruction: LD   A,(HL)
      let:8 a86 = a85[15:8] in
      let:8 a87 = a85[7:0] in
      let:8 a88 = M[(a86,a87)] in
      advance (7)
      #09A7
      #instruction: INC  HL
      let:8 a89 = a85[15:8] in
      let:8 a90 = a85[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      advance (5)
      #09A8
      #instruction: LD   H,(HL)
      let:8 a92 = a91[15:8] in
      let:8 a93 = a91[7:0] in
      let:8 a94 = M[(a92,a93)] in
      advance (7)
      #09A9
      #instruction: LD   L,A
      let:8 a95 = a88 in
      advance (5)
      #09AA
      #instruction: JP   09AD
      advance (10)
      A := a88;
      D := a82;
      E := a59;
      H := a94;
      L := a95;
      SPH := a38[15:8];
      SPL := a38[7:0];
      FlagS := a78[7];
      FlagZ := is_zero(a78);
      FlagA := ((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73)[4];
      FlagP := parity(a78);
      FlagCY := (((((a75[7:0][1] || a75[7:0][2]) && a75[7:0][3]) || a68[15:8][0]) ? a76[7:0] : a75[7:0])[4] || a68[15:8][0]);
      jump (09AD);
    }

09AD:

    #09AD
    #instruction: LD   A,D
    let:8 a1 = D in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 09;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := B1;
    #return-to: 09B1
    advance (17)
    A := a1;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (09B2);

09B1:

    #09B1
    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    A := a1;
    jump (09B2);

09B2:

    #09B2
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a9 = A in
    let:8 a10 = a8[15:8] in
    let:8 a11 = a8[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a9;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a16 = A in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a17 = updateBit((a16 >> 01),7,a16[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a18 = updateBit((a17 >> 01),7,a17[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a19 = updateBit((a18 >> 01),7,a18[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a20 = updateBit((a19 >> 01),7,a19[0]) in
    let:8 a21 = (0F & a20) in
    let:8 a22 = (0F | a20) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a23 = a15[15:8] in
    let:8 a24 = a15[7:0] in
    let:16 a25 = (-1 + (a23,a24)) in
    M[a25] := 09;
    let:8 a26 = a25[15:8] in
    let:8 a27 = a25[7:0] in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := BD;
    #return-to: 09BD
    advance (17)
    A := a21;
    SPH := a28[15:8];
    SPL := a28[7:0];
    FlagS := a21[7];
    FlagZ := is_zero(a21);
    FlagA := a22[3];
    FlagP := parity(a21);
    FlagCY := false;
    jump (09C5);

09BD:

    #09BD
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #09BE
    #instruction: AND  0F
    let:8 a9 = a8 in
    let:8 a10 = (0F & a9) in
    let:8 a11 = (0F | a9) in
    advance (7)
    #09C0
    #instruction: CALL 09C5
    let:8 a12 = a7[15:8] in
    let:8 a13 = a7[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 09;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := C3;
    #return-to: 09C3
    advance (17)
    A := a10;
    SPH := a17[15:8];
    SPL := a17[7:0];
    FlagS := a10[7];
    FlagZ := is_zero(a10);
    FlagA := a11[3];
    FlagP := parity(a10);
    FlagCY := false;
    jump (09C5);

09C3:

    #09C3
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #09C4
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    D := a8;
    E := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

09C5:

    #09C5
    #instruction: ADD  1A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,1A,a1) in
    let:8 a3 = (1A & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (08FF);

09CA:

    #09CA
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #09CD
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    #09D1
    #instruction: RET  CY
    if (a2[0]) {
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (1 + (a3,a4)) in
      let:8 a6 = M[(a3,a4)] in
      let:8 a7 = a5[15:8] in
      let:8 a8 = a5[7:0] in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      advance (11)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := F8;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagCY := a2[0];
      jump ((a10,a6));
    } else {
      advance (5)
      #09D2
      #instruction: LD   HL,20FC
      advance (10)
      #09D5
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := FC;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagCY := a2[0];
      jump ((a18,a14));
    }

09D6:

    #09D6
    #instruction: LD   HL,2402
    advance (10)
    H := 24;
    L := 02;
    jump (09D9);

09D9:

    #09D9
    #instruction: LD   (HL),00
    let:8 a1 = H in
    let:8 a2 = L in
    M[(a1,a2)] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    let:8 a3 = H in
    let:8 a4 = L in
    let:16 a5 = (1 + (a3,a4)) in
    advance (5)
    #09DC
    #instruction: LD   A,L
    let:8 a6 = a5[7:0] in
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = a6 in
    let:8 a8 = (1F & a7) in
    let:8 a9 = (1F | a7) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a10 = a8 in
    let:16 a11 = addWithCarry(!false,a10,~1C) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~1C & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a11[15:8][0]) {
      advance (10)
      A := a8;
      H := a5[15:8];
      L := a5[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := !a11[15:8][0];
      jump (09E8);
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:8 a15 = a5[15:8] in
      let:8 a16 = a5[7:0] in
      let:17 a17 = add17(0006,(a15,a16)) in
      advance (10)
      A := a8;
      D := 00;
      E := 06;
      H := a17[15:0][15:8];
      L := a17[15:0][7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := a17[16];
      jump (09E8);
    }

09E8:

    #09E8
    #instruction: LD   A,H
    let:8 a1 = H in
    advance (5)
    #09E9
    #instruction: CP   40
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~40) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~40 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #09EB
    #instruction: JP   CY,09D9
    if (!a3[15:8][0]) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (09D9);
    } else {
      advance (10)
      #09EE
      #instruction: RET
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (10)
      A := a1;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    }

09F2:

    #09F2
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #09F3
    #instruction: LD   (20E9),A
    let:8 a4 = a3 in
    M[20E9] := a4;
    advance (13)
    #09F6
    #instruction: CALL 09D6
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 09;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := F9;
    #return-to: 09F9
    advance (17)
    A := a3;
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (09D6);

09F9:

    #09F9
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #09FC
    #instruction: PUSH PSW
    let:8 a2 = a1 in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a2;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09FD
    #instruction: CALL 01E4
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := 0A;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 00;
    #return-to: 0A00
    advance (17)
    A := a1;
    SPH := a14[15:8];
    SPL := a14[7:0];
    jump (01E4);

0A00:

    #0A00
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0A01
    #instruction: LD   (2067),A
    let:8 a9 = a8 in
    M[2067] := a9;
    advance (13)
    #0A04
    #instruction: LD   A,(2067)
    let:8 a10 = M[2067] in
    advance (13)
    #0A07
    #instruction: LD   H,A
    let:8 a11 = a10 in
    advance (5)
    #0A08
    #instruction: PUSH HL
    let:8 a12 = a11 in
    let:8 a13 = L in
    let:8 a14 = a7[15:8] in
    let:8 a15 = a7[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #0A09
    #instruction: LD   L,FE
    advance (7)
    #0A0B
    #instruction: LD   A,(HL)
    let:8 a20 = a11 in
    let:8 a21 = M[(a20,FE)] in
    advance (7)
    #0A0C
    #instruction: AND  07
    let:8 a22 = a21 in
    let:8 a23 = (07 & a22) in
    let:8 a24 = (07 | a22) in
    advance (7)
    #0A0E
    #instruction: INC  A
    let:8 a25 = a23 in
    let:16 a26 = addWithCarry(true,a25,00) in
    let:8 a27 = (a25 & 0F) in
    let:8 a28 = (00 & 0F) in
    let:16 a29 = addWithCarry(true,a27,a28) in
    advance (5)
    #0A0F
    #instruction: LD   (HL),A
    let:8 a30 = a26[7:0] in
    let:8 a31 = a11 in
    M[(a31,FE)] := a30;
    advance (7)
    #0A10
    #instruction: LD   HL,1DA2
    advance (10)
    A := a26[7:0];
    H := 1D;
    L := A2;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a26[7:0][7];
    FlagZ := is_zero(a26[7:0]);
    FlagA := a29[7:0][4];
    FlagP := parity(a26[7:0]);
    FlagCY := false;
    jump (0A13);

0A13:

    #0A13
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #0A14
    #instruction: DEC  A
    let:8 a4 = A in
    let:16 a5 = addWithCarry(!true,a4,~00) in
    let:8 a6 = (a4 & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #0A15
    #instruction: JP   NZ,0A13
    if (!is_zero(a5[7:0])) {
      advance (10)
      A := a5[7:0];
      H := a3[15:8];
      L := a3[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump (0A13);
    } else {
      advance (10)
      #0A18
      #instruction: LD   A,(HL)
      let:8 a9 = a3[15:8] in
      let:8 a10 = a3[7:0] in
      let:8 a11 = M[(a9,a10)] in
      advance (7)
      #0A19
      #instruction: POP  HL
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      #0A1A
      #instruction: LD   L,FC
      advance (7)
      #0A1C
      #instruction: LD   (HL),A
      let:8 a20 = a11 in
      let:8 a21 = a19 in
      M[(a21,FC)] := a20;
      advance (7)
      #0A1D
      #instruction: INC  HL
      let:8 a22 = a19 in
      let:16 a23 = (1 + (a22,FC)) in
      advance (5)
      #0A1E
      #instruction: LD   (HL),38
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      M[(a24,a25)] := 38;
      advance (10)
      #0A20
      #instruction: LD   A,H
      let:8 a26 = a23[15:8] in
      advance (5)
      #0A21
      #instruction: RRCA
      let:8 a27 = a26 in
      advance (4)
      #0A22
      #instruction: JP   CY,0A33
      if (a27[0]) {
        advance (10)
        #0A33
        #instruction: CALL 01EF
        let:8 a28 = a18[15:8] in
        let:8 a29 = a18[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 0A;
        let:8 a31 = a30[15:8] in
        let:8 a32 = a30[7:0] in
        let:16 a33 = (-1 + (a31,a32)) in
        M[a33] := 36;
        #return-to: 0A36
        advance (17)
        A := updateBit((a27 >> 01),7,a27[0]);
        H := a23[15:8];
        L := a23[7:0];
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := a27[0];
        jump (01EF);
      } else {
        advance (10)
        #0A25
        #instruction: LD   A,21
        advance (7)
        #0A27
        #instruction: LD   (2098),A
        M[2098] := 21;
        advance (13)
        #0A2A
        #instruction: CALL 01F5
        let:8 a34 = a18[15:8] in
        let:8 a35 = a18[7:0] in
        let:16 a36 = (-1 + (a34,a35)) in
        M[a36] := 0A;
        let:8 a37 = a36[15:8] in
        let:8 a38 = a36[7:0] in
        let:16 a39 = (-1 + (a37,a38)) in
        M[a39] := 2D;
        #return-to: 0A2D
        advance (17)
        A := 21;
        H := a23[15:8];
        L := a23[7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := a27[0];
        jump (01F5);
      }
    }

0A2D:

    #0A2D
    #instruction: CALL 1904
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 30;
    #return-to: 0A30
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1904);

0A30:

    #0A30
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A36:

    #0A36
    #instruction: CALL 01C0
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 39;
    #return-to: 0A39
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01C0);

0A39:

    #0A39
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A3F:

    #0A3F
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      #0A42
      #instruction: LD   A,30
      advance (7)
      #0A44
      #instruction: LD   (20C0),A
      M[20C0] := 30;
      advance (13)
      A := 30;
      jump (0A47);
    }

0A47:

    #0A47
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #0A4A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0A4B
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #0A4C
      #instruction: CALL 0A59
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 0A;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := 4F;
      #return-to: 0A4F
      advance (17)
      A := a4;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0A59);
    }

0A4F:

    #0A4F
    #instruction: JP   Z,0A47
    if (FlagZ) {
      advance (10)
      jump (0A47);
    } else {
      advance (10)
      jump (0A52);
    }

0A52:

    #0A52
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 55;
    #return-to: 0A55
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A59);

0A55:

    #0A55
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      #0A58
      #instruction: RET
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (10)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    }

0A59:

    #0A59
    #instruction: LD   A,(2015)
    let:8 a1 = M[2015] in
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~FF) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0A5E
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a1;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump ((a14,a10));

0A6C:

    #0A6C
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    #0A6D
    #instruction: LD   A,B
    let:8 a2 = a1 in
    advance (5)
    #0A6E
    #instruction: CALL 097C
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 0A;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 71;
    #return-to: 0A71
    advance (17)
    #097C
    #instruction: LD   HL,1DA0
    advance (10)
    #097F
    #instruction: CP   02
    let:8 a9 = a2 in
    let:16 a10 = addWithCarry(!false,a9,~02) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~02 & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #0981
    #instruction: RET  CY
    if (!a10[15:8][0]) {
      let:8 a14 = a8[15:8] in
      let:8 a15 = a8[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a2;
      B := a1;
      H := 1D;
      L := A0;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      FlagCY := !a10[15:8][0];
      jump ((a21,a17));
    } else {
      advance (5)
      #0982
      #instruction: INC  HL
      advance (5)
      #0983
      #instruction: CP   04
      let:8 a22 = a2 in
      let:16 a23 = addWithCarry(!false,a22,~04) in
      let:8 a24 = (a22 & 0F) in
      let:8 a25 = (~04 & 0F) in
      let:16 a26 = addWithCarry(!false,a24,a25) in
      advance (7)
      #0985
      #instruction: RET  CY
      if (!a23[15:8][0]) {
        let:8 a27 = a8[15:8] in
        let:8 a28 = a8[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        advance (11)
        A := a2;
        B := a1;
        H := 1D;
        L := A1;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := !a23[15:8][0];
        jump ((a34,a30));
      } else {
        advance (5)
        #0986
        #instruction: INC  HL
        advance (5)
        #0987
        #instruction: RET
        let:8 a35 = a8[15:8] in
        let:8 a36 = a8[7:0] in
        let:16 a37 = (1 + (a35,a36)) in
        let:8 a38 = M[(a35,a36)] in
        let:8 a39 = a37[15:8] in
        let:8 a40 = a37[7:0] in
        let:16 a41 = (1 + (a39,a40)) in
        let:8 a42 = M[(a39,a40)] in
        advance (10)
        A := a2;
        B := a1;
        H := 1D;
        L := A2;
        SPH := a41[15:8];
        SPL := a41[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := !a23[15:8][0];
        jump ((a42,a38));
      }
    }

0A71:

    #0A71
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #0A72
    #instruction: LD   HL,20F3
    advance (10)
    #0A75
    #instruction: LD   (HL),00
    M[20F3] := 00;
    advance (10)
    #0A77
    #instruction: DEC  HL
    advance (5)
    #0A78
    #instruction: LD   (HL),A
    let:8 a4 = a3 in
    M[20F2] := a4;
    advance (7)
    #0A79
    #instruction: DEC  HL
    advance (5)
    #0A7A
    #instruction: LD   (HL),01
    M[20F1] := 01;
    advance (10)
    A := a3;
    H := 20;
    L := F1;
    jump (0A7C);

0A7C:

    #0A7C
    #instruction: LD   HL,2062
    advance (10)
    #0A7F
    #instruction: RET
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    H := 20;
    L := 62;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump ((a8,a4));

0A80:

    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    A := 02;
    jump (0A85);

0A85:

    #0A85
    #instruction: OUT  06
    let:8 a1 = A in
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    let:8 a2 = M[20CB] in
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a3 = a2 in
    let:8 a4 = a2 in
    let:8 a5 = (a3 & a4) in
    let:8 a6 = (a3 | a4) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a5)) {
      advance (10)
      A := a5;
      FlagS := a5[7];
      FlagZ := is_zero(a5);
      FlagA := a6[3];
      FlagP := parity(a5);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a7 = a5 in
      let:8 a8 = a5 in
      let:8 a9 = (a7 ^ a8) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      let:8 a10 = a9 in
      M[20C1] := a10;
      advance (13)
      #0A92
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a9;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := false;
      FlagP := parity(a9);
      FlagCY := false;
      jump ((a18,a14));
    }

0A93:

    #0A93
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    let:8 a9 = D in
    let:8 a10 = E in
    let:8 a11 = M[(a9,a10)] in
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a12 = a8[15:8] in
    let:8 a13 = a8[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 0A;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := 98;
    #return-to: 0A98
    advance (17)
    A := a11;
    SPH := a17[15:8];
    SPL := a17[7:0];
    jump (08FF);

0A98:

    #0A98
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0A99
    #instruction: LD   A,07
    advance (7)
    #0A9B
    #instruction: LD   (20C0),A
    M[20C0] := 07;
    advance (13)
    A := 07;
    D := a8;
    E := a4;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (0A9E);

0A9E:

    #0A9E
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #0AA1
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0AA2
    #instruction: JP   NZ,0A9E
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a3[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (0A9E);
    } else {
      advance (10)
      #0AA5
      #instruction: INC  DE
      let:8 a7 = D in
      let:8 a8 = E in
      let:16 a9 = (1 + (a7,a8)) in
      advance (5)
      #0AA6
      #instruction: DEC  C
      let:8 a10 = C in
      let:16 a11 = addWithCarry(!true,a10,~00) in
      let:8 a12 = (a10 & 0F) in
      let:8 a13 = (~00 & 0F) in
      let:16 a14 = addWithCarry(!true,a12,a13) in
      advance (5)
      #0AA7
      #instruction: JP   NZ,0A93
      if (!is_zero(a11[7:0])) {
        advance (10)
        A := a3[7:0];
        C := a11[7:0];
        D := a9[15:8];
        E := a9[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        jump (0A93);
      } else {
        advance (10)
        #0AAA
        #instruction: RET
        let:8 a15 = SPH in
        let:8 a16 = SPL in
        let:16 a17 = (1 + (a15,a16)) in
        let:8 a18 = M[(a15,a16)] in
        let:8 a19 = a17[15:8] in
        let:8 a20 = a17[7:0] in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        advance (10)
        A := a3[7:0];
        C := a11[7:0];
        D := a9[15:8];
        E := a9[7:0];
        SPH := a21[15:8];
        SPL := a21[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        jump ((a22,a18));
      }
    }

0AB1:

    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    A := 40;
    jump (0AD7);

0AB6:

    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    A := 80;
    jump (0AD7);

0AD7:

    #0AD7
    #instruction: LD   (20C0),A
    let:8 a1 = A in
    M[20C0] := a1;
    advance (13)
    jump (0ADA);

0ADA:

    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (10)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    }

0AE2:

    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    #0AE5
    #instruction: LD   B,0C
    advance (7)
    #0AE7
    #instruction: JP   1A32
    advance (10)
    B := 0C;
    H := 20;
    L := C2;
    jump (1A32);

0AF2:

    #0AF2
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0AF3
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 0AF6
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

0AF6:

    #0AF6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0AF9
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0AFA
    #instruction: LD   HL,3017
    advance (10)
    #0AFD
    #instruction: LD   C,04
    advance (7)
    #0AFF
    #instruction: JP   NZ,0BE8
    if (!is_zero(a4)) {
      advance (10)
      #0BE8
      #instruction: LD   DE,1DAB
      advance (10)
      #0BEB
      #instruction: CALL 0A93
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := EE;
      #return-to: 0BEE
      advance (17)
      A := a4;
      C := 04;
      D := 1D;
      E := AB;
      H := 30;
      L := 17;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0A93);
    } else {
      advance (10)
      #0B02
      #instruction: LD   DE,1CFA
      advance (10)
      #0B05
      #instruction: CALL 0A93
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 0B;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 08;
      #return-to: 0B08
      advance (17)
      A := a4;
      C := 04;
      D := 1C;
      E := FA;
      H := 30;
      L := 17;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0A93);
    }

0B08:

    #0B08
    #instruction: LD   DE,1DAF
    advance (10)
    D := 1D;
    E := AF;
    jump (0B0B);

0B0B:

    #0B0B
    #instruction: CALL 0ACF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0E;
    #return-to: 0B0E
    advance (17)
    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    #0AD2
    #instruction: LD   C,0F
    advance (7)
    #0AD4
    #instruction: JP   0A93
    advance (10)
    C := 0F;
    H := 2B;
    L := 14;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A93);

0B0E:

    #0B0E
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 11;
    #return-to: 0B11
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

0B11:

    #0B11
    #instruction: CALL 1815
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 14;
    #return-to: 0B14
    advance (17)
    #1815
    #instruction: LD   HL,2810
    advance (10)
    #1818
    #instruction: LD   DE,1CA3
    advance (10)
    #181B
    #instruction: LD   C,15
    advance (7)
    #181D
    #instruction: CALL 08F3
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 18;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 20;
    #return-to: 1820
    advance (17)
    C := 15;
    D := 1C;
    E := A3;
    H := 28;
    L := 10;
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (08F3);

0B14:

    #0B14
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    #return-to: 0B17
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB6);

0B17:

    #0B17
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0B1A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0B1B
    #instruction: JP   NZ,0B4A
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0B4A);
    } else {
      advance (10)
      #0B1E
      #instruction: LD   DE,1A95
      advance (10)
      #0B21
      #instruction: CALL 0AE2
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 24;
      #return-to: 0B24
      advance (17)
      A := a4;
      D := 1A;
      E := 95;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0AE2);
    }

0B24:

    #0B24
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 27;
    #return-to: 0B27
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A80);

0B27:

    #0B27
    #instruction: LD   DE,1BB0
    advance (10)
    #0B2A
    #instruction: CALL 0AE2
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2D;
    #return-to: 0B2D
    advance (17)
    D := 1B;
    E := B0;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AE2);

0B2D:

    #0B2D
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 30;
    #return-to: 0B30
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A80);

0B30:

    #0B30
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 33;
    #return-to: 0B33
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

0B33:

    #0B33
    #instruction: LD   DE,1FC9
    advance (10)
    #0B36
    #instruction: CALL 0AE2
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 39;
    #return-to: 0B39
    advance (17)
    D := 1F;
    E := C9;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AE2);

0B39:

    #0B39
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3C;
    #return-to: 0B3C
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A80);

0B3C:

    #0B3C
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3F;
    #return-to: 0B3F
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

0B3F:

    #0B3F
    #instruction: LD   HL,33B7
    advance (10)
    #0B42
    #instruction: LD   B,0A
    advance (7)
    #0B44
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 47;
    #return-to: 0B47
    advance (17)
    B := 0A;
    H := 33;
    L := B7;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14CB);

0B47:

    #0B47
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4A;
    #return-to: 0B4A
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB6);

0B4A:

    #0B4A
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4D;
    #return-to: 0B4D
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

0B4D:

    #0B4D
    #instruction: LD   A,(21FF)
    let:8 a1 = M[21FF] in
    advance (13)
    #0B50
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0B51
    #instruction: JP   NZ,0B5D
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0B5D);
    } else {
      advance (10)
      #0B54
      #instruction: CALL 08D1
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 57;
      #return-to: 0B57
      advance (17)
      A := a4;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (08D1);
    }

0B57:

    #0B57
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    #0B5A
    #instruction: CALL 1A7F
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 0B;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 5D;
    #return-to: 0B5D
    advance (17)
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (1A7F);

0B5D:

    #0B5D
    #instruction: CALL 01E4
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 60;
    #return-to: 0B60
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01E4);

0B60:

    #0B60
    #instruction: CALL 01C0
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 63;
    #return-to: 0B63
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01C0);

0B63:

    #0B63
    #instruction: CALL 01EF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 66;
    #return-to: 0B66
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01EF);

0B66:

    #0B66
    #instruction: CALL 021A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 69;
    #return-to: 0B69
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (021A);

0B69:

    #0B69
    #instruction: LD   A,01
    advance (7)
    #0B6B
    #instruction: LD   (20C1),A
    M[20C1] := 01;
    advance (13)
    #0B6E
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 71;
    #return-to: 0B71
    advance (17)
    A := 01;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (01CF);

0B71:

    #0B71
    #instruction: CALL 1618
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 0B74
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1618);

0B74:

    #0B74
    #instruction: CALL 0BF1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 77;
    #return-to: 0B77
    advance (17)
    #0BF1
    #instruction: CALL 190A
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 0B;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F4;
    #return-to: 0BF4
    advance (17)
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (190A);

0B77:

    #0B77
    #instruction: OUT  06
    let:8 a1 = A in
    advance (10)
    #0B79
    #instruction: CALL 0A59
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 0B;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 7C;
    #return-to: 0B7C
    advance (17)
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (0A59);

0B7C:

    #0B7C
    #instruction: JP   Z,0B71
    if (FlagZ) {
      advance (10)
      jump (0B71);
    } else {
      advance (10)
      #0B7F
      #instruction: XOR  A
      let:8 a1 = A in
      let:8 a2 = A in
      let:8 a3 = (a1 ^ a2) in
      advance (4)
      #0B80
      #instruction: LD   (2025),A
      let:8 a4 = a3 in
      M[2025] := a4;
      advance (13)
      A := a3;
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := false;
      FlagP := parity(a3);
      FlagCY := false;
      jump (0B83);
    }

0B83:

    #0B83
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 86;
    #return-to: 0B86
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A59);

0B86:

    #0B86
    #instruction: JP   NZ,0B83
    if (!FlagZ) {
      advance (10)
      jump (0B83);
    } else {
      advance (10)
      jump (0B89);
    }

0B89:

    #0B89
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0B8A
    #instruction: LD   (20C1),A
    let:8 a4 = a3 in
    M[20C1] := a4;
    advance (13)
    #0B8D
    #instruction: CALL 0AB1
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 0B;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 90;
    #return-to: 0B90
    advance (17)
    A := a3;
    SPH := a10[15:8];
    SPL := a10[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0AB1);

0B90:

    #0B90
    #instruction: CALL 1988
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 93;
    #return-to: 0B93
    advance (17)
    #1988
    #instruction: JP   09D6
    advance (10)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

0B93:

    #0B93
    #instruction: LD   C,0C
    advance (7)
    #0B95
    #instruction: LD   HL,2C11
    advance (10)
    #0B98
    #instruction: LD   DE,1F90
    advance (10)
    #0B9B
    #instruction: CALL 08F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 9E;
    #return-to: 0B9E
    advance (17)
    C := 0C;
    D := 1F;
    E := 90;
    H := 2C;
    L := 11;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (08F3);

0B9E:

    #0B9E
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0BA1
    #instruction: CP   00
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0BA3
    #instruction: JP   NZ,0BAE
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0BAE);
    } else {
      advance (10)
      #0BA6
      #instruction: LD   HL,3311
      advance (10)
      #0BA9
      #instruction: LD   A,02
      advance (7)
      #0BAB
      #instruction: CALL 08FF
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 0B;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := AE;
      #return-to: 0BAE
      advance (17)
      A := 02;
      H := 33;
      L := 11;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (08FF);
    }

0BAE:

    #0BAE
    #instruction: LD   BC,1F9C
    advance (10)
    #0BB1
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B4;
    #return-to: 0BB4
    advance (17)
    B := 1F;
    C := 9C;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1856);

0BB4:

    #0BB4
    #instruction: CALL 184C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B7;
    #return-to: 0BB7
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (184C);

0BB7:

    #0BB7
    #instruction: IN   02
    advance (10)
    #0BB9
    #instruction: RLCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    advance (4)
    #0BBA
    #instruction: JP   CY,0BC3
    if (a1[7]) {
      advance (10)
      A := updateBit((a1 << 01),0,a1[7]);
      FlagCY := a1[7];
      jump (0BC3);
    } else {
      advance (10)
      #0BBD
      #instruction: LD   BC,1FA0
      advance (10)
      #0BC0
      #instruction: CALL 183A
      let:8 a2 = SPH in
      let:8 a3 = SPL in
      let:16 a4 = (-1 + (a2,a3)) in
      M[a4] := 0B;
      let:8 a5 = a4[15:8] in
      let:8 a6 = a4[7:0] in
      let:16 a7 = (-1 + (a5,a6)) in
      M[a7] := C3;
      #return-to: 0BC3
      advance (17)
      A := updateBit((a1 << 01),0,a1[7]);
      B := 1F;
      C := A0;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagCY := a1[7];
      jump (183A);
    }

0BC3:

    #0BC3
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C6;
    #return-to: 0BC6
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB6);

0BC6:

    #0BC6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0BC9
    #instruction: CP   00
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0BCB
    #instruction: JP   NZ,0BDA
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0BDA);
    } else {
      advance (10)
      #0BCE
      #instruction: LD   DE,1FD5
      advance (10)
      #0BD1
      #instruction: CALL 0AE2
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 0B;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := D4;
      #return-to: 0BD4
      advance (17)
      A := a1;
      D := 1F;
      E := D5;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0AE2);
    }

0BD4:

    #0BD4
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D7;
    #return-to: 0BD7
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A80);

0BD7:

    #0BD7
    #instruction: CALL 189E
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 0BDA
    advance (17)
    #189E
    #instruction: LD   HL,2050
    advance (10)
    #18A1
    #instruction: LD   DE,1BC0
    advance (10)
    #18A4
    #instruction: LD   B,10
    advance (7)
    #18A6
    #instruction: CALL 1A32
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 18;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := A9;
    #return-to: 18A9
    advance (17)
    B := 10;
    D := 1B;
    E := C0;
    H := 20;
    L := 50;
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump (1A32);

0BDA:

    #0BDA
    #instruction: LD   HL,20EC
    advance (10)
    #0BDD
    #instruction: LD   A,(HL)
    let:8 a1 = M[20EC] in
    advance (7)
    #0BDE
    #instruction: INC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    advance (5)
    #0BDF
    #instruction: AND  01
    let:8 a7 = a3[7:0] in
    let:8 a8 = (01 & a7) in
    let:8 a9 = (01 | a7) in
    advance (7)
    #0BE1
    #instruction: LD   (HL),A
    let:8 a10 = a8 in
    M[20EC] := a10;
    advance (7)
    #0BE2
    #instruction: CALL 09D6
    let:8 a11 = SPH in
    let:8 a12 = SPL in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 0B;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := E5;
    #return-to: 0BE5
    advance (17)
    A := a8;
    H := 20;
    L := EC;
    SPH := a16[15:8];
    SPL := a16[7:0];
    FlagS := a8[7];
    FlagZ := is_zero(a8);
    FlagA := a9[3];
    FlagP := parity(a8);
    FlagCY := false;
    jump (09D6);

0BE5:

    #0BE5
    #instruction: JP   18DF
    advance (10)
    jump (18DF);

0BEE:

    #0BEE
    #instruction: JP   0B0B
    advance (10)
    jump (0B0B);

0BF4:

    #0BF4
    #instruction: JP   199A
    advance (10)
    #199A
    #instruction: LD   A,(201E)
    let:8 a1 = M[201E] in
    advance (13)
    #199D
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #199E
    #instruction: JP   NZ,19AC
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (19AC);
    } else {
      advance (10)
      #19A1
      #instruction: IN   01
      advance (10)
      #19A3
      #instruction: AND  76
      let:8 a6 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
      let:8 a7 = (76 & a6) in
      let:8 a8 = (76 | a6) in
      advance (7)
      #19A5
      #instruction: SUB  72
      let:8 a9 = a7 in
      let:16 a10 = addWithCarry(!false,a9,~72) in
      let:8 a11 = (a9 & 0F) in
      let:8 a12 = (~72 & 0F) in
      let:16 a13 = addWithCarry(!false,a11,a12) in
      advance (7)
      #19A7
      #instruction: RET  NZ
      if (!is_zero(a10[7:0])) {
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (1 + (a14,a15)) in
        let:8 a17 = M[(a14,a15)] in
        let:8 a18 = a16[15:8] in
        let:8 a19 = a16[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        advance (11)
        A := a10[7:0];
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump ((a21,a17));
      } else {
        advance (5)
        #19A8
        #instruction: INC  A
        let:8 a22 = a10[7:0] in
        let:16 a23 = addWithCarry(true,a22,00) in
        let:8 a24 = (a22 & 0F) in
        let:8 a25 = (00 & 0F) in
        let:16 a26 = addWithCarry(true,a24,a25) in
        advance (5)
        #19A9
        #instruction: LD   (201E),A
        let:8 a27 = a23[7:0] in
        M[201E] := a27;
        advance (13)
        A := a23[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := !a10[15:8][0];
        jump (19AC);
      }
    }

1400:

    #1400
    #instruction: NOP
    advance (4)
    #1401
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 04;
    #return-to: 1404
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1474);

1404:

    #1404
    #instruction: NOP
    advance (4)
    jump (1405);

1405:

    #1405
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1406
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1407
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #1408
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #140A
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #140C
    #instruction: OR   (HL)
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = M[(a24,a25)] in
    let:8 a27 = a23 in
    let:8 a28 = (a26 | a27) in
    advance (7)
    #140D
    #instruction: LD   (HL),A
    let:8 a29 = a28 in
    let:8 a30 = H in
    let:8 a31 = L in
    M[(a30,a31)] := a29;
    advance (7)
    #140E
    #instruction: INC  HL
    let:8 a32 = H in
    let:8 a33 = L in
    let:16 a34 = (1 + (a32,a33)) in
    advance (5)
    #140F
    #instruction: INC  DE
    let:8 a35 = D in
    let:8 a36 = E in
    let:16 a37 = (1 + (a35,a36)) in
    advance (5)
    #1410
    #instruction: XOR  A
    let:8 a38 = a28 in
    let:8 a39 = a28 in
    let:8 a40 = (a38 ^ a39) in
    advance (4)
    #1411
    #instruction: OUT  04
    let:8 a41 = a40 in
    advance (10)
    #1413
    #instruction: IN   03
    let:8 a42 = (Shifter_OFF & 07) in
    let:8 a43 = (~Shifter_OFF & 07) in
    let:8 a44 = ((a41 << a42) | ((a20 >> a43) >> 01)) in
    advance (10)
    #1415
    #instruction: OR   (HL)
    let:8 a45 = a34[15:8] in
    let:8 a46 = a34[7:0] in
    let:8 a47 = M[(a45,a46)] in
    let:8 a48 = a44 in
    let:8 a49 = (a47 | a48) in
    advance (7)
    #1416
    #instruction: LD   (HL),A
    let:8 a50 = a49 in
    let:8 a51 = a34[15:8] in
    let:8 a52 = a34[7:0] in
    M[(a51,a52)] := a50;
    advance (7)
    #1417
    #instruction: POP  HL
    let:8 a53 = a16[15:8] in
    let:8 a54 = a16[7:0] in
    let:16 a55 = (1 + (a53,a54)) in
    let:8 a56 = M[(a53,a54)] in
    let:8 a57 = a55[15:8] in
    let:8 a58 = a55[7:0] in
    let:16 a59 = (1 + (a57,a58)) in
    let:8 a60 = M[(a57,a58)] in
    advance (10)
    #1418
    #instruction: LD   BC,0020
    advance (10)
    #141B
    #instruction: ADD  HL,BC
    let:8 a61 = a60 in
    let:8 a62 = a56 in
    let:17 a63 = add17(0020,(a61,a62)) in
    advance (10)
    #141C
    #instruction: POP  BC
    let:8 a64 = a59[15:8] in
    let:8 a65 = a59[7:0] in
    let:16 a66 = (1 + (a64,a65)) in
    let:8 a67 = M[(a64,a65)] in
    let:8 a68 = a66[15:8] in
    let:8 a69 = a66[7:0] in
    let:16 a70 = (1 + (a68,a69)) in
    let:8 a71 = M[(a68,a69)] in
    advance (10)
    #141D
    #instruction: DEC  B
    let:8 a72 = a71 in
    let:16 a73 = addWithCarry(!true,a72,~00) in
    let:8 a74 = (a72 & 0F) in
    let:8 a75 = (~00 & 0F) in
    let:16 a76 = addWithCarry(!true,a74,a75) in
    advance (5)
    #141E
    #instruction: JP   NZ,1405
    if (!is_zero(a73[7:0])) {
      advance (10)
      A := a49;
      B := a73[7:0];
      C := a67;
      D := a37[15:8];
      E := a37[7:0];
      H := a63[15:0][15:8];
      L := a63[15:0][7:0];
      SPH := a70[15:8];
      SPL := a70[7:0];
      FlagS := a73[7:0][7];
      FlagZ := is_zero(a73[7:0]);
      FlagA := a76[7:0][4];
      FlagP := parity(a73[7:0]);
      FlagCY := a63[16];
      Shifter_HI := a41;
      Shifter_LO := a20;
      jump (1405);
    } else {
      advance (10)
      #1421
      #instruction: RET
      let:8 a77 = a70[15:8] in
      let:8 a78 = a70[7:0] in
      let:16 a79 = (1 + (a77,a78)) in
      let:8 a80 = M[(a77,a78)] in
      let:8 a81 = a79[15:8] in
      let:8 a82 = a79[7:0] in
      let:16 a83 = (1 + (a81,a82)) in
      let:8 a84 = M[(a81,a82)] in
      advance (10)
      A := a49;
      B := a73[7:0];
      C := a67;
      D := a37[15:8];
      E := a37[7:0];
      H := a63[15:0][15:8];
      L := a63[15:0][7:0];
      SPH := a83[15:8];
      SPL := a83[7:0];
      FlagS := a73[7:0][7];
      FlagZ := is_zero(a73[7:0]);
      FlagA := a76[7:0][4];
      FlagP := parity(a73[7:0]);
      FlagCY := a63[16];
      Shifter_HI := a41;
      Shifter_LO := a20;
      jump ((a84,a80));
    }

1424:

    #1424
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 27;
    #return-to: 1427
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1474);

1427:

    #1427
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1428
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1429
    #instruction: XOR  A
    let:8 a17 = A in
    let:8 a18 = A in
    let:8 a19 = (a17 ^ a18) in
    advance (4)
    #142A
    #instruction: LD   (HL),A
    let:8 a20 = a19 in
    let:8 a21 = H in
    let:8 a22 = L in
    M[(a21,a22)] := a20;
    advance (7)
    #142B
    #instruction: INC  HL
    let:8 a23 = H in
    let:8 a24 = L in
    let:16 a25 = (1 + (a23,a24)) in
    advance (5)
    #142C
    #instruction: LD   (HL),A
    let:8 a26 = a19 in
    let:8 a27 = a25[15:8] in
    let:8 a28 = a25[7:0] in
    M[(a27,a28)] := a26;
    advance (7)
    #142D
    #instruction: INC  HL
    let:8 a29 = a25[15:8] in
    let:8 a30 = a25[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    advance (5)
    #142E
    #instruction: POP  HL
    let:8 a32 = a16[15:8] in
    let:8 a33 = a16[7:0] in
    let:16 a34 = (1 + (a32,a33)) in
    let:8 a35 = M[(a32,a33)] in
    let:8 a36 = a34[15:8] in
    let:8 a37 = a34[7:0] in
    let:16 a38 = (1 + (a36,a37)) in
    let:8 a39 = M[(a36,a37)] in
    advance (10)
    #142F
    #instruction: LD   BC,0020
    advance (10)
    #1432
    #instruction: ADD  HL,BC
    let:8 a40 = a39 in
    let:8 a41 = a35 in
    let:17 a42 = add17(0020,(a40,a41)) in
    advance (10)
    #1433
    #instruction: POP  BC
    let:8 a43 = a38[15:8] in
    let:8 a44 = a38[7:0] in
    let:16 a45 = (1 + (a43,a44)) in
    let:8 a46 = M[(a43,a44)] in
    let:8 a47 = a45[15:8] in
    let:8 a48 = a45[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    advance (10)
    #1434
    #instruction: DEC  B
    let:8 a51 = a50 in
    let:16 a52 = addWithCarry(!true,a51,~00) in
    let:8 a53 = (a51 & 0F) in
    let:8 a54 = (~00 & 0F) in
    let:16 a55 = addWithCarry(!true,a53,a54) in
    advance (5)
    #1435
    #instruction: JP   NZ,1427
    if (!is_zero(a52[7:0])) {
      advance (10)
      A := a19;
      B := a52[7:0];
      C := a46;
      H := a42[15:0][15:8];
      L := a42[15:0][7:0];
      SPH := a49[15:8];
      SPL := a49[7:0];
      FlagS := a52[7:0][7];
      FlagZ := is_zero(a52[7:0]);
      FlagA := a55[7:0][4];
      FlagP := parity(a52[7:0]);
      FlagCY := a42[16];
      jump (1427);
    } else {
      advance (10)
      #1438
      #instruction: RET
      let:8 a56 = a49[15:8] in
      let:8 a57 = a49[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      let:8 a60 = a58[15:8] in
      let:8 a61 = a58[7:0] in
      let:16 a62 = (1 + (a60,a61)) in
      let:8 a63 = M[(a60,a61)] in
      advance (10)
      A := a19;
      B := a52[7:0];
      C := a46;
      H := a42[15:0][15:8];
      L := a42[15:0][7:0];
      SPH := a62[15:8];
      SPL := a62[7:0];
      FlagS := a52[7:0][7];
      FlagZ := is_zero(a52[7:0]);
      FlagA := a55[7:0][4];
      FlagP := parity(a52[7:0]);
      FlagCY := a42[16];
      jump ((a63,a59));
    }

1439:

    #1439
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a9 = D in
    let:8 a10 = E in
    let:8 a11 = M[(a9,a10)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a12 = a11 in
    let:8 a13 = H in
    let:8 a14 = L in
    M[(a13,a14)] := a12;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a15 = D in
    let:8 a16 = E in
    let:16 a17 = (1 + (a15,a16)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a18 = H in
    let:8 a19 = L in
    let:17 a20 = add17(0020,(a18,a19)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a21 = a8[15:8] in
    let:8 a22 = a8[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a29 = a28 in
    let:16 a30 = addWithCarry(!true,a29,~00) in
    let:8 a31 = (a29 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a30[7:0])) {
      advance (10)
      A := a11;
      B := a30[7:0];
      C := a24;
      D := a17[15:8];
      E := a17[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      FlagCY := a20[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a34 = a27[15:8] in
      let:8 a35 = a27[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      A := a11;
      B := a30[7:0];
      C := a24;
      D := a17[15:8];
      E := a17[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a40[15:8];
      SPL := a40[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      FlagCY := a20[16];
      jump ((a41,a37));
    }

1452:

    #1452
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 55;
    #return-to: 1455
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1474);

1455:

    #1455
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1456
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1457
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #1458
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #145A
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #145C
    #instruction: CPL
    let:8 a24 = a23 in
    advance (4)
    #145D
    #instruction: AND  (HL)
    let:8 a25 = H in
    let:8 a26 = L in
    let:8 a27 = M[(a25,a26)] in
    let:8 a28 = ~a24 in
    let:8 a29 = (a27 & a28) in
    let:8 a30 = (a27 | a28) in
    advance (7)
    #145E
    #instruction: LD   (HL),A
    let:8 a31 = a29 in
    let:8 a32 = H in
    let:8 a33 = L in
    M[(a32,a33)] := a31;
    advance (7)
    #145F
    #instruction: INC  HL
    let:8 a34 = H in
    let:8 a35 = L in
    let:16 a36 = (1 + (a34,a35)) in
    advance (5)
    #1460
    #instruction: INC  DE
    let:8 a37 = D in
    let:8 a38 = E in
    let:16 a39 = (1 + (a37,a38)) in
    advance (5)
    #1461
    #instruction: XOR  A
    let:8 a40 = a29 in
    let:8 a41 = a29 in
    let:8 a42 = (a40 ^ a41) in
    advance (4)
    #1462
    #instruction: OUT  04
    let:8 a43 = a42 in
    advance (10)
    #1464
    #instruction: IN   03
    let:8 a44 = (Shifter_OFF & 07) in
    let:8 a45 = (~Shifter_OFF & 07) in
    let:8 a46 = ((a43 << a44) | ((a20 >> a45) >> 01)) in
    advance (10)
    #1466
    #instruction: CPL
    let:8 a47 = a46 in
    advance (4)
    #1467
    #instruction: AND  (HL)
    let:8 a48 = a36[15:8] in
    let:8 a49 = a36[7:0] in
    let:8 a50 = M[(a48,a49)] in
    let:8 a51 = ~a47 in
    let:8 a52 = (a50 & a51) in
    let:8 a53 = (a50 | a51) in
    advance (7)
    #1468
    #instruction: LD   (HL),A
    let:8 a54 = a52 in
    let:8 a55 = a36[15:8] in
    let:8 a56 = a36[7:0] in
    M[(a55,a56)] := a54;
    advance (7)
    #1469
    #instruction: POP  HL
    let:8 a57 = a16[15:8] in
    let:8 a58 = a16[7:0] in
    let:16 a59 = (1 + (a57,a58)) in
    let:8 a60 = M[(a57,a58)] in
    let:8 a61 = a59[15:8] in
    let:8 a62 = a59[7:0] in
    let:16 a63 = (1 + (a61,a62)) in
    let:8 a64 = M[(a61,a62)] in
    advance (10)
    #146A
    #instruction: LD   BC,0020
    advance (10)
    #146D
    #instruction: ADD  HL,BC
    let:8 a65 = a64 in
    let:8 a66 = a60 in
    let:17 a67 = add17(0020,(a65,a66)) in
    advance (10)
    #146E
    #instruction: POP  BC
    let:8 a68 = a63[15:8] in
    let:8 a69 = a63[7:0] in
    let:16 a70 = (1 + (a68,a69)) in
    let:8 a71 = M[(a68,a69)] in
    let:8 a72 = a70[15:8] in
    let:8 a73 = a70[7:0] in
    let:16 a74 = (1 + (a72,a73)) in
    let:8 a75 = M[(a72,a73)] in
    advance (10)
    #146F
    #instruction: DEC  B
    let:8 a76 = a75 in
    let:16 a77 = addWithCarry(!true,a76,~00) in
    let:8 a78 = (a76 & 0F) in
    let:8 a79 = (~00 & 0F) in
    let:16 a80 = addWithCarry(!true,a78,a79) in
    advance (5)
    #1470
    #instruction: JP   NZ,1455
    if (!is_zero(a77[7:0])) {
      advance (10)
      A := a52;
      B := a77[7:0];
      C := a71;
      D := a39[15:8];
      E := a39[7:0];
      H := a67[15:0][15:8];
      L := a67[15:0][7:0];
      SPH := a74[15:8];
      SPL := a74[7:0];
      FlagS := a77[7:0][7];
      FlagZ := is_zero(a77[7:0]);
      FlagA := a80[7:0][4];
      FlagP := parity(a77[7:0]);
      FlagCY := a67[16];
      Shifter_HI := a43;
      Shifter_LO := a20;
      jump (1455);
    } else {
      advance (10)
      #1473
      #instruction: RET
      let:8 a81 = a74[15:8] in
      let:8 a82 = a74[7:0] in
      let:16 a83 = (1 + (a81,a82)) in
      let:8 a84 = M[(a81,a82)] in
      let:8 a85 = a83[15:8] in
      let:8 a86 = a83[7:0] in
      let:16 a87 = (1 + (a85,a86)) in
      let:8 a88 = M[(a85,a86)] in
      advance (10)
      A := a52;
      B := a77[7:0];
      C := a71;
      D := a39[15:8];
      E := a39[7:0];
      H := a67[15:0][15:8];
      L := a67[15:0][7:0];
      SPH := a87[15:8];
      SPL := a87[7:0];
      FlagS := a77[7:0][7];
      FlagZ := is_zero(a77[7:0]);
      FlagA := a80[7:0][4];
      FlagP := parity(a77[7:0]);
      FlagCY := a67[16];
      Shifter_HI := a43;
      Shifter_LO := a20;
      jump ((a88,a84));
    }

1474:

    #1474
    #instruction: LD   A,L
    let:8 a1 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a2 = a1 in
    let:8 a3 = (07 & a2) in
    let:8 a4 = (07 | a2) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a5 = a3 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    Shifter_OFF := a5;
    jump (1A47);

147C:

    #147C
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #147D
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    SPH := a16[15:8];
    SPL := a16[7:0];
    jump (147E);

147E:

    #147E
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #147F
    #instruction: LD   (DE),A
    let:8 a4 = D in
    let:8 a5 = E in
    let:8 a6 = a3 in
    M[(a4,a5)] := a6;
    advance (7)
    #1480
    #instruction: INC  DE
    let:8 a7 = D in
    let:8 a8 = E in
    let:16 a9 = (1 + (a7,a8)) in
    advance (5)
    #1481
    #instruction: INC  HL
    let:8 a10 = H in
    let:8 a11 = L in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1482
    #instruction: DEC  C
    let:8 a13 = C in
    let:16 a14 = addWithCarry(!true,a13,~00) in
    let:8 a15 = (a13 & 0F) in
    let:8 a16 = (~00 & 0F) in
    let:16 a17 = addWithCarry(!true,a15,a16) in
    advance (5)
    #1483
    #instruction: JP   NZ,147E
    if (!is_zero(a14[7:0])) {
      advance (10)
      A := a3;
      C := a14[7:0];
      D := a9[15:8];
      E := a9[7:0];
      H := a12[15:8];
      L := a12[7:0];
      FlagS := a14[7:0][7];
      FlagZ := is_zero(a14[7:0]);
      FlagA := a17[7:0][4];
      FlagP := parity(a14[7:0]);
      jump (147E);
    } else {
      advance (10)
      #1486
      #instruction: POP  HL
      let:8 a18 = SPH in
      let:8 a19 = SPL in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      let:8 a22 = a20[15:8] in
      let:8 a23 = a20[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      advance (10)
      #1487
      #instruction: LD   BC,0020
      advance (10)
      #148A
      #instruction: ADD  HL,BC
      let:8 a26 = a25 in
      let:8 a27 = a21 in
      let:17 a28 = add17(0020,(a26,a27)) in
      advance (10)
      #148B
      #instruction: POP  BC
      let:8 a29 = a24[15:8] in
      let:8 a30 = a24[7:0] in
      let:16 a31 = (1 + (a29,a30)) in
      let:8 a32 = M[(a29,a30)] in
      let:8 a33 = a31[15:8] in
      let:8 a34 = a31[7:0] in
      let:16 a35 = (1 + (a33,a34)) in
      let:8 a36 = M[(a33,a34)] in
      advance (10)
      #148C
      #instruction: DEC  B
      let:8 a37 = a36 in
      let:16 a38 = addWithCarry(!true,a37,~00) in
      let:8 a39 = (a37 & 0F) in
      let:8 a40 = (~00 & 0F) in
      let:16 a41 = addWithCarry(!true,a39,a40) in
      advance (5)
      #148D
      #instruction: JP   NZ,147C
      if (!is_zero(a38[7:0])) {
        advance (10)
        A := a3;
        B := a38[7:0];
        C := a32;
        D := a9[15:8];
        E := a9[7:0];
        H := a28[15:0][15:8];
        L := a28[15:0][7:0];
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a38[7:0][7];
        FlagZ := is_zero(a38[7:0]);
        FlagA := a41[7:0][4];
        FlagP := parity(a38[7:0]);
        FlagCY := a28[16];
        jump (147C);
      } else {
        advance (10)
        #1490
        #instruction: RET
        let:8 a42 = a35[15:8] in
        let:8 a43 = a35[7:0] in
        let:16 a44 = (1 + (a42,a43)) in
        let:8 a45 = M[(a42,a43)] in
        let:8 a46 = a44[15:8] in
        let:8 a47 = a44[7:0] in
        let:16 a48 = (1 + (a46,a47)) in
        let:8 a49 = M[(a46,a47)] in
        advance (10)
        A := a3;
        B := a38[7:0];
        C := a32;
        D := a9[15:8];
        E := a9[7:0];
        H := a28[15:0][15:8];
        L := a28[15:0][7:0];
        SPH := a48[15:8];
        SPL := a48[7:0];
        FlagS := a38[7:0][7];
        FlagZ := is_zero(a38[7:0]);
        FlagA := a41[7:0][4];
        FlagP := parity(a38[7:0]);
        FlagCY := a28[16];
        jump ((a49,a45));
      }
    }

1491:

    #1491
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 94;
    #return-to: 1494
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1474);

1494:

    #1494
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #1495
    #instruction: LD   (2061),A
    let:8 a4 = a3 in
    M[2061] := a4;
    advance (13)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1498);

1498:

    #1498
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1499
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #149A
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #149B
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #149D
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #149F
    #instruction: PUSH PSW
    let:8 a24 = a23 in
    let:8 a25 = a16[15:8] in
    let:8 a26 = a16[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := a24;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #14A0
    #instruction: AND  (HL)
    let:8 a31 = H in
    let:8 a32 = L in
    let:8 a33 = M[(a31,a32)] in
    let:8 a34 = a23 in
    let:8 a35 = (a33 & a34) in
    let:8 a36 = (a33 | a34) in
    advance (7)
    #14A1
    #instruction: JP   Z,14A9
    if (is_zero(a35)) {
      advance (10)
      A := a35;
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := a36[3];
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_HI := a20;
      Shifter_LO := Shifter_HI;
      jump (14A9);
    } else {
      advance (10)
      #14A4
      #instruction: LD   A,01
      advance (7)
      #14A6
      #instruction: LD   (2061),A
      M[2061] := 01;
      advance (13)
      A := 01;
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := a36[3];
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_HI := a20;
      Shifter_LO := Shifter_HI;
      jump (14A9);
    }

14A9:

    #14A9
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #14AA
    #instruction: OR   (HL)
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = M[(a9,a10)] in
    let:8 a12 = a8 in
    let:8 a13 = (a11 | a12) in
    advance (7)
    #14AB
    #instruction: LD   (HL),A
    let:8 a14 = a13 in
    let:8 a15 = H in
    let:8 a16 = L in
    M[(a15,a16)] := a14;
    advance (7)
    #14AC
    #instruction: INC  HL
    let:8 a17 = H in
    let:8 a18 = L in
    let:16 a19 = (1 + (a17,a18)) in
    advance (5)
    #14AD
    #instruction: INC  DE
    let:8 a20 = D in
    let:8 a21 = E in
    let:16 a22 = (1 + (a20,a21)) in
    advance (5)
    #14AE
    #instruction: XOR  A
    let:8 a23 = a13 in
    let:8 a24 = a13 in
    let:8 a25 = (a23 ^ a24) in
    advance (4)
    #14AF
    #instruction: OUT  04
    let:8 a26 = a25 in
    advance (10)
    #14B1
    #instruction: IN   03
    let:8 a27 = (Shifter_OFF & 07) in
    let:8 a28 = (~Shifter_OFF & 07) in
    let:8 a29 = ((a26 << a27) | ((Shifter_HI >> a28) >> 01)) in
    advance (10)
    #14B3
    #instruction: PUSH PSW
    let:8 a30 = a29 in
    let:8 a31 = a7[15:8] in
    let:8 a32 = a7[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := a30;
    let:8 a34 = a33[15:8] in
    let:8 a35 = a33[7:0] in
    let:16 a36 = (-1 + (a34,a35)) in
    M[a36] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a25[7]),6,is_zero(a25)),4,false),2,parity(a25)),0,false);
    advance (11)
    #14B4
    #instruction: AND  (HL)
    let:8 a37 = a19[15:8] in
    let:8 a38 = a19[7:0] in
    let:8 a39 = M[(a37,a38)] in
    let:8 a40 = a29 in
    let:8 a41 = (a39 & a40) in
    let:8 a42 = (a39 | a40) in
    advance (7)
    #14B5
    #instruction: JP   Z,14BD
    if (is_zero(a41)) {
      advance (10)
      A := a41;
      D := a22[15:8];
      E := a22[7:0];
      H := a19[15:8];
      L := a19[7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a41[7];
      FlagZ := is_zero(a41);
      FlagA := a42[3];
      FlagP := parity(a41);
      FlagCY := false;
      Shifter_HI := a26;
      Shifter_LO := Shifter_HI;
      jump (14BD);
    } else {
      advance (10)
      #14B8
      #instruction: LD   A,01
      advance (7)
      #14BA
      #instruction: LD   (2061),A
      M[2061] := 01;
      advance (13)
      A := 01;
      D := a22[15:8];
      E := a22[7:0];
      H := a19[15:8];
      L := a19[7:0];
      SPH := a36[15:8];
      SPL := a36[7:0];
      FlagS := a41[7];
      FlagZ := is_zero(a41);
      FlagA := a42[3];
      FlagP := parity(a41);
      FlagCY := false;
      Shifter_HI := a26;
      Shifter_LO := Shifter_HI;
      jump (14BD);
    }

14BD:

    #14BD
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #14BE
    #instruction: OR   (HL)
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = M[(a9,a10)] in
    let:8 a12 = a8 in
    let:8 a13 = (a11 | a12) in
    advance (7)
    #14BF
    #instruction: LD   (HL),A
    let:8 a14 = a13 in
    let:8 a15 = H in
    let:8 a16 = L in
    M[(a15,a16)] := a14;
    advance (7)
    #14C0
    #instruction: POP  HL
    let:8 a17 = a7[15:8] in
    let:8 a18 = a7[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #14C1
    #instruction: LD   BC,0020
    advance (10)
    #14C4
    #instruction: ADD  HL,BC
    let:8 a25 = a24 in
    let:8 a26 = a20 in
    let:17 a27 = add17(0020,(a25,a26)) in
    advance (10)
    #14C5
    #instruction: POP  BC
    let:8 a28 = a23[15:8] in
    let:8 a29 = a23[7:0] in
    let:16 a30 = (1 + (a28,a29)) in
    let:8 a31 = M[(a28,a29)] in
    let:8 a32 = a30[15:8] in
    let:8 a33 = a30[7:0] in
    let:16 a34 = (1 + (a32,a33)) in
    let:8 a35 = M[(a32,a33)] in
    advance (10)
    #14C6
    #instruction: DEC  B
    let:8 a36 = a35 in
    let:16 a37 = addWithCarry(!true,a36,~00) in
    let:8 a38 = (a36 & 0F) in
    let:8 a39 = (~00 & 0F) in
    let:16 a40 = addWithCarry(!true,a38,a39) in
    advance (5)
    #14C7
    #instruction: JP   NZ,1498
    if (!is_zero(a37[7:0])) {
      advance (10)
      A := a13;
      B := a37[7:0];
      C := a31;
      H := a27[15:0][15:8];
      L := a27[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a37[7:0][7];
      FlagZ := is_zero(a37[7:0]);
      FlagA := a40[7:0][4];
      FlagP := parity(a37[7:0]);
      FlagCY := a27[16];
      jump (1498);
    } else {
      advance (10)
      #14CA
      #instruction: RET
      let:8 a41 = a34[15:8] in
      let:8 a42 = a34[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      A := a13;
      B := a37[7:0];
      C := a31;
      H := a27[15:0][15:8];
      L := a27[15:0][7:0];
      SPH := a47[15:8];
      SPL := a47[7:0];
      FlagS := a37[7:0][7];
      FlagZ := is_zero(a37[7:0]);
      FlagA := a40[7:0][4];
      FlagP := parity(a37[7:0]);
      FlagCY := a27[16];
      jump ((a48,a44));
    }

14CB:

    #14CB
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (14CC);

14CC:

    #14CC
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    let:8 a9 = A in
    let:8 a10 = H in
    let:8 a11 = L in
    M[(a10,a11)] := a9;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:8 a12 = H in
    let:8 a13 = L in
    let:17 a14 = add17(0020,(a12,a13)) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a15 = a8[15:8] in
    let:8 a16 = a8[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a23 = a22 in
    let:16 a24 = addWithCarry(!true,a23,~00) in
    let:8 a25 = (a23 & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a24[7:0])) {
      advance (10)
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a28 = a21[15:8] in
      let:8 a29 = a21[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump ((a35,a31));
    }

14D8:

    #14D8
    #instruction: LD   A,(2025)
    let:8 a1 = M[2025] in
    advance (13)
    #14DB
    #instruction: CP   05
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~05) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~05 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #14DD
    #instruction: RET  Z
    if (is_zero(a3[7:0])) {
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (11)
      A := a1;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    } else {
      advance (5)
      #14DE
      #instruction: CP   02
      let:8 a15 = a1 in
      let:16 a16 = addWithCarry(!false,a15,~02) in
      let:8 a17 = (a15 & 0F) in
      let:8 a18 = (~02 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #14E0
      #instruction: RET  NZ
      if (!is_zero(a16[7:0])) {
        let:8 a20 = SPH in
        let:8 a21 = SPL in
        let:16 a22 = (1 + (a20,a21)) in
        let:8 a23 = M[(a20,a21)] in
        let:8 a24 = a22[15:8] in
        let:8 a25 = a22[7:0] in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        advance (11)
        A := a1;
        SPH := a26[15:8];
        SPL := a26[7:0];
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((a27,a23));
      } else {
        advance (5)
        #14E1
        #instruction: LD   A,(2029)
        let:8 a28 = M[2029] in
        advance (13)
        #14E4
        #instruction: CP   D8
        let:8 a29 = a28 in
        let:16 a30 = addWithCarry(!false,a29,~D8) in
        let:8 a31 = (a29 & 0F) in
        let:8 a32 = (~D8 & 0F) in
        let:16 a33 = addWithCarry(!false,a31,a32) in
        advance (7)
        #14E6
        #instruction: LD   B,A
        let:8 a34 = a28 in
        advance (5)
        #14E7
        #instruction: JP   NC,1530
        if (!!a30[15:8][0]) {
          advance (10)
          A := a28;
          B := a34;
          FlagS := a30[7:0][7];
          FlagZ := is_zero(a30[7:0]);
          FlagA := a33[7:0][4];
          FlagP := parity(a30[7:0]);
          FlagCY := !a30[15:8][0];
          jump (1530);
        } else {
          advance (10)
          #14EA
          #instruction: LD   A,(2002)
          let:8 a35 = M[2002] in
          advance (13)
          #14ED
          #instruction: AND  A
          let:8 a36 = a35 in
          let:8 a37 = a35 in
          let:8 a38 = (a36 & a37) in
          let:8 a39 = (a36 | a37) in
          advance (4)
          #14EE
          #instruction: RET  Z
          if (is_zero(a38)) {
            let:8 a40 = SPH in
            let:8 a41 = SPL in
            let:16 a42 = (1 + (a40,a41)) in
            let:8 a43 = M[(a40,a41)] in
            let:8 a44 = a42[15:8] in
            let:8 a45 = a42[7:0] in
            let:16 a46 = (1 + (a44,a45)) in
            let:8 a47 = M[(a44,a45)] in
            advance (11)
            A := a38;
            B := a34;
            SPH := a46[15:8];
            SPL := a46[7:0];
            FlagS := a38[7];
            FlagZ := is_zero(a38);
            FlagA := a39[3];
            FlagP := parity(a38);
            FlagCY := false;
            jump ((a47,a43));
          } else {
            advance (5)
            #14EF
            #instruction: LD   A,B
            let:8 a48 = a34 in
            advance (5)
            #14F0
            #instruction: CP   CE
            let:8 a49 = a48 in
            let:16 a50 = addWithCarry(!false,a49,~CE) in
            let:8 a51 = (a49 & 0F) in
            let:8 a52 = (~CE & 0F) in
            let:16 a53 = addWithCarry(!false,a51,a52) in
            advance (7)
            #14F2
            #instruction: JP   NC,1579
            if (!!a50[15:8][0]) {
              advance (10)
              #1579
              #instruction: LD   A,01
              advance (7)
              #157B
              #instruction: LD   (2085),A
              M[2085] := 01;
              advance (13)
              #157E
              #instruction: JP   1545
              advance (10)
              A := 01;
              B := a34;
              FlagS := a50[7:0][7];
              FlagZ := is_zero(a50[7:0]);
              FlagA := a53[7:0][4];
              FlagP := parity(a50[7:0]);
              FlagCY := !a50[15:8][0];
              jump (1545);
            } else {
              advance (10)
              #14F5
              #instruction: ADD  06
              let:8 a54 = a48 in
              let:16 a55 = addWithCarry(false,06,a54) in
              let:8 a56 = (06 & 0F) in
              let:8 a57 = (a54 & 0F) in
              let:16 a58 = addWithCarry(false,a56,a57) in
              advance (7)
              #14F7
              #instruction: LD   B,A
              let:8 a59 = a55[7:0] in
              advance (5)
              #14F8
              #instruction: LD   A,(2009)
              let:8 a60 = M[2009] in
              advance (13)
              #14FB
              #instruction: CP   90
              let:8 a61 = a60 in
              let:16 a62 = addWithCarry(!false,a61,~90) in
              let:8 a63 = (a61 & 0F) in
              let:8 a64 = (~90 & 0F) in
              let:16 a65 = addWithCarry(!false,a63,a64) in
              advance (7)
              #14FD
              #instruction: JP   NC,1504
              if (!!a62[15:8][0]) {
                advance (10)
                A := a60;
                B := a59;
                FlagS := a62[7:0][7];
                FlagZ := is_zero(a62[7:0]);
                FlagA := a65[7:0][4];
                FlagP := parity(a62[7:0]);
                FlagCY := !a62[15:8][0];
                jump (1504);
              } else {
                advance (10)
                #1500
                #instruction: CP   B
                let:8 a66 = a60 in
                let:8 a67 = a59 in
                let:16 a68 = addWithCarry(!false,a66,~a67) in
                let:8 a69 = (a66 & 0F) in
                let:8 a70 = (~a67 & 0F) in
                let:16 a71 = addWithCarry(!false,a69,a70) in
                advance (4)
                #1501
                #instruction: JP   NC,1530
                if (!!a68[15:8][0]) {
                  advance (10)
                  A := a60;
                  B := a59;
                  FlagS := a68[7:0][7];
                  FlagZ := is_zero(a68[7:0]);
                  FlagA := a71[7:0][4];
                  FlagP := parity(a68[7:0]);
                  FlagCY := !a68[15:8][0];
                  jump (1530);
                } else {
                  advance (10)
                  A := a60;
                  B := a59;
                  FlagS := a68[7:0][7];
                  FlagZ := is_zero(a68[7:0]);
                  FlagA := a71[7:0][4];
                  FlagP := parity(a68[7:0]);
                  FlagCY := !a68[15:8][0];
                  jump (1504);
                }
              }
            }
          }
        }
      }
    }

1504:

    #1504
    #instruction: LD   L,B
    let:8 a1 = B in
    advance (5)
    #1505
    #instruction: CALL 1562
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 15;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 08;
    #return-to: 1508
    advance (17)
    #1562
    #instruction: LD   A,(2009)
    let:8 a8 = M[2009] in
    advance (13)
    #1565
    #instruction: LD   H,L
    let:8 a9 = a1 in
    advance (5)
    #1566
    #instruction: CALL 1554
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 15;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 69;
    #return-to: 1569
    advance (17)
    A := a8;
    H := a9;
    L := a1;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump (1554);

1508:

    #1508
    #instruction: LD   A,(202A)
    let:8 a1 = M[202A] in
    advance (13)
    #150B
    #instruction: LD   H,A
    let:8 a2 = a1 in
    advance (5)
    #150C
    #instruction: CALL 156F
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 15;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 0F;
    #return-to: 150F
    advance (17)
    A := a1;
    H := a2;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (156F);

150F:

    #150F
    #instruction: LD   (2064),HL
    let:8 a1 = L in
    M[2064] := a1;
    let:8 a2 = H in
    M[2065] := a2;
    advance (16)
    #1512
    #instruction: LD   A,05
    advance (7)
    #1514
    #instruction: LD   (2025),A
    M[2025] := 05;
    advance (13)
    #1517
    #instruction: CALL 1581
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 15;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 1A;
    #return-to: 151A
    advance (17)
    #1581
    #instruction: LD   A,B
    let:8 a9 = B in
    advance (5)
    #1582
    #instruction: RLCA
    let:8 a10 = a9 in
    advance (4)
    #1583
    #instruction: RLCA
    let:8 a11 = updateBit((a10 << 01),0,a10[7]) in
    advance (4)
    #1584
    #instruction: RLCA
    let:8 a12 = updateBit((a11 << 01),0,a11[7]) in
    advance (4)
    #1585
    #instruction: ADD  B
    let:8 a13 = B in
    let:8 a14 = updateBit((a12 << 01),0,a12[7]) in
    let:16 a15 = addWithCarry(false,a13,a14) in
    let:8 a16 = (a13 & 0F) in
    let:8 a17 = (a14 & 0F) in
    let:16 a18 = addWithCarry(false,a16,a17) in
    advance (4)
    #1586
    #instruction: ADD  B
    let:8 a19 = B in
    let:8 a20 = a15[7:0] in
    let:16 a21 = addWithCarry(false,a19,a20) in
    let:8 a22 = (a19 & 0F) in
    let:8 a23 = (a20 & 0F) in
    let:16 a24 = addWithCarry(false,a22,a23) in
    advance (4)
    #1587
    #instruction: ADD  B
    let:8 a25 = B in
    let:8 a26 = a21[7:0] in
    let:16 a27 = addWithCarry(false,a25,a26) in
    let:8 a28 = (a25 & 0F) in
    let:8 a29 = (a26 & 0F) in
    let:16 a30 = addWithCarry(false,a28,a29) in
    advance (4)
    #1588
    #instruction: ADD  C
    let:8 a31 = C in
    let:8 a32 = a27[7:0] in
    let:16 a33 = addWithCarry(false,a31,a32) in
    let:8 a34 = (a31 & 0F) in
    let:8 a35 = (a32 & 0F) in
    let:16 a36 = addWithCarry(false,a34,a35) in
    advance (4)
    #1589
    #instruction: DEC  A
    let:8 a37 = a33[7:0] in
    let:16 a38 = addWithCarry(!true,a37,~00) in
    let:8 a39 = (a37 & 0F) in
    let:8 a40 = (~00 & 0F) in
    let:16 a41 = addWithCarry(!true,a39,a40) in
    advance (5)
    #158A
    #instruction: LD   L,A
    let:8 a42 = a38[7:0] in
    advance (5)
    #158B
    #instruction: LD   A,(2067)
    let:8 a43 = M[2067] in
    advance (13)
    #158E
    #instruction: LD   H,A
    let:8 a44 = a43 in
    advance (5)
    #158F
    #instruction: RET
    let:8 a45 = a8[15:8] in
    let:8 a46 = a8[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (1 + (a49,a50)) in
    let:8 a52 = M[(a49,a50)] in
    advance (10)
    A := a43;
    H := a44;
    L := a42;
    SPH := a51[15:8];
    SPL := a51[7:0];
    FlagS := a38[7:0][7];
    FlagZ := is_zero(a38[7:0]);
    FlagA := a41[7:0][4];
    FlagP := parity(a38[7:0]);
    FlagCY := a33[15:8][0];
    jump ((a52,a48));

151A:

    #151A
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #151B
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #151C
    #instruction: JP   Z,1530
    if (is_zero(a6)) {
      advance (10)
      A := a6;
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (1530);
    } else {
      advance (10)
      #151F
      #instruction: LD   (HL),00
      let:8 a8 = H in
      let:8 a9 = L in
      M[(a8,a9)] := 00;
      advance (10)
      #1521
      #instruction: CALL 0A5F
      let:8 a10 = SPH in
      let:8 a11 = SPL in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 15;
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 24;
      #return-to: 1524
      advance (17)
      #0A5F
      #instruction: LD   A,(20EF)
      let:8 a16 = M[20EF] in
      advance (13)
      #0A62
      #instruction: AND  A
      let:8 a17 = a16 in
      let:8 a18 = a16 in
      let:8 a19 = (a17 & a18) in
      let:8 a20 = (a17 | a18) in
      advance (4)
      #0A63
      #instruction: JP   Z,0A7C
      if (is_zero(a19)) {
        advance (10)
        A := a19;
        SPH := a15[15:8];
        SPL := a15[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump (0A7C);
      } else {
        advance (10)
        #0A66
        #instruction: LD   C,B
        let:8 a21 = B in
        advance (5)
        #0A67
        #instruction: LD   B,08
        advance (7)
        #0A69
        #instruction: CALL 18FA
        let:8 a22 = a15[15:8] in
        let:8 a23 = a15[7:0] in
        let:16 a24 = (-1 + (a22,a23)) in
        M[a24] := 0A;
        let:8 a25 = a24[15:8] in
        let:8 a26 = a24[7:0] in
        let:16 a27 = (-1 + (a25,a26)) in
        M[a27] := 6C;
        #return-to: 0A6C
        advance (17)
        A := a19;
        B := 08;
        C := a21;
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump (18FA);
      }
    }

1524:

    #1524
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 15;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 27;
    #return-to: 1527
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A3B);

1527:

    #1527
    #instruction: CALL 15D3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 15;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2A;
    #return-to: 152A
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (15D3);

152A:

    #152A
    #instruction: LD   A,10
    advance (7)
    #152C
    #instruction: LD   (2003),A
    M[2003] := 10;
    advance (13)
    #152F
    #instruction: RET
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    A := 10;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump ((a8,a4));

1530:

    #1530
    #instruction: LD   A,03
    advance (7)
    #1532
    #instruction: LD   (2025),A
    M[2025] := 03;
    advance (13)
    #1535
    #instruction: JP   154A
    advance (10)
    A := 03;
    jump (154A);

1545:

    #1545
    #instruction: LD   A,04
    advance (7)
    #1547
    #instruction: LD   (2025),A
    M[2025] := 04;
    advance (13)
    A := 04;
    jump (154A);

154A:

    #154A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #154B
    #instruction: LD   (2002),A
    let:8 a4 = a3 in
    M[2002] := a4;
    advance (13)
    #154E
    #instruction: LD   B,F7
    advance (7)
    #1550
    #instruction: JP   19DC
    advance (10)
    A := a3;
    B := F7;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (19DC);

1554:

    #1554
    #instruction: LD   C,00
    advance (7)
    #1556
    #instruction: CP   H
    let:8 a1 = A in
    let:8 a2 = H in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    #1557
    #instruction: CALL NC,1590
    if (!!a3[15:8][0]) {
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 15;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 5A;
      #return-to: 155A
      advance (17)
      C := 00;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (1590);
    } else {
      advance (11)
      C := 00;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (155A);
    }

155A:

    #155A
    #instruction: CP   H
    let:8 a1 = A in
    let:8 a2 = H in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    #155B
    #instruction: RET  NC
    if (!!a3[15:8][0]) {
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (11)
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    } else {
      advance (5)
      #155C
      #instruction: ADD  10
      let:8 a15 = A in
      let:16 a16 = addWithCarry(false,10,a15) in
      let:8 a17 = (10 & 0F) in
      let:8 a18 = (a15 & 0F) in
      let:16 a19 = addWithCarry(false,a17,a18) in
      advance (7)
      #155E
      #instruction: INC  C
      let:8 a20 = C in
      let:16 a21 = addWithCarry(true,a20,00) in
      let:8 a22 = (a20 & 0F) in
      let:8 a23 = (00 & 0F) in
      let:16 a24 = addWithCarry(true,a22,a23) in
      advance (5)
      #155F
      #instruction: JP   155A
      advance (10)
      A := a16[7:0];
      C := a21[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a16[15:8][0];
      jump (155A);
    }

1569:

    #1569
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    #156A
    #instruction: DEC  B
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #156B
    #instruction: SBC  10
    let:8 a7 = A in
    let:16 a8 = addWithCarry(!FlagCY,a7,~10) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (~10 & 0F) in
    let:16 a11 = addWithCarry(!FlagCY,a9,a10) in
    advance (7)
    #156D
    #instruction: LD   L,A
    let:8 a12 = a8[7:0] in
    advance (5)
    #156E
    #instruction: RET
    let:8 a13 = SPH in
    let:8 a14 = SPL in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a8[7:0];
    B := a3[7:0];
    L := a12;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a8[7:0][7];
    FlagZ := is_zero(a8[7:0]);
    FlagA := a11[7:0][4];
    FlagP := parity(a8[7:0]);
    FlagCY := !a8[15:8][0];
    jump ((a20,a16));

156F:

    #156F
    #instruction: LD   A,(200A)
    let:8 a1 = M[200A] in
    advance (13)
    #1572
    #instruction: CALL 1554
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 15;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 75;
    #return-to: 1575
    advance (17)
    A := a1;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (1554);

1575:

    #1575
    #instruction: SBC  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!FlagCY,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!FlagCY,a3,a4) in
    advance (7)
    #1577
    #instruction: LD   H,A
    let:8 a6 = a2[7:0] in
    advance (5)
    #1578
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a2[7:0];
    H := a6;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump ((a14,a10));

1590:

    #1590
    #instruction: INC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    #1591
    #instruction: ADD  10
    let:8 a6 = A in
    let:16 a7 = addWithCarry(false,10,a6) in
    let:8 a8 = (10 & 0F) in
    let:8 a9 = (a6 & 0F) in
    let:16 a10 = addWithCarry(false,a8,a9) in
    advance (7)
    #1593
    #instruction: JP   MI,1590
    if (a7[7:0][7]) {
      advance (10)
      A := a7[7:0];
      C := a2[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a7[15:8][0];
      jump (1590);
    } else {
      advance (10)
      #1596
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a7[7:0];
      C := a2[7:0];
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a7[15:8][0];
      jump ((a18,a14));
    }

15A4:

    #15A4
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #15A5
      #instruction: LD   B,FE
      advance (7)
      #15A7
      #instruction: LD   A,01
      advance (7)
      A := 01;
      B := FE;
      jump (15A9);
    }

15A9:

    #15A9
    #instruction: LD   (200D),A
    let:8 a1 = A in
    M[200D] := a1;
    advance (13)
    #15AC
    #instruction: LD   A,B
    let:8 a2 = B in
    advance (5)
    #15AD
    #instruction: LD   (2008),A
    let:8 a3 = a2 in
    M[2008] := a3;
    advance (13)
    #15B0
    #instruction: LD   A,(200E)
    let:8 a4 = M[200E] in
    advance (13)
    #15B3
    #instruction: LD   (2007),A
    let:8 a5 = a4 in
    M[2007] := a5;
    advance (13)
    #15B6
    #instruction: RET
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (1 + (a6,a7)) in
    let:8 a9 = M[(a6,a7)] in
    let:8 a10 = a8[15:8] in
    let:8 a11 = a8[7:0] in
    let:16 a12 = (1 + (a10,a11)) in
    let:8 a13 = M[(a10,a11)] in
    advance (10)
    A := a4;
    SPH := a12[15:8];
    SPL := a12[7:0];
    jump ((a13,a9));

15BD:

    #15BD
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #15BE
      #instruction: CALL 18F1
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 15;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := C1;
      #return-to: 15C1
      advance (17)
      #18F1
      #instruction: LD   B,02
      advance (7)
      #18F3
      #instruction: LD   A,(2082)
      let:8 a15 = M[2082] in
      advance (13)
      #18F6
      #instruction: DEC  A
      let:8 a16 = a15 in
      let:16 a17 = addWithCarry(!true,a16,~00) in
      let:8 a18 = (a16 & 0F) in
      let:8 a19 = (~00 & 0F) in
      let:16 a20 = addWithCarry(!true,a18,a19) in
      advance (5)
      #18F7
      #instruction: RET  NZ
      if (!is_zero(a17[7:0])) {
        let:8 a21 = a14[15:8] in
        let:8 a22 = a14[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        let:8 a25 = a23[15:8] in
        let:8 a26 = a23[7:0] in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        advance (11)
        A := a17[7:0];
        B := 02;
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        jump ((a28,a24));
      } else {
        advance (5)
        #18F8
        #instruction: INC  B
        let:16 a29 = addWithCarry(true,02,00) in
        let:8 a30 = (02 & 0F) in
        let:8 a31 = (00 & 0F) in
        let:16 a32 = addWithCarry(true,a30,a31) in
        advance (5)
        #18F9
        #instruction: RET
        let:8 a33 = a14[15:8] in
        let:8 a34 = a14[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a17[7:0];
        B := a29[7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        jump ((a40,a36));
      }
    }

15C1:

    #15C1
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #15C2
    #instruction: JP   15A9
    advance (10)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (15A9);

15C5:

    #15C5
    #instruction: LD   B,17
    advance (7)
    B := 17;
    jump (15C7);

15C7:

    #15C7
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #15C8
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #15C9
    #instruction: JP   NZ,166B
    if (!is_zero(a6)) {
      advance (10)
      #166B
      #instruction: SCF
      advance (4)
      #166C
      #instruction: RET
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      let:8 a12 = a10[15:8] in
      let:8 a13 = a10[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      advance (10)
      A := a6;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := true;
      jump ((a15,a11));
    } else {
      advance (10)
      #15CC
      #instruction: INC  HL
      let:8 a16 = H in
      let:8 a17 = L in
      let:16 a18 = (1 + (a16,a17)) in
      advance (5)
      #15CD
      #instruction: DEC  B
      let:8 a19 = B in
      let:16 a20 = addWithCarry(!true,a19,~00) in
      let:8 a21 = (a19 & 0F) in
      let:8 a22 = (~00 & 0F) in
      let:16 a23 = addWithCarry(!true,a21,a22) in
      advance (5)
      #15CE
      #instruction: JP   NZ,15C7
      if (!is_zero(a20[7:0])) {
        advance (10)
        A := a6;
        B := a20[7:0];
        H := a18[15:8];
        L := a18[7:0];
        FlagS := a20[7:0][7];
        FlagZ := is_zero(a20[7:0]);
        FlagA := a23[7:0][4];
        FlagP := parity(a20[7:0]);
        FlagCY := false;
        jump (15C7);
      } else {
        advance (10)
        #15D1
        #instruction: RET
        let:8 a24 = SPH in
        let:8 a25 = SPL in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        let:8 a28 = a26[15:8] in
        let:8 a29 = a26[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        advance (10)
        A := a6;
        B := a20[7:0];
        H := a18[15:8];
        L := a18[7:0];
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a20[7:0][7];
        FlagZ := is_zero(a20[7:0]);
        FlagA := a23[7:0][4];
        FlagP := parity(a20[7:0]);
        FlagCY := false;
        jump ((a31,a27));
      }
    }

15D3:

    #15D3
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 15;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D6;
    #return-to: 15D6
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1474);

15D6:

    #15D6
    #instruction: PUSH HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (15D7);

15D7:

    #15D7
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #15D8
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #15D9
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #15DA
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #15DC
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #15DE
    #instruction: LD   (HL),A
    let:8 a24 = a23 in
    let:8 a25 = H in
    let:8 a26 = L in
    M[(a25,a26)] := a24;
    advance (7)
    #15DF
    #instruction: INC  HL
    let:8 a27 = H in
    let:8 a28 = L in
    let:16 a29 = (1 + (a27,a28)) in
    advance (5)
    #15E0
    #instruction: INC  DE
    let:8 a30 = D in
    let:8 a31 = E in
    let:16 a32 = (1 + (a30,a31)) in
    advance (5)
    #15E1
    #instruction: XOR  A
    let:8 a33 = a23 in
    let:8 a34 = a23 in
    let:8 a35 = (a33 ^ a34) in
    advance (4)
    #15E2
    #instruction: OUT  04
    let:8 a36 = a35 in
    advance (10)
    #15E4
    #instruction: IN   03
    let:8 a37 = (Shifter_OFF & 07) in
    let:8 a38 = (~Shifter_OFF & 07) in
    let:8 a39 = ((a36 << a37) | ((a20 >> a38) >> 01)) in
    advance (10)
    #15E6
    #instruction: LD   (HL),A
    let:8 a40 = a39 in
    let:8 a41 = a29[15:8] in
    let:8 a42 = a29[7:0] in
    M[(a41,a42)] := a40;
    advance (7)
    #15E7
    #instruction: POP  HL
    let:8 a43 = a16[15:8] in
    let:8 a44 = a16[7:0] in
    let:16 a45 = (1 + (a43,a44)) in
    let:8 a46 = M[(a43,a44)] in
    let:8 a47 = a45[15:8] in
    let:8 a48 = a45[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    advance (10)
    #15E8
    #instruction: LD   BC,0020
    advance (10)
    #15EB
    #instruction: ADD  HL,BC
    let:8 a51 = a50 in
    let:8 a52 = a46 in
    let:17 a53 = add17(0020,(a51,a52)) in
    advance (10)
    #15EC
    #instruction: POP  BC
    let:8 a54 = a49[15:8] in
    let:8 a55 = a49[7:0] in
    let:16 a56 = (1 + (a54,a55)) in
    let:8 a57 = M[(a54,a55)] in
    let:8 a58 = a56[15:8] in
    let:8 a59 = a56[7:0] in
    let:16 a60 = (1 + (a58,a59)) in
    let:8 a61 = M[(a58,a59)] in
    advance (10)
    #15ED
    #instruction: DEC  B
    let:8 a62 = a61 in
    let:16 a63 = addWithCarry(!true,a62,~00) in
    let:8 a64 = (a62 & 0F) in
    let:8 a65 = (~00 & 0F) in
    let:16 a66 = addWithCarry(!true,a64,a65) in
    advance (5)
    #15EE
    #instruction: JP   NZ,15D7
    if (!is_zero(a63[7:0])) {
      advance (10)
      A := a39;
      B := a63[7:0];
      C := a57;
      D := a32[15:8];
      E := a32[7:0];
      H := a53[15:0][15:8];
      L := a53[15:0][7:0];
      SPH := a60[15:8];
      SPL := a60[7:0];
      FlagS := a63[7:0][7];
      FlagZ := is_zero(a63[7:0]);
      FlagA := a66[7:0][4];
      FlagP := parity(a63[7:0]);
      FlagCY := a53[16];
      Shifter_HI := a36;
      Shifter_LO := a20;
      jump (15D7);
    } else {
      advance (10)
      #15F1
      #instruction: POP  HL
      let:8 a67 = a60[15:8] in
      let:8 a68 = a60[7:0] in
      let:16 a69 = (1 + (a67,a68)) in
      let:8 a70 = M[(a67,a68)] in
      let:8 a71 = a69[15:8] in
      let:8 a72 = a69[7:0] in
      let:16 a73 = (1 + (a71,a72)) in
      let:8 a74 = M[(a71,a72)] in
      advance (10)
      #15F2
      #instruction: RET
      let:8 a75 = a73[15:8] in
      let:8 a76 = a73[7:0] in
      let:16 a77 = (1 + (a75,a76)) in
      let:8 a78 = M[(a75,a76)] in
      let:8 a79 = a77[15:8] in
      let:8 a80 = a77[7:0] in
      let:16 a81 = (1 + (a79,a80)) in
      let:8 a82 = M[(a79,a80)] in
      advance (10)
      A := a39;
      B := a63[7:0];
      C := a57;
      D := a32[15:8];
      E := a32[7:0];
      H := a74;
      L := a70;
      SPH := a81[15:8];
      SPL := a81[7:0];
      FlagS := a63[7:0][7];
      FlagZ := is_zero(a63[7:0]);
      FlagA := a66[7:0][4];
      FlagP := parity(a63[7:0]);
      FlagCY := a53[16];
      Shifter_HI := a36;
      Shifter_LO := a20;
      jump ((a82,a78));
    }

15F6:

    #15F6
    #instruction: LD   BC,3700
    advance (10)
    B := 37;
    C := 00;
    jump (15F9);

15F9:

    #15F9
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #15FA
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #15FB
    #instruction: JP   Z,15FF
    if (is_zero(a6)) {
      advance (10)
      A := a6;
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (15FF);
    } else {
      advance (10)
      #15FE
      #instruction: INC  C
      let:8 a8 = C in
      let:16 a9 = addWithCarry(true,a8,00) in
      let:8 a10 = (a8 & 0F) in
      let:8 a11 = (00 & 0F) in
      let:16 a12 = addWithCarry(true,a10,a11) in
      advance (5)
      A := a6;
      C := a9[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := false;
      jump (15FF);
    }

15FF:

    #15FF
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #1600
    #instruction: DEC  B
    let:8 a4 = B in
    let:16 a5 = addWithCarry(!true,a4,~00) in
    let:8 a6 = (a4 & 0F) in
    let:8 a7 = (~00 & 0F) in
    let:16 a8 = addWithCarry(!true,a6,a7) in
    advance (5)
    #1601
    #instruction: JP   NZ,15F9
    if (!is_zero(a5[7:0])) {
      advance (10)
      B := a5[7:0];
      H := a3[15:8];
      L := a3[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      jump (15F9);
    } else {
      advance (10)
      #1604
      #instruction: LD   A,C
      let:8 a9 = C in
      advance (5)
      #1605
      #instruction: LD   (2082),A
      let:8 a10 = a9 in
      M[2082] := a10;
      advance (13)
      #1608
      #instruction: CP   01
      let:8 a11 = a9 in
      let:16 a12 = addWithCarry(!false,a11,~01) in
      let:8 a13 = (a11 & 0F) in
      let:8 a14 = (~01 & 0F) in
      let:16 a15 = addWithCarry(!false,a13,a14) in
      advance (7)
      #160A
      #instruction: RET  NZ
      if (!is_zero(a12[7:0])) {
        let:8 a16 = SPH in
        let:8 a17 = SPL in
        let:16 a18 = (1 + (a16,a17)) in
        let:8 a19 = M[(a16,a17)] in
        let:8 a20 = a18[15:8] in
        let:8 a21 = a18[7:0] in
        let:16 a22 = (1 + (a20,a21)) in
        let:8 a23 = M[(a20,a21)] in
        advance (11)
        A := a9;
        B := a5[7:0];
        H := a3[15:8];
        L := a3[7:0];
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := !a12[15:8][0];
        jump ((a23,a19));
      } else {
        advance (5)
        #160B
        #instruction: LD   HL,206B
        advance (10)
        #160E
        #instruction: LD   (HL),01
        M[206B] := 01;
        advance (10)
        #1610
        #instruction: RET
        let:8 a24 = SPH in
        let:8 a25 = SPL in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        let:8 a28 = a26[15:8] in
        let:8 a29 = a26[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        advance (10)
        A := a9;
        B := a5[7:0];
        H := 20;
        L := 6B;
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := !a12[15:8][0];
        jump ((a31,a27));
      }
    }

1611:

    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a2 = a1 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (1 + (a3,a4)) in
    let:8 a6 = M[(a3,a4)] in
    let:8 a7 = a5[15:8] in
    let:8 a8 = a5[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    advance (10)
    A := a1;
    H := a2;
    L := 00;
    SPH := a9[15:8];
    SPL := a9[7:0];
    jump ((a10,a6));

1618:

    #1618
    #instruction: LD   A,(2015)
    let:8 a1 = M[2015] in
    advance (13)
    #161B
    #instruction: CP   FF
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~FF) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~FF & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #161D
    #instruction: RET  NZ
    if (!is_zero(a3[7:0])) {
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (11)
      A := a1;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    } else {
      advance (5)
      #161E
      #instruction: LD   HL,2010
      advance (10)
      #1621
      #instruction: LD   A,(HL)
      let:8 a15 = M[2010] in
      advance (7)
      #1622
      #instruction: INC  HL
      advance (5)
      #1623
      #instruction: LD   B,(HL)
      let:8 a16 = M[2011] in
      advance (7)
      #1624
      #instruction: OR   B
      let:8 a17 = a16 in
      let:8 a18 = a15 in
      let:8 a19 = (a17 | a18) in
      advance (4)
      #1625
      #instruction: RET  NZ
      if (!is_zero(a19)) {
        let:8 a20 = SPH in
        let:8 a21 = SPL in
        let:16 a22 = (1 + (a20,a21)) in
        let:8 a23 = M[(a20,a21)] in
        let:8 a24 = a22[15:8] in
        let:8 a25 = a22[7:0] in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        advance (11)
        A := a19;
        B := a16;
        H := 20;
        L := 11;
        SPH := a26[15:8];
        SPL := a26[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := false;
        FlagP := parity(a19);
        FlagCY := false;
        jump ((a27,a23));
      } else {
        advance (5)
        #1626
        #instruction: LD   A,(2025)
        let:8 a28 = M[2025] in
        advance (13)
        #1629
        #instruction: AND  A
        let:8 a29 = a28 in
        let:8 a30 = a28 in
        let:8 a31 = (a29 & a30) in
        let:8 a32 = (a29 | a30) in
        advance (4)
        #162A
        #instruction: RET  NZ
        if (!is_zero(a31)) {
          let:8 a33 = SPH in
          let:8 a34 = SPL in
          let:16 a35 = (1 + (a33,a34)) in
          let:8 a36 = M[(a33,a34)] in
          let:8 a37 = a35[15:8] in
          let:8 a38 = a35[7:0] in
          let:16 a39 = (1 + (a37,a38)) in
          let:8 a40 = M[(a37,a38)] in
          advance (11)
          A := a31;
          B := a16;
          H := 20;
          L := 11;
          SPH := a39[15:8];
          SPL := a39[7:0];
          FlagS := a31[7];
          FlagZ := is_zero(a31);
          FlagA := a32[3];
          FlagP := parity(a31);
          FlagCY := false;
          jump ((a40,a36));
        } else {
          advance (5)
          #162B
          #instruction: LD   A,(20EF)
          let:8 a41 = M[20EF] in
          advance (13)
          #162E
          #instruction: AND  A
          let:8 a42 = a41 in
          let:8 a43 = a41 in
          let:8 a44 = (a42 & a43) in
          let:8 a45 = (a42 | a43) in
          advance (4)
          #162F
          #instruction: JP   Z,1652
          if (is_zero(a44)) {
            advance (10)
            #1652
            #instruction: LD   HL,2025
            advance (10)
            #1655
            #instruction: LD   (HL),01
            M[2025] := 01;
            advance (10)
            #1657
            #instruction: LD   HL,(20ED)
            let:8 a46 = M[20ED] in
            let:8 a47 = M[20EE] in
            advance (16)
            #165A
            #instruction: INC  HL
            let:8 a48 = a47 in
            let:8 a49 = a46 in
            let:16 a50 = (1 + (a48,a49)) in
            advance (5)
            #165B
            #instruction: LD   A,L
            let:8 a51 = a50[7:0] in
            advance (5)
            #165C
            #instruction: CP   7E
            let:8 a52 = a51 in
            let:16 a53 = addWithCarry(!false,a52,~7E) in
            let:8 a54 = (a52 & 0F) in
            let:8 a55 = (~7E & 0F) in
            let:16 a56 = addWithCarry(!false,a54,a55) in
            advance (7)
            #165E
            #instruction: JP   CY,1663
            if (!a53[15:8][0]) {
              advance (10)
              A := a51;
              B := a16;
              H := a50[15:8];
              L := a50[7:0];
              FlagS := a53[7:0][7];
              FlagZ := is_zero(a53[7:0]);
              FlagA := a56[7:0][4];
              FlagP := parity(a53[7:0]);
              FlagCY := !a53[15:8][0];
              jump (1663);
            } else {
              advance (10)
              #1661
              #instruction: LD   L,74
              advance (7)
              A := a51;
              B := a16;
              H := a50[15:8];
              L := 74;
              FlagS := a53[7:0][7];
              FlagZ := is_zero(a53[7:0]);
              FlagA := a56[7:0][4];
              FlagP := parity(a53[7:0]);
              FlagCY := !a53[15:8][0];
              jump (1663);
            }
          } else {
            advance (10)
            #1632
            #instruction: LD   A,(202D)
            let:8 a57 = M[202D] in
            advance (13)
            #1635
            #instruction: AND  A
            let:8 a58 = a57 in
            let:8 a59 = a57 in
            let:8 a60 = (a58 & a59) in
            let:8 a61 = (a58 | a59) in
            advance (4)
            #1636
            #instruction: JP   NZ,1648
            if (!is_zero(a60)) {
              advance (10)
              #1648
              #instruction: CALL 17C0
              let:8 a62 = SPH in
              let:8 a63 = SPL in
              let:16 a64 = (-1 + (a62,a63)) in
              M[a64] := 16;
              let:8 a65 = a64[15:8] in
              let:8 a66 = a64[7:0] in
              let:16 a67 = (-1 + (a65,a66)) in
              M[a67] := 4B;
              #return-to: 164B
              advance (17)
              A := a60;
              B := a16;
              H := 20;
              L := 11;
              SPH := a67[15:8];
              SPL := a67[7:0];
              FlagS := a60[7];
              FlagZ := is_zero(a60);
              FlagA := a61[3];
              FlagP := parity(a60);
              FlagCY := false;
              jump (17C0);
            } else {
              advance (10)
              #1639
              #instruction: CALL 17C0
              let:8 a68 = SPH in
              let:8 a69 = SPL in
              let:16 a70 = (-1 + (a68,a69)) in
              M[a70] := 16;
              let:8 a71 = a70[15:8] in
              let:8 a72 = a70[7:0] in
              let:16 a73 = (-1 + (a71,a72)) in
              M[a73] := 3C;
              #return-to: 163C
              advance (17)
              A := a60;
              B := a16;
              H := 20;
              L := 11;
              SPH := a73[15:8];
              SPL := a73[7:0];
              FlagS := a60[7];
              FlagZ := is_zero(a60);
              FlagA := a61[3];
              FlagP := parity(a60);
              FlagCY := false;
              jump (17C0);
            }
          }
        }
      }
    }

163C:

    #163C
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    #163E
    #instruction: RET  Z
    if (is_zero(a2)) {
      let:8 a4 = SPH in
      let:8 a5 = SPL in
      let:16 a6 = (1 + (a4,a5)) in
      let:8 a7 = M[(a4,a5)] in
      let:8 a8 = a6[15:8] in
      let:8 a9 = a6[7:0] in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      advance (11)
      A := a2;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a11,a7));
    } else {
      advance (5)
      #163F
      #instruction: LD   A,01
      advance (7)
      #1641
      #instruction: LD   (2025),A
      M[2025] := 01;
      advance (13)
      #1644
      #instruction: LD   (202D),A
      M[202D] := 01;
      advance (13)
      #1647
      #instruction: RET
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := 01;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a19,a15));
    }

164B:

    #164B
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    #164D
    #instruction: RET  NZ
    if (!is_zero(a2)) {
      let:8 a4 = SPH in
      let:8 a5 = SPL in
      let:16 a6 = (1 + (a4,a5)) in
      let:8 a7 = M[(a4,a5)] in
      let:8 a8 = a6[15:8] in
      let:8 a9 = a6[7:0] in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      advance (11)
      A := a2;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a11,a7));
    } else {
      advance (5)
      #164E
      #instruction: LD   (202D),A
      let:8 a12 = a2 in
      M[202D] := a12;
      advance (13)
      #1651
      #instruction: RET
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := a2;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a20,a16));
    }

1663:

    #1663
    #instruction: LD   (20ED),HL
    let:8 a1 = L in
    M[20ED] := a1;
    let:8 a2 = H in
    M[20EE] := a2;
    advance (16)
    #1666
    #instruction: LD   A,(HL)
    let:8 a3 = H in
    let:8 a4 = L in
    let:8 a5 = M[(a3,a4)] in
    advance (7)
    #1667
    #instruction: LD   (201D),A
    let:8 a6 = a5 in
    M[201D] := a6;
    advance (13)
    #166A
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a5;
    SPH := a13[15:8];
    SPL := a13[7:0];
    jump ((a14,a10));

1671:

    #1671
    #instruction: CALL 1910
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 1674
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1910);

1674:

    #1674
    #instruction: LD   (HL),00
    let:8 a1 = H in
    let:8 a2 = L in
    M[(a1,a2)] := 00;
    advance (10)
    #1676
    #instruction: CALL 09CA
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 16;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 79;
    #return-to: 1679
    advance (17)
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (09CA);

1679:

    #1679
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #167A
    #instruction: LD   DE,20F5
    advance (10)
    #167D
    #instruction: LD   A,(DE)
    let:8 a4 = M[20F5] in
    advance (7)
    #167E
    #instruction: CP   (HL)
    let:8 a5 = a4 in
    let:8 a6 = a3[15:8] in
    let:8 a7 = a3[7:0] in
    let:8 a8 = M[(a6,a7)] in
    let:16 a9 = addWithCarry(!false,a5,~a8) in
    let:8 a10 = (a5 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #167F
    #instruction: DEC  DE
    advance (5)
    #1680
    #instruction: DEC  HL
    let:8 a13 = a3[15:8] in
    let:8 a14 = a3[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    advance (5)
    #1681
    #instruction: LD   A,(DE)
    let:8 a16 = M[20F4] in
    advance (7)
    #1682
    #instruction: JP   Z,168B
    if (is_zero(a9[7:0])) {
      advance (10)
      #168B
      #instruction: CP   (HL)
      let:8 a17 = a16 in
      let:8 a18 = a15[15:8] in
      let:8 a19 = a15[7:0] in
      let:8 a20 = M[(a18,a19)] in
      let:16 a21 = addWithCarry(!false,a17,~a20) in
      let:8 a22 = (a17 & 0F) in
      let:8 a23 = (~a20 & 0F) in
      let:16 a24 = addWithCarry(!false,a22,a23) in
      advance (7)
      #168C
      #instruction: JP   NC,1698
      if (!!a21[15:8][0]) {
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a21[15:8][0];
        jump (1698);
      } else {
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a21[15:8][0];
        jump (168F);
      }
    } else {
      advance (10)
      #1685
      #instruction: JP   NC,1698
      if (!!a9[15:8][0]) {
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (1698);
      } else {
        advance (10)
        #1688
        #instruction: JP   168F
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (168F);
      }
    }

168F:

    #168F
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1690
    #instruction: LD   (DE),A
    let:8 a4 = D in
    let:8 a5 = E in
    let:8 a6 = a3 in
    M[(a4,a5)] := a6;
    advance (7)
    #1691
    #instruction: INC  DE
    let:8 a7 = D in
    let:8 a8 = E in
    let:16 a9 = (1 + (a7,a8)) in
    advance (5)
    #1692
    #instruction: INC  HL
    let:8 a10 = H in
    let:8 a11 = L in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1693
    #instruction: LD   A,(HL)
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #1694
    #instruction: LD   (DE),A
    let:8 a16 = a9[15:8] in
    let:8 a17 = a9[7:0] in
    let:8 a18 = a15 in
    M[(a16,a17)] := a18;
    advance (7)
    #1695
    #instruction: CALL 1950
    let:8 a19 = SPH in
    let:8 a20 = SPL in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 16;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 98;
    #return-to: 1698
    advance (17)
    A := a15;
    D := a9[15:8];
    E := a9[7:0];
    H := a12[15:8];
    L := a12[7:0];
    SPH := a24[15:8];
    SPL := a24[7:0];
    jump (1950);

1698:

    #1698
    #instruction: LD   A,(20CE)
    let:8 a1 = M[20CE] in
    advance (13)
    #169B
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #169C
    #instruction: JP   Z,16C9
    if (is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (16C9);
    } else {
      advance (10)
      #169F
      #instruction: LD   HL,2803
      advance (10)
      #16A2
      #instruction: LD   DE,1AA6
      advance (10)
      #16A5
      #instruction: LD   C,14
      advance (7)
      #16A7
      #instruction: CALL 0A93
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 16;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := AA;
      #return-to: 16AA
      advance (17)
      A := a4;
      C := 14;
      D := 1A;
      E := A6;
      H := 28;
      L := 03;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0A93);
    }

16AA:

    #16AA
    #instruction: DEC  H
    let:8 a1 = H in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    #16AB
    #instruction: DEC  H
    let:8 a6 = a2[7:0] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #16AC
    #instruction: LD   B,1B
    advance (7)
    #16AE
    #instruction: LD   A,(2067)
    let:8 a11 = M[2067] in
    advance (13)
    #16B1
    #instruction: RRCA
    let:8 a12 = a11 in
    advance (4)
    #16B2
    #instruction: JP   CY,16B7
    if (a12[0]) {
      advance (10)
      A := updateBit((a12 >> 01),7,a12[0]);
      B := 1B;
      H := a7[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a12[0];
      jump (16B7);
    } else {
      advance (10)
      #16B5
      #instruction: LD   B,1C
      advance (7)
      A := updateBit((a12 >> 01),7,a12[0]);
      B := 1C;
      H := a7[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := a12[0];
      jump (16B7);
    }

16B7:

    #16B7
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    #16B8
    #instruction: CALL 08FF
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 16;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := BB;
    #return-to: 16BB
    advance (17)
    A := a1;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (08FF);

16BB:

    #16BB
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := BE;
    #return-to: 16BE
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

16BE:

    #16BE
    #instruction: CALL 18E7
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 16C1
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (18E7);

16C1:

    #16C1
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #16C2
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #16C3
    #instruction: JP   Z,16C9
    if (is_zero(a6)) {
      advance (10)
      A := a6;
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (16C9);
    } else {
      advance (10)
      #16C6
      #instruction: JP   02ED
      advance (10)
      A := a6;
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump (02ED);
    }

16C9:

    #16C9
    #instruction: LD   HL,2D18
    advance (10)
    #16CC
    #instruction: LD   DE,1AA6
    advance (10)
    #16CF
    #instruction: LD   C,0A
    advance (7)
    #16D1
    #instruction: CALL 0A93
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D4;
    #return-to: 16D4
    advance (17)
    C := 0A;
    D := 1A;
    E := A6;
    H := 2D;
    L := 18;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A93);

16D4:

    #16D4
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D7;
    #return-to: 16D7
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB6);

16D7:

    #16D7
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 16DA
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

16DA:

    #16DA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #16DB
    #instruction: LD   (20EF),A
    let:8 a4 = a3 in
    M[20EF] := a4;
    advance (13)
    #16DE
    #instruction: OUT  05
    let:8 a5 = a3 in
    sound_control(FleetMovement1,a5[0]);
    sound_control(FleetMovement2,a5[1]);
    sound_control(FleetMovement3,a5[2]);
    sound_control(FleetMovement4,a5[3]);
    sound_control(UfoHit,a5[4]);
    advance (10)
    #16E0
    #instruction: CALL 19D1
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 16;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := E3;
    #return-to: 16E3
    advance (17)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (19D1);

16E3:

    #16E3
    #instruction: JP   0B89
    advance (10)
    jump (0B89);

16EE:

    #16EE
    #instruction: CALL 14D8
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F1;
    #return-to: 16F1
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14D8);

16F1:

    #16F1
    #instruction: LD   B,04
    advance (7)
    #16F3
    #instruction: CALL 18FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 16F6
    advance (17)
    B := 04;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (18FA);

16F6:

    #16F6
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F9;
    #return-to: 16F9
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A59);

16F9:

    #16F9
    #instruction: JP   NZ,16EE
    if (!FlagZ) {
      advance (10)
      jump (16EE);
    } else {
      advance (10)
      #16FC
      #instruction: CALL 19D7
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 16;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := FF;
      #return-to: 16FF
      advance (17)
      SPH := a6[15:8];
      SPL := a6[7:0];
      jump (19D7);
    }

16FF:

    #16FF
    #instruction: LD   HL,2701
    advance (10)
    #1702
    #instruction: CALL 19FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 05;
    #return-to: 1705
    advance (17)
    H := 27;
    L := 01;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (19FA);

1705:

    #1705
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #1706
    #instruction: CALL 1A8B
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    #return-to: 1709
    advance (17)
    A := a3;
    SPH := a9[15:8];
    SPL := a9[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1A8B);

1709:

    #1709
    #instruction: LD   B,FB
    advance (7)
    #170B
    #instruction: JP   196B
    advance (10)
    #196B
    #instruction: CALL 19DC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 6E;
    #return-to: 196E
    advance (17)
    B := FB;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (19DC);

1711:

    #1711
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #1712
    #instruction: LD   A,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #1713
    #instruction: LD   DE,1CB8
    advance (10)
    #1716
    #instruction: LD   HL,1AA1
    advance (10)
    #1719
    #instruction: LD   C,04
    advance (7)
    #171B
    #instruction: LD   B,A
    let:8 a7 = a6 in
    advance (5)
    A := a6;
    B := a7;
    C := 04;
    D := 1C;
    E := B8;
    H := 1A;
    L := A1;
    jump (171C);

171C:

    #171C
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #171D
    #instruction: CP   B
    let:8 a4 = a3 in
    let:8 a5 = B in
    let:16 a6 = addWithCarry(!false,a4,~a5) in
    let:8 a7 = (a4 & 0F) in
    let:8 a8 = (~a5 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (4)
    #171E
    #instruction: JP   NC,1727
    if (!!a6[15:8][0]) {
      advance (10)
      A := a3;
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      FlagCY := !a6[15:8][0];
      jump (1727);
    } else {
      advance (10)
      #1721
      #instruction: INC  HL
      let:8 a10 = H in
      let:8 a11 = L in
      let:16 a12 = (1 + (a10,a11)) in
      advance (5)
      #1722
      #instruction: INC  DE
      let:8 a13 = D in
      let:8 a14 = E in
      let:16 a15 = (1 + (a13,a14)) in
      advance (5)
      #1723
      #instruction: DEC  C
      let:8 a16 = C in
      let:16 a17 = addWithCarry(!true,a16,~00) in
      let:8 a18 = (a16 & 0F) in
      let:8 a19 = (~00 & 0F) in
      let:16 a20 = addWithCarry(!true,a18,a19) in
      advance (5)
      #1724
      #instruction: JP   NZ,171C
      if (!is_zero(a17[7:0])) {
        advance (10)
        A := a3;
        C := a17[7:0];
        D := a15[15:8];
        E := a15[7:0];
        H := a12[15:8];
        L := a12[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a6[15:8][0];
        jump (171C);
      } else {
        advance (10)
        A := a3;
        C := a17[7:0];
        D := a15[15:8];
        E := a15[7:0];
        H := a12[15:8];
        L := a12[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        FlagCY := !a6[15:8][0];
        jump (1727);
      }
    }

1727:

    #1727
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1728
    #instruction: LD   (20CF),A
    let:8 a4 = a3 in
    M[20CF] := a4;
    advance (13)
    #172B
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    jump ((a12,a8));

1747:

    #1747
    #instruction: LD   A,(2068)
    let:8 a1 = M[2068] in
    advance (13)
    #174A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #174B
    #instruction: JP   Z,176D
    if (is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (176D);
    } else {
      advance (10)
      #174E
      #instruction: LD   HL,2096
      advance (10)
      #1751
      #instruction: DEC  (HL)
      let:8 a6 = M[2096] in
      let:16 a7 = addWithCarry(!true,a6,~00) in
      let:8 a8 = (a6 & 0F) in
      let:8 a9 = (~00 & 0F) in
      let:16 a10 = addWithCarry(!true,a8,a9) in
      M[2096] := a7[7:0];
      advance (10)
      #1752
      #instruction: RET  NZ
      if (!is_zero(a7[7:0])) {
        let:8 a11 = SPH in
        let:8 a12 = SPL in
        let:16 a13 = (1 + (a11,a12)) in
        let:8 a14 = M[(a11,a12)] in
        let:8 a15 = a13[15:8] in
        let:8 a16 = a13[7:0] in
        let:16 a17 = (1 + (a15,a16)) in
        let:8 a18 = M[(a15,a16)] in
        advance (11)
        A := a4;
        H := 20;
        L := 96;
        SPH := a17[15:8];
        SPL := a17[7:0];
        FlagS := a7[7:0][7];
        FlagZ := is_zero(a7[7:0]);
        FlagA := a10[7:0][4];
        FlagP := parity(a7[7:0]);
        FlagCY := false;
        jump ((a18,a14));
      } else {
        advance (5)
        #1753
        #instruction: LD   HL,2098
        advance (10)
        #1756
        #instruction: LD   A,(HL)
        let:8 a19 = M[2098] in
        advance (7)
        #1757
        #instruction: OUT  05
        let:8 a20 = a19 in
        sound_control(FleetMovement1,a20[0]);
        sound_control(FleetMovement2,a20[1]);
        sound_control(FleetMovement3,a20[2]);
        sound_control(FleetMovement4,a20[3]);
        sound_control(UfoHit,a20[4]);
        advance (10)
        #1759
        #instruction: LD   A,(2082)
        let:8 a21 = M[2082] in
        advance (13)
        #175C
        #instruction: AND  A
        let:8 a22 = a21 in
        let:8 a23 = a21 in
        let:8 a24 = (a22 & a23) in
        let:8 a25 = (a22 | a23) in
        advance (4)
        #175D
        #instruction: JP   Z,176D
        if (is_zero(a24)) {
          advance (10)
          A := a24;
          H := 20;
          L := 98;
          FlagS := a24[7];
          FlagZ := is_zero(a24);
          FlagA := a25[3];
          FlagP := parity(a24);
          FlagCY := false;
          jump (176D);
        } else {
          advance (10)
          #1760
          #instruction: DEC  HL
          advance (5)
          #1761
          #instruction: LD   A,(HL)
          let:8 a26 = M[2097] in
          advance (7)
          #1762
          #instruction: DEC  HL
          advance (5)
          #1763
          #instruction: LD   (HL),A
          let:8 a27 = a26 in
          M[2096] := a27;
          advance (7)
          #1764
          #instruction: DEC  HL
          advance (5)
          #1765
          #instruction: LD   (HL),01
          M[2095] := 01;
          advance (10)
          #1767
          #instruction: LD   A,04
          advance (7)
          #1769
          #instruction: LD   (209B),A
          M[209B] := 04;
          advance (13)
          #176C
          #instruction: RET
          let:8 a28 = SPH in
          let:8 a29 = SPL in
          let:16 a30 = (1 + (a28,a29)) in
          let:8 a31 = M[(a28,a29)] in
          let:8 a32 = a30[15:8] in
          let:8 a33 = a30[7:0] in
          let:16 a34 = (1 + (a32,a33)) in
          let:8 a35 = M[(a32,a33)] in
          advance (10)
          A := 04;
          H := 20;
          L := 95;
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a24[7];
          FlagZ := is_zero(a24);
          FlagA := a25[3];
          FlagP := parity(a24);
          FlagCY := false;
          jump ((a35,a31));
        }
      }
    }

176D:

    #176D
    #instruction: LD   A,(2098)
    let:8 a1 = M[2098] in
    advance (13)
    A := a1;
    jump (1770);

1770:

    #1770
    #instruction: AND  30
    let:8 a1 = A in
    let:8 a2 = (30 & a1) in
    let:8 a3 = (30 | a1) in
    advance (7)
    #1772
    #instruction: OUT  05
    let:8 a4 = a2 in
    sound_control(FleetMovement1,a4[0]);
    sound_control(FleetMovement2,a4[1]);
    sound_control(FleetMovement3,a4[2]);
    sound_control(FleetMovement4,a4[3]);
    sound_control(UfoHit,a4[4]);
    advance (10)
    #1774
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a2;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump ((a12,a8));

1785:

    #1785
    #instruction: CP   (HL)
    let:8 a1 = A in
    let:8 a2 = H in
    let:8 a3 = L in
    let:8 a4 = M[(a2,a3)] in
    let:16 a5 = addWithCarry(!false,a1,~a4) in
    let:8 a6 = (a1 & 0F) in
    let:8 a7 = (~a4 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #1786
    #instruction: JP   NC,178E
    if (!!a5[15:8][0]) {
      advance (10)
      #178E
      #instruction: LD   A,(DE)
      let:8 a9 = D in
      let:8 a10 = E in
      let:8 a11 = M[(a9,a10)] in
      advance (7)
      #178F
      #instruction: LD   (2097),A
      let:8 a12 = a11 in
      M[2097] := a12;
      advance (13)
      #1792
      #instruction: LD   HL,2098
      advance (10)
      #1795
      #instruction: LD   A,(HL)
      let:8 a13 = M[2098] in
      advance (7)
      #1796
      #instruction: AND  30
      let:8 a14 = a13 in
      let:8 a15 = (30 & a14) in
      let:8 a16 = (30 | a14) in
      advance (7)
      #1798
      #instruction: LD   B,A
      let:8 a17 = a15 in
      advance (5)
      #1799
      #instruction: LD   A,(HL)
      let:8 a18 = M[2098] in
      advance (7)
      #179A
      #instruction: AND  0F
      let:8 a19 = a18 in
      let:8 a20 = (0F & a19) in
      let:8 a21 = (0F | a19) in
      advance (7)
      #179C
      #instruction: RLCA
      let:8 a22 = a20 in
      advance (4)
      #179D
      #instruction: CP   10
      let:8 a23 = updateBit((a22 << 01),0,a22[7]) in
      let:16 a24 = addWithCarry(!false,a23,~10) in
      let:8 a25 = (a23 & 0F) in
      let:8 a26 = (~10 & 0F) in
      let:16 a27 = addWithCarry(!false,a25,a26) in
      advance (7)
      #179F
      #instruction: JP   NZ,17A4
      if (!is_zero(a24[7:0])) {
        advance (10)
        A := updateBit((a22 << 01),0,a22[7]);
        B := a17;
        H := 20;
        L := 98;
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump (17A4);
      } else {
        advance (10)
        #17A2
        #instruction: LD   A,01
        advance (7)
        A := 01;
        B := a17;
        H := 20;
        L := 98;
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump (17A4);
      }
    } else {
      advance (10)
      #1789
      #instruction: INC  HL
      let:8 a28 = H in
      let:8 a29 = L in
      let:16 a30 = (1 + (a28,a29)) in
      advance (5)
      #178A
      #instruction: INC  DE
      let:8 a31 = D in
      let:8 a32 = E in
      let:16 a33 = (1 + (a31,a32)) in
      advance (5)
      #178B
      #instruction: JP   1785
      advance (10)
      D := a33[15:8];
      E := a33[7:0];
      H := a30[15:8];
      L := a30[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump (1785);
    }

17A4:

    #17A4
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    #17A5
    #instruction: LD   (HL),A
    let:8 a4 = a3 in
    let:8 a5 = H in
    let:8 a6 = L in
    M[(a5,a6)] := a4;
    advance (7)
    #17A6
    #instruction: XOR  A
    let:8 a7 = a3 in
    let:8 a8 = a3 in
    let:8 a9 = (a7 ^ a8) in
    advance (4)
    #17A7
    #instruction: LD   (2095),A
    let:8 a10 = a9 in
    M[2095] := a10;
    advance (13)
    A := a9;
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := false;
    FlagP := parity(a9);
    FlagCY := false;
    jump (17AA);

17AA:

    #17AA
    #instruction: LD   HL,2099
    advance (10)
    #17AD
    #instruction: DEC  (HL)
    let:8 a1 = M[2099] in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    M[2099] := a2[7:0];
    advance (10)
    #17AE
    #instruction: RET  NZ
    if (!is_zero(a2[7:0])) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      H := 20;
      L := 99;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      jump ((a13,a9));
    } else {
      advance (5)
      #17AF
      #instruction: LD   B,EF
      advance (7)
      #17B1
      #instruction: JP   19DC
      advance (10)
      B := EF;
      H := 20;
      L := 99;
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      jump (19DC);
    }

17B4:

    #17B4
    #instruction: LD   B,EF
    advance (7)
    #17B6
    #instruction: LD   HL,2098
    advance (10)
    #17B9
    #instruction: LD   A,(HL)
    let:8 a1 = M[2098] in
    advance (7)
    #17BA
    #instruction: AND  B
    let:8 a2 = a1 in
    let:8 a3 = (EF & a2) in
    let:8 a4 = (EF | a2) in
    advance (4)
    #17BB
    #instruction: LD   (HL),A
    let:8 a5 = a3 in
    M[2098] := a5;
    advance (7)
    #17BC
    #instruction: OUT  05
    let:8 a6 = a3 in
    sound_control(FleetMovement1,a6[0]);
    sound_control(FleetMovement2,a6[1]);
    sound_control(FleetMovement3,a6[2]);
    sound_control(FleetMovement4,a6[3]);
    sound_control(UfoHit,a6[4]);
    advance (10)
    #17BE
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a3;
    B := EF;
    H := 20;
    L := 98;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a14,a10));

17C0:

    #17C0
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #17C3
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #17C4
    #instruction: JP   NC,17CA
    if (!a2[0]) {
      advance (10)
      #17CA
      #instruction: IN   02
      advance (10)
      #17CC
      #instruction: RET
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (1 + (a3,a4)) in
      let:8 a6 = M[(a3,a4)] in
      let:8 a7 = a5[15:8] in
      let:8 a8 = a5[7:0] in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      advance (10)
      A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagCY := a2[0];
      jump ((a10,a6));
    } else {
      advance (10)
      #17C7
      #instruction: IN   01
      advance (10)
      #17C9
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagCY := a2[0];
      jump ((a18,a14));
    }

17DC:

    #17DC
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DF;
    #return-to: 17DF
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (09D6);

17DF:

    #17DF
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    #17E0
    #instruction: JP   NZ,17DC
    if (!is_zero(a2[7:0])) {
      advance (10)
      B := a2[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      jump (17DC);
    } else {
      advance (10)
      #17E3
      #instruction: LD   A,01
      advance (7)
      #17E5
      #instruction: LD   (209A),A
      M[209A] := 01;
      advance (13)
      #17E8
      #instruction: CALL 19D7
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 17;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := EB;
      #return-to: 17EB
      advance (17)
      A := 01;
      B := a2[7:0];
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a2[7:0][7];
      FlagZ := is_zero(a2[7:0]);
      FlagA := a5[7:0][4];
      FlagP := parity(a2[7:0]);
      jump (19D7);
    }

17EB:

    #17EB
    #instruction: EI
    enable_interrupts()
    advance (4)
    #17EC
    #instruction: LD   DE,1CBC
    advance (10)
    #17EF
    #instruction: LD   HL,3016
    advance (10)
    #17F2
    #instruction: LD   C,04
    advance (7)
    #17F4
    #instruction: CALL 0A93
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F7;
    #return-to: 17F7
    advance (17)
    C := 04;
    D := 1C;
    E := BC;
    H := 30;
    L := 16;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0A93);

17F7:

    #17F7
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FA;
    #return-to: 17FA
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

17FA:

    #17FA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #17FB
    #instruction: LD   (209A),A
    let:8 a4 = a3 in
    M[209A] := a4;
    advance (13)
    #17FE
    #instruction: LD   (2093),A
    let:8 a5 = a3 in
    M[2093] := a5;
    advance (13)
    #1801
    #instruction: JP   16C9
    advance (10)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (16C9);

1820:

    #1820
    #instruction: LD   A,0A
    advance (7)
    #1822
    #instruction: LD   (206C),A
    M[206C] := 0A;
    advance (13)
    #1825
    #instruction: LD   BC,1DBE
    advance (10)
    A := 0A;
    B := 1D;
    C := BE;
    jump (1828);

1828:

    #1828
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2B;
    #return-to: 182B
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1856);

182B:

    #182B
    #instruction: JP   CY,1837
    if (FlagCY) {
      advance (10)
      jump (1837);
    } else {
      advance (10)
      #182E
      #instruction: CALL 1844
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 18;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 31;
      #return-to: 1831
      advance (17)
      #1844
      #instruction: PUSH BC
      let:8 a7 = B in
      let:8 a8 = C in
      let:8 a9 = a6[15:8] in
      let:8 a10 = a6[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := a7;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := a8;
      advance (11)
      #1845
      #instruction: LD   B,10
      advance (7)
      #1847
      #instruction: CALL 1439
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 18;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 4A;
      #return-to: 184A
      advance (17)
      B := 10;
      SPH := a20[15:8];
      SPL := a20[7:0];
      jump (1439);
    }

1831:

    #1831
    #instruction: JP   1828
    advance (10)
    jump (1828);

1834:

    #1834
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 37;
    #return-to: 1837
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (0AB1);

1837:

    #1837
    #instruction: LD   BC,1DCF
    advance (10)
    B := 1D;
    C := CF;
    jump (183A);

183A:

    #183A
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3D;
    #return-to: 183D
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1856);

183D:

    #183D
    #instruction: RET  CY
    if (FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #183E
      #instruction: CALL 184C
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 18;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 41;
      #return-to: 1841
      advance (17)
      SPH := a14[15:8];
      SPL := a14[7:0];
      jump (184C);
    }

1841:

    #1841
    #instruction: JP   183A
    advance (10)
    jump (183A);

184A:

    #184A
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #184B
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    B := a8;
    C := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

184C:

    #184C
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #184D
    #instruction: LD   A,(206C)
    let:8 a9 = M[206C] in
    advance (13)
    #1850
    #instruction: LD   C,A
    let:8 a10 = a9 in
    advance (5)
    #1851
    #instruction: CALL 0A93
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 18;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := 54;
    #return-to: 1854
    advance (17)
    A := a9;
    C := a10;
    SPH := a16[15:8];
    SPL := a16[7:0];
    jump (0A93);

1854:

    #1854
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #1855
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    B := a8;
    C := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

1856:

    #1856
    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1857
    #instruction: CP   FF
    let:8 a4 = a3 in
    let:16 a5 = addWithCarry(!false,a4,~FF) in
    let:8 a6 = (a4 & 0F) in
    let:8 a7 = (~FF & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a5[7:0])) {
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := a3;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := true;
      jump ((a16,a12));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      let:8 a17 = a3 in
      advance (5)
      #185C
      #instruction: INC  BC
      let:8 a18 = B in
      let:8 a19 = C in
      let:16 a20 = (1 + (a18,a19)) in
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      let:8 a21 = a20[15:8] in
      let:8 a22 = a20[7:0] in
      let:8 a23 = M[(a21,a22)] in
      advance (7)
      #185E
      #instruction: LD   H,A
      let:8 a24 = a23 in
      advance (5)
      #185F
      #instruction: INC  BC
      let:8 a25 = a20[15:8] in
      let:8 a26 = a20[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:8 a30 = M[(a28,a29)] in
      advance (7)
      #1861
      #instruction: LD   E,A
      let:8 a31 = a30 in
      advance (5)
      #1862
      #instruction: INC  BC
      let:8 a32 = a27[15:8] in
      let:8 a33 = a27[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      let:8 a35 = a34[15:8] in
      let:8 a36 = a34[7:0] in
      let:8 a37 = M[(a35,a36)] in
      advance (7)
      #1864
      #instruction: LD   D,A
      let:8 a38 = a37 in
      advance (5)
      #1865
      #instruction: INC  BC
      let:8 a39 = a34[15:8] in
      let:8 a40 = a34[7:0] in
      let:16 a41 = (1 + (a39,a40)) in
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a42 = a37 in
      let:8 a43 = a37 in
      let:8 a44 = (a42 & a43) in
      let:8 a45 = (a42 | a43) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a46 = SPH in
      let:8 a47 = SPL in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (10)
      A := a44;
      B := a41[15:8];
      C := a41[7:0];
      D := a38;
      E := a31;
      H := a24;
      L := a17;
      SPH := a52[15:8];
      SPL := a52[7:0];
      FlagS := a44[7];
      FlagZ := is_zero(a44);
      FlagA := a45[3];
      FlagP := parity(a44);
      FlagCY := false;
      jump ((a53,a49));
    }

1871:

    #1871
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    #1872
    #instruction: LD   A,(20CA)
    let:8 a2 = M[20CA] in
    advance (13)
    #1875
    #instruction: CP   B
    let:8 a3 = a2 in
    let:8 a4 = a1 in
    let:16 a5 = addWithCarry(!false,a3,~a4) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~a4 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (4)
    #1876
    #instruction: JP   Z,1898
    if (is_zero(a5[7:0])) {
      advance (10)
      #1898
      #instruction: LD   A,01
      advance (7)
      #189A
      #instruction: LD   (20CB),A
      M[20CB] := 01;
      advance (13)
      #189D
      #instruction: RET
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (10)
      A := 01;
      B := a1;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((a16,a12));
    } else {
      advance (10)
      #1879
      #instruction: LD   A,(20C2)
      let:8 a17 = M[20C2] in
      advance (13)
      #187C
      #instruction: AND  04
      let:8 a18 = a17 in
      let:8 a19 = (04 & a18) in
      let:8 a20 = (04 | a18) in
      advance (7)
      #187E
      #instruction: LD   HL,(20CC)
      let:8 a21 = M[20CC] in
      let:8 a22 = M[20CD] in
      advance (16)
      #1881
      #instruction: JP   NZ,1888
      if (!is_zero(a19)) {
        advance (10)
        A := a19;
        B := a1;
        H := a22;
        L := a21;
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump (1888);
      } else {
        advance (10)
        #1884
        #instruction: LD   DE,0030
        advance (10)
        #1887
        #instruction: ADD  HL,DE
        let:8 a23 = a22 in
        let:8 a24 = a21 in
        let:17 a25 = add17(0030,(a23,a24)) in
        advance (10)
        A := a19;
        B := a1;
        D := 00;
        E := 30;
        H := a25[15:0][15:8];
        L := a25[15:0][7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := a25[16];
        jump (1888);
      }
    }

1888:

    #1888
    #instruction: LD   (20C7),HL
    let:8 a1 = L in
    M[20C7] := a1;
    let:8 a2 = H in
    M[20C8] := a2;
    advance (16)
    #188B
    #instruction: LD   HL,20C5
    advance (10)
    #188E
    #instruction: CALL 1A3B
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 18;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 91;
    #return-to: 1891
    advance (17)
    H := 20;
    L := C5;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (1A3B);

1891:

    #1891
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = H in
    let:8 a4 = L in
    advance (4)
    #1892
    #instruction: JP   15D3
    advance (10)
    D := a3;
    E := a4;
    H := a1;
    L := a2;
    jump (15D3);

18A9:

    #18A9
    #instruction: LD   A,02
    advance (7)
    #18AB
    #instruction: LD   (2080),A
    M[2080] := 02;
    advance (13)
    #18AE
    #instruction: LD   A,FF
    advance (7)
    #18B0
    #instruction: LD   (207E),A
    M[207E] := FF;
    advance (13)
    #18B3
    #instruction: LD   A,04
    advance (7)
    #18B5
    #instruction: LD   (20C1),A
    M[20C1] := 04;
    advance (13)
    A := 04;
    jump (18B8);

18B8:

    #18B8
    #instruction: LD   A,(2055)
    let:8 a1 = M[2055] in
    advance (13)
    #18BB
    #instruction: AND  01
    let:8 a2 = a1 in
    let:8 a3 = (01 & a2) in
    let:8 a4 = (01 | a2) in
    advance (7)
    #18BD
    #instruction: JP   Z,18B8
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (18B8);
    } else {
      advance (10)
      A := a3;
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (18C0);
    }

18C0:

    #18C0
    #instruction: LD   A,(2055)
    let:8 a1 = M[2055] in
    advance (13)
    #18C3
    #instruction: AND  01
    let:8 a2 = a1 in
    let:8 a3 = (01 & a2) in
    let:8 a4 = (01 | a2) in
    advance (7)
    #18C5
    #instruction: JP   NZ,18C0
    if (!is_zero(a3)) {
      advance (10)
      A := a3;
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (18C0);
    } else {
      advance (10)
      #18C8
      #instruction: LD   HL,3311
      advance (10)
      #18CB
      #instruction: LD   A,26
      advance (7)
      #18CD
      #instruction: NOP
      advance (4)
      #18CE
      #instruction: CALL 08FF
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (-1 + (a5,a6)) in
      M[a7] := 18;
      let:8 a8 = a7[15:8] in
      let:8 a9 = a7[7:0] in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := D1;
      #return-to: 18D1
      advance (17)
      A := 26;
      H := 33;
      L := 11;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (08FF);
    }

18D1:

    #18D1
    #instruction: JP   0AB6
    advance (10)
    jump (0AB6);

18DC:

    #18DC
    #instruction: CALL 1956
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DF;
    #return-to: 18DF
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1956);

18DF:

    #18DF
    #instruction: LD   A,08
    advance (7)
    #18E1
    #instruction: LD   (20CF),A
    M[20CF] := 08;
    advance (13)
    #18E4
    #instruction: JP   0AEA
    advance (10)
    #0AEA
    #instruction: XOR  A
    let:8 a1 = (08 ^ 08) in
    advance (4)
    #0AEB
    #instruction: OUT  03
    let:8 a2 = a1 in
    sound_control(Ufo,a2[0]);
    sound_control(Shot,a2[1]);
    sound_control(PlayerDie,a2[2]);
    sound_control(InvaderDie,a2[3]);
    sound_control(ExtraLife,a2[4]);
    advance (10)
    #0AED
    #instruction: OUT  05
    let:8 a3 = a1 in
    sound_control(FleetMovement1,a3[0]);
    sound_control(FleetMovement2,a3[1]);
    sound_control(FleetMovement3,a3[2]);
    sound_control(FleetMovement4,a3[3]);
    sound_control(UfoHit,a3[4]);
    advance (10)
    #0AEF
    #instruction: CALL 1982
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0A;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := F2;
    #return-to: 0AF2
    advance (17)
    #1982
    #instruction: LD   (20C1),A
    let:8 a10 = a1 in
    M[20C1] := a10;
    advance (13)
    #1985
    #instruction: RET
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    advance (10)
    A := a1;
    SPH := a17[15:8];
    SPL := a17[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((a18,a14));

18E7:

    #18E7
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #18EA
    #instruction: LD   HL,20E7
    advance (10)
    #18ED
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #18EE
    #instruction: RET  NC
    if (!a2[0]) {
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (1 + (a3,a4)) in
      let:8 a6 = M[(a3,a4)] in
      let:8 a7 = a5[15:8] in
      let:8 a8 = a5[7:0] in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      advance (11)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := E7;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagCY := a2[0];
      jump ((a10,a6));
    } else {
      advance (5)
      #18EF
      #instruction: INC  HL
      advance (5)
      #18F0
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := E8;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagCY := a2[0];
      jump ((a18,a14));
    }

18FA:

    #18FA
    #instruction: LD   A,(2094)
    let:8 a1 = M[2094] in
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a2 = B in
    let:8 a3 = a1 in
    let:8 a4 = (a2 | a3) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    let:8 a5 = a4 in
    M[2094] := a5;
    advance (13)
    #1901
    #instruction: OUT  03
    let:8 a6 = a4 in
    sound_control(Ufo,a6[0]);
    sound_control(Shot,a6[1]);
    sound_control(PlayerDie,a6[2]);
    sound_control(InvaderDie,a6[3]);
    sound_control(ExtraLife,a6[4]);
    advance (10)
    #1903
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a4;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump ((a14,a10));

1904:

    #1904
    #instruction: LD   HL,2200
    advance (10)
    #1907
    #instruction: JP   01C3
    advance (10)
    H := 22;
    L := 00;
    jump (01C3);

190A:

    #190A
    #instruction: CALL 14D8
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0D;
    #return-to: 190D
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14D8);

190D:

    #190D
    #instruction: JP   1597
    advance (10)
    #1597
    #instruction: LD   A,(200D)
    let:8 a1 = M[200D] in
    advance (13)
    #159A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #159B
    #instruction: JP   NZ,15B7
    if (!is_zero(a4)) {
      advance (10)
      #15B7
      #instruction: LD   HL,2524
      advance (10)
      #15BA
      #instruction: CALL 15C5
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 15;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := BD;
      #return-to: 15BD
      advance (17)
      A := a4;
      H := 25;
      L := 24;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (15C5);
    } else {
      advance (10)
      #159E
      #instruction: LD   HL,3EA4
      advance (10)
      #15A1
      #instruction: CALL 15C5
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 15;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := A4;
      #return-to: 15A4
      advance (17)
      A := a4;
      H := 3E;
      L := A4;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (15C5);
    }

1910:

    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #1916
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #1917
    #instruction: RET  CY
    if (a2[0]) {
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (1 + (a3,a4)) in
      let:8 a6 = M[(a3,a4)] in
      let:8 a7 = a5[15:8] in
      let:8 a8 = a5[7:0] in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      advance (11)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := E7;
      SPH := a9[15:8];
      SPL := a9[7:0];
      FlagCY := a2[0];
      jump ((a10,a6));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := updateBit((a2 >> 01),7,a2[0]);
      H := 20;
      L := E8;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagCY := a2[0];
      jump ((a18,a14));
    }

1925:

    #1925
    #instruction: LD   HL,20F8
    advance (10)
    #1928
    #instruction: JP   1931
    advance (10)
    H := 20;
    L := F8;
    jump (1931);

192B:

    #192B
    #instruction: LD   HL,20FC
    advance (10)
    #192E
    #instruction: JP   1931
    advance (10)
    H := 20;
    L := FC;
    jump (1931);

1931:

    #1931
    #instruction: LD   E,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1932
    #instruction: INC  HL
    let:8 a4 = H in
    let:8 a5 = L in
    let:16 a6 = (1 + (a4,a5)) in
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1934
    #instruction: INC  HL
    let:8 a10 = a6[15:8] in
    let:8 a11 = a6[7:0] in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #1936
    #instruction: INC  HL
    let:8 a16 = a12[15:8] in
    let:8 a17 = a12[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:8 a21 = M[(a19,a20)] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a22 = a15 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    A := a15;
    D := a9;
    E := a3;
    H := a21;
    L := a22;
    jump (09AD);

193C:

    #193C
    #instruction: LD   C,07
    advance (7)
    #193E
    #instruction: LD   HL,3501
    advance (10)
    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    #1944
    #instruction: JP   08F3
    advance (10)
    C := 07;
    D := 1F;
    E := A9;
    H := 35;
    L := 01;
    jump (08F3);

1947:

    #1947
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    #194A
    #instruction: LD   HL,3C01
    advance (10)
    #194D
    #instruction: JP   09B2
    advance (10)
    A := a1;
    H := 3C;
    L := 01;
    jump (09B2);

1950:

    #1950
    #instruction: LD   HL,20F4
    advance (10)
    #1953
    #instruction: JP   1931
    advance (10)
    H := 20;
    L := F4;
    jump (1931);

1956:

    #1956
    #instruction: CALL 1A5C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 59;
    #return-to: 1959
    advance (17)
    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    H := 24;
    L := 00;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1A5F);

1959:

    #1959
    #instruction: CALL 191A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 5C;
    #return-to: 195C
    advance (17)
    #191A
    #instruction: LD   C,1C
    advance (7)
    #191C
    #instruction: LD   HL,241E
    advance (10)
    #191F
    #instruction: LD   DE,1AE4
    advance (10)
    #1922
    #instruction: JP   08F3
    advance (10)
    C := 1C;
    D := 1A;
    E := E4;
    H := 24;
    L := 1E;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (08F3);

195C:

    #195C
    #instruction: CALL 1925
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 5F;
    #return-to: 195F
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1925);

195F:

    #195F
    #instruction: CALL 192B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 62;
    #return-to: 1962
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (192B);

1962:

    #1962
    #instruction: CALL 1950
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 65;
    #return-to: 1965
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1950);

1965:

    #1965
    #instruction: CALL 193C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 68;
    #return-to: 1968
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (193C);

1968:

    #1968
    #instruction: JP   1947
    advance (10)
    jump (1947);

196E:

    #196E
    #instruction: JP   1671
    advance (10)
    jump (1671);

197C:

    #197C
    #instruction: CALL 1947
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7F;
    #return-to: 197F
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (1947);

197F:

    #197F
    #instruction: JP   193C
    advance (10)
    jump (193C);

19AC:

    #19AC
    #instruction: IN   01
    advance (10)
    #19AE
    #instruction: AND  76
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    let:8 a2 = (76 & a1) in
    let:8 a3 = (76 | a1) in
    advance (7)
    #19B0
    #instruction: CP   34
    let:8 a4 = a2 in
    let:16 a5 = addWithCarry(!false,a4,~34) in
    let:8 a6 = (a4 & 0F) in
    let:8 a7 = (~34 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (7)
    #19B2
    #instruction: RET  NZ
    if (!is_zero(a5[7:0])) {
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := a2;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((a16,a12));
    } else {
      advance (5)
      #19B3
      #instruction: LD   HL,2E1B
      advance (10)
      #19B6
      #instruction: LD   DE,0BF7
      advance (10)
      #19B9
      #instruction: LD   C,09
      advance (7)
      #19BB
      #instruction: JP   08F3
      advance (10)
      A := a2;
      C := 09;
      D := 0B;
      E := F7;
      H := 2E;
      L := 1B;
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump (08F3);
    }

19D1:

    #19D1
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (19D3);

19D3:

    #19D3
    #instruction: LD   (20E9),A
    let:8 a1 = A in
    M[20E9] := a1;
    advance (13)
    #19D6
    #instruction: RET
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (1 + (a2,a3)) in
    let:8 a5 = M[(a2,a3)] in
    let:8 a6 = a4[15:8] in
    let:8 a7 = a4[7:0] in
    let:16 a8 = (1 + (a6,a7)) in
    let:8 a9 = M[(a6,a7)] in
    advance (10)
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump ((a9,a5));

19D7:

    #19D7
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #19D8
    #instruction: JP   19D3
    advance (10)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (19D3);

19DC:

    #19DC
    #instruction: LD   A,(2094)
    let:8 a1 = M[2094] in
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a2 = B in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    let:8 a6 = a4 in
    M[2094] := a6;
    advance (13)
    #19E3
    #instruction: OUT  03
    let:8 a7 = a4 in
    sound_control(Ufo,a7[0]);
    sound_control(Shot,a7[1]);
    sound_control(PlayerDie,a7[2]);
    sound_control(InvaderDie,a7[3]);
    sound_control(ExtraLife,a7[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:8 a8 = SPH in
    let:8 a9 = SPL in
    let:16 a10 = (1 + (a8,a9)) in
    let:8 a11 = M[(a8,a9)] in
    let:8 a12 = a10[15:8] in
    let:8 a13 = a10[7:0] in
    let:16 a14 = (1 + (a12,a13)) in
    let:8 a15 = M[(a12,a13)] in
    advance (10)
    A := a4;
    SPH := a14[15:8];
    SPL := a14[7:0];
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump ((a15,a11));

19EC:

    #19EC
    #instruction: LD   DE,1C60
    advance (10)
    #19EF
    #instruction: LD   B,10
    advance (7)
    #19F1
    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    #19F2
    #instruction: CALL 1439
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 19;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := F5;
    #return-to: 19F5
    advance (17)
    B := 10;
    C := a1;
    D := 1C;
    E := 60;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump (1439);

19F5:

    #19F5
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #19F6
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #19F7
    #instruction: JP   NZ,19EC
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a3[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (19EC);
    } else {
      advance (10)
      A := a3[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump (19FA);
    }

19FA:

    #19FA
    #instruction: LD   B,10
    advance (7)
    #19FC
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FF;
    #return-to: 19FF
    advance (17)
    B := 10;
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (14CB);

19FF:

    #19FF
    #instruction: LD   A,H
    let:8 a1 = H in
    advance (5)
    #1A00
    #instruction: CP   35
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~35) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~35 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1A02
    #instruction: JP   NZ,19FA
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (19FA);
    } else {
      advance (10)
      #1A05
      #instruction: RET
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (10)
      A := a1;
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    }

1A06:

    #1A06
    #instruction: LD   HL,2072
    advance (10)
    #1A09
    #instruction: LD   B,(HL)
    let:8 a1 = M[2072] in
    advance (7)
    #1A0A
    #instruction: LD   A,(DE)
    let:8 a2 = D in
    let:8 a3 = E in
    let:8 a4 = M[(a2,a3)] in
    advance (7)
    #1A0B
    #instruction: AND  80
    let:8 a5 = a4 in
    let:8 a6 = (80 & a5) in
    let:8 a7 = (80 | a5) in
    advance (7)
    #1A0D
    #instruction: XOR  B
    let:8 a8 = a1 in
    let:8 a9 = a6 in
    let:8 a10 = (a8 ^ a9) in
    advance (4)
    #1A0E
    #instruction: RET  NZ
    if (!is_zero(a10)) {
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (11)
      A := a10;
      B := a1;
      H := 20;
      L := 72;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := false;
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a18,a14));
    } else {
      advance (5)
      #1A0F
      #instruction: SCF
      advance (4)
      #1A10
      #instruction: RET
      let:8 a19 = SPH in
      let:8 a20 = SPL in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      let:8 a23 = a21[15:8] in
      let:8 a24 = a21[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      advance (10)
      A := a10;
      B := a1;
      H := 20;
      L := 72;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := false;
      FlagP := parity(a10);
      FlagCY := true;
      jump ((a26,a22));
    }

1A32:

    #1A32
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    let:8 a4 = a3 in
    let:8 a5 = H in
    let:8 a6 = L in
    M[(a5,a6)] := a4;
    advance (7)
    #1A34
    #instruction: INC  HL
    let:8 a7 = H in
    let:8 a8 = L in
    let:16 a9 = (1 + (a7,a8)) in
    advance (5)
    #1A35
    #instruction: INC  DE
    let:8 a10 = D in
    let:8 a11 = E in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1A36
    #instruction: DEC  B
    let:8 a13 = B in
    let:16 a14 = addWithCarry(!true,a13,~00) in
    let:8 a15 = (a13 & 0F) in
    let:8 a16 = (~00 & 0F) in
    let:16 a17 = addWithCarry(!true,a15,a16) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a14[7:0])) {
      advance (10)
      A := a3;
      B := a14[7:0];
      D := a12[15:8];
      E := a12[7:0];
      H := a9[15:8];
      L := a9[7:0];
      FlagS := a14[7:0][7];
      FlagZ := is_zero(a14[7:0]);
      FlagA := a17[7:0][4];
      FlagP := parity(a14[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a18 = SPH in
      let:8 a19 = SPL in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      let:8 a22 = a20[15:8] in
      let:8 a23 = a20[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      advance (10)
      A := a3;
      B := a14[7:0];
      D := a12[15:8];
      E := a12[7:0];
      H := a9[15:8];
      L := a9[7:0];
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a14[7:0][7];
      FlagZ := is_zero(a14[7:0]);
      FlagA := a17[7:0][4];
      FlagP := parity(a14[7:0]);
      jump ((a25,a21));
    }

1A3B:

    #1A3B
    #instruction: LD   E,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1A3C
    #instruction: INC  HL
    let:8 a4 = H in
    let:8 a5 = L in
    let:16 a6 = (1 + (a4,a5)) in
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1A3E
    #instruction: INC  HL
    let:8 a10 = a6[15:8] in
    let:8 a11 = a6[7:0] in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #1A40
    #instruction: INC  HL
    let:8 a16 = a12[15:8] in
    let:8 a17 = a12[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:8 a21 = M[(a19,a20)] in
    advance (7)
    #1A42
    #instruction: INC  HL
    let:8 a22 = a18[15:8] in
    let:8 a23 = a18[7:0] in
    let:16 a24 = (1 + (a22,a23)) in
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:8 a27 = M[(a25,a26)] in
    advance (7)
    #1A44
    #instruction: LD   H,C
    let:8 a28 = a21 in
    advance (5)
    #1A45
    #instruction: LD   L,A
    let:8 a29 = a15 in
    advance (5)
    #1A46
    #instruction: RET
    let:8 a30 = SPH in
    let:8 a31 = SPL in
    let:16 a32 = (1 + (a30,a31)) in
    let:8 a33 = M[(a30,a31)] in
    let:8 a34 = a32[15:8] in
    let:8 a35 = a32[7:0] in
    let:16 a36 = (1 + (a34,a35)) in
    let:8 a37 = M[(a34,a35)] in
    advance (10)
    A := a15;
    B := a27;
    C := a21;
    D := a9;
    E := a3;
    H := a28;
    L := a29;
    SPH := a36[15:8];
    SPL := a36[7:0];
    jump ((a37,a33));

1A47:

    #1A47
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    B := 03;
    SPH := a8[15:8];
    SPL := a8[7:0];
    jump (1A4A);

1A4A:

    #1A4A
    #instruction: LD   A,H
    let:8 a1 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a2 = a1 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a3 = updateBit((a2 >> 01),7,FlagCY) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a4 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a5 = a4 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a6 = updateBit((a5 >> 01),7,a2[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:8 a7 = B in
    let:16 a8 = addWithCarry(!true,a7,~00) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (~00 & 0F) in
    let:16 a11 = addWithCarry(!true,a9,a10) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := updateBit((a5 >> 01),7,a2[0]);
      B := a8[7:0];
      H := a3;
      L := a6;
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := a5[0];
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a12 = a3 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a13 = a12 in
      let:8 a14 = (3F & a13) in
      let:8 a15 = (3F | a13) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a16 = a14 in
      let:8 a17 = (20 | a16) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a18 = a17 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a19 = SPH in
      let:8 a20 = SPL in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      let:8 a23 = a21[15:8] in
      let:8 a24 = a21[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      let:8 a31 = a29[15:8] in
      let:8 a32 = a29[7:0] in
      let:16 a33 = (1 + (a31,a32)) in
      let:8 a34 = M[(a31,a32)] in
      advance (10)
      A := a17;
      B := a26;
      C := a22;
      H := a18;
      L := a6;
      SPH := a33[15:8];
      SPL := a33[7:0];
      FlagS := a17[7];
      FlagZ := is_zero(a17);
      FlagA := false;
      FlagP := parity(a17);
      FlagCY := false;
      jump ((a34,a30));
    }

1A5F:

    #1A5F
    #instruction: LD   (HL),00
    let:8 a1 = H in
    let:8 a2 = L in
    M[(a1,a2)] := 00;
    advance (10)
    #1A61
    #instruction: INC  HL
    let:8 a3 = H in
    let:8 a4 = L in
    let:16 a5 = (1 + (a3,a4)) in
    advance (5)
    #1A62
    #instruction: LD   A,H
    let:8 a6 = a5[15:8] in
    advance (5)
    #1A63
    #instruction: CP   40
    let:8 a7 = a6 in
    let:16 a8 = addWithCarry(!false,a7,~40) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (~40 & 0F) in
    let:16 a11 = addWithCarry(!false,a9,a10) in
    advance (7)
    #1A65
    #instruction: JP   NZ,1A5F
    if (!is_zero(a8[7:0])) {
      advance (10)
      A := a6;
      H := a5[15:8];
      L := a5[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := !a8[15:8][0];
      jump (1A5F);
    } else {
      advance (10)
      #1A68
      #instruction: RET
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a6;
      H := a5[15:8];
      L := a5[7:0];
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a8[7:0][7];
      FlagZ := is_zero(a8[7:0]);
      FlagA := a11[7:0][4];
      FlagP := parity(a8[7:0]);
      FlagCY := !a8[15:8][0];
      jump ((a19,a15));
    }

1A69:

    #1A69
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1A6A
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    SPH := a16[15:8];
    SPL := a16[7:0];
    jump (1A6B);

1A6B:

    #1A6B
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #1A6C
    #instruction: OR   (HL)
    let:8 a4 = H in
    let:8 a5 = L in
    let:8 a6 = M[(a4,a5)] in
    let:8 a7 = a3 in
    let:8 a8 = (a6 | a7) in
    advance (7)
    #1A6D
    #instruction: LD   (HL),A
    let:8 a9 = a8 in
    let:8 a10 = H in
    let:8 a11 = L in
    M[(a10,a11)] := a9;
    advance (7)
    #1A6E
    #instruction: INC  DE
    let:8 a12 = D in
    let:8 a13 = E in
    let:16 a14 = (1 + (a12,a13)) in
    advance (5)
    #1A6F
    #instruction: INC  HL
    let:8 a15 = H in
    let:8 a16 = L in
    let:16 a17 = (1 + (a15,a16)) in
    advance (5)
    #1A70
    #instruction: DEC  C
    let:8 a18 = C in
    let:16 a19 = addWithCarry(!true,a18,~00) in
    let:8 a20 = (a18 & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1A71
    #instruction: JP   NZ,1A6B
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := a8;
      C := a19[7:0];
      D := a14[15:8];
      E := a14[7:0];
      H := a17[15:8];
      L := a17[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := false;
      jump (1A6B);
    } else {
      advance (10)
      #1A74
      #instruction: POP  HL
      let:8 a23 = SPH in
      let:8 a24 = SPL in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      #1A75
      #instruction: LD   BC,0020
      advance (10)
      #1A78
      #instruction: ADD  HL,BC
      let:8 a31 = a30 in
      let:8 a32 = a26 in
      let:17 a33 = add17(0020,(a31,a32)) in
      advance (10)
      #1A79
      #instruction: POP  BC
      let:8 a34 = a29[15:8] in
      let:8 a35 = a29[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      #1A7A
      #instruction: DEC  B
      let:8 a42 = a41 in
      let:16 a43 = addWithCarry(!true,a42,~00) in
      let:8 a44 = (a42 & 0F) in
      let:8 a45 = (~00 & 0F) in
      let:16 a46 = addWithCarry(!true,a44,a45) in
      advance (5)
      #1A7B
      #instruction: JP   NZ,1A69
      if (!is_zero(a43[7:0])) {
        advance (10)
        A := a8;
        B := a43[7:0];
        C := a37;
        D := a14[15:8];
        E := a14[7:0];
        H := a33[15:0][15:8];
        L := a33[15:0][7:0];
        SPH := a40[15:8];
        SPL := a40[7:0];
        FlagS := a43[7:0][7];
        FlagZ := is_zero(a43[7:0]);
        FlagA := a46[7:0][4];
        FlagP := parity(a43[7:0]);
        FlagCY := a33[16];
        jump (1A69);
      } else {
        advance (10)
        #1A7E
        #instruction: RET
        let:8 a47 = a40[15:8] in
        let:8 a48 = a40[7:0] in
        let:16 a49 = (1 + (a47,a48)) in
        let:8 a50 = M[(a47,a48)] in
        let:8 a51 = a49[15:8] in
        let:8 a52 = a49[7:0] in
        let:16 a53 = (1 + (a51,a52)) in
        let:8 a54 = M[(a51,a52)] in
        advance (10)
        A := a8;
        B := a43[7:0];
        C := a37;
        D := a14[15:8];
        E := a14[7:0];
        H := a33[15:0][15:8];
        L := a33[15:0][7:0];
        SPH := a53[15:8];
        SPL := a53[7:0];
        FlagS := a43[7:0][7];
        FlagZ := is_zero(a43[7:0]);
        FlagA := a46[7:0][4];
        FlagP := parity(a43[7:0]);
        FlagCY := a33[16];
        jump ((a54,a50));
      }
    }

1A7F:

    #1A7F
    #instruction: CALL 092E
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 1A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 82;
    #return-to: 1A82
    advance (17)
    SPH := a6[15:8];
    SPL := a6[7:0];
    jump (092E);

1A82:

    #1A82
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    #1A83
    #instruction: RET  Z
    if (is_zero(a3)) {
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      let:8 a9 = a7[15:8] in
      let:8 a10 = a7[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      advance (11)
      A := a3;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((a12,a8));
    } else {
      advance (5)
      #1A84
      #instruction: PUSH PSW
      let:8 a13 = a3 in
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := a13;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a3[7]),6,is_zero(a3)),4,a4[3]),2,parity(a3)),0,false);
      advance (11)
      #1A85
      #instruction: DEC  A
      let:8 a20 = a3 in
      let:16 a21 = addWithCarry(!true,a20,~00) in
      let:8 a22 = (a20 & 0F) in
      let:8 a23 = (~00 & 0F) in
      let:16 a24 = addWithCarry(!true,a22,a23) in
      advance (5)
      #1A86
      #instruction: LD   (HL),A
      let:8 a25 = a21[7:0] in
      let:8 a26 = H in
      let:8 a27 = L in
      M[(a26,a27)] := a25;
      advance (7)
      #1A87
      #instruction: CALL 19E6
      let:8 a28 = a19[15:8] in
      let:8 a29 = a19[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 1A;
      let:8 a31 = a30[15:8] in
      let:8 a32 = a30[7:0] in
      let:16 a33 = (-1 + (a31,a32)) in
      M[a33] := 8A;
      #return-to: 1A8A
      advance (17)
      #19E6
      #instruction: LD   HL,2701
      advance (10)
      #19E9
      #instruction: JP   Z,19FA
      if (is_zero(a21[7:0])) {
        advance (10)
        A := a21[7:0];
        H := 27;
        L := 01;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := false;
        jump (19FA);
      } else {
        advance (10)
        A := a21[7:0];
        H := 27;
        L := 01;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := false;
        jump (19EC);
      }
    }

1A8A:

    #1A8A
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    A := a8;
    SPH := a7[15:8];
    SPL := a7[7:0];
    FlagS := a4[7];
    FlagZ := a4[6];
    FlagA := a4[4];
    FlagP := a4[2];
    FlagCY := a4[0];
    jump (1A8B);

1A8B:

    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a1 = A in
    let:8 a2 = (0F & a1) in
    let:8 a3 = (0F | a1) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    A := a2;
    H := 25;
    L := 01;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (09C5);
