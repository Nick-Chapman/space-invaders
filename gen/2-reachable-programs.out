
0000:

    #0000
    #instruction: NOP
    advance (4)
    jump (0001);

0001:

    #0001
    #instruction: NOP
    advance (4)
    jump (0002);

0002:

    #0002
    #instruction: NOP
    advance (4)
    jump (0003);

0003:

    #0003
    #instruction: JP   18D4
    advance (10)
    jump (18D4);

0008:

    #0008
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (0009);

0009:

    #0009
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (000A);

000A:

    #000A
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (000B);

000B:

    #000B
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (000C);

000C:

    #000C
    #instruction: JP   008C
    advance (10)
    jump (008C);

0010:

    #0010
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (0011);

0011:

    #0011
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (0012);

0012:

    #0012
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (0013);

0013:

    #0013
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0014);

0014:

    #0014
    #instruction: LD   A,80
    advance (7)
    A := 80;
    jump (0016);

0016:

    #0016
    #instruction: LD   (2072),A
    let:8 a1 = A in
    M[2072] := a1;
    advance (13)
    jump (0019);

0019:

    #0019
    #instruction: LD   HL,20C0
    advance (10)
    HL := 20C0;
    jump (001C);

001C:

    #001C
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (001D);

001D:

    #001D
    #instruction: CALL 17CD
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 20;
    #return-to: 0020
    advance (17)
    SP := a3;
    jump (17CD);

0020:

    #0020
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (0022);

0022:

    #0022
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0023);

0023:

    #0023
    #instruction: JP   CY,0067
    if (FlagCY) {
      advance (10)
      jump (0067);
    } else {
      advance (10)
      jump (0026);
    }

0026:

    #0026
    #instruction: LD   A,(20EA)
    let:8 a1 = M[20EA] in
    advance (13)
    A := a1;
    jump (0029);

0029:

    #0029
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (002A);

002A:

    #002A
    #instruction: JP   Z,0042
    if (FlagZ) {
      advance (10)
      jump (0042);
    } else {
      advance (10)
      jump (002D);
    }

002D:

    #002D
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    A := a1;
    jump (0030);

0030:

    #0030
    #instruction: CP   99
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~99) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~99 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0032);

0032:

    #0032
    #instruction: JP   Z,003E
    if (FlagZ) {
      advance (10)
      jump (003E);
    } else {
      advance (10)
      jump (0035);
    }

0035:

    #0035
    #instruction: ADD  01
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,01,a1) in
    let:8 a3 = (01 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (0037);

0037:

    #0037
    #instruction: DAA
    let:8 a1 = A in
    let:8 a2 = (a1 & 0F) in
    let:16 a3 = addWithCarry(false,a2,06) in
    let:16 a4 = addWithCarry(((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4],(a1 >> 04),00) in
    let:16 a5 = addWithCarry(false,a4[7:0],06) in
    let:8 a6 = (((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2) & 0F) in
    let:8 a7 = ((((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0]) << 04) | a6) in
    advance (4)
    A := a7;
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := ((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4];
    FlagP := parity(a7);
    FlagCY := (((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0])[4] || FlagCY);
    jump (0038);

0038:

    #0038
    #instruction: LD   (20EB),A
    let:8 a1 = A in
    M[20EB] := a1;
    advance (13)
    jump (003B);

003B:

    #003B
    #instruction: CALL 1947
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3E;
    #return-to: 003E
    advance (17)
    SP := a3;
    jump (1947);

003E:

    #003E
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (003F);

003F:

    #003F
    #instruction: LD   (20EA),A
    let:8 a1 = A in
    M[20EA] := a1;
    advance (13)
    jump (0042);

0042:

    #0042
    #instruction: LD   A,(20E9)
    let:8 a1 = M[20E9] in
    advance (13)
    A := a1;
    jump (0045);

0045:

    #0045
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0046);

0046:

    #0046
    #instruction: JP   Z,0082
    if (FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0049);
    }

0049:

    #0049
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (004C);

004C:

    #004C
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (004D);

004D:

    #004D
    #instruction: JP   NZ,006F
    if (!FlagZ) {
      advance (10)
      jump (006F);
    } else {
      advance (10)
      jump (0050);
    }

0050:

    #0050
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    A := a1;
    jump (0053);

0053:

    #0053
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0054);

0054:

    #0054
    #instruction: JP   NZ,005D
    if (!FlagZ) {
      advance (10)
      jump (005D);
    } else {
      advance (10)
      jump (0057);
    }

0057:

    #0057
    #instruction: CALL 0ABF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 5A;
    #return-to: 005A
    advance (17)
    SP := a3;
    jump (0ABF);

005A:

    #005A
    #instruction: JP   0082
    advance (10)
    jump (0082);

005D:

    #005D
    #instruction: LD   A,(2093)
    let:8 a1 = M[2093] in
    advance (13)
    A := a1;
    jump (0060);

0060:

    #0060
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0061);

0061:

    #0061
    #instruction: JP   NZ,0082
    if (!FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0064);
    }

0064:

    #0064
    #instruction: JP   0765
    advance (10)
    jump (0765);

0067:

    #0067
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0069);

0069:

    #0069
    #instruction: LD   (20EA),A
    let:8 a1 = A in
    M[20EA] := a1;
    advance (13)
    jump (006C);

006C:

    #006C
    #instruction: JP   003F
    advance (10)
    jump (003F);

006F:

    #006F
    #instruction: CALL 1740
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 72;
    #return-to: 0072
    advance (17)
    SP := a3;
    jump (1740);

0072:

    #0072
    #instruction: LD   A,(2032)
    let:8 a1 = M[2032] in
    advance (13)
    A := a1;
    jump (0075);

0075:

    #0075
    #instruction: LD   (2080),A
    let:8 a1 = A in
    M[2080] := a1;
    advance (13)
    jump (0078);

0078:

    #0078
    #instruction: CALL 0100
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7B;
    #return-to: 007B
    advance (17)
    SP := a3;
    jump (0100);

007B:

    #007B
    #instruction: CALL 0248
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7E;
    #return-to: 007E
    advance (17)
    SP := a3;
    jump (0248);

007E:

    #007E
    #instruction: CALL 0913
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := 81;
    #return-to: 0081
    advance (17)
    SP := a3;
    jump (0913);

0081:

    #0081
    #instruction: NOP
    advance (4)
    jump (0082);

0082:

    #0082
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0083);

0083:

    #0083
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (0084);

0084:

    #0084
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (0085);

0085:

    #0085
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (0086);

0086:

    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (0087);

0087:

    #0087
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

008C:

    #008C
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (008D);

008D:

    #008D
    #instruction: LD   (2072),A
    let:8 a1 = A in
    M[2072] := a1;
    advance (13)
    jump (0090);

0090:

    #0090
    #instruction: LD   A,(20E9)
    let:8 a1 = M[20E9] in
    advance (13)
    A := a1;
    jump (0093);

0093:

    #0093
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0094);

0094:

    #0094
    #instruction: JP   Z,0082
    if (FlagZ) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (0097);
    }

0097:

    #0097
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (009A);

009A:

    #009A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (009B);

009B:

    #009B
    #instruction: JP   NZ,00A5
    if (!FlagZ) {
      advance (10)
      jump (00A5);
    } else {
      advance (10)
      jump (009E);
    }

009E:

    #009E
    #instruction: LD   A,(20C1)
    let:8 a1 = M[20C1] in
    advance (13)
    A := a1;
    jump (00A1);

00A1:

    #00A1
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (00A2);

00A2:

    #00A2
    #instruction: JP   NC,0082
    if (!FlagCY) {
      advance (10)
      jump (0082);
    } else {
      advance (10)
      jump (00A5);
    }

00A5:

    #00A5
    #instruction: LD   HL,2020
    advance (10)
    HL := 2020;
    jump (00A8);

00A8:

    #00A8
    #instruction: CALL 024B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := AB;
    #return-to: 00AB
    advance (17)
    SP := a3;
    jump (024B);

00AB:

    #00AB
    #instruction: CALL 0141
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := AE;
    #return-to: 00AE
    advance (17)
    SP := a3;
    jump (0141);

00AE:

    #00AE
    #instruction: JP   0082
    advance (10)
    jump (0082);

00B1:

    #00B1
    #instruction: CALL 0886
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 00;
    let:16 a3 = (-1 + a2) in
    M[a3] := B4;
    #return-to: 00B4
    advance (17)
    SP := a3;
    jump (0886);

00B4:

    #00B4
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (00B5);

00B5:

    #00B5
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (00B6);

00B6:

    #00B6
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (00B7);

00B7:

    #00B7
    #instruction: LD   H,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a2,a3[7:0]);
    jump (00B8);

00B8:

    #00B8
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (00B9);

00B9:

    #00B9
    #instruction: LD   (2009),HL
    let:16 a1 = HL in
    M[2009] := a1[7:0];
    let:16 a2 = HL in
    M[200A] := a2[15:8];
    advance (16)
    jump (00BC);

00BC:

    #00BC
    #instruction: LD   (200B),HL
    let:16 a1 = HL in
    M[200B] := a1[7:0];
    let:16 a2 = HL in
    M[200C] := a2[15:8];
    advance (16)
    jump (00BF);

00BF:

    #00BF
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (00C0);

00C0:

    #00C0
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (00C1);

00C1:

    #00C1
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (00C2);

00C2:

    #00C2
    #instruction: CP   03
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~03) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~03 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (00C4);

00C4:

    #00C4
    #instruction: JP   NZ,00C8
    if (!FlagZ) {
      advance (10)
      jump (00C8);
    } else {
      advance (10)
      jump (00C7);
    }

00C7:

    #00C7
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (00C8);

00C8:

    #00C8
    #instruction: LD   (2008),A
    let:8 a1 = A in
    M[2008] := a1;
    advance (13)
    jump (00CB);

00CB:

    #00CB
    #instruction: CP   FE
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FE) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FE & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (00CD);

00CD:

    #00CD
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (00CF);

00CF:

    #00CF
    #instruction: JP   NZ,00D3
    if (!FlagZ) {
      advance (10)
      jump (00D3);
    } else {
      advance (10)
      jump (00D2);
    }

00D2:

    #00D2
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (00D3);

00D3:

    #00D3
    #instruction: LD   (200D),A
    let:8 a1 = A in
    M[200D] := a1;
    advance (13)
    jump (00D6);

00D6:

    #00D6
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

00D7:

    #00D7
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (00D9);

00D9:

    #00D9
    #instruction: LD   (21FB),A
    let:8 a1 = A in
    M[21FB] := a1;
    advance (13)
    jump (00DC);

00DC:

    #00DC
    #instruction: LD   (22FB),A
    let:8 a1 = A in
    M[22FB] := a1;
    advance (13)
    jump (00DF);

00DF:

    #00DF
    #instruction: JP   08E4
    advance (10)
    jump (08E4);

0100:

    #0100
    #instruction: LD   HL,2002
    advance (10)
    HL := 2002;
    jump (0103);

0103:

    #0103
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0104);

0104:

    #0104
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0105);

0105:

    #0105
    #instruction: JP   NZ,1538
    if (!FlagZ) {
      advance (10)
      jump (1538);
    } else {
      advance (10)
      jump (0108);
    }

0108:

    #0108
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0109);

0109:

    #0109
    #instruction: LD   A,(2006)
    let:8 a1 = M[2006] in
    advance (13)
    A := a1;
    jump (010C);

010C:

    #010C
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (010D);

010D:

    #010D
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (0110);

0110:

    #0110
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (0111);

0111:

    #0111
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0112);

0112:

    #0112
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0113);

0113:

    #0113
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0114);

0114:

    #0114
    #instruction: JP   Z,0136
    if (FlagZ) {
      advance (10)
      jump (0136);
    } else {
      advance (10)
      jump (0117);
    }

0117:

    #0117
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0118);

0118:

    #0118
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0119);

0119:

    #0119
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (011A);

011A:

    #011A
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (011B);

011B:

    #011B
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (011C);

011C:

    #011C
    #instruction: AND  FE
    let:8 a1 = A in
    let:8 a2 = (FE & a1) in
    let:8 a3 = (FE | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (011E);

011E:

    #011E
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (011F);

011F:

    #011F
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (0120);

0120:

    #0120
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (0121);

0121:

    #0121
    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump (0122);

0122:

    #0122
    #instruction: LD   D,00
    advance (7)
    D := 00;
    jump (0124);

0124:

    #0124
    #instruction: LD   HL,1C00
    advance (10)
    HL := 1C00;
    jump (0127);

0127:

    #0127
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (0128);

0128:

    #0128
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (0129);

0129:

    #0129
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (012A);

012A:

    #012A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (012B);

012B:

    #012B
    #instruction: CALL NZ,013B
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (-1 + a1) in
      M[a2] := 01;
      let:16 a3 = (-1 + a2) in
      M[a3] := 2E;
      #return-to: 012E
      advance (17)
      SP := a3;
      jump (013B);
    } else {
      advance (11)
      jump (012E);
    }

012E:

    #012E
    #instruction: LD   HL,(200B)
    let:8 a1 = M[200B] in
    let:16 a2 = HL in
    let:8 a3 = M[200C] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (0131);

0131:

    #0131
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0133);

0133:

    #0133
    #instruction: CALL 15D3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 01;
    let:16 a3 = (-1 + a2) in
    M[a3] := 36;
    #return-to: 0136
    advance (17)
    SP := a3;
    jump (15D3);

0136:

    #0136
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0137);

0137:

    #0137
    #instruction: LD   (2000),A
    let:8 a1 = A in
    M[2000] := a1;
    advance (13)
    jump (013A);

013A:

    #013A
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

013B:

    #013B
    #instruction: LD   HL,0030
    advance (10)
    HL := 0030;
    jump (013E);

013E:

    #013E
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (013F);

013F:

    #013F
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (0140);

0140:

    #0140
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0141:

    #0141
    #instruction: LD   A,(2068)
    let:8 a1 = M[2068] in
    advance (13)
    A := a1;
    jump (0144);

0144:

    #0144
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0145);

0145:

    #0145
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0146);
    }

0146:

    #0146
    #instruction: LD   A,(2000)
    let:8 a1 = M[2000] in
    advance (13)
    A := a1;
    jump (0149);

0149:

    #0149
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (014A);

014A:

    #014A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (014B);
    }

014B:

    #014B
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (014E);

014E:

    #014E
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (014F);

014F:

    #014F
    #instruction: LD   A,(2006)
    let:8 a1 = M[2006] in
    advance (13)
    A := a1;
    jump (0152);

0152:

    #0152
    #instruction: LD   D,02
    advance (7)
    D := 02;
    jump (0154);

0154:

    #0154
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0155);

0155:

    #0155
    #instruction: CP   37
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~37) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~37 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0157);

0157:

    #0157
    #instruction: CALL Z,01A1
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (-1 + a1) in
      M[a2] := 01;
      let:16 a3 = (-1 + a2) in
      M[a3] := 5A;
      #return-to: 015A
      advance (17)
      SP := a3;
      jump (01A1);
    } else {
      advance (11)
      jump (015A);
    }

015A:

    #015A
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (015B);

015B:

    #015B
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (015C);

015C:

    #015C
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (015D);

015D:

    #015D
    #instruction: JP   NZ,0154
    if (!FlagZ) {
      advance (10)
      jump (0154);
    } else {
      advance (10)
      jump (0160);
    }

0160:

    #0160
    #instruction: LD   (2006),A
    let:8 a1 = A in
    M[2006] := a1;
    advance (13)
    jump (0163);

0163:

    #0163
    #instruction: CALL 017A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 01;
    let:16 a3 = (-1 + a2) in
    M[a3] := 66;
    #return-to: 0166
    advance (17)
    SP := a3;
    jump (017A);

0166:

    #0166
    #instruction: LD   H,C
    let:8 a1 = C in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (0167);

0167:

    #0167
    #instruction: LD   (200B),HL
    let:16 a1 = HL in
    M[200B] := a1[7:0];
    let:16 a2 = HL in
    M[200C] := a2[15:8];
    advance (16)
    jump (016A);

016A:

    #016A
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (016B);

016B:

    #016B
    #instruction: CP   28
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~28) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~28 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (016D);

016D:

    #016D
    #instruction: JP   CY,1971
    if (FlagCY) {
      advance (10)
      jump (1971);
    } else {
      advance (10)
      jump (0170);
    }

0170:

    #0170
    #instruction: LD   A,D
    let:8 a1 = D in
    advance (5)
    A := a1;
    jump (0171);

0171:

    #0171
    #instruction: LD   (2004),A
    let:8 a1 = A in
    M[2004] := a1;
    advance (13)
    jump (0174);

0174:

    #0174
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0176);

0176:

    #0176
    #instruction: LD   (2000),A
    let:8 a1 = A in
    M[2000] := a1;
    advance (13)
    jump (0179);

0179:

    #0179
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

017A:

    #017A
    #instruction: LD   D,00
    advance (7)
    D := 00;
    jump (017C);

017C:

    #017C
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (017D);

017D:

    #017D
    #instruction: LD   HL,2009
    advance (10)
    HL := 2009;
    jump (0180);

0180:

    #0180
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (0181);

0181:

    #0181
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0182);

0182:

    #0182
    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump (0183);

0183:

    #0183
    #instruction: CP   0B
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0B) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0B & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0185);

0185:

    #0185
    #instruction: JP   MI,0194
    if (FlagS) {
      advance (10)
      jump (0194);
    } else {
      advance (10)
      jump (0188);
    }

0188:

    #0188
    #instruction: SBC  0B
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!FlagCY,a1,~0B) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0B & 0F) in
    let:16 a5 = addWithCarry(!FlagCY,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (018A);

018A:

    #018A
    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump (018B);

018B:

    #018B
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (018C);

018C:

    #018C
    #instruction: ADD  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,10,a1) in
    let:8 a3 = (10 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (018E);

018E:

    #018E
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (018F);

018F:

    #018F
    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    A := a1;
    jump (0190);

0190:

    #0190
    #instruction: INC  D
    let:8 a1 = D in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    D := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0191);

0191:

    #0191
    #instruction: JP   0183
    advance (10)
    jump (0183);

0194:

    #0194
    #instruction: LD   L,B
    let:8 a1 = B in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (0195);

0195:

    #0195
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0196);

0196:

    #0196
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0197);
    }

0197:

    #0197
    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump (0198);

0198:

    #0198
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (0199);

0199:

    #0199
    #instruction: ADD  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,10,a1) in
    let:8 a3 = (10 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (019B);

019B:

    #019B
    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    C := a1;
    jump (019C);

019C:

    #019C
    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    A := a1;
    jump (019D);

019D:

    #019D
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (019E);

019E:

    #019E
    #instruction: JP   0195
    advance (10)
    jump (0195);

01A1:

    #01A1
    #instruction: DEC  D
    let:8 a1 = D in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    D := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (01A2);

01A2:

    #01A2
    #instruction: JP   Z,01CD
    if (FlagZ) {
      advance (10)
      jump (01CD);
    } else {
      advance (10)
      jump (01A5);
    }

01A5:

    #01A5
    #instruction: LD   HL,2006
    advance (10)
    HL := 2006;
    jump (01A8);

01A8:

    #01A8
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (01AA);

01AA:

    #01AA
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (01AB);

01AB:

    #01AB
    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump (01AC);

01AC:

    #01AC
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (01AE);

01AE:

    #01AE
    #instruction: CALL 01D9
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 01;
    let:16 a3 = (-1 + a2) in
    M[a3] := B1;
    #return-to: 01B1
    advance (17)
    SP := a3;
    jump (01D9);

01B1:

    #01B1
    #instruction: LD   HL,2005
    advance (10)
    HL := 2005;
    jump (01B4);

01B4:

    #01B4
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (01B5);

01B5:

    #01B5
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (01B6);

01B6:

    #01B6
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (01B8);

01B8:

    #01B8
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (01B9);

01B9:

    #01B9
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (01BA);

01BA:

    #01BA
    #instruction: LD   HL,2067
    advance (10)
    HL := 2067;
    jump (01BD);

01BD:

    #01BD
    #instruction: LD   H,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a2,a3[7:0]);
    jump (01BE);

01BE:

    #01BE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

01C0:

    #01C0
    #instruction: LD   HL,2100
    advance (10)
    HL := 2100;
    jump (01C3);

01C3:

    #01C3
    #instruction: LD   B,37
    advance (7)
    B := 37;
    jump (01C5);

01C5:

    #01C5
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (01C7);

01C7:

    #01C7
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (01C8);

01C8:

    #01C8
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (01C9);

01C9:

    #01C9
    #instruction: JP   NZ,01C5
    if (!FlagZ) {
      advance (10)
      jump (01C5);
    } else {
      advance (10)
      jump (01CC);
    }

01CC:

    #01CC
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

01CD:

    #01CD
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (01CE);

01CE:

    #01CE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

01CF:

    #01CF
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (01D1);

01D1:

    #01D1
    #instruction: LD   B,E0
    advance (7)
    B := E0;
    jump (01D3);

01D3:

    #01D3
    #instruction: LD   HL,2402
    advance (10)
    HL := 2402;
    jump (01D6);

01D6:

    #01D6
    #instruction: JP   14CC
    advance (10)
    jump (14CC);

01D9:

    #01D9
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (01DA);

01DA:

    #01DA
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (01DB);

01DB:

    #01DB
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (01DC);

01DC:

    #01DC
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (01DD);

01DD:

    #01DD
    #instruction: ADD  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(false,a2,a3) in
    let:8 a5 = (a2 & 0F) in
    let:8 a6 = (a3 & 0F) in
    let:16 a7 = addWithCarry(false,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := a4[15:8][0];
    jump (01DE);

01DE:

    #01DE
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (01DF);

01DF:

    #01DF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (01E0);

01E0:

    #01E0
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (01E1);

01E1:

    #01E1
    #instruction: ADD  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(false,a2,a3) in
    let:8 a5 = (a2 & 0F) in
    let:8 a6 = (a3 & 0F) in
    let:16 a7 = addWithCarry(false,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := a4[15:8][0];
    jump (01E2);

01E2:

    #01E2
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (01E3);

01E3:

    #01E3
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

01E4:

    #01E4
    #instruction: LD   B,C0
    advance (7)
    B := C0;
    jump (01E6);

01E6:

    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    D := 1B;
    E := 00;
    jump (01E9);

01E9:

    #01E9
    #instruction: LD   HL,2000
    advance (10)
    HL := 2000;
    jump (01EC);

01EC:

    #01EC
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

01EF:

    #01EF
    #instruction: LD   HL,2142
    advance (10)
    HL := 2142;
    jump (01F2);

01F2:

    #01F2
    #instruction: JP   01F8
    advance (10)
    jump (01F8);

01F5:

    #01F5
    #instruction: LD   HL,2242
    advance (10)
    HL := 2242;
    jump (01F8);

01F8:

    #01F8
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (01FA);

01FA:

    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    D := 1D;
    E := 20;
    jump (01FD);

01FD:

    #01FD
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (01FE);

01FE:

    #01FE
    #instruction: LD   B,2C
    advance (7)
    B := 2C;
    jump (0200);

0200:

    #0200
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := 03;
    #return-to: 0203
    advance (17)
    SP := a3;
    jump (1A32);

0203:

    #0203
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (0204);

0204:

    #0204
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0205);

0205:

    #0205
    #instruction: JP   NZ,01FD
    if (!FlagZ) {
      advance (10)
      jump (01FD);
    } else {
      advance (10)
      jump (0208);
    }

0208:

    #0208
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0209:

    #0209
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (020B);

020B:

    #020B
    #instruction: JP   021B
    advance (10)
    jump (021B);

020E:

    #020E
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0210);

0210:

    #0210
    #instruction: JP   0214
    advance (10)
    jump (0214);

0213:

    #0213
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0214);

0214:

    #0214
    #instruction: LD   DE,2242
    advance (10)
    D := 22;
    E := 42;
    jump (0217);

0217:

    #0217
    #instruction: JP   021E
    advance (10)
    jump (021E);

021A:

    #021A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (021B);

021B:

    #021B
    #instruction: LD   DE,2142
    advance (10)
    D := 21;
    E := 42;
    jump (021E);

021E:

    #021E
    #instruction: LD   (2081),A
    let:8 a1 = A in
    M[2081] := a1;
    advance (13)
    jump (0221);

0221:

    #0221
    #instruction: LD   BC,1602
    advance (10)
    B := 16;
    C := 02;
    jump (0224);

0224:

    #0224
    #instruction: LD   HL,2806
    advance (10)
    HL := 2806;
    jump (0227);

0227:

    #0227
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (0229);

0229:

    #0229
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (022A);

022A:

    #022A
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (022B);

022B:

    #022B
    #instruction: LD   A,(2081)
    let:8 a1 = M[2081] in
    advance (13)
    A := a1;
    jump (022E);

022E:

    #022E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (022F);

022F:

    #022F
    #instruction: JP   NZ,0242
    if (!FlagZ) {
      advance (10)
      jump (0242);
    } else {
      advance (10)
      jump (0232);
    }

0232:

    #0232
    #instruction: CALL 1A69
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := 35;
    #return-to: 0235
    advance (17)
    SP := a3;
    jump (1A69);

0235:

    #0235
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (0236);

0236:

    #0236
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (0237);

0237:

    #0237
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0238);

0238:

    #0238
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0239);
    }

0239:

    #0239
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (023A);

023A:

    #023A
    #instruction: LD   DE,02E0
    advance (10)
    D := 02;
    E := E0;
    jump (023D);

023D:

    #023D
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (023E);

023E:

    #023E
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (023F);

023F:

    #023F
    #instruction: JP   0229
    advance (10)
    jump (0229);

0242:

    #0242
    #instruction: CALL 147C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := 45;
    #return-to: 0245
    advance (17)
    SP := a3;
    jump (147C);

0245:

    #0245
    #instruction: JP   0235
    advance (10)
    jump (0235);

0248:

    #0248
    #instruction: LD   HL,2010
    advance (10)
    HL := 2010;
    jump (024B);

024B:

    #024B
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (024C);

024C:

    #024C
    #instruction: CP   FF
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FF) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FF & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (024E);

024E:

    #024E
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (024F);
    }

024F:

    #024F
    #instruction: CP   FE
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FE) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FE & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0251);

0251:

    #0251
    #instruction: JP   Z,0281
    if (FlagZ) {
      advance (10)
      jump (0281);
    } else {
      advance (10)
      jump (0254);
    }

0254:

    #0254
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0255);

0255:

    #0255
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (0256);

0256:

    #0256
    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    C := a1;
    jump (0257);

0257:

    #0257
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0258);

0258:

    #0258
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (0259);

0259:

    #0259
    #instruction: JP   NZ,0277
    if (!FlagZ) {
      advance (10)
      jump (0277);
    } else {
      advance (10)
      jump (025C);
    }

025C:

    #025C
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (025D);

025D:

    #025D
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (025E);

025E:

    #025E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (025F);

025F:

    #025F
    #instruction: JP   NZ,0288
    if (!FlagZ) {
      advance (10)
      jump (0288);
    } else {
      advance (10)
      jump (0262);
    }

0262:

    #0262
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0263);

0263:

    #0263
    #instruction: LD   E,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    E := a2;
    jump (0264);

0264:

    #0264
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0265);

0265:

    #0265
    #instruction: LD   D,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    D := a2;
    jump (0266);

0266:

    #0266
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0267);

0267:

    #0267
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (0268);

0268:

    #0268
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0269);

0269:

    #0269
    #instruction: LD   HL,026F
    advance (10)
    HL := 026F;
    jump (026C);

026C:

    #026C
    #instruction: EX   (SP),HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:8 a4 = M[a2] in
    let:16 a5 = HL in
    let:16 a6 = HL in
    M[a1] := a5[7:0];
    M[a2] := a6[15:8];
    let:16 a7 = HL in
    let:16 a8 = (a7[15:8],a3) in
    advance (18)
    HL := (a4,a8[7:0]);
    jump (026D);

026D:

    #026D
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (026E);

026E:

    #026E
    #instruction: JP   (HL)
    let:16 a1 = HL in
    advance (5)
    jump (a1);

026F:

    #026F
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0270);

0270:

    #0270
    #instruction: LD   DE,000C
    advance (10)
    D := 00;
    E := 0C;
    jump (0273);

0273:

    #0273
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (0274);

0274:

    #0274
    #instruction: JP   024B
    advance (10)
    jump (024B);

0277:

    #0277
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0278);

0278:

    #0278
    #instruction: INC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0279);

0279:

    #0279
    #instruction: JP   NZ,027D
    if (!FlagZ) {
      advance (10)
      jump (027D);
    } else {
      advance (10)
      jump (027C);
    }

027C:

    #027C
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (027D);

027D:

    #027D
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (027E);

027E:

    #027E
    #instruction: LD   (HL),B
    let:8 a1 = B in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (027F);

027F:

    #027F
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0280);

0280:

    #0280
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0281);

0281:

    #0281
    #instruction: LD   DE,0010
    advance (10)
    D := 00;
    E := 10;
    jump (0284);

0284:

    #0284
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (0285);

0285:

    #0285
    #instruction: JP   024B
    advance (10)
    jump (024B);

0288:

    #0288
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (0289);

0289:

    #0289
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (028A);

028A:

    #028A
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (028B);

028B:

    #028B
    #instruction: JP   0281
    advance (10)
    jump (0281);

028E:

    #028E
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (028F);

028F:

    #028F
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0290);

0290:

    #0290
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0291);

0291:

    #0291
    #instruction: CP   FF
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FF) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FF & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0293);

0293:

    #0293
    #instruction: JP   Z,033B
    if (FlagZ) {
      advance (10)
      jump (033B);
    } else {
      advance (10)
      jump (0296);
    }

0296:

    #0296
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0297);

0297:

    #0297
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (0298);

0298:

    #0298
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0299);
    }

0299:

    #0299
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (029A);

029A:

    #029A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (029B);

029B:

    #029B
    #instruction: LD   (2068),A
    let:8 a1 = A in
    M[2068] := a1;
    advance (13)
    jump (029E);

029E:

    #029E
    #instruction: LD   (2069),A
    let:8 a1 = A in
    M[2069] := a1;
    advance (13)
    jump (02A1);

02A1:

    #02A1
    #instruction: LD   A,30
    advance (7)
    A := 30;
    jump (02A3);

02A3:

    #02A3
    #instruction: LD   (206A),A
    let:8 a1 = A in
    M[206A] := a1;
    advance (13)
    jump (02A6);

02A6:

    #02A6
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (02A7);

02A7:

    #02A7
    #instruction: LD   (HL),05
    let:16 a1 = HL in
    M[a1] := 05;
    advance (10)
    jump (02A9);

02A9:

    #02A9
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (02AA);

02AA:

    #02AA
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (02AB);

02AB:

    #02AB
    #instruction: JP   NZ,039B
    if (!FlagZ) {
      advance (10)
      jump (039B);
    } else {
      advance (10)
      jump (02AE);
    }

02AE:

    #02AE
    #instruction: LD   HL,(201A)
    let:8 a1 = M[201A] in
    let:16 a2 = HL in
    let:8 a3 = M[201B] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (02B1);

02B1:

    #02B1
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (02B3);

02B3:

    #02B3
    #instruction: CALL 1424
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := B6;
    #return-to: 02B6
    advance (17)
    SP := a3;
    jump (1424);

02B6:

    #02B6
    #instruction: LD   HL,2010
    advance (10)
    HL := 2010;
    jump (02B9);

02B9:

    #02B9
    #instruction: LD   DE,1B10
    advance (10)
    D := 1B;
    E := 10;
    jump (02BC);

02BC:

    #02BC
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (02BE);

02BE:

    #02BE
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := C1;
    #return-to: 02C1
    advance (17)
    SP := a3;
    jump (1A32);

02C1:

    #02C1
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (02C3);

02C3:

    #02C3
    #instruction: CALL 19DC
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := C6;
    #return-to: 02C6
    advance (17)
    SP := a3;
    jump (19DC);

02C6:

    #02C6
    #instruction: LD   A,(206D)
    let:8 a1 = M[206D] in
    advance (13)
    A := a1;
    jump (02C9);

02C9:

    #02C9
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (02CA);

02CA:

    #02CA
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (02CB);
    }

02CB:

    #02CB
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (02CE);

02CE:

    #02CE
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (02CF);

02CF:

    #02CF
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (02D0);
    }

02D0:

    #02D0
    #instruction: LD   SP,2400
    advance (10)
    SP := 2400;
    jump (02D3);

02D3:

    #02D3
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (02D4);

02D4:

    #02D4
    #instruction: CALL 19D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := D7;
    #return-to: 02D7
    advance (17)
    SP := a3;
    jump (19D7);

02D7:

    #02D7
    #instruction: CALL 092E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := DA;
    #return-to: 02DA
    advance (17)
    SP := a3;
    jump (092E);

02DA:

    #02DA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (02DB);

02DB:

    #02DB
    #instruction: JP   Z,166D
    if (FlagZ) {
      advance (10)
      jump (166D);
    } else {
      advance (10)
      jump (02DE);
    }

02DE:

    #02DE
    #instruction: CALL 18E7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := E1;
    #return-to: 02E1
    advance (17)
    SP := a3;
    jump (18E7);

02E1:

    #02E1
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (02E2);

02E2:

    #02E2
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (02E3);

02E3:

    #02E3
    #instruction: JP   Z,032C
    if (FlagZ) {
      advance (10)
      jump (032C);
    } else {
      advance (10)
      jump (02E6);
    }

02E6:

    #02E6
    #instruction: LD   A,(20CE)
    let:8 a1 = M[20CE] in
    advance (13)
    A := a1;
    jump (02E9);

02E9:

    #02E9
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (02EA);

02EA:

    #02EA
    #instruction: JP   Z,032C
    if (FlagZ) {
      advance (10)
      jump (032C);
    } else {
      advance (10)
      jump (02ED);
    }

02ED:

    #02ED
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (02F0);

02F0:

    #02F0
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (02F1);

02F1:

    #02F1
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (02F2);

02F2:

    #02F2
    #instruction: JP   CY,0332
    if (FlagCY) {
      advance (10)
      jump (0332);
    } else {
      advance (10)
      jump (02F5);
    }

02F5:

    #02F5
    #instruction: CALL 020E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := F8;
    #return-to: 02F8
    advance (17)
    SP := a3;
    jump (020E);

02F8:

    #02F8
    #instruction: CALL 0878
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 02;
    let:16 a3 = (-1 + a2) in
    M[a3] := FB;
    #return-to: 02FB
    advance (17)
    SP := a3;
    jump (0878);

02FB:

    #02FB
    #instruction: LD   (HL),E
    let:8 a1 = E in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (02FC);

02FC:

    #02FC
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (02FD);

02FD:

    #02FD
    #instruction: LD   (HL),D
    let:8 a1 = D in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (02FE);

02FE:

    #02FE
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (02FF);

02FF:

    #02FF
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0300);

0300:

    #0300
    #instruction: LD   (HL),B
    let:8 a1 = B in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0301);

0301:

    #0301
    #instruction: NOP
    advance (4)
    jump (0302);

0302:

    #0302
    #instruction: CALL 01E4
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 05;
    #return-to: 0305
    advance (17)
    SP := a3;
    jump (01E4);

0305:

    #0305
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (0306);

0306:

    #0306
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0307);

0307:

    #0307
    #instruction: LD   A,21
    advance (7)
    A := 21;
    jump (0309);

0309:

    #0309
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (030B);

030B:

    #030B
    #instruction: JP   NC,0312
    if (!FlagCY) {
      advance (10)
      jump (0312);
    } else {
      advance (10)
      jump (030E);
    }

030E:

    #030E
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (0310);

0310:

    #0310
    #instruction: LD   A,22
    advance (7)
    A := 22;
    jump (0312);

0312:

    #0312
    #instruction: LD   (2067),A
    let:8 a1 = A in
    M[2067] := a1;
    advance (13)
    jump (0315);

0315:

    #0315
    #instruction: CALL 0AB6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 18;
    #return-to: 0318
    advance (17)
    SP := a3;
    jump (0AB6);

0318:

    #0318
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0319);

0319:

    #0319
    #instruction: LD   (2011),A
    let:8 a1 = A in
    M[2011] := a1;
    advance (13)
    jump (031C);

031C:

    #031C
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (031D);

031D:

    #031D
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (031F);

031F:

    #031F
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0320);

0320:

    #0320
    #instruction: LD   (2098),A
    let:8 a1 = A in
    M[2098] := a1;
    advance (13)
    jump (0323);

0323:

    #0323
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 26;
    #return-to: 0326
    advance (17)
    SP := a3;
    jump (09D6);

0326:

    #0326
    #instruction: CALL 1A7F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 29;
    #return-to: 0329
    advance (17)
    SP := a3;
    jump (1A7F);

0329:

    #0329
    #instruction: JP   07F9
    advance (10)
    jump (07F9);

032C:

    #032C
    #instruction: CALL 1A7F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2F;
    #return-to: 032F
    advance (17)
    SP := a3;
    jump (1A7F);

032F:

    #032F
    #instruction: JP   0817
    advance (10)
    jump (0817);

0332:

    #0332
    #instruction: CALL 0209
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 35;
    #return-to: 0335
    advance (17)
    SP := a3;
    jump (0209);

0335:

    #0335
    #instruction: JP   02F8
    advance (10)
    jump (02F8);

033B:

    #033B
    #instruction: LD   HL,2068
    advance (10)
    HL := 2068;
    jump (033E);

033E:

    #033E
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (0340);

0340:

    #0340
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0341);

0341:

    #0341
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0342);

0342:

    #0342
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0343);

0343:

    #0343
    #instruction: JP   03B0
    advance (10)
    jump (03B0);

0346:

    #0346
    #instruction: NOP
    advance (4)
    jump (0347);

0347:

    #0347
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0348);

0348:

    #0348
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (034A);

034A:

    #034A
    #instruction: LD   A,(201B)
    let:8 a1 = M[201B] in
    advance (13)
    A := a1;
    jump (034D);

034D:

    #034D
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (034E);

034E:

    #034E
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (0351);

0351:

    #0351
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0352);

0352:

    #0352
    #instruction: JP   NZ,0363
    if (!FlagZ) {
      advance (10)
      jump (0363);
    } else {
      advance (10)
      jump (0355);
    }

0355:

    #0355
    #instruction: LD   A,(201D)
    let:8 a1 = M[201D] in
    advance (13)
    A := a1;
    jump (0358);

0358:

    #0358
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0359);

0359:

    #0359
    #instruction: JP   CY,0381
    if (FlagCY) {
      advance (10)
      jump (0381);
    } else {
      advance (10)
      jump (035C);
    }

035C:

    #035C
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (035D);

035D:

    #035D
    #instruction: JP   CY,038E
    if (FlagCY) {
      advance (10)
      jump (038E);
    } else {
      advance (10)
      jump (0360);
    }

0360:

    #0360
    #instruction: JP   036F
    advance (10)
    jump (036F);

0363:

    #0363
    #instruction: CALL 17C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 66;
    #return-to: 0366
    advance (17)
    SP := a3;
    jump (17C0);

0366:

    #0366
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (0367);

0367:

    #0367
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (0368);

0368:

    #0368
    #instruction: JP   CY,0381
    if (FlagCY) {
      advance (10)
      jump (0381);
    } else {
      advance (10)
      jump (036B);
    }

036B:

    #036B
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (036C);

036C:

    #036C
    #instruction: JP   CY,038E
    if (FlagCY) {
      advance (10)
      jump (038E);
    } else {
      advance (10)
      jump (036F);
    }

036F:

    #036F
    #instruction: LD   HL,2018
    advance (10)
    HL := 2018;
    jump (0372);

0372:

    #0372
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 75;
    #return-to: 0375
    advance (17)
    SP := a3;
    jump (1A3B);

0375:

    #0375
    #instruction: CALL 1A47
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 78;
    #return-to: 0378
    advance (17)
    SP := a3;
    jump (1A47);

0378:

    #0378
    #instruction: CALL 1439
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7B;
    #return-to: 037B
    advance (17)
    SP := a3;
    jump (1439);

037B:

    #037B
    #instruction: LD   A,00
    advance (7)
    A := 00;
    jump (037D);

037D:

    #037D
    #instruction: LD   (2012),A
    let:8 a1 = A in
    M[2012] := a1;
    advance (13)
    jump (0380);

0380:

    #0380
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0381:

    #0381
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (0382);

0382:

    #0382
    #instruction: CP   D9
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~D9) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~D9 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0384);

0384:

    #0384
    #instruction: JP   Z,036F
    if (FlagZ) {
      advance (10)
      jump (036F);
    } else {
      advance (10)
      jump (0387);
    }

0387:

    #0387
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0388);

0388:

    #0388
    #instruction: LD   (201B),A
    let:8 a1 = A in
    M[201B] := a1;
    advance (13)
    jump (038B);

038B:

    #038B
    #instruction: JP   036F
    advance (10)
    jump (036F);

038E:

    #038E
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (038F);

038F:

    #038F
    #instruction: CP   30
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~30) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~30 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0391);

0391:

    #0391
    #instruction: JP   Z,036F
    if (FlagZ) {
      advance (10)
      jump (036F);
    } else {
      advance (10)
      jump (0394);
    }

0394:

    #0394
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0395);

0395:

    #0395
    #instruction: LD   (201B),A
    let:8 a1 = A in
    M[201B] := a1;
    advance (13)
    jump (0398);

0398:

    #0398
    #instruction: JP   036F
    advance (10)
    jump (036F);

039B:

    #039B
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (039C);

039C:

    #039C
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (039E);

039E:

    #039E
    #instruction: LD   (2015),A
    let:8 a1 = A in
    M[2015] := a1;
    advance (13)
    jump (03A1);

03A1:

    #03A1
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (03A2);

03A2:

    #03A2
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (03A3);

03A3:

    #03A3
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (03A4);

03A4:

    #03A4
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (03A5);

03A5:

    #03A5
    #instruction: LD   HL,1C70
    advance (10)
    HL := 1C70;
    jump (03A8);

03A8:

    #03A8
    #instruction: ADD  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1[7:0],a2) in
    let:8 a4 = (a1[7:0] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (03A9);

03A9:

    #03A9
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (03AA);

03AA:

    #03AA
    #instruction: LD   (2018),HL
    let:16 a1 = HL in
    M[2018] := a1[7:0];
    let:16 a2 = HL in
    M[2019] := a2[15:8];
    advance (16)
    jump (03AD);

03AD:

    #03AD
    #instruction: JP   036F
    advance (10)
    jump (036F);

03B0:

    #03B0
    #instruction: JP   NZ,034A
    if (!FlagZ) {
      advance (10)
      jump (034A);
    } else {
      advance (10)
      jump (03B3);
    }

03B3:

    #03B3
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03B4);

03B4:

    #03B4
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03B5);

03B5:

    #03B5
    #instruction: JP   NZ,034A
    if (!FlagZ) {
      advance (10)
      jump (034A);
    } else {
      advance (10)
      jump (03B8);
    }

03B8:

    #03B8
    #instruction: JP   0346
    advance (10)
    jump (0346);

03BB:

    #03BB
    #instruction: LD   DE,202A
    advance (10)
    D := 20;
    E := 2A;
    jump (03BE);

03BE:

    #03BE
    #instruction: CALL 1A06
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := C1;
    #return-to: 03C1
    advance (17)
    SP := a3;
    jump (1A06);

03C1:

    #03C1
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (03C2);

03C2:

    #03C2
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (03C3);
    }

03C3:

    #03C3
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03C4);

03C4:

    #03C4
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (03C5);

03C5:

    #03C5
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (03C6);

03C6:

    #03C6
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (03C7);
    }

03C7:

    #03C7
    #instruction: CP   01
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~01) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~01 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (03C9);

03C9:

    #03C9
    #instruction: JP   Z,03FA
    if (FlagZ) {
      advance (10)
      jump (03FA);
    } else {
      advance (10)
      jump (03CC);
    }

03CC:

    #03CC
    #instruction: CP   02
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~02) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~02 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (03CE);

03CE:

    #03CE
    #instruction: JP   Z,040A
    if (FlagZ) {
      advance (10)
      jump (040A);
    } else {
      advance (10)
      jump (03D1);
    }

03D1:

    #03D1
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03D2);

03D2:

    #03D2
    #instruction: CP   03
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~03) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~03 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (03D4);

03D4:

    #03D4
    #instruction: JP   NZ,042A
    if (!FlagZ) {
      advance (10)
      jump (042A);
    } else {
      advance (10)
      jump (03D7);
    }

03D7:

    #03D7
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03D8);

03D8:

    #03D8
    #instruction: JP   Z,0436
    if (FlagZ) {
      advance (10)
      jump (0436);
    } else {
      advance (10)
      jump (03DB);
    }

03DB:

    #03DB
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (03DC);

03DC:

    #03DC
    #instruction: CP   0F
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0F) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0F & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (03DE);

03DE:

    #03DE
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (03DF);
    }

03DF:

    #03DF
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (03E0);

03E0:

    #03E0
    #instruction: CALL 0430
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := E3;
    #return-to: 03E3
    advance (17)
    SP := a3;
    jump (0430);

03E3:

    #03E3
    #instruction: CALL 1452
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := E6;
    #return-to: 03E6
    advance (17)
    SP := a3;
    jump (1452);

03E6:

    #03E6
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (03E7);

03E7:

    #03E7
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03E8);

03E8:

    #03E8
    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03E9);

03E9:

    #03E9
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03EA);

03EA:

    #03EA
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03EB);

03EB:

    #03EB
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03EC);

03EC:

    #03EC
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03ED);

03ED:

    #03ED
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03EE);

03EE:

    #03EE
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03EF);

03EF:

    #03EF
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03F0);

03F0:

    #03F0
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (03F1);

03F1:

    #03F1
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (03F2);

03F2:

    #03F2
    #instruction: LD   (HL),08
    let:16 a1 = HL in
    M[a1] := 08;
    advance (10)
    jump (03F4);

03F4:

    #03F4
    #instruction: CALL 0430
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 03;
    let:16 a3 = (-1 + a2) in
    M[a3] := F7;
    #return-to: 03F7
    advance (17)
    SP := a3;
    jump (0430);

03F7:

    #03F7
    #instruction: JP   1400
    advance (10)
    jump (1400);

03FA:

    #03FA
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (03FB);

03FB:

    #03FB
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (03FC);

03FC:

    #03FC
    #instruction: LD   A,(201B)
    let:8 a1 = M[201B] in
    advance (13)
    A := a1;
    jump (03FF);

03FF:

    #03FF
    #instruction: ADD  08
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,08,a1) in
    let:8 a3 = (08 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (0401);

0401:

    #0401
    #instruction: LD   (202A),A
    let:8 a1 = A in
    M[202A] := a1;
    advance (13)
    jump (0404);

0404:

    #0404
    #instruction: CALL 0430
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 07;
    #return-to: 0407
    advance (17)
    SP := a3;
    jump (0430);

0407:

    #0407
    #instruction: JP   1400
    advance (10)
    jump (1400);

040A:

    #040A
    #instruction: CALL 0430
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 0D;
    #return-to: 040D
    advance (17)
    SP := a3;
    jump (0430);

040D:

    #040D
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (040E);

040E:

    #040E
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (040F);

040F:

    #040F
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (0410);

0410:

    #0410
    #instruction: CALL 1452
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 13;
    #return-to: 0413
    advance (17)
    SP := a3;
    jump (1452);

0413:

    #0413
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (0414);

0414:

    #0414
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0415);

0415:

    #0415
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (0416);

0416:

    #0416
    #instruction: LD   A,(202C)
    let:8 a1 = M[202C] in
    advance (13)
    A := a1;
    jump (0419);

0419:

    #0419
    #instruction: ADD  L
    let:16 a1 = HL in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1[7:0],a2) in
    let:8 a4 = (a1[7:0] & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (041A);

041A:

    #041A
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (041B);

041B:

    #041B
    #instruction: LD   (2029),A
    let:8 a1 = A in
    M[2029] := a1;
    advance (13)
    jump (041E);

041E:

    #041E
    #instruction: CALL 1491
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 21;
    #return-to: 0421
    advance (17)
    SP := a3;
    jump (1491);

0421:

    #0421
    #instruction: LD   A,(2061)
    let:8 a1 = M[2061] in
    advance (13)
    A := a1;
    jump (0424);

0424:

    #0424
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0425);

0425:

    #0425
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0426);
    }

0426:

    #0426
    #instruction: LD   (2002),A
    let:8 a1 = A in
    M[2002] := a1;
    advance (13)
    jump (0429);

0429:

    #0429
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

042A:

    #042A
    #instruction: CP   05
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~05) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~05 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (042C);

042C:

    #042C
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (042D);
    }

042D:

    #042D
    #instruction: JP   0436
    advance (10)
    jump (0436);

0430:

    #0430
    #instruction: LD   HL,2027
    advance (10)
    HL := 2027;
    jump (0433);

0433:

    #0433
    #instruction: JP   1A3B
    advance (10)
    jump (1A3B);

0436:

    #0436
    #instruction: CALL 0430
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 39;
    #return-to: 0439
    advance (17)
    SP := a3;
    jump (0430);

0439:

    #0439
    #instruction: CALL 1452
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3C;
    #return-to: 043C
    advance (17)
    SP := a3;
    jump (1452);

043C:

    #043C
    #instruction: LD   HL,2025
    advance (10)
    HL := 2025;
    jump (043F);

043F:

    #043F
    #instruction: LD   DE,1B25
    advance (10)
    D := 1B;
    E := 25;
    jump (0442);

0442:

    #0442
    #instruction: LD   B,07
    advance (7)
    B := 07;
    jump (0444);

0444:

    #0444
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 47;
    #return-to: 0447
    advance (17)
    SP := a3;
    jump (1A32);

0447:

    #0447
    #instruction: LD   HL,(208D)
    let:8 a1 = M[208D] in
    let:16 a2 = HL in
    let:8 a3 = M[208E] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (044A);

044A:

    #044A
    #instruction: INC  L
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[7:0],00) in
    let:8 a3 = (a1[7:0] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a6[15:8],a2[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (044B);

044B:

    #044B
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (044C);

044C:

    #044C
    #instruction: CP   63
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~63) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~63 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (044E);

044E:

    #044E
    #instruction: JP   CY,0453
    if (FlagCY) {
      advance (10)
      jump (0453);
    } else {
      advance (10)
      jump (0451);
    }

0451:

    #0451
    #instruction: LD   L,54
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],54);
    jump (0453);

0453:

    #0453
    #instruction: LD   (208D),HL
    let:16 a1 = HL in
    M[208D] := a1[7:0];
    let:16 a2 = HL in
    M[208E] := a2[15:8];
    advance (16)
    jump (0456);

0456:

    #0456
    #instruction: LD   HL,(208F)
    let:8 a1 = M[208F] in
    let:16 a2 = HL in
    let:8 a3 = M[2090] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (0459);

0459:

    #0459
    #instruction: INC  L
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[7:0],00) in
    let:8 a3 = (a1[7:0] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a6[15:8],a2[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (045A);

045A:

    #045A
    #instruction: LD   (208F),HL
    let:16 a1 = HL in
    M[208F] := a1[7:0];
    let:16 a2 = HL in
    M[2090] := a2[15:8];
    advance (16)
    jump (045D);

045D:

    #045D
    #instruction: LD   A,(2084)
    let:8 a1 = M[2084] in
    advance (13)
    A := a1;
    jump (0460);

0460:

    #0460
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0461);

0461:

    #0461
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0462);
    }

0462:

    #0462
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0463);

0463:

    #0463
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0465);

0465:

    #0465
    #instruction: LD   BC,0229
    advance (10)
    B := 02;
    C := 29;
    jump (0468);

0468:

    #0468
    #instruction: JP   NZ,046E
    if (!FlagZ) {
      advance (10)
      jump (046E);
    } else {
      advance (10)
      jump (046B);
    }

046B:

    #046B
    #instruction: LD   BC,FEE0
    advance (10)
    B := FE;
    C := E0;
    jump (046E);

046E:

    #046E
    #instruction: LD   HL,208A
    advance (10)
    HL := 208A;
    jump (0471);

0471:

    #0471
    #instruction: LD   (HL),C
    let:8 a1 = C in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0472);

0472:

    #0472
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0473);

0473:

    #0473
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0474);

0474:

    #0474
    #instruction: LD   (HL),B
    let:8 a1 = B in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0475);

0475:

    #0475
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0476:

    #0476
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0477);

0477:

    #0477
    #instruction: LD   A,(1B32)
    advance (13)
    A := 02;
    jump (047A);

047A:

    #047A
    #instruction: LD   (2032),A
    let:8 a1 = A in
    M[2032] := a1;
    advance (13)
    jump (047D);

047D:

    #047D
    #instruction: LD   HL,(2038)
    let:8 a1 = M[2038] in
    let:16 a2 = HL in
    let:8 a3 = M[2039] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (0480);

0480:

    #0480
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (0481);

0481:

    #0481
    #instruction: OR   H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[15:8] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0482);

0482:

    #0482
    #instruction: JP   NZ,048A
    if (!FlagZ) {
      advance (10)
      jump (048A);
    } else {
      advance (10)
      jump (0485);
    }

0485:

    #0485
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0486);

0486:

    #0486
    #instruction: LD   (2038),HL
    let:16 a1 = HL in
    M[2038] := a1[7:0];
    let:16 a2 = HL in
    M[2039] := a2[15:8];
    advance (16)
    jump (0489);

0489:

    #0489
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

048A:

    #048A
    #instruction: LD   DE,2035
    advance (10)
    D := 20;
    E := 35;
    jump (048D);

048D:

    #048D
    #instruction: LD   A,F9
    advance (7)
    A := F9;
    jump (048F);

048F:

    #048F
    #instruction: CALL 0550
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := 92;
    #return-to: 0492
    advance (17)
    SP := a3;
    jump (0550);

0492:

    #0492
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    A := a1;
    jump (0495);

0495:

    #0495
    #instruction: LD   (2070),A
    let:8 a1 = A in
    M[2070] := a1;
    advance (13)
    jump (0498);

0498:

    #0498
    #instruction: LD   A,(2056)
    let:8 a1 = M[2056] in
    advance (13)
    A := a1;
    jump (049B);

049B:

    #049B
    #instruction: LD   (2071),A
    let:8 a1 = A in
    M[2071] := a1;
    advance (13)
    jump (049E);

049E:

    #049E
    #instruction: CALL 0563
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := A1;
    #return-to: 04A1
    advance (17)
    SP := a3;
    jump (0563);

04A1:

    #04A1
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    A := a1;
    jump (04A4);

04A4:

    #04A4
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (04A5);

04A5:

    #04A5
    #instruction: LD   HL,2035
    advance (10)
    HL := 2035;
    jump (04A8);

04A8:

    #04A8
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (04AB);
    }

04AB:

    #04AB
    #instruction: LD   DE,1B30
    advance (10)
    D := 1B;
    E := 30;
    jump (04AE);

04AE:

    #04AE
    #instruction: LD   HL,2030
    advance (10)
    HL := 2030;
    jump (04B1);

04B1:

    #04B1
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (04B3);

04B3:

    #04B3
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

04B6:

    #04B6
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (04B7);

04B7:

    #04B7
    #instruction: LD   A,(206E)
    let:8 a1 = M[206E] in
    advance (13)
    A := a1;
    jump (04BA);

04BA:

    #04BA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (04BB);

04BB:

    #04BB
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (04BC);
    }

04BC:

    #04BC
    #instruction: LD   A,(2080)
    let:8 a1 = M[2080] in
    advance (13)
    A := a1;
    jump (04BF);

04BF:

    #04BF
    #instruction: CP   01
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~01) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~01 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (04C1);

04C1:

    #04C1
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (04C2);
    }

04C2:

    #04C2
    #instruction: LD   DE,2045
    advance (10)
    D := 20;
    E := 45;
    jump (04C5);

04C5:

    #04C5
    #instruction: LD   A,ED
    advance (7)
    A := ED;
    jump (04C7);

04C7:

    #04C7
    #instruction: CALL 0550
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := CA;
    #return-to: 04CA
    advance (17)
    SP := a3;
    jump (0550);

04CA:

    #04CA
    #instruction: LD   A,(2036)
    let:8 a1 = M[2036] in
    advance (13)
    A := a1;
    jump (04CD);

04CD:

    #04CD
    #instruction: LD   (2070),A
    let:8 a1 = A in
    M[2070] := a1;
    advance (13)
    jump (04D0);

04D0:

    #04D0
    #instruction: LD   A,(2056)
    let:8 a1 = M[2056] in
    advance (13)
    A := a1;
    jump (04D3);

04D3:

    #04D3
    #instruction: LD   (2071),A
    let:8 a1 = A in
    M[2071] := a1;
    advance (13)
    jump (04D6);

04D6:

    #04D6
    #instruction: CALL 0563
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := D9;
    #return-to: 04D9
    advance (17)
    SP := a3;
    jump (0563);

04D9:

    #04D9
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    A := a1;
    jump (04DC);

04DC:

    #04DC
    #instruction: CP   10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (04DE);

04DE:

    #04DE
    #instruction: JP   CY,04E7
    if (FlagCY) {
      advance (10)
      jump (04E7);
    } else {
      advance (10)
      jump (04E1);
    }

04E1:

    #04E1
    #instruction: LD   A,(1B48)
    advance (13)
    A := 00;
    jump (04E4);

04E4:

    #04E4
    #instruction: LD   (2076),A
    let:8 a1 = A in
    M[2076] := a1;
    advance (13)
    jump (04E7);

04E7:

    #04E7
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    A := a1;
    jump (04EA);

04EA:

    #04EA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (04EB);

04EB:

    #04EB
    #instruction: LD   HL,2045
    advance (10)
    HL := 2045;
    jump (04EE);

04EE:

    #04EE
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (04F1);
    }

04F1:

    #04F1
    #instruction: LD   DE,1B40
    advance (10)
    D := 1B;
    E := 40;
    jump (04F4);

04F4:

    #04F4
    #instruction: LD   HL,2040
    advance (10)
    HL := 2040;
    jump (04F7);

04F7:

    #04F7
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (04F9);

04F9:

    #04F9
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 04;
    let:16 a3 = (-1 + a2) in
    M[a3] := FC;
    #return-to: 04FC
    advance (17)
    SP := a3;
    jump (1A32);

04FC:

    #04FC
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (04FF);

04FF:

    #04FF
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0500);

0500:

    #0500
    #instruction: JP   NZ,0508
    if (!FlagZ) {
      advance (10)
      jump (0508);
    } else {
      advance (10)
      jump (0503);
    }

0503:

    #0503
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0505);

0505:

    #0505
    #instruction: LD   (206E),A
    let:8 a1 = A in
    M[206E] := a1;
    advance (13)
    jump (0508);

0508:

    #0508
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:16 a2 = HL in
    let:8 a3 = M[2077] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (050B);

050B:

    #050B
    #instruction: JP   067E
    advance (10)
    jump (067E);

050E:

    #050E
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (050F);

050F:

    #050F
    #instruction: LD   DE,2055
    advance (10)
    D := 20;
    E := 55;
    jump (0512);

0512:

    #0512
    #instruction: LD   A,DB
    advance (7)
    A := DB;
    jump (0514);

0514:

    #0514
    #instruction: CALL 0550
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := 17;
    #return-to: 0517
    advance (17)
    SP := a3;
    jump (0550);

0517:

    #0517
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    A := a1;
    jump (051A);

051A:

    #051A
    #instruction: LD   (2070),A
    let:8 a1 = A in
    M[2070] := a1;
    advance (13)
    jump (051D);

051D:

    #051D
    #instruction: LD   A,(2036)
    let:8 a1 = M[2036] in
    advance (13)
    A := a1;
    jump (0520);

0520:

    #0520
    #instruction: LD   (2071),A
    let:8 a1 = A in
    M[2071] := a1;
    advance (13)
    jump (0523);

0523:

    #0523
    #instruction: CALL 0563
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := 26;
    #return-to: 0526
    advance (17)
    SP := a3;
    jump (0563);

0526:

    #0526
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    A := a1;
    jump (0529);

0529:

    #0529
    #instruction: CP   15
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~15) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~15 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (052B);

052B:

    #052B
    #instruction: JP   CY,0534
    if (FlagCY) {
      advance (10)
      jump (0534);
    } else {
      advance (10)
      jump (052E);
    }

052E:

    #052E
    #instruction: LD   A,(1B58)
    advance (13)
    A := 06;
    jump (0531);

0531:

    #0531
    #instruction: LD   (2076),A
    let:8 a1 = A in
    M[2076] := a1;
    advance (13)
    jump (0534);

0534:

    #0534
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    A := a1;
    jump (0537);

0537:

    #0537
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0538);

0538:

    #0538
    #instruction: LD   HL,2055
    advance (10)
    HL := 2055;
    jump (053B);

053B:

    #053B
    #instruction: JP   NZ,055B
    if (!FlagZ) {
      advance (10)
      jump (055B);
    } else {
      advance (10)
      jump (053E);
    }

053E:

    #053E
    #instruction: LD   DE,1B50
    advance (10)
    D := 1B;
    E := 50;
    jump (0541);

0541:

    #0541
    #instruction: LD   HL,2050
    advance (10)
    HL := 2050;
    jump (0544);

0544:

    #0544
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0546);

0546:

    #0546
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := 49;
    #return-to: 0549
    advance (17)
    SP := a3;
    jump (1A32);

0549:

    #0549
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:16 a2 = HL in
    let:8 a3 = M[2077] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (054C);

054C:

    #054C
    #instruction: LD   (2058),HL
    let:16 a1 = HL in
    M[2058] := a1[7:0];
    let:16 a2 = HL in
    M[2059] := a2[15:8];
    advance (16)
    jump (054F);

054F:

    #054F
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0550:

    #0550
    #instruction: LD   (207F),A
    let:8 a1 = A in
    M[207F] := a1;
    advance (13)
    jump (0553);

0553:

    #0553
    #instruction: LD   HL,2073
    advance (10)
    HL := 2073;
    jump (0556);

0556:

    #0556
    #instruction: LD   B,0B
    advance (7)
    B := 0B;
    jump (0558);

0558:

    #0558
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

055B:

    #055B
    #instruction: LD   DE,2073
    advance (10)
    D := 20;
    E := 73;
    jump (055E);

055E:

    #055E
    #instruction: LD   B,0B
    advance (7)
    B := 0B;
    jump (0560);

0560:

    #0560
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0563:

    #0563
    #instruction: LD   HL,2073
    advance (10)
    HL := 2073;
    jump (0566);

0566:

    #0566
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0567);

0567:

    #0567
    #instruction: AND  80
    let:8 a1 = A in
    let:8 a2 = (80 & a1) in
    let:8 a3 = (80 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0569);

0569:

    #0569
    #instruction: JP   NZ,05C1
    if (!FlagZ) {
      advance (10)
      jump (05C1);
    } else {
      advance (10)
      jump (056C);
    }

056C:

    #056C
    #instruction: LD   A,(20C1)
    let:8 a1 = M[20C1] in
    advance (13)
    A := a1;
    jump (056F);

056F:

    #056F
    #instruction: CP   04
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~04) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~04 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0571);

0571:

    #0571
    #instruction: LD   A,(2069)
    let:8 a1 = M[2069] in
    advance (13)
    A := a1;
    jump (0574);

0574:

    #0574
    #instruction: JP   Z,05B7
    if (FlagZ) {
      advance (10)
      jump (05B7);
    } else {
      advance (10)
      jump (0577);
    }

0577:

    #0577
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0578);

0578:

    #0578
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0579);
    }

0579:

    #0579
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (057A);

057A:

    #057A
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (057C);

057C:

    #057C
    #instruction: LD   A,(2070)
    let:8 a1 = M[2070] in
    advance (13)
    A := a1;
    jump (057F);

057F:

    #057F
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0580);

0580:

    #0580
    #instruction: JP   Z,0589
    if (FlagZ) {
      advance (10)
      jump (0589);
    } else {
      advance (10)
      jump (0583);
    }

0583:

    #0583
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (0584);

0584:

    #0584
    #instruction: LD   A,(20CF)
    let:8 a1 = M[20CF] in
    advance (13)
    A := a1;
    jump (0587);

0587:

    #0587
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (0588);

0588:

    #0588
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0589);
    }

0589:

    #0589
    #instruction: LD   A,(2071)
    let:8 a1 = M[2071] in
    advance (13)
    A := a1;
    jump (058C);

058C:

    #058C
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (058D);

058D:

    #058D
    #instruction: JP   Z,0596
    if (FlagZ) {
      advance (10)
      jump (0596);
    } else {
      advance (10)
      jump (0590);
    }

0590:

    #0590
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (0591);

0591:

    #0591
    #instruction: LD   A,(20CF)
    let:8 a1 = M[20CF] in
    advance (13)
    A := a1;
    jump (0594);

0594:

    #0594
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (0595);

0595:

    #0595
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0596);
    }

0596:

    #0596
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0597);

0597:

    #0597
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0598);

0598:

    #0598
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0599);

0599:

    #0599
    #instruction: JP   Z,061B
    if (FlagZ) {
      advance (10)
      jump (061B);
    } else {
      advance (10)
      jump (059C);
    }

059C:

    #059C
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:16 a2 = HL in
    let:8 a3 = M[2077] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (059F);

059F:

    #059F
    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump (05A0);

05A0:

    #05A0
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (05A1);

05A1:

    #05A1
    #instruction: NOP
    advance (4)
    jump (05A2);

05A2:

    #05A2
    #instruction: LD   (2076),HL
    let:16 a1 = HL in
    M[2076] := a1[7:0];
    let:16 a2 = HL in
    M[2077] := a2[15:8];
    advance (16)
    jump (05A5);

05A5:

    #05A5
    #instruction: CALL 062F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := A8;
    #return-to: 05A8
    advance (17)
    SP := a3;
    jump (062F);

05A8:

    #05A8
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (05A9);
    }

05A9:

    #05A9
    #instruction: CALL 017A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := AC;
    #return-to: 05AC
    advance (17)
    SP := a3;
    jump (017A);

05AC:

    #05AC
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (05AD);

05AD:

    #05AD
    #instruction: ADD  07
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,07,a1) in
    let:8 a3 = (07 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (05AF);

05AF:

    #05AF
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (05B0);

05B0:

    #05B0
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (05B1);

05B1:

    #05B1
    #instruction: SUB  0A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0A) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0A & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (05B3);

05B3:

    #05B3
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (05B4);

05B4:

    #05B4
    #instruction: LD   (207B),HL
    let:16 a1 = HL in
    M[207B] := a1[7:0];
    let:16 a2 = HL in
    M[207C] := a2[15:8];
    advance (16)
    jump (05B7);

05B7:

    #05B7
    #instruction: LD   HL,2073
    advance (10)
    HL := 2073;
    jump (05BA);

05BA:

    #05BA
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (05BB);

05BB:

    #05BB
    #instruction: OR   80
    let:8 a1 = A in
    let:8 a2 = (80 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := false;
    FlagP := parity(a2);
    FlagCY := false;
    jump (05BD);

05BD:

    #05BD
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (05BE);

05BE:

    #05BE
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (05BF);

05BF:

    #05BF
    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (05C0);

05C0:

    #05C0
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

05C1:

    #05C1
    #instruction: LD   DE,207C
    advance (10)
    D := 20;
    E := 7C;
    jump (05C4);

05C4:

    #05C4
    #instruction: CALL 1A06
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := C7;
    #return-to: 05C7
    advance (17)
    SP := a3;
    jump (1A06);

05C7:

    #05C7
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (05C8);
    }

05C8:

    #05C8
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (05C9);

05C9:

    #05C9
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (05CA);

05CA:

    #05CA
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (05CC);

05CC:

    #05CC
    #instruction: JP   NZ,0644
    if (!FlagZ) {
      advance (10)
      jump (0644);
    } else {
      advance (10)
      jump (05CF);
    }

05CF:

    #05CF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (05D0);

05D0:

    #05D0
    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (05D1);

05D1:

    #05D1
    #instruction: CALL 0675
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := D4;
    #return-to: 05D4
    advance (17)
    SP := a3;
    jump (0675);

05D4:

    #05D4
    #instruction: LD   A,(2079)
    let:8 a1 = M[2079] in
    advance (13)
    A := a1;
    jump (05D7);

05D7:

    #05D7
    #instruction: ADD  03
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,03,a1) in
    let:8 a3 = (03 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (05D9);

05D9:

    #05D9
    #instruction: LD   HL,207F
    advance (10)
    HL := 207F;
    jump (05DC);

05DC:

    #05DC
    #instruction: CP   (HL)
    let:8 a1 = A in
    let:16 a2 = HL in
    let:8 a3 = M[a2] in
    let:16 a4 = addWithCarry(!false,a1,~a3) in
    let:8 a5 = (a1 & 0F) in
    let:8 a6 = (~a3 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump (05DD);

05DD:

    #05DD
    #instruction: JP   CY,05E2
    if (FlagCY) {
      advance (10)
      jump (05E2);
    } else {
      advance (10)
      jump (05E0);
    }

05E0:

    #05E0
    #instruction: SUB  0C
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0C) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0C & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (05E2);

05E2:

    #05E2
    #instruction: LD   (2079),A
    let:8 a1 = A in
    M[2079] := a1;
    advance (13)
    jump (05E5);

05E5:

    #05E5
    #instruction: LD   A,(207B)
    let:8 a1 = M[207B] in
    advance (13)
    A := a1;
    jump (05E8);

05E8:

    #05E8
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (05E9);

05E9:

    #05E9
    #instruction: LD   A,(207E)
    let:8 a1 = M[207E] in
    advance (13)
    A := a1;
    jump (05EC);

05EC:

    #05EC
    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (05ED);

05ED:

    #05ED
    #instruction: LD   (207B),A
    let:8 a1 = A in
    M[207B] := a1;
    advance (13)
    jump (05F0);

05F0:

    #05F0
    #instruction: CALL 066C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 05;
    let:16 a3 = (-1 + a2) in
    M[a3] := F3;
    #return-to: 05F3
    advance (17)
    SP := a3;
    jump (066C);

05F3:

    #05F3
    #instruction: LD   A,(207B)
    let:8 a1 = M[207B] in
    advance (13)
    A := a1;
    jump (05F6);

05F6:

    #05F6
    #instruction: CP   15
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~15) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~15 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (05F8);

05F8:

    #05F8
    #instruction: JP   CY,0612
    if (FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (05FB);
    }

05FB:

    #05FB
    #instruction: LD   A,(2061)
    let:8 a1 = M[2061] in
    advance (13)
    A := a1;
    jump (05FE);

05FE:

    #05FE
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (05FF);

05FF:

    #05FF
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0600);
    }

0600:

    #0600
    #instruction: LD   A,(207B)
    let:8 a1 = M[207B] in
    advance (13)
    A := a1;
    jump (0603);

0603:

    #0603
    #instruction: CP   1E
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~1E) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~1E & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0605);

0605:

    #0605
    #instruction: JP   CY,0612
    if (FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (0608);
    }

0608:

    #0608
    #instruction: CP   27
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~27) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~27 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (060A);

060A:

    #060A
    #instruction: NOP
    advance (4)
    jump (060B);

060B:

    #060B
    #instruction: JP   NC,0612
    if (!FlagCY) {
      advance (10)
      jump (0612);
    } else {
      advance (10)
      jump (060E);
    }

060E:

    #060E
    #instruction: SUB  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(!false,a2,~a1) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~a1 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (060F);

060F:

    #060F
    #instruction: LD   (2015),A
    let:8 a1 = A in
    M[2015] := a1;
    advance (13)
    jump (0612);

0612:

    #0612
    #instruction: LD   A,(2073)
    let:8 a1 = M[2073] in
    advance (13)
    A := a1;
    jump (0615);

0615:

    #0615
    #instruction: OR   01
    let:8 a1 = A in
    let:8 a2 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := false;
    FlagP := parity(a2);
    FlagCY := false;
    jump (0617);

0617:

    #0617
    #instruction: LD   (2073),A
    let:8 a1 = A in
    M[2073] := a1;
    advance (13)
    jump (061A);

061A:

    #061A
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

061B:

    #061B
    #instruction: LD   A,(201B)
    let:8 a1 = M[201B] in
    advance (13)
    A := a1;
    jump (061E);

061E:

    #061E
    #instruction: ADD  08
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,08,a1) in
    let:8 a3 = (08 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (0620);

0620:

    #0620
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (0621);

0621:

    #0621
    #instruction: CALL 156F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := 24;
    #return-to: 0624
    advance (17)
    SP := a3;
    jump (156F);

0624:

    #0624
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (0625);

0625:

    #0625
    #instruction: CP   0C
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~0C) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~0C & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0627);

0627:

    #0627
    #instruction: JP   CY,05A5
    if (FlagCY) {
      advance (10)
      jump (05A5);
    } else {
      advance (10)
      jump (062A);
    }

062A:

    #062A
    #instruction: LD   C,0B
    advance (7)
    C := 0B;
    jump (062C);

062C:

    #062C
    #instruction: JP   05A5
    advance (10)
    jump (05A5);

062F:

    #062F
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0630);

0630:

    #0630
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (0633);

0633:

    #0633
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (0634);

0634:

    #0634
    #instruction: LD   L,C
    let:8 a1 = C in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (0635);

0635:

    #0635
    #instruction: LD   D,05
    advance (7)
    D := 05;
    jump (0637);

0637:

    #0637
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0638);

0638:

    #0638
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0639);

0639:

    #0639
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (063A);

063A:

    #063A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (063B);
    }

063B:

    #063B
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (063C);

063C:

    #063C
    #instruction: ADD  0B
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,0B,a1) in
    let:8 a3 = (0B & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (063E);

063E:

    #063E
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (063F);

063F:

    #063F
    #instruction: DEC  D
    let:8 a1 = D in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    D := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0640);

0640:

    #0640
    #instruction: JP   NZ,0637
    if (!FlagZ) {
      advance (10)
      jump (0637);
    } else {
      advance (10)
      jump (0643);
    }

0643:

    #0643
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0644:

    #0644
    #instruction: LD   HL,2078
    advance (10)
    HL := 2078;
    jump (0647);

0647:

    #0647
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (0648);

0648:

    #0648
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0649);

0649:

    #0649
    #instruction: CP   03
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~03) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~03 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (064B);

064B:

    #064B
    #instruction: JP   NZ,0667
    if (!FlagZ) {
      advance (10)
      jump (0667);
    } else {
      advance (10)
      jump (064E);
    }

064E:

    #064E
    #instruction: CALL 0675
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := 51;
    #return-to: 0651
    advance (17)
    SP := a3;
    jump (0675);

0651:

    #0651
    #instruction: LD   HL,1CDC
    advance (10)
    HL := 1CDC;
    jump (0654);

0654:

    #0654
    #instruction: LD   (2079),HL
    let:16 a1 = HL in
    M[2079] := a1[7:0];
    let:16 a2 = HL in
    M[207A] := a2[15:8];
    advance (16)
    jump (0657);

0657:

    #0657
    #instruction: LD   HL,207C
    advance (10)
    HL := 207C;
    jump (065A);

065A:

    #065A
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (065B);

065B:

    #065B
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (065C);

065C:

    #065C
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (065D);

065D:

    #065D
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (065E);

065E:

    #065E
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (065F);

065F:

    #065F
    #instruction: LD   A,06
    advance (7)
    A := 06;
    jump (0661);

0661:

    #0661
    #instruction: LD   (207D),A
    let:8 a1 = A in
    M[207D] := a1;
    advance (13)
    jump (0664);

0664:

    #0664
    #instruction: JP   066C
    advance (10)
    jump (066C);

0667:

    #0667
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0668);

0668:

    #0668
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0669);
    }

0669:

    #0669
    #instruction: JP   0675
    advance (10)
    jump (0675);

066C:

    #066C
    #instruction: LD   HL,2079
    advance (10)
    HL := 2079;
    jump (066F);

066F:

    #066F
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := 72;
    #return-to: 0672
    advance (17)
    SP := a3;
    jump (1A3B);

0672:

    #0672
    #instruction: JP   1491
    advance (10)
    jump (1491);

0675:

    #0675
    #instruction: LD   HL,2079
    advance (10)
    HL := 2079;
    jump (0678);

0678:

    #0678
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7B;
    #return-to: 067B
    advance (17)
    SP := a3;
    jump (1A3B);

067B:

    #067B
    #instruction: JP   1452
    advance (10)
    jump (1452);

067E:

    #067E
    #instruction: LD   (2048),HL
    let:16 a1 = HL in
    M[2048] := a1[7:0];
    let:16 a2 = HL in
    M[2049] := a2[15:8];
    advance (16)
    jump (0681);

0681:

    #0681
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0682:

    #0682
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0683);

0683:

    #0683
    #instruction: LD   A,(2080)
    let:8 a1 = M[2080] in
    advance (13)
    A := a1;
    jump (0686);

0686:

    #0686
    #instruction: CP   02
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~02) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~02 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0688);

0688:

    #0688
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0689);
    }

0689:

    #0689
    #instruction: LD   HL,2083
    advance (10)
    HL := 2083;
    jump (068C);

068C:

    #068C
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (068D);

068D:

    #068D
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (068E);

068E:

    #068E
    #instruction: JP   Z,050F
    if (FlagZ) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (0691);
    }

0691:

    #0691
    #instruction: LD   A,(2056)
    let:8 a1 = M[2056] in
    advance (13)
    A := a1;
    jump (0694);

0694:

    #0694
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0695);

0695:

    #0695
    #instruction: JP   NZ,050F
    if (!FlagZ) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (0698);
    }

0698:

    #0698
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0699);

0699:

    #0699
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (069A);

069A:

    #069A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (069B);

069B:

    #069B
    #instruction: JP   NZ,06AB
    if (!FlagZ) {
      advance (10)
      jump (06AB);
    } else {
      advance (10)
      jump (069E);
    }

069E:

    #069E
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (06A1);

06A1:

    #06A1
    #instruction: CP   08
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~08) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~08 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (06A3);

06A3:

    #06A3
    #instruction: JP   CY,050F
    if (FlagCY) {
      advance (10)
      jump (050F);
    } else {
      advance (10)
      jump (06A6);
    }

06A6:

    #06A6
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (06A8);

06A8:

    #06A8
    #instruction: CALL 073C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := AB;
    #return-to: 06AB
    advance (17)
    SP := a3;
    jump (073C);

06AB:

    #06AB
    #instruction: LD   DE,208A
    advance (10)
    D := 20;
    E := 8A;
    jump (06AE);

06AE:

    #06AE
    #instruction: CALL 1A06
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := B1;
    #return-to: 06B1
    advance (17)
    SP := a3;
    jump (1A06);

06B1:

    #06B1
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (06B2);
    }

06B2:

    #06B2
    #instruction: LD   HL,2085
    advance (10)
    HL := 2085;
    jump (06B5);

06B5:

    #06B5
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (06B6);

06B6:

    #06B6
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (06B7);

06B7:

    #06B7
    #instruction: JP   NZ,06D6
    if (!FlagZ) {
      advance (10)
      jump (06D6);
    } else {
      advance (10)
      jump (06BA);
    }

06BA:

    #06BA
    #instruction: LD   HL,208A
    advance (10)
    HL := 208A;
    jump (06BD);

06BD:

    #06BD
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (06BE);

06BE:

    #06BE
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (06BF);

06BF:

    #06BF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (06C0);

06C0:

    #06C0
    #instruction: ADD  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:16 a4 = addWithCarry(false,a2,a3) in
    let:8 a5 = (a2 & 0F) in
    let:8 a6 = (a3 & 0F) in
    let:16 a7 = addWithCarry(false,a5,a6) in
    advance (7)
    A := a4[7:0];
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := a4[15:8][0];
    jump (06C1);

06C1:

    #06C1
    #instruction: LD   (208A),A
    let:8 a1 = A in
    M[208A] := a1;
    advance (13)
    jump (06C4);

06C4:

    #06C4
    #instruction: CALL 073C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := C7;
    #return-to: 06C7
    advance (17)
    SP := a3;
    jump (073C);

06C7:

    #06C7
    #instruction: LD   HL,208A
    advance (10)
    HL := 208A;
    jump (06CA);

06CA:

    #06CA
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (06CB);

06CB:

    #06CB
    #instruction: CP   28
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~28) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~28 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (06CD);

06CD:

    #06CD
    #instruction: JP   CY,06F9
    if (FlagCY) {
      advance (10)
      jump (06F9);
    } else {
      advance (10)
      jump (06D0);
    }

06D0:

    #06D0
    #instruction: CP   E1
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~E1) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~E1 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (06D2);

06D2:

    #06D2
    #instruction: JP   NC,06F9
    if (!FlagCY) {
      advance (10)
      jump (06F9);
    } else {
      advance (10)
      jump (06D5);
    }

06D5:

    #06D5
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

06D6:

    #06D6
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (06D8);

06D8:

    #06D8
    #instruction: CALL 19DC
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := DB;
    #return-to: 06DB
    advance (17)
    SP := a3;
    jump (19DC);

06DB:

    #06DB
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (06DC);

06DC:

    #06DC
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (06DD);

06DD:

    #06DD
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (06DE);

06DE:

    #06DE
    #instruction: CP   1F
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~1F) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~1F & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (06E0);

06E0:

    #06E0
    #instruction: JP   Z,074B
    if (FlagZ) {
      advance (10)
      jump (074B);
    } else {
      advance (10)
      jump (06E3);
    }

06E3:

    #06E3
    #instruction: CP   18
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~18) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~18 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (06E5);

06E5:

    #06E5
    #instruction: JP   Z,070C
    if (FlagZ) {
      advance (10)
      jump (070C);
    } else {
      advance (10)
      jump (06E8);
    }

06E8:

    #06E8
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (06E9);

06E9:

    #06E9
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (06EA);
    }

06EA:

    #06EA
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (06EC);

06EC:

    #06EC
    #instruction: LD   HL,2098
    advance (10)
    HL := 2098;
    jump (06EF);

06EF:

    #06EF
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (06F0);

06F0:

    #06F0
    #instruction: AND  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (06F1);

06F1:

    #06F1
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (06F2);

06F2:

    #06F2
    #instruction: AND  20
    let:8 a1 = A in
    let:8 a2 = (20 & a1) in
    let:8 a3 = (20 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (06F4);

06F4:

    #06F4
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (06F6);

06F6:

    #06F6
    #instruction: NOP
    advance (4)
    jump (06F7);

06F7:

    #06F7
    #instruction: NOP
    advance (4)
    jump (06F8);

06F8:

    #06F8
    #instruction: NOP
    advance (4)
    jump (06F9);

06F9:

    #06F9
    #instruction: CALL 0742
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := FC;
    #return-to: 06FC
    advance (17)
    SP := a3;
    jump (0742);

06FC:

    #06FC
    #instruction: CALL 14CB
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 06;
    let:16 a3 = (-1 + a2) in
    M[a3] := FF;
    #return-to: 06FF
    advance (17)
    SP := a3;
    jump (14CB);

06FF:

    #06FF
    #instruction: LD   HL,2083
    advance (10)
    HL := 2083;
    jump (0702);

0702:

    #0702
    #instruction: LD   B,0A
    advance (7)
    B := 0A;
    jump (0704);

0704:

    #0704
    #instruction: CALL 075F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 07;
    #return-to: 0707
    advance (17)
    SP := a3;
    jump (075F);

0707:

    #0707
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (0709);

0709:

    #0709
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

070C:

    #070C
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (070E);

070E:

    #070E
    #instruction: LD   (20F1),A
    let:8 a1 = A in
    M[20F1] := a1;
    advance (13)
    jump (0711);

0711:

    #0711
    #instruction: LD   HL,(208D)
    let:8 a1 = M[208D] in
    let:16 a2 = HL in
    let:8 a3 = M[208E] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (0714);

0714:

    #0714
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (0715);

0715:

    #0715
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (0717);

0717:

    #0717
    #instruction: LD   HL,1D50
    advance (10)
    HL := 1D50;
    jump (071A);

071A:

    #071A
    #instruction: LD   DE,1D4C
    advance (10)
    D := 1D;
    E := 4C;
    jump (071D);

071D:

    #071D
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (071E);

071E:

    #071E
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (071F);

071F:

    #071F
    #instruction: JP   Z,0728
    if (FlagZ) {
      advance (10)
      jump (0728);
    } else {
      advance (10)
      jump (0722);
    }

0722:

    #0722
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0723);

0723:

    #0723
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (0724);

0724:

    #0724
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0725);

0725:

    #0725
    #instruction: JP   NZ,071D
    if (!FlagZ) {
      advance (10)
      jump (071D);
    } else {
      advance (10)
      jump (0728);
    }

0728:

    #0728
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0729);

0729:

    #0729
    #instruction: LD   (2087),A
    let:8 a1 = A in
    M[2087] := a1;
    advance (13)
    jump (072C);

072C:

    #072C
    #instruction: LD   H,00
    let:16 a1 = HL in
    advance (7)
    HL := (00,a1[7:0]);
    jump (072E);

072E:

    #072E
    #instruction: LD   L,B
    let:8 a1 = B in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (072F);

072F:

    #072F
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0730);

0730:

    #0730
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0731);

0731:

    #0731
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0732);

0732:

    #0732
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0733);

0733:

    #0733
    #instruction: LD   (20F2),HL
    let:16 a1 = HL in
    M[20F2] := a1[7:0];
    let:16 a2 = HL in
    M[20F3] := a2[15:8];
    advance (16)
    jump (0736);

0736:

    #0736
    #instruction: CALL 0742
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 39;
    #return-to: 0739
    advance (17)
    SP := a3;
    jump (0742);

0739:

    #0739
    #instruction: JP   08F1
    advance (10)
    jump (08F1);

073C:

    #073C
    #instruction: CALL 0742
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3F;
    #return-to: 073F
    advance (17)
    SP := a3;
    jump (0742);

073F:

    #073F
    #instruction: JP   1439
    advance (10)
    jump (1439);

0742:

    #0742
    #instruction: LD   HL,2087
    advance (10)
    HL := 2087;
    jump (0745);

0745:

    #0745
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 48;
    #return-to: 0748
    advance (17)
    SP := a3;
    jump (1A3B);

0748:

    #0748
    #instruction: JP   1A47
    advance (10)
    jump (1A47);

074B:

    #074B
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (074D);

074D:

    #074D
    #instruction: LD   HL,2098
    advance (10)
    HL := 2098;
    jump (0750);

0750:

    #0750
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0751);

0751:

    #0751
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0752);

0752:

    #0752
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0753);

0753:

    #0753
    #instruction: CALL 1770
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 56;
    #return-to: 0756
    advance (17)
    SP := a3;
    jump (1770);

0756:

    #0756
    #instruction: LD   HL,1D7C
    advance (10)
    HL := 1D7C;
    jump (0759);

0759:

    #0759
    #instruction: LD   (2087),HL
    let:16 a1 = HL in
    M[2087] := a1[7:0];
    let:16 a2 = HL in
    M[2088] := a2[15:8];
    advance (16)
    jump (075C);

075C:

    #075C
    #instruction: JP   073C
    advance (10)
    jump (073C);

075F:

    #075F
    #instruction: LD   DE,1B83
    advance (10)
    D := 1B;
    E := 83;
    jump (0762);

0762:

    #0762
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0765:

    #0765
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0767);

0767:

    #0767
    #instruction: LD   (2093),A
    let:8 a1 = A in
    M[2093] := a1;
    advance (13)
    jump (076A);

076A:

    #076A
    #instruction: LD   SP,2400
    advance (10)
    SP := 2400;
    jump (076D);

076D:

    #076D
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (076E);

076E:

    #076E
    #instruction: CALL 1979
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 71;
    #return-to: 0771
    advance (17)
    SP := a3;
    jump (1979);

0771:

    #0771
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 74;
    #return-to: 0774
    advance (17)
    SP := a3;
    jump (09D6);

0774:

    #0774
    #instruction: LD   HL,3013
    advance (10)
    HL := 3013;
    jump (0777);

0777:

    #0777
    #instruction: LD   DE,1FF3
    advance (10)
    D := 1F;
    E := F3;
    jump (077A);

077A:

    #077A
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (077C);

077C:

    #077C
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7F;
    #return-to: 077F
    advance (17)
    SP := a3;
    jump (08F3);

077F:

    #077F
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    A := a1;
    jump (0782);

0782:

    #0782
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0783);

0783:

    #0783
    #instruction: LD   HL,2810
    advance (10)
    HL := 2810;
    jump (0786);

0786:

    #0786
    #instruction: LD   C,14
    advance (7)
    C := 14;
    jump (0788);

0788:

    #0788
    #instruction: JP   NZ,0857
    if (!FlagZ) {
      advance (10)
      jump (0857);
    } else {
      advance (10)
      jump (078B);
    }

078B:

    #078B
    #instruction: LD   DE,1ACF
    advance (10)
    D := 1A;
    E := CF;
    jump (078E);

078E:

    #078E
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := 91;
    #return-to: 0791
    advance (17)
    SP := a3;
    jump (08F3);

0791:

    #0791
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (0793);

0793:

    #0793
    #instruction: AND  04
    let:8 a1 = A in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0795);

0795:

    #0795
    #instruction: JP   Z,077F
    if (FlagZ) {
      advance (10)
      jump (077F);
    } else {
      advance (10)
      jump (0798);
    }

0798:

    #0798
    #instruction: LD   B,99
    advance (7)
    B := 99;
    jump (079A);

079A:

    #079A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (079B);

079B:

    #079B
    #instruction: LD   (20CE),A
    let:8 a1 = A in
    M[20CE] := a1;
    advance (13)
    jump (079E);

079E:

    #079E
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    A := a1;
    jump (07A1);

07A1:

    #07A1
    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (07A2);

07A2:

    #07A2
    #instruction: DAA
    let:8 a1 = A in
    let:8 a2 = (a1 & 0F) in
    let:16 a3 = addWithCarry(false,a2,06) in
    let:16 a4 = addWithCarry(((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4],(a1 >> 04),00) in
    let:16 a5 = addWithCarry(false,a4[7:0],06) in
    let:8 a6 = (((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2) & 0F) in
    let:8 a7 = ((((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0]) << 04) | a6) in
    advance (4)
    A := a7;
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := ((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4];
    FlagP := parity(a7);
    FlagCY := (((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0])[4] || FlagCY);
    jump (07A3);

07A3:

    #07A3
    #instruction: LD   (20EB),A
    let:8 a1 = A in
    M[20EB] := a1;
    advance (13)
    jump (07A6);

07A6:

    #07A6
    #instruction: CALL 1947
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := A9;
    #return-to: 07A9
    advance (17)
    SP := a3;
    jump (1947);

07A9:

    #07A9
    #instruction: LD   HL,0000
    advance (10)
    HL := 0000;
    jump (07AC);

07AC:

    #07AC
    #instruction: LD   (20F8),HL
    let:16 a1 = HL in
    M[20F8] := a1[7:0];
    let:16 a2 = HL in
    M[20F9] := a2[15:8];
    advance (16)
    jump (07AF);

07AF:

    #07AF
    #instruction: LD   (20FC),HL
    let:16 a1 = HL in
    M[20FC] := a1[7:0];
    let:16 a2 = HL in
    M[20FD] := a2[15:8];
    advance (16)
    jump (07B2);

07B2:

    #07B2
    #instruction: CALL 1925
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := B5;
    #return-to: 07B5
    advance (17)
    SP := a3;
    jump (1925);

07B5:

    #07B5
    #instruction: CALL 192B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := B8;
    #return-to: 07B8
    advance (17)
    SP := a3;
    jump (192B);

07B8:

    #07B8
    #instruction: CALL 19D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := BB;
    #return-to: 07BB
    advance (17)
    SP := a3;
    jump (19D7);

07BB:

    #07BB
    #instruction: LD   HL,0101
    advance (10)
    HL := 0101;
    jump (07BE);

07BE:

    #07BE
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (07BF);

07BF:

    #07BF
    #instruction: LD   (20EF),A
    let:8 a1 = A in
    M[20EF] := a1;
    advance (13)
    jump (07C2);

07C2:

    #07C2
    #instruction: LD   (20E7),HL
    let:16 a1 = HL in
    M[20E7] := a1[7:0];
    let:16 a2 = HL in
    M[20E8] := a2[15:8];
    advance (16)
    jump (07C5);

07C5:

    #07C5
    #instruction: LD   (20E5),HL
    let:16 a1 = HL in
    M[20E5] := a1[7:0];
    let:16 a2 = HL in
    M[20E6] := a2[15:8];
    advance (16)
    jump (07C8);

07C8:

    #07C8
    #instruction: CALL 1956
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := CB;
    #return-to: 07CB
    advance (17)
    SP := a3;
    jump (1956);

07CB:

    #07CB
    #instruction: CALL 01EF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := CE;
    #return-to: 07CE
    advance (17)
    SP := a3;
    jump (01EF);

07CE:

    #07CE
    #instruction: CALL 01F5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := D1;
    #return-to: 07D1
    advance (17)
    SP := a3;
    jump (01F5);

07D1:

    #07D1
    #instruction: CALL 08D1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := D4;
    #return-to: 07D4
    advance (17)
    SP := a3;
    jump (08D1);

07D4:

    #07D4
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    jump (07D7);

07D7:

    #07D7
    #instruction: LD   (22FF),A
    let:8 a1 = A in
    M[22FF] := a1;
    advance (13)
    jump (07DA);

07DA:

    #07DA
    #instruction: CALL 00D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := DD;
    #return-to: 07DD
    advance (17)
    SP := a3;
    jump (00D7);

07DD:

    #07DD
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (07DE);

07DE:

    #07DE
    #instruction: LD   (21FE),A
    let:8 a1 = A in
    M[21FE] := a1;
    advance (13)
    jump (07E1);

07E1:

    #07E1
    #instruction: LD   (22FE),A
    let:8 a1 = A in
    M[22FE] := a1;
    advance (13)
    jump (07E4);

07E4:

    #07E4
    #instruction: CALL 01C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := E7;
    #return-to: 07E7
    advance (17)
    SP := a3;
    jump (01C0);

07E7:

    #07E7
    #instruction: CALL 1904
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := EA;
    #return-to: 07EA
    advance (17)
    SP := a3;
    jump (1904);

07EA:

    #07EA
    #instruction: LD   HL,3878
    advance (10)
    HL := 3878;
    jump (07ED);

07ED:

    #07ED
    #instruction: LD   (21FC),HL
    let:16 a1 = HL in
    M[21FC] := a1[7:0];
    let:16 a2 = HL in
    M[21FD] := a2[15:8];
    advance (16)
    jump (07F0);

07F0:

    #07F0
    #instruction: LD   (22FC),HL
    let:16 a1 = HL in
    M[22FC] := a1[7:0];
    let:16 a2 = HL in
    M[22FD] := a2[15:8];
    advance (16)
    jump (07F3);

07F3:

    #07F3
    #instruction: CALL 01E4
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := F6;
    #return-to: 07F6
    advance (17)
    SP := a3;
    jump (01E4);

07F6:

    #07F6
    #instruction: CALL 1A7F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := F9;
    #return-to: 07F9
    advance (17)
    SP := a3;
    jump (1A7F);

07F9:

    #07F9
    #instruction: CALL 088D
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := FC;
    #return-to: 07FC
    advance (17)
    SP := a3;
    jump (088D);

07FC:

    #07FC
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 07;
    let:16 a3 = (-1 + a2) in
    M[a3] := FF;
    #return-to: 07FF
    advance (17)
    SP := a3;
    jump (09D6);

07FF:

    #07FF
    #instruction: NOP
    advance (4)
    jump (0800);

0800:

    #0800
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0801);

0801:

    #0801
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (0804);

0804:

    #0804
    #instruction: CALL 01CF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 07;
    #return-to: 0807
    advance (17)
    SP := a3;
    jump (01CF);

0807:

    #0807
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (080A);

080A:

    #080A
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (080B);

080B:

    #080B
    #instruction: JP   CY,0872
    if (FlagCY) {
      advance (10)
      jump (0872);
    } else {
      advance (10)
      jump (080E);
    }

080E:

    #080E
    #instruction: CALL 0213
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 11;
    #return-to: 0811
    advance (17)
    SP := a3;
    jump (0213);

0811:

    #0811
    #instruction: CALL 01CF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 14;
    #return-to: 0814
    advance (17)
    SP := a3;
    jump (01CF);

0814:

    #0814
    #instruction: CALL 00B1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 17;
    #return-to: 0817
    advance (17)
    SP := a3;
    jump (00B1);

0817:

    #0817
    #instruction: CALL 19D1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    #return-to: 081A
    advance (17)
    SP := a3;
    jump (19D1);

081A:

    #081A
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (081C);

081C:

    #081C
    #instruction: CALL 18FA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 1F;
    #return-to: 081F
    advance (17)
    SP := a3;
    jump (18FA);

081F:

    #081F
    #instruction: CALL 1618
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 22;
    #return-to: 0822
    advance (17)
    SP := a3;
    jump (1618);

0822:

    #0822
    #instruction: CALL 190A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 25;
    #return-to: 0825
    advance (17)
    SP := a3;
    jump (190A);

0825:

    #0825
    #instruction: CALL 15F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 28;
    #return-to: 0828
    advance (17)
    SP := a3;
    jump (15F3);

0828:

    #0828
    #instruction: CALL 0988
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2B;
    #return-to: 082B
    advance (17)
    SP := a3;
    jump (0988);

082B:

    #082B
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (082E);

082E:

    #082E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (082F);

082F:

    #082F
    #instruction: JP   Z,09EF
    if (FlagZ) {
      advance (10)
      jump (09EF);
    } else {
      advance (10)
      jump (0832);
    }

0832:

    #0832
    #instruction: CALL 170E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 35;
    #return-to: 0835
    advance (17)
    SP := a3;
    jump (170E);

0835:

    #0835
    #instruction: CALL 0935
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 38;
    #return-to: 0838
    advance (17)
    SP := a3;
    jump (0935);

0838:

    #0838
    #instruction: CALL 08D8
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3B;
    #return-to: 083B
    advance (17)
    SP := a3;
    jump (08D8);

083B:

    #083B
    #instruction: CALL 172C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3E;
    #return-to: 083E
    advance (17)
    SP := a3;
    jump (172C);

083E:

    #083E
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 41;
    #return-to: 0841
    advance (17)
    SP := a3;
    jump (0A59);

0841:

    #0841
    #instruction: JP   Z,0849
    if (FlagZ) {
      advance (10)
      jump (0849);
    } else {
      advance (10)
      jump (0844);
    }

0844:

    #0844
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (0846);

0846:

    #0846
    #instruction: CALL 18FA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 49;
    #return-to: 0849
    advance (17)
    SP := a3;
    jump (18FA);

0849:

    #0849
    #instruction: CALL 1775
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4C;
    #return-to: 084C
    advance (17)
    SP := a3;
    jump (1775);

084C:

    #084C
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    jump (084E);

084E:

    #084E
    #instruction: CALL 1804
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 51;
    #return-to: 0851
    advance (17)
    SP := a3;
    jump (1804);

0851:

    #0851
    #instruction: JP   081F
    advance (10)
    jump (081F);

0857:

    #0857
    #instruction: LD   DE,1ABA
    advance (10)
    D := 1A;
    E := BA;
    jump (085A);

085A:

    #085A
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 5D;
    #return-to: 085D
    advance (17)
    SP := a3;
    jump (08F3);

085D:

    #085D
    #instruction: LD   B,98
    advance (7)
    B := 98;
    jump (085F);

085F:

    #085F
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (0861);

0861:

    #0861
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0862);

0862:

    #0862
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0863);

0863:

    #0863
    #instruction: JP   CY,086D
    if (FlagCY) {
      advance (10)
      jump (086D);
    } else {
      advance (10)
      jump (0866);
    }

0866:

    #0866
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0867);

0867:

    #0867
    #instruction: JP   CY,0798
    if (FlagCY) {
      advance (10)
      jump (0798);
    } else {
      advance (10)
      jump (086A);
    }

086A:

    #086A
    #instruction: JP   077F
    advance (10)
    jump (077F);

086D:

    #086D
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (086F);

086F:

    #086F
    #instruction: JP   079B
    advance (10)
    jump (079B);

0872:

    #0872
    #instruction: CALL 021A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 75;
    #return-to: 0875
    advance (17)
    SP := a3;
    jump (021A);

0875:

    #0875
    #instruction: JP   0814
    advance (10)
    jump (0814);

0878:

    #0878
    #instruction: LD   A,(2008)
    let:8 a1 = M[2008] in
    advance (13)
    A := a1;
    jump (087B);

087B:

    #087B
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (087C);

087C:

    #087C
    #instruction: LD   HL,(2009)
    let:8 a1 = M[2009] in
    let:16 a2 = HL in
    let:8 a3 = M[200A] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (087F);

087F:

    #087F
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (0880);

0880:

    #0880
    #instruction: JP   0886
    advance (10)
    jump (0886);

0886:

    #0886
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (0889);

0889:

    #0889
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (088A);

088A:

    #088A
    #instruction: LD   L,FC
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],FC);
    jump (088C);

088C:

    #088C
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

088D:

    #088D
    #instruction: LD   HL,2B11
    advance (10)
    HL := 2B11;
    jump (0890);

0890:

    #0890
    #instruction: LD   DE,1B70
    advance (10)
    D := 1B;
    E := 70;
    jump (0893);

0893:

    #0893
    #instruction: LD   C,0E
    advance (7)
    C := 0E;
    jump (0895);

0895:

    #0895
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := 98;
    #return-to: 0898
    advance (17)
    SP := a3;
    jump (08F3);

0898:

    #0898
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (089B);

089B:

    #089B
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (089C);

089C:

    #089C
    #instruction: LD   A,1C
    advance (7)
    A := 1C;
    jump (089E);

089E:

    #089E
    #instruction: LD   HL,3711
    advance (10)
    HL := 3711;
    jump (08A1);

08A1:

    #08A1
    #instruction: CALL NC,08FF
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (-1 + a1) in
      M[a2] := 08;
      let:16 a3 = (-1 + a2) in
      M[a3] := A4;
      #return-to: 08A4
      advance (17)
      SP := a3;
      jump (08FF);
    } else {
      advance (11)
      jump (08A4);
    }

08A4:

    #08A4
    #instruction: LD   A,B0
    advance (7)
    A := B0;
    jump (08A6);

08A6:

    #08A6
    #instruction: LD   (20C0),A
    let:8 a1 = A in
    M[20C0] := a1;
    advance (13)
    jump (08A9);

08A9:

    #08A9
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    A := a1;
    jump (08AC);

08AC:

    #08AC
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (08AD);

08AD:

    #08AD
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (08AE);
    }

08AE:

    #08AE
    #instruction: AND  04
    let:8 a1 = A in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (08B0);

08B0:

    #08B0
    #instruction: JP   NZ,08BC
    if (!FlagZ) {
      advance (10)
      jump (08BC);
    } else {
      advance (10)
      jump (08B3);
    }

08B3:

    #08B3
    #instruction: CALL 09CA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := B6;
    #return-to: 08B6
    advance (17)
    SP := a3;
    jump (09CA);

08B6:

    #08B6
    #instruction: CALL 1931
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := B9;
    #return-to: 08B9
    advance (17)
    SP := a3;
    jump (1931);

08B9:

    #08B9
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08BC:

    #08BC
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (08BE);

08BE:

    #08BE
    #instruction: LD   HL,271C
    advance (10)
    HL := 271C;
    jump (08C1);

08C1:

    #08C1
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (08C4);

08C4:

    #08C4
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (08C5);

08C5:

    #08C5
    #instruction: JP   CY,08CB
    if (FlagCY) {
      advance (10)
      jump (08CB);
    } else {
      advance (10)
      jump (08C8);
    }

08C8:

    #08C8
    #instruction: LD   HL,391C
    advance (10)
    HL := 391C;
    jump (08CB);

08CB:

    #08CB
    #instruction: CALL 14CB
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := CE;
    #return-to: 08CE
    advance (17)
    SP := a3;
    jump (14CB);

08CE:

    #08CE
    #instruction: JP   08A9
    advance (10)
    jump (08A9);

08D1:

    #08D1
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
    jump (08D3);

08D3:

    #08D3
    #instruction: AND  03
    let:8 a1 = A in
    let:8 a2 = (03 & a1) in
    let:8 a3 = (03 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (08D5);

08D5:

    #08D5
    #instruction: ADD  03
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,03,a1) in
    let:8 a3 = (03 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (08D7);

08D7:

    #08D7
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

08D8:

    #08D8
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (08DB);

08DB:

    #08DB
    #instruction: CP   09
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~09) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~09 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (08DD);

08DD:

    #08DD
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (08DE);
    }

08DE:

    #08DE
    #instruction: LD   A,FB
    advance (7)
    A := FB;
    jump (08E0);

08E0:

    #08E0
    #instruction: LD   (207E),A
    let:8 a1 = A in
    M[207E] := a1;
    advance (13)
    jump (08E3);

08E3:

    #08E3
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

08E4:

    #08E4
    #instruction: LD   A,(20CE)
    let:8 a1 = M[20CE] in
    advance (13)
    A := a1;
    jump (08E7);

08E7:

    #08E7
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (08E8);

08E8:

    #08E8
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (08E9);
    }

08E9:

    #08E9
    #instruction: LD   HL,391C
    advance (10)
    HL := 391C;
    jump (08EC);

08EC:

    #08EC
    #instruction: LD   B,20
    advance (7)
    B := 20;
    jump (08EE);

08EE:

    #08EE
    #instruction: JP   14CB
    advance (10)
    jump (14CB);

08F1:

    #08F1
    #instruction: LD   C,03
    advance (7)
    C := 03;
    jump (08F3);

08F3:

    #08F3
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (08F4);

08F4:

    #08F4
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (08F5);

08F5:

    #08F5
    #instruction: CALL 08FF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 08;
    let:16 a3 = (-1 + a2) in
    M[a3] := F8;
    #return-to: 08F8
    advance (17)
    SP := a3;
    jump (08FF);

08F8:

    #08F8
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (08F9);

08F9:

    #08F9
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (08FA);

08FA:

    #08FA
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (08FB);

08FB:

    #08FB
    #instruction: JP   NZ,08F3
    if (!FlagZ) {
      advance (10)
      jump (08F3);
    } else {
      advance (10)
      jump (08FE);
    }

08FE:

    #08FE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

08FF:

    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    D := 1E;
    E := 00;
    jump (0902);

0902:

    #0902
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0903);

0903:

    #0903
    #instruction: LD   H,00
    let:16 a1 = HL in
    advance (7)
    HL := (00,a1[7:0]);
    jump (0905);

0905:

    #0905
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (0906);

0906:

    #0906
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0907);

0907:

    #0907
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0908);

0908:

    #0908
    #instruction: ADD  HL,HL
    let:16 a1 = HL in
    let:16 a2 = HL in
    let:17 a3 = add17(a1,a2) in
    advance (10)
    HL := a3[15:0];
    FlagCY := a3[16];
    jump (0909);

0909:

    #0909
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (090A);

090A:

    #090A
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (090B);

090B:

    #090B
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (090C);

090C:

    #090C
    #instruction: LD   B,08
    advance (7)
    B := 08;
    jump (090E);

090E:

    #090E
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    jump (0910);

0910:

    #0910
    #instruction: JP   1439
    advance (10)
    jump (1439);

0913:

    #0913
    #instruction: LD   A,(2009)
    let:8 a1 = M[2009] in
    advance (13)
    A := a1;
    jump (0916);

0916:

    #0916
    #instruction: CP   78
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~78) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~78 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0918);

0918:

    #0918
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0919);
    }

0919:

    #0919
    #instruction: LD   HL,(2091)
    let:8 a1 = M[2091] in
    let:16 a2 = HL in
    let:8 a3 = M[2092] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (091C);

091C:

    #091C
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (091D);

091D:

    #091D
    #instruction: OR   H
    let:16 a1 = HL in
    let:8 a2 = A in
    let:8 a3 = (a1[15:8] | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (091E);

091E:

    #091E
    #instruction: JP   NZ,0929
    if (!FlagZ) {
      advance (10)
      jump (0929);
    } else {
      advance (10)
      jump (0921);
    }

0921:

    #0921
    #instruction: LD   HL,0600
    advance (10)
    HL := 0600;
    jump (0924);

0924:

    #0924
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0926);

0926:

    #0926
    #instruction: LD   (2083),A
    let:8 a1 = A in
    M[2083] := a1;
    advance (13)
    jump (0929);

0929:

    #0929
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (092A);

092A:

    #092A
    #instruction: LD   (2091),HL
    let:16 a1 = HL in
    M[2091] := a1[7:0];
    let:16 a2 = HL in
    M[2092] := a2[15:8];
    advance (16)
    jump (092D);

092D:

    #092D
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

092E:

    #092E
    #instruction: CALL 1611
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 31;
    #return-to: 0931
    advance (17)
    SP := a3;
    jump (1611);

0931:

    #0931
    #instruction: LD   L,FF
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],FF);
    jump (0933);

0933:

    #0933
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0934);

0934:

    #0934
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0935:

    #0935
    #instruction: CALL 1910
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 38;
    #return-to: 0938
    advance (17)
    SP := a3;
    jump (1910);

0938:

    #0938
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0939);

0939:

    #0939
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (093A);

093A:

    #093A
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (093B);

093B:

    #093B
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (093C);

093C:

    #093C
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (093D);
    }

093D:

    #093D
    #instruction: LD   B,15
    advance (7)
    B := 15;
    jump (093F);

093F:

    #093F
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
    jump (0941);

0941:

    #0941
    #instruction: AND  08
    let:8 a1 = A in
    let:8 a2 = (08 & a1) in
    let:8 a3 = (08 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0943);

0943:

    #0943
    #instruction: JP   Z,0948
    if (FlagZ) {
      advance (10)
      jump (0948);
    } else {
      advance (10)
      jump (0946);
    }

0946:

    #0946
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0948);

0948:

    #0948
    #instruction: CALL 09CA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4B;
    #return-to: 094B
    advance (17)
    SP := a3;
    jump (09CA);

094B:

    #094B
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (094C);

094C:

    #094C
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (094D);

094D:

    #094D
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (094E);

094E:

    #094E
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (094F);
    }

094F:

    #094F
    #instruction: CALL 092E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 52;
    #return-to: 0952
    advance (17)
    SP := a3;
    jump (092E);

0952:

    #0952
    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (0953);

0953:

    #0953
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0954);

0954:

    #0954
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (0955);

0955:

    #0955
    #instruction: LD   HL,2501
    advance (10)
    HL := 2501;
    jump (0958);

0958:

    #0958
    #instruction: INC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[15:8],00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0959);

0959:

    #0959
    #instruction: INC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(true,a1[15:8],00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (095A);

095A:

    #095A
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (095B);

095B:

    #095B
    #instruction: JP   NZ,0958
    if (!FlagZ) {
      advance (10)
      jump (0958);
    } else {
      advance (10)
      jump (095E);
    }

095E:

    #095E
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0960);

0960:

    #0960
    #instruction: LD   DE,1C60
    advance (10)
    D := 1C;
    E := 60;
    jump (0963);

0963:

    #0963
    #instruction: CALL 1439
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 66;
    #return-to: 0966
    advance (17)
    SP := a3;
    jump (1439);

0966:

    #0966
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (0967);

0967:

    #0967
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0968);

0968:

    #0968
    #instruction: CALL 1A8B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 6B;
    #return-to: 096B
    advance (17)
    SP := a3;
    jump (1A8B);

096B:

    #096B
    #instruction: CALL 1910
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 6E;
    #return-to: 096E
    advance (17)
    SP := a3;
    jump (1910);

096E:

    #096E
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (096F);

096F:

    #096F
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0970);

0970:

    #0970
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (0972);

0972:

    #0972
    #instruction: LD   A,FF
    advance (7)
    A := FF;
    jump (0974);

0974:

    #0974
    #instruction: LD   (2099),A
    let:8 a1 = A in
    M[2099] := a1;
    advance (13)
    jump (0977);

0977:

    #0977
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (0979);

0979:

    #0979
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

097C:

    #097C
    #instruction: LD   HL,1DA0
    advance (10)
    HL := 1DA0;
    jump (097F);

097F:

    #097F
    #instruction: CP   02
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~02) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~02 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0981);

0981:

    #0981
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0982);
    }

0982:

    #0982
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0983);

0983:

    #0983
    #instruction: CP   04
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~04) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~04 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0985);

0985:

    #0985
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0986);
    }

0986:

    #0986
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0987);

0987:

    #0987
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0988:

    #0988
    #instruction: CALL 09CA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := 8B;
    #return-to: 098B
    advance (17)
    SP := a3;
    jump (09CA);

098B:

    #098B
    #instruction: LD   A,(20F1)
    let:8 a1 = M[20F1] in
    advance (13)
    A := a1;
    jump (098E);

098E:

    #098E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (098F);

098F:

    #098F
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0990);
    }

0990:

    #0990
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0991);

0991:

    #0991
    #instruction: LD   (20F1),A
    let:8 a1 = A in
    M[20F1] := a1;
    advance (13)
    jump (0994);

0994:

    #0994
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0995);

0995:

    #0995
    #instruction: LD   HL,(20F2)
    let:8 a1 = M[20F2] in
    let:16 a2 = HL in
    let:8 a3 = M[20F3] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (0998);

0998:

    #0998
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (0999);

0999:

    #0999
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (099A);

099A:

    #099A
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (099B);

099B:

    #099B
    #instruction: ADD  E
    let:8 a1 = E in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (099C);

099C:

    #099C
    #instruction: DAA
    let:8 a1 = A in
    let:8 a2 = (a1 & 0F) in
    let:16 a3 = addWithCarry(false,a2,06) in
    let:16 a4 = addWithCarry(((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4],(a1 >> 04),00) in
    let:16 a5 = addWithCarry(false,a4[7:0],06) in
    let:8 a6 = (((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2) & 0F) in
    let:8 a7 = ((((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0]) << 04) | a6) in
    advance (4)
    A := a7;
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := ((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4];
    FlagP := parity(a7);
    FlagCY := (((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0])[4] || FlagCY);
    jump (099D);

099D:

    #099D
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (099E);

099E:

    #099E
    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump (099F);

099F:

    #099F
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (09A0);

09A0:

    #09A0
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (09A1);

09A1:

    #09A1
    #instruction: ADC  D
    let:8 a1 = D in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(FlagCY,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(FlagCY,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (09A2);

09A2:

    #09A2
    #instruction: DAA
    let:8 a1 = A in
    let:8 a2 = (a1 & 0F) in
    let:16 a3 = addWithCarry(false,a2,06) in
    let:16 a4 = addWithCarry(((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4],(a1 >> 04),00) in
    let:16 a5 = addWithCarry(false,a4[7:0],06) in
    let:8 a6 = (((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2) & 0F) in
    let:8 a7 = ((((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0]) << 04) | a6) in
    advance (4)
    A := a7;
    FlagS := a7[7];
    FlagZ := is_zero(a7);
    FlagA := ((((a2[1] || a2[2]) && a2[3]) || FlagA) ? a3[7:0] : a2)[4];
    FlagP := parity(a7);
    FlagCY := (((((a4[7:0][1] || a4[7:0][2]) && a4[7:0][3]) || FlagCY) ? a5[7:0] : a4[7:0])[4] || FlagCY);
    jump (09A3);

09A3:

    #09A3
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (09A4);

09A4:

    #09A4
    #instruction: LD   D,A
    let:8 a1 = A in
    advance (5)
    D := a1;
    jump (09A5);

09A5:

    #09A5
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (09A6);

09A6:

    #09A6
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (09A7);

09A7:

    #09A7
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (09A8);

09A8:

    #09A8
    #instruction: LD   H,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a2,a3[7:0]);
    jump (09A9);

09A9:

    #09A9
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (09AA);

09AA:

    #09AA
    #instruction: JP   09AD
    advance (10)
    jump (09AD);

09AD:

    #09AD
    #instruction: LD   A,D
    let:8 a1 = D in
    advance (5)
    A := a1;
    jump (09AE);

09AE:

    #09AE
    #instruction: CALL 09B2
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := B1;
    #return-to: 09B1
    advance (17)
    SP := a3;
    jump (09B2);

09B1:

    #09B1
    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    A := a1;
    jump (09B2);

09B2:

    #09B2
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (09B3);

09B3:

    #09B3
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (09B4);

09B4:

    #09B4
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (09B5);

09B5:

    #09B5
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (09B6);

09B6:

    #09B6
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (09B7);

09B7:

    #09B7
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (09B8);

09B8:

    #09B8
    #instruction: AND  0F
    let:8 a1 = A in
    let:8 a2 = (0F & a1) in
    let:8 a3 = (0F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (09BA);

09BA:

    #09BA
    #instruction: CALL 09C5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := BD;
    #return-to: 09BD
    advance (17)
    SP := a3;
    jump (09C5);

09BD:

    #09BD
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (09BE);

09BE:

    #09BE
    #instruction: AND  0F
    let:8 a1 = A in
    let:8 a2 = (0F & a1) in
    let:8 a3 = (0F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (09C0);

09C0:

    #09C0
    #instruction: CALL 09C5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := C3;
    #return-to: 09C3
    advance (17)
    SP := a3;
    jump (09C5);

09C3:

    #09C3
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (09C4);

09C4:

    #09C4
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

09C5:

    #09C5
    #instruction: ADD  1A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,1A,a1) in
    let:8 a3 = (1A & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (09C7);

09C7:

    #09C7
    #instruction: JP   08FF
    advance (10)
    jump (08FF);

09CA:

    #09CA
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (09CD);

09CD:

    #09CD
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (09CE);

09CE:

    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    HL := 20F8;
    jump (09D1);

09D1:

    #09D1
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (09D2);
    }

09D2:

    #09D2
    #instruction: LD   HL,20FC
    advance (10)
    HL := 20FC;
    jump (09D5);

09D5:

    #09D5
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

09D6:

    #09D6
    #instruction: LD   HL,2402
    advance (10)
    HL := 2402;
    jump (09D9);

09D9:

    #09D9
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (09DB);

09DB:

    #09DB
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (09DC);

09DC:

    #09DC
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (09DD);

09DD:

    #09DD
    #instruction: AND  1F
    let:8 a1 = A in
    let:8 a2 = (1F & a1) in
    let:8 a3 = (1F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (09DF);

09DF:

    #09DF
    #instruction: CP   1C
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~1C) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~1C & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (09E1);

09E1:

    #09E1
    #instruction: JP   CY,09E8
    if (FlagCY) {
      advance (10)
      jump (09E8);
    } else {
      advance (10)
      jump (09E4);
    }

09E4:

    #09E4
    #instruction: LD   DE,0006
    advance (10)
    D := 00;
    E := 06;
    jump (09E7);

09E7:

    #09E7
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (09E8);

09E8:

    #09E8
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (09E9);

09E9:

    #09E9
    #instruction: CP   40
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~40) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~40 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (09EB);

09EB:

    #09EB
    #instruction: JP   CY,09D9
    if (FlagCY) {
      advance (10)
      jump (09D9);
    } else {
      advance (10)
      jump (09EE);
    }

09EE:

    #09EE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

09EF:

    #09EF
    #instruction: CALL 0A3C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := F2;
    #return-to: 09F2
    advance (17)
    SP := a3;
    jump (0A3C);

09F2:

    #09F2
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (09F3);

09F3:

    #09F3
    #instruction: LD   (20E9),A
    let:8 a1 = A in
    M[20E9] := a1;
    advance (13)
    jump (09F6);

09F6:

    #09F6
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 09;
    let:16 a3 = (-1 + a2) in
    M[a3] := F9;
    #return-to: 09F9
    advance (17)
    SP := a3;
    jump (09D6);

09F9:

    #09F9
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (09FC);

09FC:

    #09FC
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (09FD);

09FD:

    #09FD
    #instruction: CALL 01E4
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 00;
    #return-to: 0A00
    advance (17)
    SP := a3;
    jump (01E4);

0A00:

    #0A00
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (0A01);

0A01:

    #0A01
    #instruction: LD   (2067),A
    let:8 a1 = A in
    M[2067] := a1;
    advance (13)
    jump (0A04);

0A04:

    #0A04
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (0A07);

0A07:

    #0A07
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (0A08);

0A08:

    #0A08
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (0A09);

0A09:

    #0A09
    #instruction: LD   L,FE
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],FE);
    jump (0A0B);

0A0B:

    #0A0B
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0A0C);

0A0C:

    #0A0C
    #instruction: AND  07
    let:8 a1 = A in
    let:8 a2 = (07 & a1) in
    let:8 a3 = (07 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0A0E);

0A0E:

    #0A0E
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0A0F);

0A0F:

    #0A0F
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0A10);

0A10:

    #0A10
    #instruction: LD   HL,1DA2
    advance (10)
    HL := 1DA2;
    jump (0A13);

0A13:

    #0A13
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0A14);

0A14:

    #0A14
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0A15);

0A15:

    #0A15
    #instruction: JP   NZ,0A13
    if (!FlagZ) {
      advance (10)
      jump (0A13);
    } else {
      advance (10)
      jump (0A18);
    }

0A18:

    #0A18
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0A19);

0A19:

    #0A19
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0A1A);

0A1A:

    #0A1A
    #instruction: LD   L,FC
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],FC);
    jump (0A1C);

0A1C:

    #0A1C
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0A1D);

0A1D:

    #0A1D
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (0A1E);

0A1E:

    #0A1E
    #instruction: LD   (HL),38
    let:16 a1 = HL in
    M[a1] := 38;
    advance (10)
    jump (0A20);

0A20:

    #0A20
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (0A21);

0A21:

    #0A21
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0A22);

0A22:

    #0A22
    #instruction: JP   CY,0A33
    if (FlagCY) {
      advance (10)
      jump (0A33);
    } else {
      advance (10)
      jump (0A25);
    }

0A25:

    #0A25
    #instruction: LD   A,21
    advance (7)
    A := 21;
    jump (0A27);

0A27:

    #0A27
    #instruction: LD   (2098),A
    let:8 a1 = A in
    M[2098] := a1;
    advance (13)
    jump (0A2A);

0A2A:

    #0A2A
    #instruction: CALL 01F5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2D;
    #return-to: 0A2D
    advance (17)
    SP := a3;
    jump (01F5);

0A2D:

    #0A2D
    #instruction: CALL 1904
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 30;
    #return-to: 0A30
    advance (17)
    SP := a3;
    jump (1904);

0A30:

    #0A30
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A33:

    #0A33
    #instruction: CALL 01EF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 36;
    #return-to: 0A36
    advance (17)
    SP := a3;
    jump (01EF);

0A36:

    #0A36
    #instruction: CALL 01C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 39;
    #return-to: 0A39
    advance (17)
    SP := a3;
    jump (01C0);

0A39:

    #0A39
    #instruction: JP   0804
    advance (10)
    jump (0804);

0A3C:

    #0A3C
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3F;
    #return-to: 0A3F
    advance (17)
    SP := a3;
    jump (0A59);

0A3F:

    #0A3F
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      jump (0A42);
    }

0A42:

    #0A42
    #instruction: LD   A,30
    advance (7)
    A := 30;
    jump (0A44);

0A44:

    #0A44
    #instruction: LD   (20C0),A
    let:8 a1 = A in
    M[20C0] := a1;
    advance (13)
    jump (0A47);

0A47:

    #0A47
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    A := a1;
    jump (0A4A);

0A4A:

    #0A4A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0A4B);

0A4B:

    #0A4B
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (0A4C);
    }

0A4C:

    #0A4C
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4F;
    #return-to: 0A4F
    advance (17)
    SP := a3;
    jump (0A59);

0A4F:

    #0A4F
    #instruction: JP   Z,0A47
    if (FlagZ) {
      advance (10)
      jump (0A47);
    } else {
      advance (10)
      jump (0A52);
    }

0A52:

    #0A52
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 55;
    #return-to: 0A55
    advance (17)
    SP := a3;
    jump (0A59);

0A55:

    #0A55
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      jump (0A52);
    } else {
      advance (10)
      jump (0A58);
    }

0A58:

    #0A58
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0A59:

    #0A59
    #instruction: LD   A,(2015)
    let:8 a1 = M[2015] in
    advance (13)
    A := a1;
    jump (0A5C);

0A5C:

    #0A5C
    #instruction: CP   FF
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FF) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FF & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0A5E);

0A5E:

    #0A5E
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0A5F:

    #0A5F
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (0A62);

0A62:

    #0A62
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0A63);

0A63:

    #0A63
    #instruction: JP   Z,0A7C
    if (FlagZ) {
      advance (10)
      jump (0A7C);
    } else {
      advance (10)
      jump (0A66);
    }

0A66:

    #0A66
    #instruction: LD   C,B
    let:8 a1 = B in
    advance (5)
    C := a1;
    jump (0A67);

0A67:

    #0A67
    #instruction: LD   B,08
    advance (7)
    B := 08;
    jump (0A69);

0A69:

    #0A69
    #instruction: CALL 18FA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 6C;
    #return-to: 0A6C
    advance (17)
    SP := a3;
    jump (18FA);

0A6C:

    #0A6C
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    B := a1;
    jump (0A6D);

0A6D:

    #0A6D
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (0A6E);

0A6E:

    #0A6E
    #instruction: CALL 097C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 71;
    #return-to: 0A71
    advance (17)
    SP := a3;
    jump (097C);

0A71:

    #0A71
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0A72);

0A72:

    #0A72
    #instruction: LD   HL,20F3
    advance (10)
    HL := 20F3;
    jump (0A75);

0A75:

    #0A75
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (0A77);

0A77:

    #0A77
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0A78);

0A78:

    #0A78
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0A79);

0A79:

    #0A79
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (0A7A);

0A7A:

    #0A7A
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (0A7C);

0A7C:

    #0A7C
    #instruction: LD   HL,2062
    advance (10)
    HL := 2062;
    jump (0A7F);

0A7F:

    #0A7F
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0A80:

    #0A80
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (0A82);

0A82:

    #0A82
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (0A85);

0A85:

    #0A85
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    jump (0A87);

0A87:

    #0A87
    #instruction: LD   A,(20CB)
    let:8 a1 = M[20CB] in
    advance (13)
    A := a1;
    jump (0A8A);

0A8A:

    #0A8A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0A8B);

0A8B:

    #0A8B
    #instruction: JP   Z,0A85
    if (FlagZ) {
      advance (10)
      jump (0A85);
    } else {
      advance (10)
      jump (0A8E);
    }

0A8E:

    #0A8E
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0A8F);

0A8F:

    #0A8F
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (0A92);

0A92:

    #0A92
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0A93:

    #0A93
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (0A94);

0A94:

    #0A94
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (0A95);

0A95:

    #0A95
    #instruction: CALL 08FF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 98;
    #return-to: 0A98
    advance (17)
    SP := a3;
    jump (08FF);

0A98:

    #0A98
    #instruction: POP  DE
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    D := a5;
    E := a3;
    jump (0A99);

0A99:

    #0A99
    #instruction: LD   A,07
    advance (7)
    A := 07;
    jump (0A9B);

0A9B:

    #0A9B
    #instruction: LD   (20C0),A
    let:8 a1 = A in
    M[20C0] := a1;
    advance (13)
    jump (0A9E);

0A9E:

    #0A9E
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    A := a1;
    jump (0AA1);

0AA1:

    #0AA1
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0AA2);

0AA2:

    #0AA2
    #instruction: JP   NZ,0A9E
    if (!FlagZ) {
      advance (10)
      jump (0A9E);
    } else {
      advance (10)
      jump (0AA5);
    }

0AA5:

    #0AA5
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (0AA6);

0AA6:

    #0AA6
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0AA7);

0AA7:

    #0AA7
    #instruction: JP   NZ,0A93
    if (!FlagZ) {
      advance (10)
      jump (0A93);
    } else {
      advance (10)
      jump (0AAA);
    }

0AAA:

    #0AAA
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0AAB:

    #0AAB
    #instruction: LD   HL,2050
    advance (10)
    HL := 2050;
    jump (0AAE);

0AAE:

    #0AAE
    #instruction: JP   024B
    advance (10)
    jump (024B);

0AB1:

    #0AB1
    #instruction: LD   A,40
    advance (7)
    A := 40;
    jump (0AB3);

0AB3:

    #0AB3
    #instruction: JP   0AD7
    advance (10)
    jump (0AD7);

0AB6:

    #0AB6
    #instruction: LD   A,80
    advance (7)
    A := 80;
    jump (0AB8);

0AB8:

    #0AB8
    #instruction: JP   0AD7
    advance (10)
    jump (0AD7);

0ABB:

    #0ABB
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (0ABC);

0ABC:

    #0ABC
    #instruction: JP   0072
    advance (10)
    jump (0072);

0ABF:

    #0ABF
    #instruction: LD   A,(20C1)
    let:8 a1 = M[20C1] in
    advance (13)
    A := a1;
    jump (0AC2);

0AC2:

    #0AC2
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0AC3);

0AC3:

    #0AC3
    #instruction: JP   CY,0ABB
    if (FlagCY) {
      advance (10)
      jump (0ABB);
    } else {
      advance (10)
      jump (0AC6);
    }

0AC6:

    #0AC6
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0AC7);

0AC7:

    #0AC7
    #instruction: JP   CY,1868
    if (FlagCY) {
      advance (10)
      jump (1868);
    } else {
      advance (10)
      jump (0ACA);
    }

0ACA:

    #0ACA
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (0ACB);

0ACB:

    #0ACB
    #instruction: JP   CY,0AAB
    if (FlagCY) {
      advance (10)
      jump (0AAB);
    } else {
      advance (10)
      jump (0ACE);
    }

0ACE:

    #0ACE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0ACF:

    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    HL := 2B14;
    jump (0AD2);

0AD2:

    #0AD2
    #instruction: LD   C,0F
    advance (7)
    C := 0F;
    jump (0AD4);

0AD4:

    #0AD4
    #instruction: JP   0A93
    advance (10)
    jump (0A93);

0AD7:

    #0AD7
    #instruction: LD   (20C0),A
    let:8 a1 = A in
    M[20C0] := a1;
    advance (13)
    jump (0ADA);

0ADA:

    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    A := a1;
    jump (0ADD);

0ADD:

    #0ADD
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0ADE);

0ADE:

    #0ADE
    #instruction: JP   NZ,0ADA
    if (!FlagZ) {
      advance (10)
      jump (0ADA);
    } else {
      advance (10)
      jump (0AE1);
    }

0AE1:

    #0AE1
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

0AE2:

    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    HL := 20C2;
    jump (0AE5);

0AE5:

    #0AE5
    #instruction: LD   B,0C
    advance (7)
    B := 0C;
    jump (0AE7);

0AE7:

    #0AE7
    #instruction: JP   1A32
    advance (10)
    jump (1A32);

0AEA:

    #0AEA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0AEB);

0AEB:

    #0AEB
    #instruction: OUT  03
    let:8 a1 = A in
    sound_control(Ufo,a1[0]);
    sound_control(Shot,a1[1]);
    sound_control(PlayerDie,a1[2]);
    sound_control(InvaderDie,a1[3]);
    sound_control(ExtraLife,a1[4]);
    advance (10)
    jump (0AED);

0AED:

    #0AED
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (0AEF);

0AEF:

    #0AEF
    #instruction: CALL 1982
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := F2;
    #return-to: 0AF2
    advance (17)
    SP := a3;
    jump (1982);

0AF2:

    #0AF2
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (0AF3);

0AF3:

    #0AF3
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0A;
    let:16 a3 = (-1 + a2) in
    M[a3] := F6;
    #return-to: 0AF6
    advance (17)
    SP := a3;
    jump (0AB1);

0AF6:

    #0AF6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    A := a1;
    jump (0AF9);

0AF9:

    #0AF9
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0AFA);

0AFA:

    #0AFA
    #instruction: LD   HL,3017
    advance (10)
    HL := 3017;
    jump (0AFD);

0AFD:

    #0AFD
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (0AFF);

0AFF:

    #0AFF
    #instruction: JP   NZ,0BE8
    if (!FlagZ) {
      advance (10)
      jump (0BE8);
    } else {
      advance (10)
      jump (0B02);
    }

0B02:

    #0B02
    #instruction: LD   DE,1CFA
    advance (10)
    D := 1C;
    E := FA;
    jump (0B05);

0B05:

    #0B05
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 08;
    #return-to: 0B08
    advance (17)
    SP := a3;
    jump (0A93);

0B08:

    #0B08
    #instruction: LD   DE,1DAF
    advance (10)
    D := 1D;
    E := AF;
    jump (0B0B);

0B0B:

    #0B0B
    #instruction: CALL 0ACF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 0E;
    #return-to: 0B0E
    advance (17)
    SP := a3;
    jump (0ACF);

0B0E:

    #0B0E
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 11;
    #return-to: 0B11
    advance (17)
    SP := a3;
    jump (0AB1);

0B11:

    #0B11
    #instruction: CALL 1815
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 14;
    #return-to: 0B14
    advance (17)
    SP := a3;
    jump (1815);

0B14:

    #0B14
    #instruction: CALL 0AB6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 17;
    #return-to: 0B17
    advance (17)
    SP := a3;
    jump (0AB6);

0B17:

    #0B17
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    A := a1;
    jump (0B1A);

0B1A:

    #0B1A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0B1B);

0B1B:

    #0B1B
    #instruction: JP   NZ,0B4A
    if (!FlagZ) {
      advance (10)
      jump (0B4A);
    } else {
      advance (10)
      jump (0B1E);
    }

0B1E:

    #0B1E
    #instruction: LD   DE,1A95
    advance (10)
    D := 1A;
    E := 95;
    jump (0B21);

0B21:

    #0B21
    #instruction: CALL 0AE2
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 24;
    #return-to: 0B24
    advance (17)
    SP := a3;
    jump (0AE2);

0B24:

    #0B24
    #instruction: CALL 0A80
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 27;
    #return-to: 0B27
    advance (17)
    SP := a3;
    jump (0A80);

0B27:

    #0B27
    #instruction: LD   DE,1BB0
    advance (10)
    D := 1B;
    E := B0;
    jump (0B2A);

0B2A:

    #0B2A
    #instruction: CALL 0AE2
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2D;
    #return-to: 0B2D
    advance (17)
    SP := a3;
    jump (0AE2);

0B2D:

    #0B2D
    #instruction: CALL 0A80
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 30;
    #return-to: 0B30
    advance (17)
    SP := a3;
    jump (0A80);

0B30:

    #0B30
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 33;
    #return-to: 0B33
    advance (17)
    SP := a3;
    jump (0AB1);

0B33:

    #0B33
    #instruction: LD   DE,1FC9
    advance (10)
    D := 1F;
    E := C9;
    jump (0B36);

0B36:

    #0B36
    #instruction: CALL 0AE2
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 39;
    #return-to: 0B39
    advance (17)
    SP := a3;
    jump (0AE2);

0B39:

    #0B39
    #instruction: CALL 0A80
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3C;
    #return-to: 0B3C
    advance (17)
    SP := a3;
    jump (0A80);

0B3C:

    #0B3C
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3F;
    #return-to: 0B3F
    advance (17)
    SP := a3;
    jump (0AB1);

0B3F:

    #0B3F
    #instruction: LD   HL,33B7
    advance (10)
    HL := 33B7;
    jump (0B42);

0B42:

    #0B42
    #instruction: LD   B,0A
    advance (7)
    B := 0A;
    jump (0B44);

0B44:

    #0B44
    #instruction: CALL 14CB
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 47;
    #return-to: 0B47
    advance (17)
    SP := a3;
    jump (14CB);

0B47:

    #0B47
    #instruction: CALL 0AB6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4A;
    #return-to: 0B4A
    advance (17)
    SP := a3;
    jump (0AB6);

0B4A:

    #0B4A
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4D;
    #return-to: 0B4D
    advance (17)
    SP := a3;
    jump (09D6);

0B4D:

    #0B4D
    #instruction: LD   A,(21FF)
    let:8 a1 = M[21FF] in
    advance (13)
    A := a1;
    jump (0B50);

0B50:

    #0B50
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (0B51);

0B51:

    #0B51
    #instruction: JP   NZ,0B5D
    if (!FlagZ) {
      advance (10)
      jump (0B5D);
    } else {
      advance (10)
      jump (0B54);
    }

0B54:

    #0B54
    #instruction: CALL 08D1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 57;
    #return-to: 0B57
    advance (17)
    SP := a3;
    jump (08D1);

0B57:

    #0B57
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    jump (0B5A);

0B5A:

    #0B5A
    #instruction: CALL 1A7F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 5D;
    #return-to: 0B5D
    advance (17)
    SP := a3;
    jump (1A7F);

0B5D:

    #0B5D
    #instruction: CALL 01E4
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 60;
    #return-to: 0B60
    advance (17)
    SP := a3;
    jump (01E4);

0B60:

    #0B60
    #instruction: CALL 01C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 63;
    #return-to: 0B63
    advance (17)
    SP := a3;
    jump (01C0);

0B63:

    #0B63
    #instruction: CALL 01EF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 66;
    #return-to: 0B66
    advance (17)
    SP := a3;
    jump (01EF);

0B66:

    #0B66
    #instruction: CALL 021A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 69;
    #return-to: 0B69
    advance (17)
    SP := a3;
    jump (021A);

0B69:

    #0B69
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (0B6B);

0B6B:

    #0B6B
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (0B6E);

0B6E:

    #0B6E
    #instruction: CALL 01CF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 71;
    #return-to: 0B71
    advance (17)
    SP := a3;
    jump (01CF);

0B71:

    #0B71
    #instruction: CALL 1618
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 74;
    #return-to: 0B74
    advance (17)
    SP := a3;
    jump (1618);

0B74:

    #0B74
    #instruction: CALL 0BF1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 77;
    #return-to: 0B77
    advance (17)
    SP := a3;
    jump (0BF1);

0B77:

    #0B77
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    jump (0B79);

0B79:

    #0B79
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7C;
    #return-to: 0B7C
    advance (17)
    SP := a3;
    jump (0A59);

0B7C:

    #0B7C
    #instruction: JP   Z,0B71
    if (FlagZ) {
      advance (10)
      jump (0B71);
    } else {
      advance (10)
      jump (0B7F);
    }

0B7F:

    #0B7F
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0B80);

0B80:

    #0B80
    #instruction: LD   (2025),A
    let:8 a1 = A in
    M[2025] := a1;
    advance (13)
    jump (0B83);

0B83:

    #0B83
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 86;
    #return-to: 0B86
    advance (17)
    SP := a3;
    jump (0A59);

0B86:

    #0B86
    #instruction: JP   NZ,0B83
    if (!FlagZ) {
      advance (10)
      jump (0B83);
    } else {
      advance (10)
      jump (0B89);
    }

0B89:

    #0B89
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (0B8A);

0B8A:

    #0B8A
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (0B8D);

0B8D:

    #0B8D
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 90;
    #return-to: 0B90
    advance (17)
    SP := a3;
    jump (0AB1);

0B90:

    #0B90
    #instruction: CALL 1988
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 93;
    #return-to: 0B93
    advance (17)
    SP := a3;
    jump (1988);

0B93:

    #0B93
    #instruction: LD   C,0C
    advance (7)
    C := 0C;
    jump (0B95);

0B95:

    #0B95
    #instruction: LD   HL,2C11
    advance (10)
    HL := 2C11;
    jump (0B98);

0B98:

    #0B98
    #instruction: LD   DE,1F90
    advance (10)
    D := 1F;
    E := 90;
    jump (0B9B);

0B9B:

    #0B9B
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := 9E;
    #return-to: 0B9E
    advance (17)
    SP := a3;
    jump (08F3);

0B9E:

    #0B9E
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    A := a1;
    jump (0BA1);

0BA1:

    #0BA1
    #instruction: CP   00
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0BA3);

0BA3:

    #0BA3
    #instruction: JP   NZ,0BAE
    if (!FlagZ) {
      advance (10)
      jump (0BAE);
    } else {
      advance (10)
      jump (0BA6);
    }

0BA6:

    #0BA6
    #instruction: LD   HL,3311
    advance (10)
    HL := 3311;
    jump (0BA9);

0BA9:

    #0BA9
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (0BAB);

0BAB:

    #0BAB
    #instruction: CALL 08FF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := AE;
    #return-to: 0BAE
    advance (17)
    SP := a3;
    jump (08FF);

0BAE:

    #0BAE
    #instruction: LD   BC,1F9C
    advance (10)
    B := 1F;
    C := 9C;
    jump (0BB1);

0BB1:

    #0BB1
    #instruction: CALL 1856
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := B4;
    #return-to: 0BB4
    advance (17)
    SP := a3;
    jump (1856);

0BB4:

    #0BB4
    #instruction: CALL 184C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := B7;
    #return-to: 0BB7
    advance (17)
    SP := a3;
    jump (184C);

0BB7:

    #0BB7
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
    jump (0BB9);

0BB9:

    #0BB9
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (0BBA);

0BBA:

    #0BBA
    #instruction: JP   CY,0BC3
    if (FlagCY) {
      advance (10)
      jump (0BC3);
    } else {
      advance (10)
      jump (0BBD);
    }

0BBD:

    #0BBD
    #instruction: LD   BC,1FA0
    advance (10)
    B := 1F;
    C := A0;
    jump (0BC0);

0BC0:

    #0BC0
    #instruction: CALL 183A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := C3;
    #return-to: 0BC3
    advance (17)
    SP := a3;
    jump (183A);

0BC3:

    #0BC3
    #instruction: CALL 0AB6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := C6;
    #return-to: 0BC6
    advance (17)
    SP := a3;
    jump (0AB6);

0BC6:

    #0BC6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    A := a1;
    jump (0BC9);

0BC9:

    #0BC9
    #instruction: CP   00
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (0BCB);

0BCB:

    #0BCB
    #instruction: JP   NZ,0BDA
    if (!FlagZ) {
      advance (10)
      jump (0BDA);
    } else {
      advance (10)
      jump (0BCE);
    }

0BCE:

    #0BCE
    #instruction: LD   DE,1FD5
    advance (10)
    D := 1F;
    E := D5;
    jump (0BD1);

0BD1:

    #0BD1
    #instruction: CALL 0AE2
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := D4;
    #return-to: 0BD4
    advance (17)
    SP := a3;
    jump (0AE2);

0BD4:

    #0BD4
    #instruction: CALL 0A80
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := D7;
    #return-to: 0BD7
    advance (17)
    SP := a3;
    jump (0A80);

0BD7:

    #0BD7
    #instruction: CALL 189E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := DA;
    #return-to: 0BDA
    advance (17)
    SP := a3;
    jump (189E);

0BDA:

    #0BDA
    #instruction: LD   HL,20EC
    advance (10)
    HL := 20EC;
    jump (0BDD);

0BDD:

    #0BDD
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (0BDE);

0BDE:

    #0BDE
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (0BDF);

0BDF:

    #0BDF
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (0BE1);

0BE1:

    #0BE1
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (0BE2);

0BE2:

    #0BE2
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := E5;
    #return-to: 0BE5
    advance (17)
    SP := a3;
    jump (09D6);

0BE5:

    #0BE5
    #instruction: JP   18DF
    advance (10)
    jump (18DF);

0BE8:

    #0BE8
    #instruction: LD   DE,1DAB
    advance (10)
    D := 1D;
    E := AB;
    jump (0BEB);

0BEB:

    #0BEB
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := EE;
    #return-to: 0BEE
    advance (17)
    SP := a3;
    jump (0A93);

0BEE:

    #0BEE
    #instruction: JP   0B0B
    advance (10)
    jump (0B0B);

0BF1:

    #0BF1
    #instruction: CALL 190A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 0B;
    let:16 a3 = (-1 + a2) in
    M[a3] := F4;
    #return-to: 0BF4
    advance (17)
    SP := a3;
    jump (190A);

0BF4:

    #0BF4
    #instruction: JP   199A
    advance (10)
    jump (199A);

1400:

    #1400
    #instruction: NOP
    advance (4)
    jump (1401);

1401:

    #1401
    #instruction: CALL 1474
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    let:16 a3 = (-1 + a2) in
    M[a3] := 04;
    #return-to: 1404
    advance (17)
    SP := a3;
    jump (1474);

1404:

    #1404
    #instruction: NOP
    advance (4)
    jump (1405);

1405:

    #1405
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1406);

1406:

    #1406
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (1407);

1407:

    #1407
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1408);

1408:

    #1408
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (140A);

140A:

    #140A
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (140C);

140C:

    #140C
    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump (140D);

140D:

    #140D
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (140E);

140E:

    #140E
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (140F);

140F:

    #140F
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1410);

1410:

    #1410
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1411);

1411:

    #1411
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (1413);

1413:

    #1413
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (1415);

1415:

    #1415
    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump (1416);

1416:

    #1416
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1417);

1417:

    #1417
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (1418);

1418:

    #1418
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (141B);

141B:

    #141B
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (141C);

141C:

    #141C
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (141D);

141D:

    #141D
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (141E);

141E:

    #141E
    #instruction: JP   NZ,1405
    if (!FlagZ) {
      advance (10)
      jump (1405);
    } else {
      advance (10)
      jump (1421);
    }

1421:

    #1421
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1424:

    #1424
    #instruction: CALL 1474
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    let:16 a3 = (-1 + a2) in
    M[a3] := 27;
    #return-to: 1427
    advance (17)
    SP := a3;
    jump (1474);

1427:

    #1427
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1428);

1428:

    #1428
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (1429);

1429:

    #1429
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (142A);

142A:

    #142A
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (142B);

142B:

    #142B
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (142C);

142C:

    #142C
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (142D);

142D:

    #142D
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (142E);

142E:

    #142E
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (142F);

142F:

    #142F
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1432);

1432:

    #1432
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (1433);

1433:

    #1433
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (1434);

1434:

    #1434
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1435);

1435:

    #1435
    #instruction: JP   NZ,1427
    if (!FlagZ) {
      advance (10)
      jump (1427);
    } else {
      advance (10)
      jump (1438);
    }

1438:

    #1438
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1439:

    #1439
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (143A);

143A:

    #143A
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (143B);

143B:

    #143B
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (143C);

143C:

    #143C
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (143D);

143D:

    #143D
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1440);

1440:

    #1440
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (1441);

1441:

    #1441
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (1442);

1442:

    #1442
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1443);

1443:

    #1443
    #instruction: JP   NZ,1439
    if (!FlagZ) {
      advance (10)
      jump (1439);
    } else {
      advance (10)
      jump (1446);
    }

1446:

    #1446
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1452:

    #1452
    #instruction: CALL 1474
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    let:16 a3 = (-1 + a2) in
    M[a3] := 55;
    #return-to: 1455
    advance (17)
    SP := a3;
    jump (1474);

1455:

    #1455
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1456);

1456:

    #1456
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (1457);

1457:

    #1457
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1458);

1458:

    #1458
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (145A);

145A:

    #145A
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (145C);

145C:

    #145C
    #instruction: CPL
    let:8 a1 = A in
    advance (4)
    A := ~a1;
    jump (145D);

145D:

    #145D
    #instruction: AND  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump (145E);

145E:

    #145E
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (145F);

145F:

    #145F
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1460);

1460:

    #1460
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1461);

1461:

    #1461
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1462);

1462:

    #1462
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (1464);

1464:

    #1464
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (1466);

1466:

    #1466
    #instruction: CPL
    let:8 a1 = A in
    advance (4)
    A := ~a1;
    jump (1467);

1467:

    #1467
    #instruction: AND  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump (1468);

1468:

    #1468
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1469);

1469:

    #1469
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (146A);

146A:

    #146A
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (146D);

146D:

    #146D
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (146E);

146E:

    #146E
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (146F);

146F:

    #146F
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1470);

1470:

    #1470
    #instruction: JP   NZ,1455
    if (!FlagZ) {
      advance (10)
      jump (1455);
    } else {
      advance (10)
      jump (1473);
    }

1473:

    #1473
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1474:

    #1474
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (1475);

1475:

    #1475
    #instruction: AND  07
    let:8 a1 = A in
    let:8 a2 = (07 & a1) in
    let:8 a3 = (07 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1477);

1477:

    #1477
    #instruction: OUT  02
    let:8 a1 = A in
    advance (10)
    Shifter_OFF := a1;
    jump (1479);

1479:

    #1479
    #instruction: JP   1A47
    advance (10)
    jump (1A47);

147C:

    #147C
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (147D);

147D:

    #147D
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (147E);

147E:

    #147E
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (147F);

147F:

    #147F
    #instruction: LD   (DE),A
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = A in
    M[(a1,a2)] := a3;
    advance (7)
    jump (1480);

1480:

    #1480
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1481);

1481:

    #1481
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1482);

1482:

    #1482
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1483);

1483:

    #1483
    #instruction: JP   NZ,147E
    if (!FlagZ) {
      advance (10)
      jump (147E);
    } else {
      advance (10)
      jump (1486);
    }

1486:

    #1486
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (1487);

1487:

    #1487
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (148A);

148A:

    #148A
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (148B);

148B:

    #148B
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (148C);

148C:

    #148C
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (148D);

148D:

    #148D
    #instruction: JP   NZ,147C
    if (!FlagZ) {
      advance (10)
      jump (147C);
    } else {
      advance (10)
      jump (1490);
    }

1490:

    #1490
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1491:

    #1491
    #instruction: CALL 1474
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 14;
    let:16 a3 = (-1 + a2) in
    M[a3] := 94;
    #return-to: 1494
    advance (17)
    SP := a3;
    jump (1474);

1494:

    #1494
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1495);

1495:

    #1495
    #instruction: LD   (2061),A
    let:8 a1 = A in
    M[2061] := a1;
    advance (13)
    jump (1498);

1498:

    #1498
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1499);

1499:

    #1499
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (149A);

149A:

    #149A
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (149B);

149B:

    #149B
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (149D);

149D:

    #149D
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (149F);

149F:

    #149F
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (14A0);

14A0:

    #14A0
    #instruction: AND  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump (14A1);

14A1:

    #14A1
    #instruction: JP   Z,14A9
    if (FlagZ) {
      advance (10)
      jump (14A9);
    } else {
      advance (10)
      jump (14A4);
    }

14A4:

    #14A4
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (14A6);

14A6:

    #14A6
    #instruction: LD   (2061),A
    let:8 a1 = A in
    M[2061] := a1;
    advance (13)
    jump (14A9);

14A9:

    #14A9
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (14AA);

14AA:

    #14AA
    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump (14AB);

14AB:

    #14AB
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (14AC);

14AC:

    #14AC
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (14AD);

14AD:

    #14AD
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (14AE);

14AE:

    #14AE
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (14AF);

14AF:

    #14AF
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (14B1);

14B1:

    #14B1
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (14B3);

14B3:

    #14B3
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (14B4);

14B4:

    #14B4
    #instruction: AND  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := a5[3];
    FlagP := parity(a4);
    FlagCY := false;
    jump (14B5);

14B5:

    #14B5
    #instruction: JP   Z,14BD
    if (FlagZ) {
      advance (10)
      jump (14BD);
    } else {
      advance (10)
      jump (14B8);
    }

14B8:

    #14B8
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (14BA);

14BA:

    #14BA
    #instruction: LD   (2061),A
    let:8 a1 = A in
    M[2061] := a1;
    advance (13)
    jump (14BD);

14BD:

    #14BD
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (14BE);

14BE:

    #14BE
    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump (14BF);

14BF:

    #14BF
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (14C0);

14C0:

    #14C0
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (14C1);

14C1:

    #14C1
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (14C4);

14C4:

    #14C4
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (14C5);

14C5:

    #14C5
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (14C6);

14C6:

    #14C6
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (14C7);

14C7:

    #14C7
    #instruction: JP   NZ,1498
    if (!FlagZ) {
      advance (10)
      jump (1498);
    } else {
      advance (10)
      jump (14CA);
    }

14CA:

    #14CA
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

14CB:

    #14CB
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (14CC);

14CC:

    #14CC
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (14CD);

14CD:

    #14CD
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (14CE);

14CE:

    #14CE
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (14D1);

14D1:

    #14D1
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (14D2);

14D2:

    #14D2
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (14D3);

14D3:

    #14D3
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (14D4);

14D4:

    #14D4
    #instruction: JP   NZ,14CC
    if (!FlagZ) {
      advance (10)
      jump (14CC);
    } else {
      advance (10)
      jump (14D7);
    }

14D7:

    #14D7
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

14D8:

    #14D8
    #instruction: LD   A,(2025)
    let:8 a1 = M[2025] in
    advance (13)
    A := a1;
    jump (14DB);

14DB:

    #14DB
    #instruction: CP   05
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~05) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~05 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (14DD);

14DD:

    #14DD
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (14DE);
    }

14DE:

    #14DE
    #instruction: CP   02
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~02) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~02 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (14E0);

14E0:

    #14E0
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (14E1);
    }

14E1:

    #14E1
    #instruction: LD   A,(2029)
    let:8 a1 = M[2029] in
    advance (13)
    A := a1;
    jump (14E4);

14E4:

    #14E4
    #instruction: CP   D8
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~D8) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~D8 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (14E6);

14E6:

    #14E6
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (14E7);

14E7:

    #14E7
    #instruction: JP   NC,1530
    if (!FlagCY) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (14EA);
    }

14EA:

    #14EA
    #instruction: LD   A,(2002)
    let:8 a1 = M[2002] in
    advance (13)
    A := a1;
    jump (14ED);

14ED:

    #14ED
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (14EE);

14EE:

    #14EE
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (14EF);
    }

14EF:

    #14EF
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (14F0);

14F0:

    #14F0
    #instruction: CP   CE
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~CE) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~CE & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (14F2);

14F2:

    #14F2
    #instruction: JP   NC,1579
    if (!FlagCY) {
      advance (10)
      jump (1579);
    } else {
      advance (10)
      jump (14F5);
    }

14F5:

    #14F5
    #instruction: ADD  06
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,06,a1) in
    let:8 a3 = (06 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (14F7);

14F7:

    #14F7
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (14F8);

14F8:

    #14F8
    #instruction: LD   A,(2009)
    let:8 a1 = M[2009] in
    advance (13)
    A := a1;
    jump (14FB);

14FB:

    #14FB
    #instruction: CP   90
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~90) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~90 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (14FD);

14FD:

    #14FD
    #instruction: JP   NC,1504
    if (!FlagCY) {
      advance (10)
      jump (1504);
    } else {
      advance (10)
      jump (1500);
    }

1500:

    #1500
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (1501);

1501:

    #1501
    #instruction: JP   NC,1530
    if (!FlagCY) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (1504);
    }

1504:

    #1504
    #instruction: LD   L,B
    let:8 a1 = B in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (1505);

1505:

    #1505
    #instruction: CALL 1562
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 08;
    #return-to: 1508
    advance (17)
    SP := a3;
    jump (1562);

1508:

    #1508
    #instruction: LD   A,(202A)
    let:8 a1 = M[202A] in
    advance (13)
    A := a1;
    jump (150B);

150B:

    #150B
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (150C);

150C:

    #150C
    #instruction: CALL 156F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 0F;
    #return-to: 150F
    advance (17)
    SP := a3;
    jump (156F);

150F:

    #150F
    #instruction: LD   (2064),HL
    let:16 a1 = HL in
    M[2064] := a1[7:0];
    let:16 a2 = HL in
    M[2065] := a2[15:8];
    advance (16)
    jump (1512);

1512:

    #1512
    #instruction: LD   A,05
    advance (7)
    A := 05;
    jump (1514);

1514:

    #1514
    #instruction: LD   (2025),A
    let:8 a1 = A in
    M[2025] := a1;
    advance (13)
    jump (1517);

1517:

    #1517
    #instruction: CALL 1581
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 1A;
    #return-to: 151A
    advance (17)
    SP := a3;
    jump (1581);

151A:

    #151A
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (151B);

151B:

    #151B
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (151C);

151C:

    #151C
    #instruction: JP   Z,1530
    if (FlagZ) {
      advance (10)
      jump (1530);
    } else {
      advance (10)
      jump (151F);
    }

151F:

    #151F
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (1521);

1521:

    #1521
    #instruction: CALL 0A5F
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 24;
    #return-to: 1524
    advance (17)
    SP := a3;
    jump (0A5F);

1524:

    #1524
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 27;
    #return-to: 1527
    advance (17)
    SP := a3;
    jump (1A3B);

1527:

    #1527
    #instruction: CALL 15D3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2A;
    #return-to: 152A
    advance (17)
    SP := a3;
    jump (15D3);

152A:

    #152A
    #instruction: LD   A,10
    advance (7)
    A := 10;
    jump (152C);

152C:

    #152C
    #instruction: LD   (2003),A
    let:8 a1 = A in
    M[2003] := a1;
    advance (13)
    jump (152F);

152F:

    #152F
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1530:

    #1530
    #instruction: LD   A,03
    advance (7)
    A := 03;
    jump (1532);

1532:

    #1532
    #instruction: LD   (2025),A
    let:8 a1 = A in
    M[2025] := a1;
    advance (13)
    jump (1535);

1535:

    #1535
    #instruction: JP   154A
    advance (10)
    jump (154A);

1538:

    #1538
    #instruction: LD   HL,2003
    advance (10)
    HL := 2003;
    jump (153B);

153B:

    #153B
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (153C);

153C:

    #153C
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (153D);
    }

153D:

    #153D
    #instruction: LD   HL,(2064)
    let:8 a1 = M[2064] in
    let:16 a2 = HL in
    let:8 a3 = M[2065] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (1540);

1540:

    #1540
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (1542);

1542:

    #1542
    #instruction: CALL 1424
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 45;
    #return-to: 1545
    advance (17)
    SP := a3;
    jump (1424);

1545:

    #1545
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (1547);

1547:

    #1547
    #instruction: LD   (2025),A
    let:8 a1 = A in
    M[2025] := a1;
    advance (13)
    jump (154A);

154A:

    #154A
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (154B);

154B:

    #154B
    #instruction: LD   (2002),A
    let:8 a1 = A in
    M[2002] := a1;
    advance (13)
    jump (154E);

154E:

    #154E
    #instruction: LD   B,F7
    advance (7)
    B := F7;
    jump (1550);

1550:

    #1550
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

1554:

    #1554
    #instruction: LD   C,00
    advance (7)
    C := 00;
    jump (1556);

1556:

    #1556
    #instruction: CP   H
    let:8 a1 = A in
    let:16 a2 = HL in
    let:16 a3 = addWithCarry(!false,a1,~a2[15:8]) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2[15:8] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (1557);

1557:

    #1557
    #instruction: CALL NC,1590
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (-1 + a1) in
      M[a2] := 15;
      let:16 a3 = (-1 + a2) in
      M[a3] := 5A;
      #return-to: 155A
      advance (17)
      SP := a3;
      jump (1590);
    } else {
      advance (11)
      jump (155A);
    }

155A:

    #155A
    #instruction: CP   H
    let:8 a1 = A in
    let:16 a2 = HL in
    let:16 a3 = addWithCarry(!false,a1,~a2[15:8]) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2[15:8] & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (155B);

155B:

    #155B
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (155C);
    }

155C:

    #155C
    #instruction: ADD  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,10,a1) in
    let:8 a3 = (10 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (155E);

155E:

    #155E
    #instruction: INC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (155F);

155F:

    #155F
    #instruction: JP   155A
    advance (10)
    jump (155A);

1562:

    #1562
    #instruction: LD   A,(2009)
    let:8 a1 = M[2009] in
    advance (13)
    A := a1;
    jump (1565);

1565:

    #1565
    #instruction: LD   H,L
    let:16 a1 = HL in
    let:16 a2 = HL in
    advance (5)
    HL := (a1[7:0],a2[7:0]);
    jump (1566);

1566:

    #1566
    #instruction: CALL 1554
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 69;
    #return-to: 1569
    advance (17)
    SP := a3;
    jump (1554);

1569:

    #1569
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    B := a1;
    jump (156A);

156A:

    #156A
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (156B);

156B:

    #156B
    #instruction: SBC  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!FlagCY,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!FlagCY,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (156D);

156D:

    #156D
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (156E);

156E:

    #156E
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

156F:

    #156F
    #instruction: LD   A,(200A)
    let:8 a1 = M[200A] in
    advance (13)
    A := a1;
    jump (1572);

1572:

    #1572
    #instruction: CALL 1554
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := 75;
    #return-to: 1575
    advance (17)
    SP := a3;
    jump (1554);

1575:

    #1575
    #instruction: SBC  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!FlagCY,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!FlagCY,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (1577);

1577:

    #1577
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (1578);

1578:

    #1578
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1579:

    #1579
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (157B);

157B:

    #157B
    #instruction: LD   (2085),A
    let:8 a1 = A in
    M[2085] := a1;
    advance (13)
    jump (157E);

157E:

    #157E
    #instruction: JP   1545
    advance (10)
    jump (1545);

1581:

    #1581
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (1582);

1582:

    #1582
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (1583);

1583:

    #1583
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (1584);

1584:

    #1584
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (1585);

1585:

    #1585
    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (1586);

1586:

    #1586
    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (1587);

1587:

    #1587
    #instruction: ADD  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (1588);

1588:

    #1588
    #instruction: ADD  C
    let:8 a1 = C in
    let:8 a2 = A in
    let:16 a3 = addWithCarry(false,a1,a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (4)
    A := a3[7:0];
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := a3[15:8][0];
    jump (1589);

1589:

    #1589
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (158A);

158A:

    #158A
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (158B);

158B:

    #158B
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (158E);

158E:

    #158E
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (158F);

158F:

    #158F
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1590:

    #1590
    #instruction: INC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1591);

1591:

    #1591
    #instruction: ADD  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(false,10,a1) in
    let:8 a3 = (10 & 0F) in
    let:8 a4 = (a1 & 0F) in
    let:16 a5 = addWithCarry(false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := a2[15:8][0];
    jump (1593);

1593:

    #1593
    #instruction: JP   MI,1590
    if (FlagS) {
      advance (10)
      jump (1590);
    } else {
      advance (10)
      jump (1596);
    }

1596:

    #1596
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1597:

    #1597
    #instruction: LD   A,(200D)
    let:8 a1 = M[200D] in
    advance (13)
    A := a1;
    jump (159A);

159A:

    #159A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (159B);

159B:

    #159B
    #instruction: JP   NZ,15B7
    if (!FlagZ) {
      advance (10)
      jump (15B7);
    } else {
      advance (10)
      jump (159E);
    }

159E:

    #159E
    #instruction: LD   HL,3EA4
    advance (10)
    HL := 3EA4;
    jump (15A1);

15A1:

    #15A1
    #instruction: CALL 15C5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := A4;
    #return-to: 15A4
    advance (17)
    SP := a3;
    jump (15C5);

15A4:

    #15A4
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (15A5);
    }

15A5:

    #15A5
    #instruction: LD   B,FE
    advance (7)
    B := FE;
    jump (15A7);

15A7:

    #15A7
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (15A9);

15A9:

    #15A9
    #instruction: LD   (200D),A
    let:8 a1 = A in
    M[200D] := a1;
    advance (13)
    jump (15AC);

15AC:

    #15AC
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (15AD);

15AD:

    #15AD
    #instruction: LD   (2008),A
    let:8 a1 = A in
    M[2008] := a1;
    advance (13)
    jump (15B0);

15B0:

    #15B0
    #instruction: LD   A,(200E)
    let:8 a1 = M[200E] in
    advance (13)
    A := a1;
    jump (15B3);

15B3:

    #15B3
    #instruction: LD   (2007),A
    let:8 a1 = A in
    M[2007] := a1;
    advance (13)
    jump (15B6);

15B6:

    #15B6
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

15B7:

    #15B7
    #instruction: LD   HL,2524
    advance (10)
    HL := 2524;
    jump (15BA);

15BA:

    #15BA
    #instruction: CALL 15C5
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := BD;
    #return-to: 15BD
    advance (17)
    SP := a3;
    jump (15C5);

15BD:

    #15BD
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (15BE);
    }

15BE:

    #15BE
    #instruction: CALL 18F1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := C1;
    #return-to: 15C1
    advance (17)
    SP := a3;
    jump (18F1);

15C1:

    #15C1
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (15C2);

15C2:

    #15C2
    #instruction: JP   15A9
    advance (10)
    jump (15A9);

15C5:

    #15C5
    #instruction: LD   B,17
    advance (7)
    B := 17;
    jump (15C7);

15C7:

    #15C7
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (15C8);

15C8:

    #15C8
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (15C9);

15C9:

    #15C9
    #instruction: JP   NZ,166B
    if (!FlagZ) {
      advance (10)
      jump (166B);
    } else {
      advance (10)
      jump (15CC);
    }

15CC:

    #15CC
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (15CD);

15CD:

    #15CD
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (15CE);

15CE:

    #15CE
    #instruction: JP   NZ,15C7
    if (!FlagZ) {
      advance (10)
      jump (15C7);
    } else {
      advance (10)
      jump (15D1);
    }

15D1:

    #15D1
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

15D3:

    #15D3
    #instruction: CALL 1474
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := D6;
    #return-to: 15D6
    advance (17)
    SP := a3;
    jump (1474);

15D6:

    #15D6
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (15D7);

15D7:

    #15D7
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (15D8);

15D8:

    #15D8
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (15D9);

15D9:

    #15D9
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (15DA);

15DA:

    #15DA
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (15DC);

15DC:

    #15DC
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (15DE);

15DE:

    #15DE
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (15DF);

15DF:

    #15DF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (15E0);

15E0:

    #15E0
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (15E1);

15E1:

    #15E1
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (15E2);

15E2:

    #15E2
    #instruction: OUT  04
    let:8 a1 = A in
    advance (10)
    Shifter_HI := a1;
    Shifter_LO := Shifter_HI;
    jump (15E4);

15E4:

    #15E4
    #instruction: IN   03
    let:8 a1 = (Shifter_OFF & 07) in
    let:8 a2 = (~Shifter_OFF & 07) in
    let:8 a3 = ((Shifter_HI << a1) | ((Shifter_LO >> a2) >> 01)) in
    advance (10)
    A := a3;
    jump (15E6);

15E6:

    #15E6
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (15E7);

15E7:

    #15E7
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (15E8);

15E8:

    #15E8
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (15EB);

15EB:

    #15EB
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (15EC);

15EC:

    #15EC
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (15ED);

15ED:

    #15ED
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (15EE);

15EE:

    #15EE
    #instruction: JP   NZ,15D7
    if (!FlagZ) {
      advance (10)
      jump (15D7);
    } else {
      advance (10)
      jump (15F1);
    }

15F1:

    #15F1
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (15F2);

15F2:

    #15F2
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

15F3:

    #15F3
    #instruction: CALL 1611
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 15;
    let:16 a3 = (-1 + a2) in
    M[a3] := F6;
    #return-to: 15F6
    advance (17)
    SP := a3;
    jump (1611);

15F6:

    #15F6
    #instruction: LD   BC,3700
    advance (10)
    B := 37;
    C := 00;
    jump (15F9);

15F9:

    #15F9
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (15FA);

15FA:

    #15FA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (15FB);

15FB:

    #15FB
    #instruction: JP   Z,15FF
    if (FlagZ) {
      advance (10)
      jump (15FF);
    } else {
      advance (10)
      jump (15FE);
    }

15FE:

    #15FE
    #instruction: INC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (15FF);

15FF:

    #15FF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1600);

1600:

    #1600
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1601);

1601:

    #1601
    #instruction: JP   NZ,15F9
    if (!FlagZ) {
      advance (10)
      jump (15F9);
    } else {
      advance (10)
      jump (1604);
    }

1604:

    #1604
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (1605);

1605:

    #1605
    #instruction: LD   (2082),A
    let:8 a1 = A in
    M[2082] := a1;
    advance (13)
    jump (1608);

1608:

    #1608
    #instruction: CP   01
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~01) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~01 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (160A);

160A:

    #160A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (160B);
    }

160B:

    #160B
    #instruction: LD   HL,206B
    advance (10)
    HL := 206B;
    jump (160E);

160E:

    #160E
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (1610);

1610:

    #1610
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1611:

    #1611
    #instruction: LD   L,00
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],00);
    jump (1613);

1613:

    #1613
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (1616);

1616:

    #1616
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (1617);

1617:

    #1617
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1618:

    #1618
    #instruction: LD   A,(2015)
    let:8 a1 = M[2015] in
    advance (13)
    A := a1;
    jump (161B);

161B:

    #161B
    #instruction: CP   FF
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FF) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FF & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (161D);

161D:

    #161D
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (161E);
    }

161E:

    #161E
    #instruction: LD   HL,2010
    advance (10)
    HL := 2010;
    jump (1621);

1621:

    #1621
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1622);

1622:

    #1622
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1623);

1623:

    #1623
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (1624);

1624:

    #1624
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1625);

1625:

    #1625
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1626);
    }

1626:

    #1626
    #instruction: LD   A,(2025)
    let:8 a1 = M[2025] in
    advance (13)
    A := a1;
    jump (1629);

1629:

    #1629
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (162A);

162A:

    #162A
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (162B);
    }

162B:

    #162B
    #instruction: LD   A,(20EF)
    let:8 a1 = M[20EF] in
    advance (13)
    A := a1;
    jump (162E);

162E:

    #162E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (162F);

162F:

    #162F
    #instruction: JP   Z,1652
    if (FlagZ) {
      advance (10)
      jump (1652);
    } else {
      advance (10)
      jump (1632);
    }

1632:

    #1632
    #instruction: LD   A,(202D)
    let:8 a1 = M[202D] in
    advance (13)
    A := a1;
    jump (1635);

1635:

    #1635
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (1636);

1636:

    #1636
    #instruction: JP   NZ,1648
    if (!FlagZ) {
      advance (10)
      jump (1648);
    } else {
      advance (10)
      jump (1639);
    }

1639:

    #1639
    #instruction: CALL 17C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3C;
    #return-to: 163C
    advance (17)
    SP := a3;
    jump (17C0);

163C:

    #163C
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (163E);

163E:

    #163E
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (163F);
    }

163F:

    #163F
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (1641);

1641:

    #1641
    #instruction: LD   (2025),A
    let:8 a1 = A in
    M[2025] := a1;
    advance (13)
    jump (1644);

1644:

    #1644
    #instruction: LD   (202D),A
    let:8 a1 = A in
    M[202D] := a1;
    advance (13)
    jump (1647);

1647:

    #1647
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1648:

    #1648
    #instruction: CALL 17C0
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4B;
    #return-to: 164B
    advance (17)
    SP := a3;
    jump (17C0);

164B:

    #164B
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (164D);

164D:

    #164D
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (164E);
    }

164E:

    #164E
    #instruction: LD   (202D),A
    let:8 a1 = A in
    M[202D] := a1;
    advance (13)
    jump (1651);

1651:

    #1651
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1652:

    #1652
    #instruction: LD   HL,2025
    advance (10)
    HL := 2025;
    jump (1655);

1655:

    #1655
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (1657);

1657:

    #1657
    #instruction: LD   HL,(20ED)
    let:8 a1 = M[20ED] in
    let:16 a2 = HL in
    let:8 a3 = M[20EE] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (165A);

165A:

    #165A
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (165B);

165B:

    #165B
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (165C);

165C:

    #165C
    #instruction: CP   7E
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~7E) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~7E & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (165E);

165E:

    #165E
    #instruction: JP   CY,1663
    if (FlagCY) {
      advance (10)
      jump (1663);
    } else {
      advance (10)
      jump (1661);
    }

1661:

    #1661
    #instruction: LD   L,74
    let:16 a1 = HL in
    advance (7)
    HL := (a1[15:8],74);
    jump (1663);

1663:

    #1663
    #instruction: LD   (20ED),HL
    let:16 a1 = HL in
    M[20ED] := a1[7:0];
    let:16 a2 = HL in
    M[20EE] := a2[15:8];
    advance (16)
    jump (1666);

1666:

    #1666
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1667);

1667:

    #1667
    #instruction: LD   (201D),A
    let:8 a1 = A in
    M[201D] := a1;
    advance (13)
    jump (166A);

166A:

    #166A
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

166B:

    #166B
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (166C);

166C:

    #166C
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

166D:

    #166D
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (166E);

166E:

    #166E
    #instruction: CALL 1A8B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 71;
    #return-to: 1671
    advance (17)
    SP := a3;
    jump (1A8B);

1671:

    #1671
    #instruction: CALL 1910
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 74;
    #return-to: 1674
    advance (17)
    SP := a3;
    jump (1910);

1674:

    #1674
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (1676);

1676:

    #1676
    #instruction: CALL 09CA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 79;
    #return-to: 1679
    advance (17)
    SP := a3;
    jump (09CA);

1679:

    #1679
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (167A);

167A:

    #167A
    #instruction: LD   DE,20F5
    advance (10)
    D := 20;
    E := F5;
    jump (167D);

167D:

    #167D
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (167E);

167E:

    #167E
    #instruction: CP   (HL)
    let:8 a1 = A in
    let:16 a2 = HL in
    let:8 a3 = M[a2] in
    let:16 a4 = addWithCarry(!false,a1,~a3) in
    let:8 a5 = (a1 & 0F) in
    let:8 a6 = (~a3 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump (167F);

167F:

    #167F
    #instruction: DEC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1680);

1680:

    #1680
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (1681);

1681:

    #1681
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1682);

1682:

    #1682
    #instruction: JP   Z,168B
    if (FlagZ) {
      advance (10)
      jump (168B);
    } else {
      advance (10)
      jump (1685);
    }

1685:

    #1685
    #instruction: JP   NC,1698
    if (!FlagCY) {
      advance (10)
      jump (1698);
    } else {
      advance (10)
      jump (1688);
    }

1688:

    #1688
    #instruction: JP   168F
    advance (10)
    jump (168F);

168B:

    #168B
    #instruction: CP   (HL)
    let:8 a1 = A in
    let:16 a2 = HL in
    let:8 a3 = M[a2] in
    let:16 a4 = addWithCarry(!false,a1,~a3) in
    let:8 a5 = (a1 & 0F) in
    let:8 a6 = (~a3 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump (168C);

168C:

    #168C
    #instruction: JP   NC,1698
    if (!FlagCY) {
      advance (10)
      jump (1698);
    } else {
      advance (10)
      jump (168F);
    }

168F:

    #168F
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1690);

1690:

    #1690
    #instruction: LD   (DE),A
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = A in
    M[(a1,a2)] := a3;
    advance (7)
    jump (1691);

1691:

    #1691
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1692);

1692:

    #1692
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1693);

1693:

    #1693
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1694);

1694:

    #1694
    #instruction: LD   (DE),A
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = A in
    M[(a1,a2)] := a3;
    advance (7)
    jump (1695);

1695:

    #1695
    #instruction: CALL 1950
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := 98;
    #return-to: 1698
    advance (17)
    SP := a3;
    jump (1950);

1698:

    #1698
    #instruction: LD   A,(20CE)
    let:8 a1 = M[20CE] in
    advance (13)
    A := a1;
    jump (169B);

169B:

    #169B
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (169C);

169C:

    #169C
    #instruction: JP   Z,16C9
    if (FlagZ) {
      advance (10)
      jump (16C9);
    } else {
      advance (10)
      jump (169F);
    }

169F:

    #169F
    #instruction: LD   HL,2803
    advance (10)
    HL := 2803;
    jump (16A2);

16A2:

    #16A2
    #instruction: LD   DE,1AA6
    advance (10)
    D := 1A;
    E := A6;
    jump (16A5);

16A5:

    #16A5
    #instruction: LD   C,14
    advance (7)
    C := 14;
    jump (16A7);

16A7:

    #16A7
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := AA;
    #return-to: 16AA
    advance (17)
    SP := a3;
    jump (0A93);

16AA:

    #16AA
    #instruction: DEC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(!true,a1[15:8],~00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (16AB);

16AB:

    #16AB
    #instruction: DEC  H
    let:16 a1 = HL in
    let:16 a2 = addWithCarry(!true,a1[15:8],~00) in
    let:8 a3 = (a1[15:8] & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    let:16 a6 = HL in
    advance (5)
    HL := (a2[7:0],a6[7:0]);
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (16AC);

16AC:

    #16AC
    #instruction: LD   B,1B
    advance (7)
    B := 1B;
    jump (16AE);

16AE:

    #16AE
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (16B1);

16B1:

    #16B1
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (16B2);

16B2:

    #16B2
    #instruction: JP   CY,16B7
    if (FlagCY) {
      advance (10)
      jump (16B7);
    } else {
      advance (10)
      jump (16B5);
    }

16B5:

    #16B5
    #instruction: LD   B,1C
    advance (7)
    B := 1C;
    jump (16B7);

16B7:

    #16B7
    #instruction: LD   A,B
    let:8 a1 = B in
    advance (5)
    A := a1;
    jump (16B8);

16B8:

    #16B8
    #instruction: CALL 08FF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := BB;
    #return-to: 16BB
    advance (17)
    SP := a3;
    jump (08FF);

16BB:

    #16BB
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := BE;
    #return-to: 16BE
    advance (17)
    SP := a3;
    jump (0AB1);

16BE:

    #16BE
    #instruction: CALL 18E7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := C1;
    #return-to: 16C1
    advance (17)
    SP := a3;
    jump (18E7);

16C1:

    #16C1
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (16C2);

16C2:

    #16C2
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (16C3);

16C3:

    #16C3
    #instruction: JP   Z,16C9
    if (FlagZ) {
      advance (10)
      jump (16C9);
    } else {
      advance (10)
      jump (16C6);
    }

16C6:

    #16C6
    #instruction: JP   02ED
    advance (10)
    jump (02ED);

16C9:

    #16C9
    #instruction: LD   HL,2D18
    advance (10)
    HL := 2D18;
    jump (16CC);

16CC:

    #16CC
    #instruction: LD   DE,1AA6
    advance (10)
    D := 1A;
    E := A6;
    jump (16CF);

16CF:

    #16CF
    #instruction: LD   C,0A
    advance (7)
    C := 0A;
    jump (16D1);

16D1:

    #16D1
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := D4;
    #return-to: 16D4
    advance (17)
    SP := a3;
    jump (0A93);

16D4:

    #16D4
    #instruction: CALL 0AB6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := D7;
    #return-to: 16D7
    advance (17)
    SP := a3;
    jump (0AB6);

16D7:

    #16D7
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := DA;
    #return-to: 16DA
    advance (17)
    SP := a3;
    jump (09D6);

16DA:

    #16DA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (16DB);

16DB:

    #16DB
    #instruction: LD   (20EF),A
    let:8 a1 = A in
    M[20EF] := a1;
    advance (13)
    jump (16DE);

16DE:

    #16DE
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (16E0);

16E0:

    #16E0
    #instruction: CALL 19D1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := E3;
    #return-to: 16E3
    advance (17)
    SP := a3;
    jump (19D1);

16E3:

    #16E3
    #instruction: JP   0B89
    advance (10)
    jump (0B89);

16E6:

    #16E6
    #instruction: LD   SP,2400
    advance (10)
    SP := 2400;
    jump (16E9);

16E9:

    #16E9
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (16EA);

16EA:

    #16EA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (16EB);

16EB:

    #16EB
    #instruction: LD   (2015),A
    let:8 a1 = A in
    M[2015] := a1;
    advance (13)
    jump (16EE);

16EE:

    #16EE
    #instruction: CALL 14D8
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := F1;
    #return-to: 16F1
    advance (17)
    SP := a3;
    jump (14D8);

16F1:

    #16F1
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (16F3);

16F3:

    #16F3
    #instruction: CALL 18FA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := F6;
    #return-to: 16F6
    advance (17)
    SP := a3;
    jump (18FA);

16F6:

    #16F6
    #instruction: CALL 0A59
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := F9;
    #return-to: 16F9
    advance (17)
    SP := a3;
    jump (0A59);

16F9:

    #16F9
    #instruction: JP   NZ,16EE
    if (!FlagZ) {
      advance (10)
      jump (16EE);
    } else {
      advance (10)
      jump (16FC);
    }

16FC:

    #16FC
    #instruction: CALL 19D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 16;
    let:16 a3 = (-1 + a2) in
    M[a3] := FF;
    #return-to: 16FF
    advance (17)
    SP := a3;
    jump (19D7);

16FF:

    #16FF
    #instruction: LD   HL,2701
    advance (10)
    HL := 2701;
    jump (1702);

1702:

    #1702
    #instruction: CALL 19FA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := 05;
    #return-to: 1705
    advance (17)
    SP := a3;
    jump (19FA);

1705:

    #1705
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1706);

1706:

    #1706
    #instruction: CALL 1A8B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := 09;
    #return-to: 1709
    advance (17)
    SP := a3;
    jump (1A8B);

1709:

    #1709
    #instruction: LD   B,FB
    advance (7)
    B := FB;
    jump (170B);

170B:

    #170B
    #instruction: JP   196B
    advance (10)
    jump (196B);

170E:

    #170E
    #instruction: CALL 09CA
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := 11;
    #return-to: 1711
    advance (17)
    SP := a3;
    jump (09CA);

1711:

    #1711
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1712);

1712:

    #1712
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1713);

1713:

    #1713
    #instruction: LD   DE,1CB8
    advance (10)
    D := 1C;
    E := B8;
    jump (1716);

1716:

    #1716
    #instruction: LD   HL,1AA1
    advance (10)
    HL := 1AA1;
    jump (1719);

1719:

    #1719
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (171B);

171B:

    #171B
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (171C);

171C:

    #171C
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (171D);

171D:

    #171D
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (171E);

171E:

    #171E
    #instruction: JP   NC,1727
    if (!FlagCY) {
      advance (10)
      jump (1727);
    } else {
      advance (10)
      jump (1721);
    }

1721:

    #1721
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1722);

1722:

    #1722
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1723);

1723:

    #1723
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1724);

1724:

    #1724
    #instruction: JP   NZ,171C
    if (!FlagZ) {
      advance (10)
      jump (171C);
    } else {
      advance (10)
      jump (1727);
    }

1727:

    #1727
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1728);

1728:

    #1728
    #instruction: LD   (20CF),A
    let:8 a1 = A in
    M[20CF] := a1;
    advance (13)
    jump (172B);

172B:

    #172B
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

172C:

    #172C
    #instruction: LD   A,(2025)
    let:8 a1 = M[2025] in
    advance (13)
    A := a1;
    jump (172F);

172F:

    #172F
    #instruction: CP   00
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (1731);

1731:

    #1731
    #instruction: JP   NZ,1739
    if (!FlagZ) {
      advance (10)
      jump (1739);
    } else {
      advance (10)
      jump (1734);
    }

1734:

    #1734
    #instruction: LD   B,FD
    advance (7)
    B := FD;
    jump (1736);

1736:

    #1736
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

1739:

    #1739
    #instruction: LD   B,02
    advance (7)
    B := 02;
    jump (173B);

173B:

    #173B
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

1740:

    #1740
    #instruction: LD   HL,209B
    advance (10)
    HL := 209B;
    jump (1743);

1743:

    #1743
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (1744);

1744:

    #1744
    #instruction: CALL Z,176D
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (-1 + a1) in
      M[a2] := 17;
      let:16 a3 = (-1 + a2) in
      M[a3] := 47;
      #return-to: 1747
      advance (17)
      SP := a3;
      jump (176D);
    } else {
      advance (11)
      jump (1747);
    }

1747:

    #1747
    #instruction: LD   A,(2068)
    let:8 a1 = M[2068] in
    advance (13)
    A := a1;
    jump (174A);

174A:

    #174A
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (174B);

174B:

    #174B
    #instruction: JP   Z,176D
    if (FlagZ) {
      advance (10)
      jump (176D);
    } else {
      advance (10)
      jump (174E);
    }

174E:

    #174E
    #instruction: LD   HL,2096
    advance (10)
    HL := 2096;
    jump (1751);

1751:

    #1751
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (1752);

1752:

    #1752
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1753);
    }

1753:

    #1753
    #instruction: LD   HL,2098
    advance (10)
    HL := 2098;
    jump (1756);

1756:

    #1756
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1757);

1757:

    #1757
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (1759);

1759:

    #1759
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (175C);

175C:

    #175C
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (175D);

175D:

    #175D
    #instruction: JP   Z,176D
    if (FlagZ) {
      advance (10)
      jump (176D);
    } else {
      advance (10)
      jump (1760);
    }

1760:

    #1760
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (1761);

1761:

    #1761
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1762);

1762:

    #1762
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (1763);

1763:

    #1763
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1764);

1764:

    #1764
    #instruction: DEC  HL
    let:16 a1 = HL in
    let:16 a2 = (-1 + a1) in
    advance (5)
    HL := a2;
    jump (1765);

1765:

    #1765
    #instruction: LD   (HL),01
    let:16 a1 = HL in
    M[a1] := 01;
    advance (10)
    jump (1767);

1767:

    #1767
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (1769);

1769:

    #1769
    #instruction: LD   (209B),A
    let:8 a1 = A in
    M[209B] := a1;
    advance (13)
    jump (176C);

176C:

    #176C
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

176D:

    #176D
    #instruction: LD   A,(2098)
    let:8 a1 = M[2098] in
    advance (13)
    A := a1;
    jump (1770);

1770:

    #1770
    #instruction: AND  30
    let:8 a1 = A in
    let:8 a2 = (30 & a1) in
    let:8 a3 = (30 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1772);

1772:

    #1772
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (1774);

1774:

    #1774
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1775:

    #1775
    #instruction: LD   A,(2095)
    let:8 a1 = M[2095] in
    advance (13)
    A := a1;
    jump (1778);

1778:

    #1778
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (1779);

1779:

    #1779
    #instruction: JP   Z,17AA
    if (FlagZ) {
      advance (10)
      jump (17AA);
    } else {
      advance (10)
      jump (177C);
    }

177C:

    #177C
    #instruction: LD   HL,1A11
    advance (10)
    HL := 1A11;
    jump (177F);

177F:

    #177F
    #instruction: LD   DE,1A21
    advance (10)
    D := 1A;
    E := 21;
    jump (1782);

1782:

    #1782
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (1785);

1785:

    #1785
    #instruction: CP   (HL)
    let:8 a1 = A in
    let:16 a2 = HL in
    let:8 a3 = M[a2] in
    let:16 a4 = addWithCarry(!false,a1,~a3) in
    let:8 a5 = (a1 & 0F) in
    let:8 a6 = (~a3 & 0F) in
    let:16 a7 = addWithCarry(!false,a5,a6) in
    advance (7)
    FlagS := a4[7:0][7];
    FlagZ := is_zero(a4[7:0]);
    FlagA := a7[7:0][4];
    FlagP := parity(a4[7:0]);
    FlagCY := !a4[15:8][0];
    jump (1786);

1786:

    #1786
    #instruction: JP   NC,178E
    if (!FlagCY) {
      advance (10)
      jump (178E);
    } else {
      advance (10)
      jump (1789);
    }

1789:

    #1789
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (178A);

178A:

    #178A
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (178B);

178B:

    #178B
    #instruction: JP   1785
    advance (10)
    jump (1785);

178E:

    #178E
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (178F);

178F:

    #178F
    #instruction: LD   (2097),A
    let:8 a1 = A in
    M[2097] := a1;
    advance (13)
    jump (1792);

1792:

    #1792
    #instruction: LD   HL,2098
    advance (10)
    HL := 2098;
    jump (1795);

1795:

    #1795
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1796);

1796:

    #1796
    #instruction: AND  30
    let:8 a1 = A in
    let:8 a2 = (30 & a1) in
    let:8 a3 = (30 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1798);

1798:

    #1798
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (1799);

1799:

    #1799
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (179A);

179A:

    #179A
    #instruction: AND  0F
    let:8 a1 = A in
    let:8 a2 = (0F & a1) in
    let:8 a3 = (0F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (179C);

179C:

    #179C
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 << 01),0,a1[7]);
    FlagCY := a1[7];
    jump (179D);

179D:

    #179D
    #instruction: CP   10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (179F);

179F:

    #179F
    #instruction: JP   NZ,17A4
    if (!FlagZ) {
      advance (10)
      jump (17A4);
    } else {
      advance (10)
      jump (17A2);
    }

17A2:

    #17A2
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (17A4);

17A4:

    #17A4
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (17A5);

17A5:

    #17A5
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (17A6);

17A6:

    #17A6
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (17A7);

17A7:

    #17A7
    #instruction: LD   (2095),A
    let:8 a1 = A in
    M[2095] := a1;
    advance (13)
    jump (17AA);

17AA:

    #17AA
    #instruction: LD   HL,2099
    advance (10)
    HL := 2099;
    jump (17AD);

17AD:

    #17AD
    #instruction: DEC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (17AE);

17AE:

    #17AE
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (17AF);
    }

17AF:

    #17AF
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (17B1);

17B1:

    #17B1
    #instruction: JP   19DC
    advance (10)
    jump (19DC);

17B4:

    #17B4
    #instruction: LD   B,EF
    advance (7)
    B := EF;
    jump (17B6);

17B6:

    #17B6
    #instruction: LD   HL,2098
    advance (10)
    HL := 2098;
    jump (17B9);

17B9:

    #17B9
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (17BA);

17BA:

    #17BA
    #instruction: AND  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (17BB);

17BB:

    #17BB
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (17BC);

17BC:

    #17BC
    #instruction: OUT  05
    let:8 a1 = A in
    sound_control(FleetMovement1,a1[0]);
    sound_control(FleetMovement2,a1[1]);
    sound_control(FleetMovement3,a1[2]);
    sound_control(FleetMovement4,a1[3]);
    sound_control(UfoHit,a1[4]);
    advance (10)
    jump (17BE);

17BE:

    #17BE
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

17C0:

    #17C0
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (17C3);

17C3:

    #17C3
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (17C4);

17C4:

    #17C4
    #instruction: JP   NC,17CA
    if (!FlagCY) {
      advance (10)
      jump (17CA);
    } else {
      advance (10)
      jump (17C7);
    }

17C7:

    #17C7
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (17C9);

17C9:

    #17C9
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

17CA:

    #17CA
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
    jump (17CC);

17CC:

    #17CC
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

17CD:

    #17CD
    #instruction: IN   02
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed(Dip3_livesLow)),1,is_pressed(Dip5_livesHigh)),2,is_pressed(Tilt)),3,is_pressed(Dip6_extraShipEarly)),4,is_pressed(P2shoot)),5,is_pressed(P2left)),6,is_pressed(P2right)),7,is_pressed(Dip7_coinInfoOff));
    jump (17CF);

17CF:

    #17CF
    #instruction: AND  04
    let:8 a1 = A in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (17D1);

17D1:

    #17D1
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (17D2);
    }

17D2:

    #17D2
    #instruction: LD   A,(209A)
    let:8 a1 = M[209A] in
    advance (13)
    A := a1;
    jump (17D5);

17D5:

    #17D5
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (17D6);

17D6:

    #17D6
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (17D7);
    }

17D7:

    #17D7
    #instruction: LD   SP,2400
    advance (10)
    SP := 2400;
    jump (17DA);

17DA:

    #17DA
    #instruction: LD   B,04
    advance (7)
    B := 04;
    jump (17DC);

17DC:

    #17DC
    #instruction: CALL 09D6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := DF;
    #return-to: 17DF
    advance (17)
    SP := a3;
    jump (09D6);

17DF:

    #17DF
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (17E0);

17E0:

    #17E0
    #instruction: JP   NZ,17DC
    if (!FlagZ) {
      advance (10)
      jump (17DC);
    } else {
      advance (10)
      jump (17E3);
    }

17E3:

    #17E3
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (17E5);

17E5:

    #17E5
    #instruction: LD   (209A),A
    let:8 a1 = A in
    M[209A] := a1;
    advance (13)
    jump (17E8);

17E8:

    #17E8
    #instruction: CALL 19D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := EB;
    #return-to: 17EB
    advance (17)
    SP := a3;
    jump (19D7);

17EB:

    #17EB
    #instruction: EI
    enable_interrupts()
    advance (4)
    jump (17EC);

17EC:

    #17EC
    #instruction: LD   DE,1CBC
    advance (10)
    D := 1C;
    E := BC;
    jump (17EF);

17EF:

    #17EF
    #instruction: LD   HL,3016
    advance (10)
    HL := 3016;
    jump (17F2);

17F2:

    #17F2
    #instruction: LD   C,04
    advance (7)
    C := 04;
    jump (17F4);

17F4:

    #17F4
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := F7;
    #return-to: 17F7
    advance (17)
    SP := a3;
    jump (0A93);

17F7:

    #17F7
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 17;
    let:16 a3 = (-1 + a2) in
    M[a3] := FA;
    #return-to: 17FA
    advance (17)
    SP := a3;
    jump (0AB1);

17FA:

    #17FA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (17FB);

17FB:

    #17FB
    #instruction: LD   (209A),A
    let:8 a1 = A in
    M[209A] := a1;
    advance (13)
    jump (17FE);

17FE:

    #17FE
    #instruction: LD   (2093),A
    let:8 a1 = A in
    M[2093] := a1;
    advance (13)
    jump (1801);

1801:

    #1801
    #instruction: JP   16C9
    advance (10)
    jump (16C9);

1804:

    #1804
    #instruction: LD   HL,2084
    advance (10)
    HL := 2084;
    jump (1807);

1807:

    #1807
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1808);

1808:

    #1808
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (1809);

1809:

    #1809
    #instruction: JP   Z,0707
    if (FlagZ) {
      advance (10)
      jump (0707);
    } else {
      advance (10)
      jump (180C);
    }

180C:

    #180C
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (180D);

180D:

    #180D
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (180E);

180E:

    #180E
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (180F);

180F:

    #180F
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1810);
    }

1810:

    #1810
    #instruction: LD   B,01
    advance (7)
    B := 01;
    jump (1812);

1812:

    #1812
    #instruction: JP   18FA
    advance (10)
    jump (18FA);

1815:

    #1815
    #instruction: LD   HL,2810
    advance (10)
    HL := 2810;
    jump (1818);

1818:

    #1818
    #instruction: LD   DE,1CA3
    advance (10)
    D := 1C;
    E := A3;
    jump (181B);

181B:

    #181B
    #instruction: LD   C,15
    advance (7)
    C := 15;
    jump (181D);

181D:

    #181D
    #instruction: CALL 08F3
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 20;
    #return-to: 1820
    advance (17)
    SP := a3;
    jump (08F3);

1820:

    #1820
    #instruction: LD   A,0A
    advance (7)
    A := 0A;
    jump (1822);

1822:

    #1822
    #instruction: LD   (206C),A
    let:8 a1 = A in
    M[206C] := a1;
    advance (13)
    jump (1825);

1825:

    #1825
    #instruction: LD   BC,1DBE
    advance (10)
    B := 1D;
    C := BE;
    jump (1828);

1828:

    #1828
    #instruction: CALL 1856
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 2B;
    #return-to: 182B
    advance (17)
    SP := a3;
    jump (1856);

182B:

    #182B
    #instruction: JP   CY,1837
    if (FlagCY) {
      advance (10)
      jump (1837);
    } else {
      advance (10)
      jump (182E);
    }

182E:

    #182E
    #instruction: CALL 1844
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 31;
    #return-to: 1831
    advance (17)
    SP := a3;
    jump (1844);

1831:

    #1831
    #instruction: JP   1828
    advance (10)
    jump (1828);

1834:

    #1834
    #instruction: CALL 0AB1
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 37;
    #return-to: 1837
    advance (17)
    SP := a3;
    jump (0AB1);

1837:

    #1837
    #instruction: LD   BC,1DCF
    advance (10)
    B := 1D;
    C := CF;
    jump (183A);

183A:

    #183A
    #instruction: CALL 1856
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 3D;
    #return-to: 183D
    advance (17)
    SP := a3;
    jump (1856);

183D:

    #183D
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (183E);
    }

183E:

    #183E
    #instruction: CALL 184C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 41;
    #return-to: 1841
    advance (17)
    SP := a3;
    jump (184C);

1841:

    #1841
    #instruction: JP   183A
    advance (10)
    jump (183A);

1844:

    #1844
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1845);

1845:

    #1845
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (1847);

1847:

    #1847
    #instruction: CALL 1439
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 4A;
    #return-to: 184A
    advance (17)
    SP := a3;
    jump (1439);

184A:

    #184A
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (184B);

184B:

    #184B
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

184C:

    #184C
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (184D);

184D:

    #184D
    #instruction: LD   A,(206C)
    let:8 a1 = M[206C] in
    advance (13)
    A := a1;
    jump (1850);

1850:

    #1850
    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    C := a1;
    jump (1851);

1851:

    #1851
    #instruction: CALL 0A93
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 54;
    #return-to: 1854
    advance (17)
    SP := a3;
    jump (0A93);

1854:

    #1854
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (1855);

1855:

    #1855
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1856:

    #1856
    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1857);

1857:

    #1857
    #instruction: CP   FF
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~FF) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~FF & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (1859);

1859:

    #1859
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (185A);

185A:

    #185A
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (185B);
    }

185B:

    #185B
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (185C);

185C:

    #185C
    #instruction: INC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump (185D);

185D:

    #185D
    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (185E);

185E:

    #185E
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (185F);

185F:

    #185F
    #instruction: INC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump (1860);

1860:

    #1860
    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1861);

1861:

    #1861
    #instruction: LD   E,A
    let:8 a1 = A in
    advance (5)
    E := a1;
    jump (1862);

1862:

    #1862
    #instruction: INC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump (1863);

1863:

    #1863
    #instruction: LD   A,(BC)
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1864);

1864:

    #1864
    #instruction: LD   D,A
    let:8 a1 = A in
    advance (5)
    D := a1;
    jump (1865);

1865:

    #1865
    #instruction: INC  BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    B := a3[15:8];
    C := a3[7:0];
    jump (1866);

1866:

    #1866
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (1867);

1867:

    #1867
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1868:

    #1868
    #instruction: LD   HL,20C2
    advance (10)
    HL := 20C2;
    jump (186B);

186B:

    #186B
    #instruction: INC  (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    let:16 a7 = HL in
    M[a7] := a3[7:0];
    advance (10)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    jump (186C);

186C:

    #186C
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (186D);

186D:

    #186D
    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump (186E);

186E:

    #186E
    #instruction: CALL 01D9
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 71;
    #return-to: 1871
    advance (17)
    SP := a3;
    jump (01D9);

1871:

    #1871
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    B := a1;
    jump (1872);

1872:

    #1872
    #instruction: LD   A,(20CA)
    let:8 a1 = M[20CA] in
    advance (13)
    A := a1;
    jump (1875);

1875:

    #1875
    #instruction: CP   B
    let:8 a1 = A in
    let:8 a2 = B in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    FlagS := a3[7:0][7];
    FlagZ := is_zero(a3[7:0]);
    FlagA := a6[7:0][4];
    FlagP := parity(a3[7:0]);
    FlagCY := !a3[15:8][0];
    jump (1876);

1876:

    #1876
    #instruction: JP   Z,1898
    if (FlagZ) {
      advance (10)
      jump (1898);
    } else {
      advance (10)
      jump (1879);
    }

1879:

    #1879
    #instruction: LD   A,(20C2)
    let:8 a1 = M[20C2] in
    advance (13)
    A := a1;
    jump (187C);

187C:

    #187C
    #instruction: AND  04
    let:8 a1 = A in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (187E);

187E:

    #187E
    #instruction: LD   HL,(20CC)
    let:8 a1 = M[20CC] in
    let:16 a2 = HL in
    let:8 a3 = M[20CD] in
    let:16 a4 = (a2[15:8],a1) in
    advance (16)
    HL := (a3,a4[7:0]);
    jump (1881);

1881:

    #1881
    #instruction: JP   NZ,1888
    if (!FlagZ) {
      advance (10)
      jump (1888);
    } else {
      advance (10)
      jump (1884);
    }

1884:

    #1884
    #instruction: LD   DE,0030
    advance (10)
    D := 00;
    E := 30;
    jump (1887);

1887:

    #1887
    #instruction: ADD  HL,DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (1888);

1888:

    #1888
    #instruction: LD   (20C7),HL
    let:16 a1 = HL in
    M[20C7] := a1[7:0];
    let:16 a2 = HL in
    M[20C8] := a2[15:8];
    advance (16)
    jump (188B);

188B:

    #188B
    #instruction: LD   HL,20C5
    advance (10)
    HL := 20C5;
    jump (188E);

188E:

    #188E
    #instruction: CALL 1A3B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := 91;
    #return-to: 1891
    advance (17)
    SP := a3;
    jump (1A3B);

1891:

    #1891
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = HL in
    let:16 a4 = HL in
    let:16 a5 = HL in
    let:16 a6 = (a1,a5[7:0]) in
    advance (4)
    HL := (a6[15:8],a2);
    D := a3[15:8];
    E := a4[7:0];
    jump (1892);

1892:

    #1892
    #instruction: JP   15D3
    advance (10)
    jump (15D3);

1898:

    #1898
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (189A);

189A:

    #189A
    #instruction: LD   (20CB),A
    let:8 a1 = A in
    M[20CB] := a1;
    advance (13)
    jump (189D);

189D:

    #189D
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

189E:

    #189E
    #instruction: LD   HL,2050
    advance (10)
    HL := 2050;
    jump (18A1);

18A1:

    #18A1
    #instruction: LD   DE,1BC0
    advance (10)
    D := 1B;
    E := C0;
    jump (18A4);

18A4:

    #18A4
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (18A6);

18A6:

    #18A6
    #instruction: CALL 1A32
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := A9;
    #return-to: 18A9
    advance (17)
    SP := a3;
    jump (1A32);

18A9:

    #18A9
    #instruction: LD   A,02
    advance (7)
    A := 02;
    jump (18AB);

18AB:

    #18AB
    #instruction: LD   (2080),A
    let:8 a1 = A in
    M[2080] := a1;
    advance (13)
    jump (18AE);

18AE:

    #18AE
    #instruction: LD   A,FF
    advance (7)
    A := FF;
    jump (18B0);

18B0:

    #18B0
    #instruction: LD   (207E),A
    let:8 a1 = A in
    M[207E] := a1;
    advance (13)
    jump (18B3);

18B3:

    #18B3
    #instruction: LD   A,04
    advance (7)
    A := 04;
    jump (18B5);

18B5:

    #18B5
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (18B8);

18B8:

    #18B8
    #instruction: LD   A,(2055)
    let:8 a1 = M[2055] in
    advance (13)
    A := a1;
    jump (18BB);

18BB:

    #18BB
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (18BD);

18BD:

    #18BD
    #instruction: JP   Z,18B8
    if (FlagZ) {
      advance (10)
      jump (18B8);
    } else {
      advance (10)
      jump (18C0);
    }

18C0:

    #18C0
    #instruction: LD   A,(2055)
    let:8 a1 = M[2055] in
    advance (13)
    A := a1;
    jump (18C3);

18C3:

    #18C3
    #instruction: AND  01
    let:8 a1 = A in
    let:8 a2 = (01 & a1) in
    let:8 a3 = (01 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (18C5);

18C5:

    #18C5
    #instruction: JP   NZ,18C0
    if (!FlagZ) {
      advance (10)
      jump (18C0);
    } else {
      advance (10)
      jump (18C8);
    }

18C8:

    #18C8
    #instruction: LD   HL,3311
    advance (10)
    HL := 3311;
    jump (18CB);

18CB:

    #18CB
    #instruction: LD   A,26
    advance (7)
    A := 26;
    jump (18CD);

18CD:

    #18CD
    #instruction: NOP
    advance (4)
    jump (18CE);

18CE:

    #18CE
    #instruction: CALL 08FF
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := D1;
    #return-to: 18D1
    advance (17)
    SP := a3;
    jump (08FF);

18D1:

    #18D1
    #instruction: JP   0AB6
    advance (10)
    jump (0AB6);

18D4:

    #18D4
    #instruction: LD   SP,2400
    advance (10)
    SP := 2400;
    jump (18D7);

18D7:

    #18D7
    #instruction: LD   B,00
    advance (7)
    B := 00;
    jump (18D9);

18D9:

    #18D9
    #instruction: CALL 01E6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := DC;
    #return-to: 18DC
    advance (17)
    SP := a3;
    jump (01E6);

18DC:

    #18DC
    #instruction: CALL 1956
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 18;
    let:16 a3 = (-1 + a2) in
    M[a3] := DF;
    #return-to: 18DF
    advance (17)
    SP := a3;
    jump (1956);

18DF:

    #18DF
    #instruction: LD   A,08
    advance (7)
    A := 08;
    jump (18E1);

18E1:

    #18E1
    #instruction: LD   (20CF),A
    let:8 a1 = A in
    M[20CF] := a1;
    advance (13)
    jump (18E4);

18E4:

    #18E4
    #instruction: JP   0AEA
    advance (10)
    jump (0AEA);

18E7:

    #18E7
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (18EA);

18EA:

    #18EA
    #instruction: LD   HL,20E7
    advance (10)
    HL := 20E7;
    jump (18ED);

18ED:

    #18ED
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (18EE);

18EE:

    #18EE
    #instruction: RET  NC
    if (!FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (18EF);
    }

18EF:

    #18EF
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (18F0);

18F0:

    #18F0
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

18F1:

    #18F1
    #instruction: LD   B,02
    advance (7)
    B := 02;
    jump (18F3);

18F3:

    #18F3
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    A := a1;
    jump (18F6);

18F6:

    #18F6
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (18F7);

18F7:

    #18F7
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (18F8);
    }

18F8:

    #18F8
    #instruction: INC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (18F9);

18F9:

    #18F9
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

18FA:

    #18FA
    #instruction: LD   A,(2094)
    let:8 a1 = M[2094] in
    advance (13)
    A := a1;
    jump (18FD);

18FD:

    #18FD
    #instruction: OR   B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (18FE);

18FE:

    #18FE
    #instruction: LD   (2094),A
    let:8 a1 = A in
    M[2094] := a1;
    advance (13)
    jump (1901);

1901:

    #1901
    #instruction: OUT  03
    let:8 a1 = A in
    sound_control(Ufo,a1[0]);
    sound_control(Shot,a1[1]);
    sound_control(PlayerDie,a1[2]);
    sound_control(InvaderDie,a1[3]);
    sound_control(ExtraLife,a1[4]);
    advance (10)
    jump (1903);

1903:

    #1903
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1904:

    #1904
    #instruction: LD   HL,2200
    advance (10)
    HL := 2200;
    jump (1907);

1907:

    #1907
    #instruction: JP   01C3
    advance (10)
    jump (01C3);

190A:

    #190A
    #instruction: CALL 14D8
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 0D;
    #return-to: 190D
    advance (17)
    SP := a3;
    jump (14D8);

190D:

    #190D
    #instruction: JP   1597
    advance (10)
    jump (1597);

1910:

    #1910
    #instruction: LD   HL,20E7
    advance (10)
    HL := 20E7;
    jump (1913);

1913:

    #1913
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    A := a1;
    jump (1916);

1916:

    #1916
    #instruction: RRCA
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,a1[0]);
    FlagCY := a1[0];
    jump (1917);

1917:

    #1917
    #instruction: RET  CY
    if (FlagCY) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1918);
    }

1918:

    #1918
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1919);

1919:

    #1919
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

191A:

    #191A
    #instruction: LD   C,1C
    advance (7)
    C := 1C;
    jump (191C);

191C:

    #191C
    #instruction: LD   HL,241E
    advance (10)
    HL := 241E;
    jump (191F);

191F:

    #191F
    #instruction: LD   DE,1AE4
    advance (10)
    D := 1A;
    E := E4;
    jump (1922);

1922:

    #1922
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

1925:

    #1925
    #instruction: LD   HL,20F8
    advance (10)
    HL := 20F8;
    jump (1928);

1928:

    #1928
    #instruction: JP   1931
    advance (10)
    jump (1931);

192B:

    #192B
    #instruction: LD   HL,20FC
    advance (10)
    HL := 20FC;
    jump (192E);

192E:

    #192E
    #instruction: JP   1931
    advance (10)
    jump (1931);

1931:

    #1931
    #instruction: LD   E,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    E := a2;
    jump (1932);

1932:

    #1932
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1933);

1933:

    #1933
    #instruction: LD   D,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    D := a2;
    jump (1934);

1934:

    #1934
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1935);

1935:

    #1935
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1936);

1936:

    #1936
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1937);

1937:

    #1937
    #instruction: LD   H,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:16 a3 = HL in
    advance (7)
    HL := (a2,a3[7:0]);
    jump (1938);

1938:

    #1938
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (1939);

1939:

    #1939
    #instruction: JP   09AD
    advance (10)
    jump (09AD);

193C:

    #193C
    #instruction: LD   C,07
    advance (7)
    C := 07;
    jump (193E);

193E:

    #193E
    #instruction: LD   HL,3501
    advance (10)
    HL := 3501;
    jump (1941);

1941:

    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    D := 1F;
    E := A9;
    jump (1944);

1944:

    #1944
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

1947:

    #1947
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    A := a1;
    jump (194A);

194A:

    #194A
    #instruction: LD   HL,3C01
    advance (10)
    HL := 3C01;
    jump (194D);

194D:

    #194D
    #instruction: JP   09B2
    advance (10)
    jump (09B2);

1950:

    #1950
    #instruction: LD   HL,20F4
    advance (10)
    HL := 20F4;
    jump (1953);

1953:

    #1953
    #instruction: JP   1931
    advance (10)
    jump (1931);

1956:

    #1956
    #instruction: CALL 1A5C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 59;
    #return-to: 1959
    advance (17)
    SP := a3;
    jump (1A5C);

1959:

    #1959
    #instruction: CALL 191A
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 5C;
    #return-to: 195C
    advance (17)
    SP := a3;
    jump (191A);

195C:

    #195C
    #instruction: CALL 1925
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 5F;
    #return-to: 195F
    advance (17)
    SP := a3;
    jump (1925);

195F:

    #195F
    #instruction: CALL 192B
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 62;
    #return-to: 1962
    advance (17)
    SP := a3;
    jump (192B);

1962:

    #1962
    #instruction: CALL 1950
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 65;
    #return-to: 1965
    advance (17)
    SP := a3;
    jump (1950);

1965:

    #1965
    #instruction: CALL 193C
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 68;
    #return-to: 1968
    advance (17)
    SP := a3;
    jump (193C);

1968:

    #1968
    #instruction: JP   1947
    advance (10)
    jump (1947);

196B:

    #196B
    #instruction: CALL 19DC
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 6E;
    #return-to: 196E
    advance (17)
    SP := a3;
    jump (19DC);

196E:

    #196E
    #instruction: JP   1671
    advance (10)
    jump (1671);

1971:

    #1971
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (1973);

1973:

    #1973
    #instruction: LD   (206D),A
    let:8 a1 = A in
    M[206D] := a1;
    advance (13)
    jump (1976);

1976:

    #1976
    #instruction: JP   16E6
    advance (10)
    jump (16E6);

1979:

    #1979
    #instruction: CALL 19D7
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7C;
    #return-to: 197C
    advance (17)
    SP := a3;
    jump (19D7);

197C:

    #197C
    #instruction: CALL 1947
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := 7F;
    #return-to: 197F
    advance (17)
    SP := a3;
    jump (1947);

197F:

    #197F
    #instruction: JP   193C
    advance (10)
    jump (193C);

1982:

    #1982
    #instruction: LD   (20C1),A
    let:8 a1 = A in
    M[20C1] := a1;
    advance (13)
    jump (1985);

1985:

    #1985
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1988:

    #1988
    #instruction: JP   09D6
    advance (10)
    jump (09D6);

199A:

    #199A
    #instruction: LD   A,(201E)
    let:8 a1 = M[201E] in
    advance (13)
    A := a1;
    jump (199D);

199D:

    #199D
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (199E);

199E:

    #199E
    #instruction: JP   NZ,19AC
    if (!FlagZ) {
      advance (10)
      jump (19AC);
    } else {
      advance (10)
      jump (19A1);
    }

19A1:

    #19A1
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (19A3);

19A3:

    #19A3
    #instruction: AND  76
    let:8 a1 = A in
    let:8 a2 = (76 & a1) in
    let:8 a3 = (76 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (19A5);

19A5:

    #19A5
    #instruction: SUB  72
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~72) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~72 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (19A7);

19A7:

    #19A7
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (19A8);
    }

19A8:

    #19A8
    #instruction: INC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(true,a1,00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (00 & 0F) in
    let:16 a5 = addWithCarry(true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (19A9);

19A9:

    #19A9
    #instruction: LD   (201E),A
    let:8 a1 = A in
    M[201E] := a1;
    advance (13)
    jump (19AC);

19AC:

    #19AC
    #instruction: IN   01
    advance (10)
    A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(CoinEntry)),1,is_pressed(P2start)),2,is_pressed(P1start)),4,is_pressed(P1shoot)),5,is_pressed(P1left)),6,is_pressed(P1right));
    jump (19AE);

19AE:

    #19AE
    #instruction: AND  76
    let:8 a1 = A in
    let:8 a2 = (76 & a1) in
    let:8 a3 = (76 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (19B0);

19B0:

    #19B0
    #instruction: CP   34
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~34) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~34 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (19B2);

19B2:

    #19B2
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (19B3);
    }

19B3:

    #19B3
    #instruction: LD   HL,2E1B
    advance (10)
    HL := 2E1B;
    jump (19B6);

19B6:

    #19B6
    #instruction: LD   DE,0BF7
    advance (10)
    D := 0B;
    E := F7;
    jump (19B9);

19B9:

    #19B9
    #instruction: LD   C,09
    advance (7)
    C := 09;
    jump (19BB);

19BB:

    #19BB
    #instruction: JP   08F3
    advance (10)
    jump (08F3);

19D1:

    #19D1
    #instruction: LD   A,01
    advance (7)
    A := 01;
    jump (19D3);

19D3:

    #19D3
    #instruction: LD   (20E9),A
    let:8 a1 = A in
    M[20E9] := a1;
    advance (13)
    jump (19D6);

19D6:

    #19D6
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

19D7:

    #19D7
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (19D8);

19D8:

    #19D8
    #instruction: JP   19D3
    advance (10)
    jump (19D3);

19DC:

    #19DC
    #instruction: LD   A,(2094)
    let:8 a1 = M[2094] in
    advance (13)
    A := a1;
    jump (19DF);

19DF:

    #19DF
    #instruction: AND  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (19E0);

19E0:

    #19E0
    #instruction: LD   (2094),A
    let:8 a1 = A in
    M[2094] := a1;
    advance (13)
    jump (19E3);

19E3:

    #19E3
    #instruction: OUT  03
    let:8 a1 = A in
    sound_control(Ufo,a1[0]);
    sound_control(Shot,a1[1]);
    sound_control(PlayerDie,a1[2]);
    sound_control(InvaderDie,a1[3]);
    sound_control(ExtraLife,a1[4]);
    advance (10)
    jump (19E5);

19E5:

    #19E5
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

19E6:

    #19E6
    #instruction: LD   HL,2701
    advance (10)
    HL := 2701;
    jump (19E9);

19E9:

    #19E9
    #instruction: JP   Z,19FA
    if (FlagZ) {
      advance (10)
      jump (19FA);
    } else {
      advance (10)
      jump (19EC);
    }

19EC:

    #19EC
    #instruction: LD   DE,1C60
    advance (10)
    D := 1C;
    E := 60;
    jump (19EF);

19EF:

    #19EF
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (19F1);

19F1:

    #19F1
    #instruction: LD   C,A
    let:8 a1 = A in
    advance (5)
    C := a1;
    jump (19F2);

19F2:

    #19F2
    #instruction: CALL 1439
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := F5;
    #return-to: 19F5
    advance (17)
    SP := a3;
    jump (1439);

19F5:

    #19F5
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    A := a1;
    jump (19F6);

19F6:

    #19F6
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (19F7);

19F7:

    #19F7
    #instruction: JP   NZ,19EC
    if (!FlagZ) {
      advance (10)
      jump (19EC);
    } else {
      advance (10)
      jump (19FA);
    }

19FA:

    #19FA
    #instruction: LD   B,10
    advance (7)
    B := 10;
    jump (19FC);

19FC:

    #19FC
    #instruction: CALL 14CB
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 19;
    let:16 a3 = (-1 + a2) in
    M[a3] := FF;
    #return-to: 19FF
    advance (17)
    SP := a3;
    jump (14CB);

19FF:

    #19FF
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (1A00);

1A00:

    #1A00
    #instruction: CP   35
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~35) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~35 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (1A02);

1A02:

    #1A02
    #instruction: JP   NZ,19FA
    if (!FlagZ) {
      advance (10)
      jump (19FA);
    } else {
      advance (10)
      jump (1A05);
    }

1A05:

    #1A05
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A06:

    #1A06
    #instruction: LD   HL,2072
    advance (10)
    HL := 2072;
    jump (1A09);

1A09:

    #1A09
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (1A0A);

1A0A:

    #1A0A
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1A0B);

1A0B:

    #1A0B
    #instruction: AND  80
    let:8 a1 = A in
    let:8 a2 = (80 & a1) in
    let:8 a3 = (80 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1A0D);

1A0D:

    #1A0D
    #instruction: XOR  B
    let:8 a1 = B in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump (1A0E);

1A0E:

    #1A0E
    #instruction: RET  NZ
    if (!FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1A0F);
    }

1A0F:

    #1A0F
    #instruction: SCF
    advance (4)
    FlagCY := true;
    jump (1A10);

1A10:

    #1A10
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A32:

    #1A32
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1A33);

1A33:

    #1A33
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1A34);

1A34:

    #1A34
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A35);

1A35:

    #1A35
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1A36);

1A36:

    #1A36
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1A37);

1A37:

    #1A37
    #instruction: JP   NZ,1A32
    if (!FlagZ) {
      advance (10)
      jump (1A32);
    } else {
      advance (10)
      jump (1A3A);
    }

1A3A:

    #1A3A
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A3B:

    #1A3B
    #instruction: LD   E,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    E := a2;
    jump (1A3C);

1A3C:

    #1A3C
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A3D);

1A3D:

    #1A3D
    #instruction: LD   D,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    D := a2;
    jump (1A3E);

1A3E:

    #1A3E
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A3F);

1A3F:

    #1A3F
    #instruction: LD   A,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    A := a2;
    jump (1A40);

1A40:

    #1A40
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A41);

1A41:

    #1A41
    #instruction: LD   C,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    C := a2;
    jump (1A42);

1A42:

    #1A42
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A43);

1A43:

    #1A43
    #instruction: LD   B,(HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    advance (7)
    B := a2;
    jump (1A44);

1A44:

    #1A44
    #instruction: LD   H,C
    let:8 a1 = C in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (1A45);

1A45:

    #1A45
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (1A46);

1A46:

    #1A46
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A47:

    #1A47
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1A48);

1A48:

    #1A48
    #instruction: LD   B,03
    advance (7)
    B := 03;
    jump (1A4A);

1A4A:

    #1A4A
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (1A4B);

1A4B:

    #1A4B
    #instruction: RAR
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,FlagCY);
    FlagCY := a1[0];
    jump (1A4C);

1A4C:

    #1A4C
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (1A4D);

1A4D:

    #1A4D
    #instruction: LD   A,L
    let:16 a1 = HL in
    advance (5)
    A := a1[7:0];
    jump (1A4E);

1A4E:

    #1A4E
    #instruction: RAR
    let:8 a1 = A in
    advance (4)
    A := updateBit((a1 >> 01),7,FlagCY);
    FlagCY := a1[0];
    jump (1A4F);

1A4F:

    #1A4F
    #instruction: LD   L,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a2[15:8],a1);
    jump (1A50);

1A50:

    #1A50
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1A51);

1A51:

    #1A51
    #instruction: JP   NZ,1A4A
    if (!FlagZ) {
      advance (10)
      jump (1A4A);
    } else {
      advance (10)
      jump (1A54);
    }

1A54:

    #1A54
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (1A55);

1A55:

    #1A55
    #instruction: AND  3F
    let:8 a1 = A in
    let:8 a2 = (3F & a1) in
    let:8 a3 = (3F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1A57);

1A57:

    #1A57
    #instruction: OR   20
    let:8 a1 = A in
    let:8 a2 = (20 | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := false;
    FlagP := parity(a2);
    FlagCY := false;
    jump (1A59);

1A59:

    #1A59
    #instruction: LD   H,A
    let:8 a1 = A in
    let:16 a2 = HL in
    advance (5)
    HL := (a1,a2[7:0]);
    jump (1A5A);

1A5A:

    #1A5A
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (1A5B);

1A5B:

    #1A5B
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A5C:

    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    HL := 2400;
    jump (1A5F);

1A5F:

    #1A5F
    #instruction: LD   (HL),00
    let:16 a1 = HL in
    M[a1] := 00;
    advance (10)
    jump (1A61);

1A61:

    #1A61
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A62);

1A62:

    #1A62
    #instruction: LD   A,H
    let:16 a1 = HL in
    advance (5)
    A := a1[15:8];
    jump (1A63);

1A63:

    #1A63
    #instruction: CP   40
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!false,a1,~40) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~40 & 0F) in
    let:16 a5 = addWithCarry(!false,a3,a4) in
    advance (7)
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump (1A65);

1A65:

    #1A65
    #instruction: JP   NZ,1A5F
    if (!FlagZ) {
      advance (10)
      jump (1A5F);
    } else {
      advance (10)
      jump (1A68);
    }

1A68:

    #1A68
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A69:

    #1A69
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = SP in
    let:16 a4 = (-1 + a3) in
    M[a4] := a1;
    let:16 a5 = (-1 + a4) in
    M[a5] := a2;
    advance (11)
    SP := a5;
    jump (1A6A);

1A6A:

    #1A6A
    #instruction: PUSH HL
    let:16 a1 = HL in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1[15:8];
    let:16 a4 = (-1 + a3) in
    M[a4] := a1[7:0];
    advance (11)
    SP := a4;
    jump (1A6B);

1A6B:

    #1A6B
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    A := a3;
    jump (1A6C);

1A6C:

    #1A6C
    #instruction: OR   (HL)
    let:16 a1 = HL in
    let:8 a2 = M[a1] in
    let:8 a3 = A in
    let:8 a4 = (a2 | a3) in
    advance (7)
    A := a4;
    FlagS := a4[7];
    FlagZ := is_zero(a4);
    FlagA := false;
    FlagP := parity(a4);
    FlagCY := false;
    jump (1A6D);

1A6D:

    #1A6D
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1A6E);

1A6E:

    #1A6E
    #instruction: INC  DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    D := a3[15:8];
    E := a3[7:0];
    jump (1A6F);

1A6F:

    #1A6F
    #instruction: INC  HL
    let:16 a1 = HL in
    let:16 a2 = (1 + a1) in
    advance (5)
    HL := a2;
    jump (1A70);

1A70:

    #1A70
    #instruction: DEC  C
    let:8 a1 = C in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    C := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1A71);

1A71:

    #1A71
    #instruction: JP   NZ,1A6B
    if (!FlagZ) {
      advance (10)
      jump (1A6B);
    } else {
      advance (10)
      jump (1A74);
    }

1A74:

    #1A74
    #instruction: POP  HL
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    HL := (a5,a3);
    jump (1A75);

1A75:

    #1A75
    #instruction: LD   BC,0020
    advance (10)
    B := 00;
    C := 20;
    jump (1A78);

1A78:

    #1A78
    #instruction: ADD  HL,BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:16 a3 = HL in
    let:17 a4 = add17((a1,a2),a3) in
    advance (10)
    HL := a4[15:0];
    FlagCY := a4[16];
    jump (1A79);

1A79:

    #1A79
    #instruction: POP  BC
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    B := a5;
    C := a3;
    jump (1A7A);

1A7A:

    #1A7A
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    B := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1A7B);

1A7B:

    #1A7B
    #instruction: JP   NZ,1A69
    if (!FlagZ) {
      advance (10)
      jump (1A69);
    } else {
      advance (10)
      jump (1A7E);
    }

1A7E:

    #1A7E
    #instruction: RET
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    jump ((a5,a3));

1A7F:

    #1A7F
    #instruction: CALL 092E
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 82;
    #return-to: 1A82
    advance (17)
    SP := a3;
    jump (092E);

1A82:

    #1A82
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    A := a3;
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump (1A83);

1A83:

    #1A83
    #instruction: RET  Z
    if (FlagZ) {
      let:16 a1 = SP in
      let:16 a2 = (1 + a1) in
      let:8 a3 = M[a1] in
      let:16 a4 = (1 + a2) in
      let:8 a5 = M[a2] in
      advance (11)
      SP := a4;
      jump ((a5,a3));
    } else {
      advance (5)
      jump (1A84);
    }

1A84:

    #1A84
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:16 a2 = SP in
    let:16 a3 = (-1 + a2) in
    M[a3] := a1;
    let:16 a4 = (-1 + a3) in
    M[a4] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    SP := a4;
    jump (1A85);

1A85:

    #1A85
    #instruction: DEC  A
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    A := a2[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    jump (1A86);

1A86:

    #1A86
    #instruction: LD   (HL),A
    let:8 a1 = A in
    let:16 a2 = HL in
    M[a2] := a1;
    advance (7)
    jump (1A87);

1A87:

    #1A87
    #instruction: CALL 19E6
    let:16 a1 = SP in
    let:16 a2 = (-1 + a1) in
    M[a2] := 1A;
    let:16 a3 = (-1 + a2) in
    M[a3] := 8A;
    #return-to: 1A8A
    advance (17)
    SP := a3;
    jump (19E6);

1A8A:

    #1A8A
    #instruction: POP  PSW
    let:16 a1 = SP in
    let:16 a2 = (1 + a1) in
    let:8 a3 = M[a1] in
    let:16 a4 = (1 + a2) in
    let:8 a5 = M[a2] in
    advance (10)
    SP := a4;
    A := a5;
    FlagS := a3[7];
    FlagZ := a3[6];
    FlagA := a3[4];
    FlagP := a3[2];
    FlagCY := a3[0];
    jump (1A8B);

1A8B:

    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    HL := 2501;
    jump (1A8E);

1A8E:

    #1A8E
    #instruction: AND  0F
    let:8 a1 = A in
    let:8 a2 = (0F & a1) in
    let:8 a3 = (0F | a1) in
    advance (7)
    A := a2;
    FlagS := a2[7];
    FlagZ := is_zero(a2);
    FlagA := a3[3];
    FlagP := parity(a2);
    FlagCY := false;
    jump (1A90);

1A90:

    #1A90
    #instruction: JP   09C5
    advance (10)
    jump (09C5);
