
0000:

    #0000
    #instruction: NOP
    advance (4)
    #0001
    #instruction: NOP
    advance (4)
    #0002
    #instruction: NOP
    advance (4)
    #0003
    #instruction: JP   18D4
    advance (10)
    #18D4
    #instruction: LD   SP,2400
    advance (10)
    #18D7
    #instruction: LD   B,00
    advance (7)
    #18D9
    #instruction: CALL 01E6
    M[23FF] := 18;
    M[23FE] := DC;
    #return-to: 18DC
    advance (17)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a1 = addWithCarry(!true,00,~00) in
    let:8 a2 = (00 & 0F) in
    let:8 a3 = (~00 & 0F) in
    let:16 a4 = addWithCarry(!true,a2,a3) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a1[7:0])) {
      advance (10)
      A := 01;
      B := a1[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := 23;
      SPL := FE;
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a5 = M[23FE] in
      let:8 a6 = M[23FF] in
      advance (10)
      A := 01;
      B := a1[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := 24;
      SPL := 00;
      FlagS := a1[7:0][7];
      FlagZ := is_zero(a1[7:0]);
      FlagA := a4[7:0][4];
      FlagP := parity(a1[7:0]);
      jump ((a6,a5));
    }

0008:

    #0008
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := a1;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0009
    #instruction: PUSH BC
    let:8 a8 = B in
    let:8 a9 = C in
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #000A
    #instruction: PUSH DE
    let:8 a16 = D in
    let:8 a17 = E in
    let:8 a18 = a15[15:8] in
    let:8 a19 = a15[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a16;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a17;
    advance (11)
    #000B
    #instruction: PUSH HL
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = a23[15:8] in
    let:8 a27 = a23[7:0] in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := a24;
    let:8 a29 = a28[15:8] in
    let:8 a30 = a28[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := a25;
    advance (11)
    #000C
    #instruction: JP   008C
    advance (10)
    #008C
    #instruction: XOR  A
    let:8 a32 = A in
    let:8 a33 = A in
    let:8 a34 = (a32 ^ a33) in
    advance (4)
    #008D
    #instruction: LD   (2072),A
    let:8 a35 = a34 in
    M[2072] := a35;
    advance (13)
    #0090
    #instruction: LD   A,(20E9)
    let:8 a36 = M[20E9] in
    advance (13)
    #0093
    #instruction: AND  A
    let:8 a37 = a36 in
    let:8 a38 = a36 in
    let:8 a39 = (a37 & a38) in
    let:8 a40 = (a37 | a38) in
    advance (4)
    #0094
    #instruction: JP   Z,0082
    if (is_zero(a39)) {
      advance (10)
      #0082
      #instruction: POP  HL
      let:8 a41 = a31[15:8] in
      let:8 a42 = a31[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      #0083
      #instruction: POP  DE
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      let:8 a53 = a51[15:8] in
      let:8 a54 = a51[7:0] in
      let:16 a55 = (1 + (a53,a54)) in
      let:8 a56 = M[(a53,a54)] in
      advance (10)
      #0084
      #instruction: POP  BC
      let:8 a57 = a55[15:8] in
      let:8 a58 = a55[7:0] in
      let:16 a59 = (1 + (a57,a58)) in
      let:8 a60 = M[(a57,a58)] in
      let:8 a61 = a59[15:8] in
      let:8 a62 = a59[7:0] in
      let:16 a63 = (1 + (a61,a62)) in
      let:8 a64 = M[(a61,a62)] in
      advance (10)
      #0085
      #instruction: POP  PSW
      let:8 a65 = a63[15:8] in
      let:8 a66 = a63[7:0] in
      let:16 a67 = (1 + (a65,a66)) in
      let:8 a68 = M[(a65,a66)] in
      let:8 a69 = a67[15:8] in
      let:8 a70 = a67[7:0] in
      let:16 a71 = (1 + (a69,a70)) in
      let:8 a72 = M[(a69,a70)] in
      advance (10)
      #0086
      #instruction: EI
      enable_interrupts()
      advance (4)
      #0087
      #instruction: RET
      let:8 a73 = a71[15:8] in
      let:8 a74 = a71[7:0] in
      let:16 a75 = (1 + (a73,a74)) in
      let:8 a76 = M[(a73,a74)] in
      let:8 a77 = a75[15:8] in
      let:8 a78 = a75[7:0] in
      let:16 a79 = (1 + (a77,a78)) in
      let:8 a80 = M[(a77,a78)] in
      advance (10)
      A := a72;
      B := a64;
      C := a60;
      D := a56;
      E := a52;
      H := a48;
      L := a44;
      SPH := a79[15:8];
      SPL := a79[7:0];
      FlagS := a68[7];
      FlagZ := a68[6];
      FlagA := a68[4];
      FlagP := a68[2];
      FlagCY := a68[0];
      jump ((a80,a76));
    } else {
      advance (10)
      #0097
      #instruction: LD   A,(20EF)
      let:8 a81 = M[20EF] in
      advance (13)
      #009A
      #instruction: AND  A
      let:8 a82 = a81 in
      let:8 a83 = a81 in
      let:8 a84 = (a82 & a83) in
      let:8 a85 = (a82 | a83) in
      advance (4)
      #009B
      #instruction: JP   NZ,00A5
      if (!is_zero(a84)) {
        advance (10)
        #00A5
        #instruction: LD   HL,2020
        advance (10)
        #00A8
        #instruction: CALL 024B
        let:8 a86 = a31[15:8] in
        let:8 a87 = a31[7:0] in
        let:16 a88 = (-1 + (a86,a87)) in
        M[a88] := 00;
        let:8 a89 = a88[15:8] in
        let:8 a90 = a88[7:0] in
        let:16 a91 = (-1 + (a89,a90)) in
        M[a91] := AB;
        #return-to: 00AB
        advance (17)
        #024B
        #instruction: LD   A,(HL)
        let:8 a92 = M[2020] in
        advance (7)
        #024C
        #instruction: CP   FF
        let:8 a93 = a92 in
        let:16 a94 = addWithCarry(!false,a93,~FF) in
        let:8 a95 = (a93 & 0F) in
        let:8 a96 = (~FF & 0F) in
        let:16 a97 = addWithCarry(!false,a95,a96) in
        advance (7)
        #024E
        #instruction: RET  Z
        if (is_zero(a94[7:0])) {
          let:8 a98 = a91[15:8] in
          let:8 a99 = a91[7:0] in
          let:16 a100 = (1 + (a98,a99)) in
          let:8 a101 = M[(a98,a99)] in
          let:8 a102 = a100[15:8] in
          let:8 a103 = a100[7:0] in
          let:16 a104 = (1 + (a102,a103)) in
          let:8 a105 = M[(a102,a103)] in
          advance (11)
          A := a92;
          H := 20;
          L := 20;
          SPH := a104[15:8];
          SPL := a104[7:0];
          FlagS := a94[7:0][7];
          FlagZ := is_zero(a94[7:0]);
          FlagA := a97[7:0][4];
          FlagP := parity(a94[7:0]);
          FlagCY := !a94[15:8][0];
          jump ((a105,a101));
        } else {
          advance (5)
          #024F
          #instruction: CP   FE
          let:8 a106 = a92 in
          let:16 a107 = addWithCarry(!false,a106,~FE) in
          let:8 a108 = (a106 & 0F) in
          let:8 a109 = (~FE & 0F) in
          let:16 a110 = addWithCarry(!false,a108,a109) in
          advance (7)
          #0251
          #instruction: JP   Z,0281
          if (is_zero(a107[7:0])) {
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a111 = add17(0010,2020) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a92;
            D := 00;
            E := 10;
            H := a111[15:0][15:8];
            L := a111[15:0][7:0];
            SPH := a91[15:8];
            SPL := a91[7:0];
            FlagS := a107[7:0][7];
            FlagZ := is_zero(a107[7:0]);
            FlagA := a110[7:0][4];
            FlagP := parity(a107[7:0]);
            FlagCY := a111[16];
            jump (024B);
          } else {
            advance (10)
            #0254
            #instruction: INC  HL
            advance (5)
            #0255
            #instruction: LD   B,(HL)
            let:8 a112 = M[2021] in
            advance (7)
            #0256
            #instruction: LD   C,A
            let:8 a113 = a92 in
            advance (5)
            #0257
            #instruction: OR   B
            let:8 a114 = a112 in
            let:8 a115 = a92 in
            let:8 a116 = (a114 | a115) in
            advance (4)
            #0258
            #instruction: LD   A,C
            let:8 a117 = a113 in
            advance (5)
            #0259
            #instruction: JP   NZ,0277
            if (!is_zero(a116)) {
              advance (10)
              #0277
              #instruction: DEC  B
              let:8 a118 = a112 in
              let:16 a119 = addWithCarry(!true,a118,~00) in
              let:8 a120 = (a118 & 0F) in
              let:8 a121 = (~00 & 0F) in
              let:16 a122 = addWithCarry(!true,a120,a121) in
              advance (5)
              #0278
              #instruction: INC  B
              let:8 a123 = a119[7:0] in
              let:16 a124 = addWithCarry(true,a123,00) in
              let:8 a125 = (a123 & 0F) in
              let:8 a126 = (00 & 0F) in
              let:16 a127 = addWithCarry(true,a125,a126) in
              advance (5)
              #0279
              #instruction: JP   NZ,027D
              if (!is_zero(a124[7:0])) {
                advance (10)
                #027D
                #instruction: DEC  B
                let:8 a128 = a124[7:0] in
                let:16 a129 = addWithCarry(!true,a128,~00) in
                let:8 a130 = (a128 & 0F) in
                let:8 a131 = (~00 & 0F) in
                let:16 a132 = addWithCarry(!true,a130,a131) in
                advance (5)
                #027E
                #instruction: LD   (HL),B
                let:8 a133 = a129[7:0] in
                M[2021] := a133;
                advance (7)
                #027F
                #instruction: DEC  HL
                advance (5)
                #0280
                #instruction: LD   (HL),A
                let:8 a134 = a117 in
                M[2020] := a134;
                advance (7)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a135 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := a117;
                B := a129[7:0];
                C := a113;
                D := 00;
                E := 10;
                H := a135[15:0][15:8];
                L := a135[15:0][7:0];
                SPH := a91[15:8];
                SPL := a91[7:0];
                FlagS := a129[7:0][7];
                FlagZ := is_zero(a129[7:0]);
                FlagA := a132[7:0][4];
                FlagP := parity(a129[7:0]);
                FlagCY := a135[16];
                jump (024B);
              } else {
                advance (10)
                #027C
                #instruction: DEC  A
                let:8 a136 = a117 in
                let:16 a137 = addWithCarry(!true,a136,~00) in
                let:8 a138 = (a136 & 0F) in
                let:8 a139 = (~00 & 0F) in
                let:16 a140 = addWithCarry(!true,a138,a139) in
                advance (5)
                #027D
                #instruction: DEC  B
                let:8 a141 = a124[7:0] in
                let:16 a142 = addWithCarry(!true,a141,~00) in
                let:8 a143 = (a141 & 0F) in
                let:8 a144 = (~00 & 0F) in
                let:16 a145 = addWithCarry(!true,a143,a144) in
                advance (5)
                #027E
                #instruction: LD   (HL),B
                let:8 a146 = a142[7:0] in
                M[2021] := a146;
                advance (7)
                #027F
                #instruction: DEC  HL
                advance (5)
                #0280
                #instruction: LD   (HL),A
                let:8 a147 = a137[7:0] in
                M[2020] := a147;
                advance (7)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a148 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := a137[7:0];
                B := a142[7:0];
                C := a113;
                D := 00;
                E := 10;
                H := a148[15:0][15:8];
                L := a148[15:0][7:0];
                SPH := a91[15:8];
                SPL := a91[7:0];
                FlagS := a142[7:0][7];
                FlagZ := is_zero(a142[7:0]);
                FlagA := a145[7:0][4];
                FlagP := parity(a142[7:0]);
                FlagCY := a148[16];
                jump (024B);
              }
            } else {
              advance (10)
              #025C
              #instruction: INC  HL
              advance (5)
              #025D
              #instruction: LD   A,(HL)
              let:8 a149 = M[2022] in
              advance (7)
              #025E
              #instruction: AND  A
              let:8 a150 = a149 in
              let:8 a151 = a149 in
              let:8 a152 = (a150 & a151) in
              let:8 a153 = (a150 | a151) in
              advance (4)
              #025F
              #instruction: JP   NZ,0288
              if (!is_zero(a152)) {
                advance (10)
                #0288
                #instruction: DEC  (HL)
                let:8 a154 = M[2022] in
                let:16 a155 = addWithCarry(!true,a154,~00) in
                let:8 a156 = (a154 & 0F) in
                let:8 a157 = (~00 & 0F) in
                let:16 a158 = addWithCarry(!true,a156,a157) in
                M[2022] := a155[7:0];
                advance (10)
                #0289
                #instruction: DEC  HL
                advance (5)
                #028A
                #instruction: DEC  HL
                advance (5)
                #028B
                #instruction: JP   0281
                advance (10)
                #0281
                #instruction: LD   DE,0010
                advance (10)
                #0284
                #instruction: ADD  HL,DE
                let:17 a159 = add17(0010,2020) in
                advance (10)
                #0285
                #instruction: JP   024B
                advance (10)
                A := a152;
                B := a112;
                C := a113;
                D := 00;
                E := 10;
                H := a159[15:0][15:8];
                L := a159[15:0][7:0];
                SPH := a91[15:8];
                SPL := a91[7:0];
                FlagS := a155[7:0][7];
                FlagZ := is_zero(a155[7:0]);
                FlagA := a158[7:0][4];
                FlagP := parity(a155[7:0]);
                FlagCY := a159[16];
                jump (024B);
              } else {
                advance (10)
                #0262
                #instruction: INC  HL
                advance (5)
                #0263
                #instruction: LD   E,(HL)
                let:8 a160 = M[2023] in
                advance (7)
                #0264
                #instruction: INC  HL
                advance (5)
                #0265
                #instruction: LD   D,(HL)
                let:8 a161 = M[2024] in
                advance (7)
                #0266
                #instruction: PUSH HL
                let:8 a162 = a91[15:8] in
                let:8 a163 = a91[7:0] in
                let:16 a164 = (-1 + (a162,a163)) in
                M[a164] := 20;
                let:8 a165 = a164[15:8] in
                let:8 a166 = a164[7:0] in
                let:16 a167 = (-1 + (a165,a166)) in
                M[a167] := 24;
                advance (11)
                #0267
                #instruction: EX   DE,HL
                let:8 a168 = a161 in
                let:8 a169 = a160 in
                advance (4)
                #0268
                #instruction: PUSH HL
                let:8 a170 = a168 in
                let:8 a171 = a169 in
                let:8 a172 = a167[15:8] in
                let:8 a173 = a167[7:0] in
                let:16 a174 = (-1 + (a172,a173)) in
                M[a174] := a170;
                let:8 a175 = a174[15:8] in
                let:8 a176 = a174[7:0] in
                let:16 a177 = (-1 + (a175,a176)) in
                M[a177] := a171;
                advance (11)
                #0269
                #instruction: LD   HL,026F
                advance (10)
                #026C
                #instruction: EX   (SP),HL
                let:8 a178 = a177[15:8] in
                let:8 a179 = a177[7:0] in
                let:16 a180 = (1 + (a178,a179)) in
                let:8 a181 = M[(a178,a179)] in
                let:8 a182 = M[a180] in
                M[(a178,a179)] := 6F;
                M[a180] := 02;
                advance (18)
                #026D
                #instruction: PUSH DE
                let:8 a183 = a177[15:8] in
                let:8 a184 = a177[7:0] in
                let:16 a185 = (-1 + (a183,a184)) in
                M[a185] := 20;
                let:8 a186 = a185[15:8] in
                let:8 a187 = a185[7:0] in
                let:16 a188 = (-1 + (a186,a187)) in
                M[a188] := 24;
                advance (11)
                #026E
                #instruction: JP   (HL)
                let:8 a189 = a182 in
                let:8 a190 = a181 in
                advance (5)
                A := a152;
                B := a112;
                C := a113;
                D := 20;
                E := 24;
                H := a182;
                L := a181;
                SPH := a188[15:8];
                SPL := a188[7:0];
                FlagS := a152[7];
                FlagZ := is_zero(a152);
                FlagA := a153[3];
                FlagP := parity(a152);
                FlagCY := false;
                jump ((a189,a190));
              }
            }
          }
        }
      } else {
        advance (10)
        #009E
        #instruction: LD   A,(20C1)
        let:8 a191 = M[20C1] in
        advance (13)
        #00A1
        #instruction: RRCA
        let:8 a192 = a191 in
        advance (4)
        #00A2
        #instruction: JP   NC,0082
        if (!a192[0]) {
          advance (10)
          #0082
          #instruction: POP  HL
          let:8 a193 = a31[15:8] in
          let:8 a194 = a31[7:0] in
          let:16 a195 = (1 + (a193,a194)) in
          let:8 a196 = M[(a193,a194)] in
          let:8 a197 = a195[15:8] in
          let:8 a198 = a195[7:0] in
          let:16 a199 = (1 + (a197,a198)) in
          let:8 a200 = M[(a197,a198)] in
          advance (10)
          #0083
          #instruction: POP  DE
          let:8 a201 = a199[15:8] in
          let:8 a202 = a199[7:0] in
          let:16 a203 = (1 + (a201,a202)) in
          let:8 a204 = M[(a201,a202)] in
          let:8 a205 = a203[15:8] in
          let:8 a206 = a203[7:0] in
          let:16 a207 = (1 + (a205,a206)) in
          let:8 a208 = M[(a205,a206)] in
          advance (10)
          #0084
          #instruction: POP  BC
          let:8 a209 = a207[15:8] in
          let:8 a210 = a207[7:0] in
          let:16 a211 = (1 + (a209,a210)) in
          let:8 a212 = M[(a209,a210)] in
          let:8 a213 = a211[15:8] in
          let:8 a214 = a211[7:0] in
          let:16 a215 = (1 + (a213,a214)) in
          let:8 a216 = M[(a213,a214)] in
          advance (10)
          #0085
          #instruction: POP  PSW
          let:8 a217 = a215[15:8] in
          let:8 a218 = a215[7:0] in
          let:16 a219 = (1 + (a217,a218)) in
          let:8 a220 = M[(a217,a218)] in
          let:8 a221 = a219[15:8] in
          let:8 a222 = a219[7:0] in
          let:16 a223 = (1 + (a221,a222)) in
          let:8 a224 = M[(a221,a222)] in
          advance (10)
          #0086
          #instruction: EI
          enable_interrupts()
          advance (4)
          #0087
          #instruction: RET
          let:8 a225 = a223[15:8] in
          let:8 a226 = a223[7:0] in
          let:16 a227 = (1 + (a225,a226)) in
          let:8 a228 = M[(a225,a226)] in
          let:8 a229 = a227[15:8] in
          let:8 a230 = a227[7:0] in
          let:16 a231 = (1 + (a229,a230)) in
          let:8 a232 = M[(a229,a230)] in
          advance (10)
          A := a224;
          B := a216;
          C := a212;
          D := a208;
          E := a204;
          H := a200;
          L := a196;
          SPH := a231[15:8];
          SPL := a231[7:0];
          FlagS := a220[7];
          FlagZ := a220[6];
          FlagA := a220[4];
          FlagP := a220[2];
          FlagCY := a220[0];
          jump ((a232,a228));
        } else {
          advance (10)
          #00A5
          #instruction: LD   HL,2020
          advance (10)
          #00A8
          #instruction: CALL 024B
          let:8 a233 = a31[15:8] in
          let:8 a234 = a31[7:0] in
          let:16 a235 = (-1 + (a233,a234)) in
          M[a235] := 00;
          let:8 a236 = a235[15:8] in
          let:8 a237 = a235[7:0] in
          let:16 a238 = (-1 + (a236,a237)) in
          M[a238] := AB;
          #return-to: 00AB
          advance (17)
          #024B
          #instruction: LD   A,(HL)
          let:8 a239 = M[2020] in
          advance (7)
          #024C
          #instruction: CP   FF
          let:8 a240 = a239 in
          let:16 a241 = addWithCarry(!false,a240,~FF) in
          let:8 a242 = (a240 & 0F) in
          let:8 a243 = (~FF & 0F) in
          let:16 a244 = addWithCarry(!false,a242,a243) in
          advance (7)
          #024E
          #instruction: RET  Z
          if (is_zero(a241[7:0])) {
            let:8 a245 = a238[15:8] in
            let:8 a246 = a238[7:0] in
            let:16 a247 = (1 + (a245,a246)) in
            let:8 a248 = M[(a245,a246)] in
            let:8 a249 = a247[15:8] in
            let:8 a250 = a247[7:0] in
            let:16 a251 = (1 + (a249,a250)) in
            let:8 a252 = M[(a249,a250)] in
            advance (11)
            A := a239;
            H := 20;
            L := 20;
            SPH := a251[15:8];
            SPL := a251[7:0];
            FlagS := a241[7:0][7];
            FlagZ := is_zero(a241[7:0]);
            FlagA := a244[7:0][4];
            FlagP := parity(a241[7:0]);
            FlagCY := !a241[15:8][0];
            jump ((a252,a248));
          } else {
            advance (5)
            #024F
            #instruction: CP   FE
            let:8 a253 = a239 in
            let:16 a254 = addWithCarry(!false,a253,~FE) in
            let:8 a255 = (a253 & 0F) in
            let:8 a256 = (~FE & 0F) in
            let:16 a257 = addWithCarry(!false,a255,a256) in
            advance (7)
            #0251
            #instruction: JP   Z,0281
            if (is_zero(a254[7:0])) {
              advance (10)
              #0281
              #instruction: LD   DE,0010
              advance (10)
              #0284
              #instruction: ADD  HL,DE
              let:17 a258 = add17(0010,2020) in
              advance (10)
              #0285
              #instruction: JP   024B
              advance (10)
              A := a239;
              D := 00;
              E := 10;
              H := a258[15:0][15:8];
              L := a258[15:0][7:0];
              SPH := a238[15:8];
              SPL := a238[7:0];
              FlagS := a254[7:0][7];
              FlagZ := is_zero(a254[7:0]);
              FlagA := a257[7:0][4];
              FlagP := parity(a254[7:0]);
              FlagCY := a258[16];
              jump (024B);
            } else {
              advance (10)
              #0254
              #instruction: INC  HL
              advance (5)
              #0255
              #instruction: LD   B,(HL)
              let:8 a259 = M[2021] in
              advance (7)
              #0256
              #instruction: LD   C,A
              let:8 a260 = a239 in
              advance (5)
              #0257
              #instruction: OR   B
              let:8 a261 = a259 in
              let:8 a262 = a239 in
              let:8 a263 = (a261 | a262) in
              advance (4)
              #0258
              #instruction: LD   A,C
              let:8 a264 = a260 in
              advance (5)
              #0259
              #instruction: JP   NZ,0277
              if (!is_zero(a263)) {
                advance (10)
                #0277
                #instruction: DEC  B
                let:8 a265 = a259 in
                let:16 a266 = addWithCarry(!true,a265,~00) in
                let:8 a267 = (a265 & 0F) in
                let:8 a268 = (~00 & 0F) in
                let:16 a269 = addWithCarry(!true,a267,a268) in
                advance (5)
                #0278
                #instruction: INC  B
                let:8 a270 = a266[7:0] in
                let:16 a271 = addWithCarry(true,a270,00) in
                let:8 a272 = (a270 & 0F) in
                let:8 a273 = (00 & 0F) in
                let:16 a274 = addWithCarry(true,a272,a273) in
                advance (5)
                #0279
                #instruction: JP   NZ,027D
                if (!is_zero(a271[7:0])) {
                  advance (10)
                  #027D
                  #instruction: DEC  B
                  let:8 a275 = a271[7:0] in
                  let:16 a276 = addWithCarry(!true,a275,~00) in
                  let:8 a277 = (a275 & 0F) in
                  let:8 a278 = (~00 & 0F) in
                  let:16 a279 = addWithCarry(!true,a277,a278) in
                  advance (5)
                  #027E
                  #instruction: LD   (HL),B
                  let:8 a280 = a276[7:0] in
                  M[2021] := a280;
                  advance (7)
                  #027F
                  #instruction: DEC  HL
                  advance (5)
                  #0280
                  #instruction: LD   (HL),A
                  let:8 a281 = a264 in
                  M[2020] := a281;
                  advance (7)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a282 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := a264;
                  B := a276[7:0];
                  C := a260;
                  D := 00;
                  E := 10;
                  H := a282[15:0][15:8];
                  L := a282[15:0][7:0];
                  SPH := a238[15:8];
                  SPL := a238[7:0];
                  FlagS := a276[7:0][7];
                  FlagZ := is_zero(a276[7:0]);
                  FlagA := a279[7:0][4];
                  FlagP := parity(a276[7:0]);
                  FlagCY := a282[16];
                  jump (024B);
                } else {
                  advance (10)
                  #027C
                  #instruction: DEC  A
                  let:8 a283 = a264 in
                  let:16 a284 = addWithCarry(!true,a283,~00) in
                  let:8 a285 = (a283 & 0F) in
                  let:8 a286 = (~00 & 0F) in
                  let:16 a287 = addWithCarry(!true,a285,a286) in
                  advance (5)
                  #027D
                  #instruction: DEC  B
                  let:8 a288 = a271[7:0] in
                  let:16 a289 = addWithCarry(!true,a288,~00) in
                  let:8 a290 = (a288 & 0F) in
                  let:8 a291 = (~00 & 0F) in
                  let:16 a292 = addWithCarry(!true,a290,a291) in
                  advance (5)
                  #027E
                  #instruction: LD   (HL),B
                  let:8 a293 = a289[7:0] in
                  M[2021] := a293;
                  advance (7)
                  #027F
                  #instruction: DEC  HL
                  advance (5)
                  #0280
                  #instruction: LD   (HL),A
                  let:8 a294 = a284[7:0] in
                  M[2020] := a294;
                  advance (7)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a295 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := a284[7:0];
                  B := a289[7:0];
                  C := a260;
                  D := 00;
                  E := 10;
                  H := a295[15:0][15:8];
                  L := a295[15:0][7:0];
                  SPH := a238[15:8];
                  SPL := a238[7:0];
                  FlagS := a289[7:0][7];
                  FlagZ := is_zero(a289[7:0]);
                  FlagA := a292[7:0][4];
                  FlagP := parity(a289[7:0]);
                  FlagCY := a295[16];
                  jump (024B);
                }
              } else {
                advance (10)
                #025C
                #instruction: INC  HL
                advance (5)
                #025D
                #instruction: LD   A,(HL)
                let:8 a296 = M[2022] in
                advance (7)
                #025E
                #instruction: AND  A
                let:8 a297 = a296 in
                let:8 a298 = a296 in
                let:8 a299 = (a297 & a298) in
                let:8 a300 = (a297 | a298) in
                advance (4)
                #025F
                #instruction: JP   NZ,0288
                if (!is_zero(a299)) {
                  advance (10)
                  #0288
                  #instruction: DEC  (HL)
                  let:8 a301 = M[2022] in
                  let:16 a302 = addWithCarry(!true,a301,~00) in
                  let:8 a303 = (a301 & 0F) in
                  let:8 a304 = (~00 & 0F) in
                  let:16 a305 = addWithCarry(!true,a303,a304) in
                  M[2022] := a302[7:0];
                  advance (10)
                  #0289
                  #instruction: DEC  HL
                  advance (5)
                  #028A
                  #instruction: DEC  HL
                  advance (5)
                  #028B
                  #instruction: JP   0281
                  advance (10)
                  #0281
                  #instruction: LD   DE,0010
                  advance (10)
                  #0284
                  #instruction: ADD  HL,DE
                  let:17 a306 = add17(0010,2020) in
                  advance (10)
                  #0285
                  #instruction: JP   024B
                  advance (10)
                  A := a299;
                  B := a259;
                  C := a260;
                  D := 00;
                  E := 10;
                  H := a306[15:0][15:8];
                  L := a306[15:0][7:0];
                  SPH := a238[15:8];
                  SPL := a238[7:0];
                  FlagS := a302[7:0][7];
                  FlagZ := is_zero(a302[7:0]);
                  FlagA := a305[7:0][4];
                  FlagP := parity(a302[7:0]);
                  FlagCY := a306[16];
                  jump (024B);
                } else {
                  advance (10)
                  #0262
                  #instruction: INC  HL
                  advance (5)
                  #0263
                  #instruction: LD   E,(HL)
                  let:8 a307 = M[2023] in
                  advance (7)
                  #0264
                  #instruction: INC  HL
                  advance (5)
                  #0265
                  #instruction: LD   D,(HL)
                  let:8 a308 = M[2024] in
                  advance (7)
                  #0266
                  #instruction: PUSH HL
                  let:8 a309 = a238[15:8] in
                  let:8 a310 = a238[7:0] in
                  let:16 a311 = (-1 + (a309,a310)) in
                  M[a311] := 20;
                  let:8 a312 = a311[15:8] in
                  let:8 a313 = a311[7:0] in
                  let:16 a314 = (-1 + (a312,a313)) in
                  M[a314] := 24;
                  advance (11)
                  #0267
                  #instruction: EX   DE,HL
                  let:8 a315 = a308 in
                  let:8 a316 = a307 in
                  advance (4)
                  #0268
                  #instruction: PUSH HL
                  let:8 a317 = a315 in
                  let:8 a318 = a316 in
                  let:8 a319 = a314[15:8] in
                  let:8 a320 = a314[7:0] in
                  let:16 a321 = (-1 + (a319,a320)) in
                  M[a321] := a317;
                  let:8 a322 = a321[15:8] in
                  let:8 a323 = a321[7:0] in
                  let:16 a324 = (-1 + (a322,a323)) in
                  M[a324] := a318;
                  advance (11)
                  #0269
                  #instruction: LD   HL,026F
                  advance (10)
                  #026C
                  #instruction: EX   (SP),HL
                  let:8 a325 = a324[15:8] in
                  let:8 a326 = a324[7:0] in
                  let:16 a327 = (1 + (a325,a326)) in
                  let:8 a328 = M[(a325,a326)] in
                  let:8 a329 = M[a327] in
                  M[(a325,a326)] := 6F;
                  M[a327] := 02;
                  advance (18)
                  #026D
                  #instruction: PUSH DE
                  let:8 a330 = a324[15:8] in
                  let:8 a331 = a324[7:0] in
                  let:16 a332 = (-1 + (a330,a331)) in
                  M[a332] := 20;
                  let:8 a333 = a332[15:8] in
                  let:8 a334 = a332[7:0] in
                  let:16 a335 = (-1 + (a333,a334)) in
                  M[a335] := 24;
                  advance (11)
                  #026E
                  #instruction: JP   (HL)
                  let:8 a336 = a329 in
                  let:8 a337 = a328 in
                  advance (5)
                  A := a299;
                  B := a259;
                  C := a260;
                  D := 20;
                  E := 24;
                  H := a329;
                  L := a328;
                  SPH := a335[15:8];
                  SPL := a335[7:0];
                  FlagS := a299[7];
                  FlagZ := is_zero(a299);
                  FlagA := a300[3];
                  FlagP := parity(a299);
                  FlagCY := false;
                  jump ((a336,a337));
                }
              }
            }
          }
        }
      }
    }

0010:

    #0010
    #instruction: PUSH PSW
    let:8 a1 = A in
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := a1;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #0011
    #instruction: PUSH BC
    let:8 a8 = B in
    let:8 a9 = C in
    let:8 a10 = a7[15:8] in
    let:8 a11 = a7[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #0012
    #instruction: PUSH DE
    let:8 a16 = D in
    let:8 a17 = E in
    let:8 a18 = a15[15:8] in
    let:8 a19 = a15[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a16;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a17;
    advance (11)
    #0013
    #instruction: PUSH HL
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = a23[15:8] in
    let:8 a27 = a23[7:0] in
    let:16 a28 = (-1 + (a26,a27)) in
    M[a28] := a24;
    let:8 a29 = a28[15:8] in
    let:8 a30 = a28[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := a25;
    advance (11)
    #0014
    #instruction: LD   A,80
    advance (7)
    #0016
    #instruction: LD   (2072),A
    M[2072] := 80;
    advance (13)
    #0019
    #instruction: LD   HL,20C0
    advance (10)
    #001C
    #instruction: DEC  (HL)
    let:8 a32 = M[20C0] in
    let:16 a33 = addWithCarry(!true,a32,~00) in
    let:8 a34 = (a32 & 0F) in
    let:8 a35 = (~00 & 0F) in
    let:16 a36 = addWithCarry(!true,a34,a35) in
    M[20C0] := a33[7:0];
    advance (10)
    #001D
    #instruction: CALL 17CD
    let:8 a37 = a31[15:8] in
    let:8 a38 = a31[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := 00;
    let:8 a40 = a39[15:8] in
    let:8 a41 = a39[7:0] in
    let:16 a42 = (-1 + (a40,a41)) in
    M[a42] := 20;
    #return-to: 0020
    advance (17)
    #17CD
    #instruction: IN   02
    advance (10)
    #17CF
    #instruction: AND  04
    let:8 a43 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    let:8 a44 = (04 & a43) in
    let:8 a45 = (04 | a43) in
    advance (7)
    #17D1
    #instruction: RET  Z
    if (is_zero(a44)) {
      let:8 a46 = a42[15:8] in
      let:8 a47 = a42[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (11)
      A := a44;
      H := 20;
      L := C0;
      SPH := a52[15:8];
      SPL := a52[7:0];
      FlagS := a44[7];
      FlagZ := is_zero(a44);
      FlagA := a45[3];
      FlagP := parity(a44);
      FlagCY := false;
      jump ((a53,a49));
    } else {
      advance (5)
      #17D2
      #instruction: LD   A,(209A)
      let:8 a54 = M[209A] in
      advance (13)
      #17D5
      #instruction: AND  A
      let:8 a55 = a54 in
      let:8 a56 = a54 in
      let:8 a57 = (a55 & a56) in
      let:8 a58 = (a55 | a56) in
      advance (4)
      #17D6
      #instruction: RET  NZ
      if (!is_zero(a57)) {
        let:8 a59 = a42[15:8] in
        let:8 a60 = a42[7:0] in
        let:16 a61 = (1 + (a59,a60)) in
        let:8 a62 = M[(a59,a60)] in
        let:8 a63 = a61[15:8] in
        let:8 a64 = a61[7:0] in
        let:16 a65 = (1 + (a63,a64)) in
        let:8 a66 = M[(a63,a64)] in
        advance (11)
        A := a57;
        H := 20;
        L := C0;
        SPH := a65[15:8];
        SPL := a65[7:0];
        FlagS := a57[7];
        FlagZ := is_zero(a57);
        FlagA := a58[3];
        FlagP := parity(a57);
        FlagCY := false;
        jump ((a66,a62));
      } else {
        advance (5)
        #17D7
        #instruction: LD   SP,2400
        advance (10)
        #17DA
        #instruction: LD   B,04
        advance (7)
        #17DC
        #instruction: CALL 09D6
        M[23FF] := 17;
        M[23FE] := DF;
        #return-to: 17DF
        advance (17)
        #09D6
        #instruction: LD   HL,2402
        advance (10)
        #09D9
        #instruction: LD   (HL),00
        M[2402] := 00;
        advance (10)
        #09DB
        #instruction: INC  HL
        advance (5)
        #09DC
        #instruction: LD   A,L
        advance (5)
        #09DD
        #instruction: AND  1F
        let:8 a67 = (1F & 03) in
        let:8 a68 = (1F | 03) in
        advance (7)
        #09DF
        #instruction: CP   1C
        let:8 a69 = a67 in
        let:16 a70 = addWithCarry(!false,a69,~1C) in
        let:8 a71 = (a69 & 0F) in
        let:8 a72 = (~1C & 0F) in
        let:16 a73 = addWithCarry(!false,a71,a72) in
        advance (7)
        #09E1
        #instruction: JP   CY,09E8
        if (!a70[15:8][0]) {
          advance (10)
          #09E8
          #instruction: LD   A,H
          advance (5)
          #09E9
          #instruction: CP   40
          let:16 a74 = addWithCarry(!false,24,~40) in
          let:8 a75 = (24 & 0F) in
          let:8 a76 = (~40 & 0F) in
          let:16 a77 = addWithCarry(!false,a75,a76) in
          advance (7)
          #09EB
          #instruction: JP   CY,09D9
          if (!a74[15:8][0]) {
            advance (10)
            A := 24;
            B := 04;
            H := 24;
            L := 03;
            SPH := 23;
            SPL := FE;
            FlagS := a74[7:0][7];
            FlagZ := is_zero(a74[7:0]);
            FlagA := a77[7:0][4];
            FlagP := parity(a74[7:0]);
            FlagCY := !a74[15:8][0];
            jump (09D9);
          } else {
            advance (10)
            #09EE
            #instruction: RET
            let:8 a78 = M[23FE] in
            let:8 a79 = M[23FF] in
            advance (10)
            A := 24;
            B := 04;
            H := 24;
            L := 03;
            SPH := 24;
            SPL := 00;
            FlagS := a74[7:0][7];
            FlagZ := is_zero(a74[7:0]);
            FlagA := a77[7:0][4];
            FlagP := parity(a74[7:0]);
            FlagCY := !a74[15:8][0];
            jump ((a79,a78));
          }
        } else {
          advance (10)
          #09E4
          #instruction: LD   DE,0006
          advance (10)
          #09E7
          #instruction: ADD  HL,DE
          let:17 a80 = add17(0006,2403) in
          advance (10)
          #09E8
          #instruction: LD   A,H
          let:8 a81 = a80[15:0][15:8] in
          advance (5)
          #09E9
          #instruction: CP   40
          let:8 a82 = a81 in
          let:16 a83 = addWithCarry(!false,a82,~40) in
          let:8 a84 = (a82 & 0F) in
          let:8 a85 = (~40 & 0F) in
          let:16 a86 = addWithCarry(!false,a84,a85) in
          advance (7)
          #09EB
          #instruction: JP   CY,09D9
          if (!a83[15:8][0]) {
            advance (10)
            A := a81;
            B := 04;
            D := 00;
            E := 06;
            H := a80[15:0][15:8];
            L := a80[15:0][7:0];
            SPH := 23;
            SPL := FE;
            FlagS := a83[7:0][7];
            FlagZ := is_zero(a83[7:0]);
            FlagA := a86[7:0][4];
            FlagP := parity(a83[7:0]);
            FlagCY := !a83[15:8][0];
            jump (09D9);
          } else {
            advance (10)
            #09EE
            #instruction: RET
            let:8 a87 = M[23FE] in
            let:8 a88 = M[23FF] in
            advance (10)
            A := a81;
            B := 04;
            D := 00;
            E := 06;
            H := a80[15:0][15:8];
            L := a80[15:0][7:0];
            SPH := 24;
            SPL := 00;
            FlagS := a83[7:0][7];
            FlagZ := is_zero(a83[7:0]);
            FlagA := a86[7:0][4];
            FlagP := parity(a83[7:0]);
            FlagCY := !a83[15:8][0];
            jump ((a88,a87));
          }
        }
      }
    }

0020:

    #0020
    #instruction: IN   01
    advance (10)
    #0022
    #instruction: RRCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    advance (4)
    #0023
    #instruction: JP   CY,0067
    if (a1[0]) {
      advance (10)
      #0067
      #instruction: LD   A,01
      advance (7)
      #0069
      #instruction: LD   (20EA),A
      M[20EA] := 01;
      advance (13)
      #006C
      #instruction: JP   003F
      advance (10)
      #003F
      #instruction: LD   (20EA),A
      M[20EA] := 01;
      advance (13)
      #0042
      #instruction: LD   A,(20E9)
      let:8 a2 = M[20E9] in
      advance (13)
      #0045
      #instruction: AND  A
      let:8 a3 = a2 in
      let:8 a4 = a2 in
      let:8 a5 = (a3 & a4) in
      let:8 a6 = (a3 | a4) in
      advance (4)
      #0046
      #instruction: JP   Z,0082
      if (is_zero(a5)) {
        advance (10)
        #0082
        #instruction: POP  HL
        let:8 a7 = SPH in
        let:8 a8 = SPL in
        let:16 a9 = (1 + (a7,a8)) in
        let:8 a10 = M[(a7,a8)] in
        let:8 a11 = a9[15:8] in
        let:8 a12 = a9[7:0] in
        let:16 a13 = (1 + (a11,a12)) in
        let:8 a14 = M[(a11,a12)] in
        advance (10)
        #0083
        #instruction: POP  DE
        let:8 a15 = a13[15:8] in
        let:8 a16 = a13[7:0] in
        let:16 a17 = (1 + (a15,a16)) in
        let:8 a18 = M[(a15,a16)] in
        let:8 a19 = a17[15:8] in
        let:8 a20 = a17[7:0] in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        advance (10)
        #0084
        #instruction: POP  BC
        let:8 a23 = a21[15:8] in
        let:8 a24 = a21[7:0] in
        let:16 a25 = (1 + (a23,a24)) in
        let:8 a26 = M[(a23,a24)] in
        let:8 a27 = a25[15:8] in
        let:8 a28 = a25[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        advance (10)
        #0085
        #instruction: POP  PSW
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        let:8 a35 = a33[15:8] in
        let:8 a36 = a33[7:0] in
        let:16 a37 = (1 + (a35,a36)) in
        let:8 a38 = M[(a35,a36)] in
        advance (10)
        #0086
        #instruction: EI
        enable_interrupts()
        advance (4)
        #0087
        #instruction: RET
        let:8 a39 = a37[15:8] in
        let:8 a40 = a37[7:0] in
        let:16 a41 = (1 + (a39,a40)) in
        let:8 a42 = M[(a39,a40)] in
        let:8 a43 = a41[15:8] in
        let:8 a44 = a41[7:0] in
        let:16 a45 = (1 + (a43,a44)) in
        let:8 a46 = M[(a43,a44)] in
        advance (10)
        A := a38;
        B := a30;
        C := a26;
        D := a22;
        E := a18;
        H := a14;
        L := a10;
        SPH := a45[15:8];
        SPL := a45[7:0];
        FlagS := a34[7];
        FlagZ := a34[6];
        FlagA := a34[4];
        FlagP := a34[2];
        FlagCY := a34[0];
        jump ((a46,a42));
      } else {
        advance (10)
        #0049
        #instruction: LD   A,(20EF)
        let:8 a47 = M[20EF] in
        advance (13)
        #004C
        #instruction: AND  A
        let:8 a48 = a47 in
        let:8 a49 = a47 in
        let:8 a50 = (a48 & a49) in
        let:8 a51 = (a48 | a49) in
        advance (4)
        #004D
        #instruction: JP   NZ,006F
        if (!is_zero(a50)) {
          advance (10)
          #006F
          #instruction: CALL 1740
          let:8 a52 = SPH in
          let:8 a53 = SPL in
          let:16 a54 = (-1 + (a52,a53)) in
          M[a54] := 00;
          let:8 a55 = a54[15:8] in
          let:8 a56 = a54[7:0] in
          let:16 a57 = (-1 + (a55,a56)) in
          M[a57] := 72;
          #return-to: 0072
          advance (17)
          #1740
          #instruction: LD   HL,209B
          advance (10)
          #1743
          #instruction: DEC  (HL)
          let:8 a58 = M[209B] in
          let:16 a59 = addWithCarry(!true,a58,~00) in
          let:8 a60 = (a58 & 0F) in
          let:8 a61 = (~00 & 0F) in
          let:16 a62 = addWithCarry(!true,a60,a61) in
          M[209B] := a59[7:0];
          advance (10)
          #1744
          #instruction: CALL Z,176D
          if (is_zero(a59[7:0])) {
            let:8 a63 = a57[15:8] in
            let:8 a64 = a57[7:0] in
            let:16 a65 = (-1 + (a63,a64)) in
            M[a65] := 17;
            let:8 a66 = a65[15:8] in
            let:8 a67 = a65[7:0] in
            let:16 a68 = (-1 + (a66,a67)) in
            M[a68] := 47;
            #return-to: 1747
            advance (17)
            #176D
            #instruction: LD   A,(2098)
            let:8 a69 = M[2098] in
            advance (13)
            #1770
            #instruction: AND  30
            let:8 a70 = a69 in
            let:8 a71 = (30 & a70) in
            let:8 a72 = (30 | a70) in
            advance (7)
            #1772
            #instruction: OUT  05
            let:8 a73 = a71 in
            sound_control(FleetMovement1,a73[0]);
            sound_control(FleetMovement2,a73[1]);
            sound_control(FleetMovement3,a73[2]);
            sound_control(FleetMovement4,a73[3]);
            sound_control(UfoHit,a73[4]);
            advance (10)
            #1774
            #instruction: RET
            let:8 a74 = a68[15:8] in
            let:8 a75 = a68[7:0] in
            let:16 a76 = (1 + (a74,a75)) in
            let:8 a77 = M[(a74,a75)] in
            let:8 a78 = a76[15:8] in
            let:8 a79 = a76[7:0] in
            let:16 a80 = (1 + (a78,a79)) in
            let:8 a81 = M[(a78,a79)] in
            advance (10)
            A := a71;
            H := 20;
            L := 9B;
            SPH := a80[15:8];
            SPL := a80[7:0];
            FlagS := a71[7];
            FlagZ := is_zero(a71);
            FlagA := a72[3];
            FlagP := parity(a71);
            FlagCY := false;
            jump ((a81,a77));
          } else {
            advance (11)
            A := a50;
            H := 20;
            L := 9B;
            SPH := a57[15:8];
            SPL := a57[7:0];
            FlagS := a59[7:0][7];
            FlagZ := is_zero(a59[7:0]);
            FlagA := a62[7:0][4];
            FlagP := parity(a59[7:0]);
            FlagCY := false;
            jump (1747);
          }
        } else {
          advance (10)
          #0050
          #instruction: LD   A,(20EB)
          let:8 a82 = M[20EB] in
          advance (13)
          #0053
          #instruction: AND  A
          let:8 a83 = a82 in
          let:8 a84 = a82 in
          let:8 a85 = (a83 & a84) in
          let:8 a86 = (a83 | a84) in
          advance (4)
          #0054
          #instruction: JP   NZ,005D
          if (!is_zero(a85)) {
            advance (10)
            #005D
            #instruction: LD   A,(2093)
            let:8 a87 = M[2093] in
            advance (13)
            #0060
            #instruction: AND  A
            let:8 a88 = a87 in
            let:8 a89 = a87 in
            let:8 a90 = (a88 & a89) in
            let:8 a91 = (a88 | a89) in
            advance (4)
            #0061
            #instruction: JP   NZ,0082
            if (!is_zero(a90)) {
              advance (10)
              #0082
              #instruction: POP  HL
              let:8 a92 = SPH in
              let:8 a93 = SPL in
              let:16 a94 = (1 + (a92,a93)) in
              let:8 a95 = M[(a92,a93)] in
              let:8 a96 = a94[15:8] in
              let:8 a97 = a94[7:0] in
              let:16 a98 = (1 + (a96,a97)) in
              let:8 a99 = M[(a96,a97)] in
              advance (10)
              #0083
              #instruction: POP  DE
              let:8 a100 = a98[15:8] in
              let:8 a101 = a98[7:0] in
              let:16 a102 = (1 + (a100,a101)) in
              let:8 a103 = M[(a100,a101)] in
              let:8 a104 = a102[15:8] in
              let:8 a105 = a102[7:0] in
              let:16 a106 = (1 + (a104,a105)) in
              let:8 a107 = M[(a104,a105)] in
              advance (10)
              #0084
              #instruction: POP  BC
              let:8 a108 = a106[15:8] in
              let:8 a109 = a106[7:0] in
              let:16 a110 = (1 + (a108,a109)) in
              let:8 a111 = M[(a108,a109)] in
              let:8 a112 = a110[15:8] in
              let:8 a113 = a110[7:0] in
              let:16 a114 = (1 + (a112,a113)) in
              let:8 a115 = M[(a112,a113)] in
              advance (10)
              #0085
              #instruction: POP  PSW
              let:8 a116 = a114[15:8] in
              let:8 a117 = a114[7:0] in
              let:16 a118 = (1 + (a116,a117)) in
              let:8 a119 = M[(a116,a117)] in
              let:8 a120 = a118[15:8] in
              let:8 a121 = a118[7:0] in
              let:16 a122 = (1 + (a120,a121)) in
              let:8 a123 = M[(a120,a121)] in
              advance (10)
              #0086
              #instruction: EI
              enable_interrupts()
              advance (4)
              #0087
              #instruction: RET
              let:8 a124 = a122[15:8] in
              let:8 a125 = a122[7:0] in
              let:16 a126 = (1 + (a124,a125)) in
              let:8 a127 = M[(a124,a125)] in
              let:8 a128 = a126[15:8] in
              let:8 a129 = a126[7:0] in
              let:16 a130 = (1 + (a128,a129)) in
              let:8 a131 = M[(a128,a129)] in
              advance (10)
              A := a123;
              B := a115;
              C := a111;
              D := a107;
              E := a103;
              H := a99;
              L := a95;
              SPH := a130[15:8];
              SPL := a130[7:0];
              FlagS := a119[7];
              FlagZ := a119[6];
              FlagA := a119[4];
              FlagP := a119[2];
              FlagCY := a119[0];
              jump ((a131,a127));
            } else {
              advance (10)
              #0064
              #instruction: JP   0765
              advance (10)
              #0765
              #instruction: LD   A,01
              advance (7)
              #0767
              #instruction: LD   (2093),A
              M[2093] := 01;
              advance (13)
              #076A
              #instruction: LD   SP,2400
              advance (10)
              #076D
              #instruction: EI
              enable_interrupts()
              advance (4)
              #076E
              #instruction: CALL 1979
              M[23FF] := 07;
              M[23FE] := 71;
              #return-to: 0771
              advance (17)
              #1979
              #instruction: CALL 19D7
              M[23FD] := 19;
              M[23FC] := 7C;
              #return-to: 197C
              advance (17)
              #19D7
              #instruction: XOR  A
              let:8 a132 = (01 ^ 01) in
              advance (4)
              #19D8
              #instruction: JP   19D3
              advance (10)
              #19D3
              #instruction: LD   (20E9),A
              let:8 a133 = a132 in
              M[20E9] := a133;
              advance (13)
              #19D6
              #instruction: RET
              let:8 a134 = M[23FC] in
              let:8 a135 = M[23FD] in
              advance (10)
              A := a132;
              SPH := 23;
              SPL := FE;
              FlagS := a132[7];
              FlagZ := is_zero(a132);
              FlagA := false;
              FlagP := parity(a132);
              FlagCY := false;
              jump ((a135,a134));
            }
          } else {
            advance (10)
            #0057
            #instruction: CALL 0ABF
            let:8 a136 = SPH in
            let:8 a137 = SPL in
            let:16 a138 = (-1 + (a136,a137)) in
            M[a138] := 00;
            let:8 a139 = a138[15:8] in
            let:8 a140 = a138[7:0] in
            let:16 a141 = (-1 + (a139,a140)) in
            M[a141] := 5A;
            #return-to: 005A
            advance (17)
            #0ABF
            #instruction: LD   A,(20C1)
            let:8 a142 = M[20C1] in
            advance (13)
            #0AC2
            #instruction: RRCA
            let:8 a143 = a142 in
            advance (4)
            #0AC3
            #instruction: JP   CY,0ABB
            if (a143[0]) {
              advance (10)
              #0ABB
              #instruction: POP  HL
              let:8 a144 = a141[15:8] in
              let:8 a145 = a141[7:0] in
              let:16 a146 = (1 + (a144,a145)) in
              let:8 a147 = M[(a144,a145)] in
              let:8 a148 = a146[15:8] in
              let:8 a149 = a146[7:0] in
              let:16 a150 = (1 + (a148,a149)) in
              let:8 a151 = M[(a148,a149)] in
              advance (10)
              #0ABC
              #instruction: JP   0072
              advance (10)
              A := updateBit((a143 >> 01),7,a143[0]);
              H := a151;
              L := a147;
              SPH := a150[15:8];
              SPL := a150[7:0];
              FlagS := a85[7];
              FlagZ := is_zero(a85);
              FlagA := a86[3];
              FlagP := parity(a85);
              FlagCY := a143[0];
              jump (0072);
            } else {
              advance (10)
              #0AC6
              #instruction: RRCA
              let:8 a152 = updateBit((a143 >> 01),7,a143[0]) in
              advance (4)
              #0AC7
              #instruction: JP   CY,1868
              if (a152[0]) {
                advance (10)
                #1868
                #instruction: LD   HL,20C2
                advance (10)
                #186B
                #instruction: INC  (HL)
                let:8 a153 = M[20C2] in
                let:16 a154 = addWithCarry(true,a153,00) in
                let:8 a155 = (a153 & 0F) in
                let:8 a156 = (00 & 0F) in
                let:16 a157 = addWithCarry(true,a155,a156) in
                M[20C2] := a154[7:0];
                advance (10)
                #186C
                #instruction: INC  HL
                advance (5)
                #186D
                #instruction: LD   C,(HL)
                let:8 a158 = M[20C3] in
                advance (7)
                #186E
                #instruction: CALL 01D9
                let:8 a159 = a141[15:8] in
                let:8 a160 = a141[7:0] in
                let:16 a161 = (-1 + (a159,a160)) in
                M[a161] := 18;
                let:8 a162 = a161[15:8] in
                let:8 a163 = a161[7:0] in
                let:16 a164 = (-1 + (a162,a163)) in
                M[a164] := 71;
                #return-to: 1871
                advance (17)
                #01D9
                #instruction: INC  HL
                advance (5)
                #01DA
                #instruction: LD   B,(HL)
                let:8 a165 = M[20C4] in
                advance (7)
                #01DB
                #instruction: INC  HL
                advance (5)
                #01DC
                #instruction: LD   A,C
                let:8 a166 = a158 in
                advance (5)
                #01DD
                #instruction: ADD  (HL)
                let:8 a167 = M[20C5] in
                let:8 a168 = a166 in
                let:16 a169 = addWithCarry(false,a167,a168) in
                let:8 a170 = (a167 & 0F) in
                let:8 a171 = (a168 & 0F) in
                let:16 a172 = addWithCarry(false,a170,a171) in
                advance (7)
                #01DE
                #instruction: LD   (HL),A
                let:8 a173 = a169[7:0] in
                M[20C5] := a173;
                advance (7)
                #01DF
                #instruction: INC  HL
                advance (5)
                #01E0
                #instruction: LD   A,B
                let:8 a174 = a165 in
                advance (5)
                #01E1
                #instruction: ADD  (HL)
                let:8 a175 = M[20C6] in
                let:8 a176 = a174 in
                let:16 a177 = addWithCarry(false,a175,a176) in
                let:8 a178 = (a175 & 0F) in
                let:8 a179 = (a176 & 0F) in
                let:16 a180 = addWithCarry(false,a178,a179) in
                advance (7)
                #01E2
                #instruction: LD   (HL),A
                let:8 a181 = a177[7:0] in
                M[20C6] := a181;
                advance (7)
                #01E3
                #instruction: RET
                let:8 a182 = a164[15:8] in
                let:8 a183 = a164[7:0] in
                let:16 a184 = (1 + (a182,a183)) in
                let:8 a185 = M[(a182,a183)] in
                let:8 a186 = a184[15:8] in
                let:8 a187 = a184[7:0] in
                let:16 a188 = (1 + (a186,a187)) in
                let:8 a189 = M[(a186,a187)] in
                advance (10)
                A := a177[7:0];
                B := a165;
                C := a158;
                H := 20;
                L := C6;
                SPH := a188[15:8];
                SPL := a188[7:0];
                FlagS := a177[7:0][7];
                FlagZ := is_zero(a177[7:0]);
                FlagA := a180[7:0][4];
                FlagP := parity(a177[7:0]);
                FlagCY := a177[15:8][0];
                jump ((a189,a185));
              } else {
                advance (10)
                #0ACA
                #instruction: RRCA
                let:8 a190 = updateBit((a152 >> 01),7,a152[0]) in
                advance (4)
                #0ACB
                #instruction: JP   CY,0AAB
                if (a190[0]) {
                  advance (10)
                  #0AAB
                  #instruction: LD   HL,2050
                  advance (10)
                  #0AAE
                  #instruction: JP   024B
                  advance (10)
                  #024B
                  #instruction: LD   A,(HL)
                  let:8 a191 = M[2050] in
                  advance (7)
                  #024C
                  #instruction: CP   FF
                  let:8 a192 = a191 in
                  let:16 a193 = addWithCarry(!false,a192,~FF) in
                  let:8 a194 = (a192 & 0F) in
                  let:8 a195 = (~FF & 0F) in
                  let:16 a196 = addWithCarry(!false,a194,a195) in
                  advance (7)
                  #024E
                  #instruction: RET  Z
                  if (is_zero(a193[7:0])) {
                    let:8 a197 = a141[15:8] in
                    let:8 a198 = a141[7:0] in
                    let:16 a199 = (1 + (a197,a198)) in
                    let:8 a200 = M[(a197,a198)] in
                    let:8 a201 = a199[15:8] in
                    let:8 a202 = a199[7:0] in
                    let:16 a203 = (1 + (a201,a202)) in
                    let:8 a204 = M[(a201,a202)] in
                    advance (11)
                    A := a191;
                    H := 20;
                    L := 50;
                    SPH := a203[15:8];
                    SPL := a203[7:0];
                    FlagS := a193[7:0][7];
                    FlagZ := is_zero(a193[7:0]);
                    FlagA := a196[7:0][4];
                    FlagP := parity(a193[7:0]);
                    FlagCY := !a193[15:8][0];
                    jump ((a204,a200));
                  } else {
                    advance (5)
                    #024F
                    #instruction: CP   FE
                    let:8 a205 = a191 in
                    let:16 a206 = addWithCarry(!false,a205,~FE) in
                    let:8 a207 = (a205 & 0F) in
                    let:8 a208 = (~FE & 0F) in
                    let:16 a209 = addWithCarry(!false,a207,a208) in
                    advance (7)
                    #0251
                    #instruction: JP   Z,0281
                    if (is_zero(a206[7:0])) {
                      advance (10)
                      #0281
                      #instruction: LD   DE,0010
                      advance (10)
                      #0284
                      #instruction: ADD  HL,DE
                      let:17 a210 = add17(0010,2050) in
                      advance (10)
                      #0285
                      #instruction: JP   024B
                      advance (10)
                      A := a191;
                      D := 00;
                      E := 10;
                      H := a210[15:0][15:8];
                      L := a210[15:0][7:0];
                      SPH := a141[15:8];
                      SPL := a141[7:0];
                      FlagS := a206[7:0][7];
                      FlagZ := is_zero(a206[7:0]);
                      FlagA := a209[7:0][4];
                      FlagP := parity(a206[7:0]);
                      FlagCY := a210[16];
                      jump (024B);
                    } else {
                      advance (10)
                      #0254
                      #instruction: INC  HL
                      advance (5)
                      #0255
                      #instruction: LD   B,(HL)
                      let:8 a211 = M[2051] in
                      advance (7)
                      #0256
                      #instruction: LD   C,A
                      let:8 a212 = a191 in
                      advance (5)
                      #0257
                      #instruction: OR   B
                      let:8 a213 = a211 in
                      let:8 a214 = a191 in
                      let:8 a215 = (a213 | a214) in
                      advance (4)
                      #0258
                      #instruction: LD   A,C
                      let:8 a216 = a212 in
                      advance (5)
                      #0259
                      #instruction: JP   NZ,0277
                      if (!is_zero(a215)) {
                        advance (10)
                        #0277
                        #instruction: DEC  B
                        let:8 a217 = a211 in
                        let:16 a218 = addWithCarry(!true,a217,~00) in
                        let:8 a219 = (a217 & 0F) in
                        let:8 a220 = (~00 & 0F) in
                        let:16 a221 = addWithCarry(!true,a219,a220) in
                        advance (5)
                        #0278
                        #instruction: INC  B
                        let:8 a222 = a218[7:0] in
                        let:16 a223 = addWithCarry(true,a222,00) in
                        let:8 a224 = (a222 & 0F) in
                        let:8 a225 = (00 & 0F) in
                        let:16 a226 = addWithCarry(true,a224,a225) in
                        advance (5)
                        #0279
                        #instruction: JP   NZ,027D
                        if (!is_zero(a223[7:0])) {
                          advance (10)
                          #027D
                          #instruction: DEC  B
                          let:8 a227 = a223[7:0] in
                          let:16 a228 = addWithCarry(!true,a227,~00) in
                          let:8 a229 = (a227 & 0F) in
                          let:8 a230 = (~00 & 0F) in
                          let:16 a231 = addWithCarry(!true,a229,a230) in
                          advance (5)
                          #027E
                          #instruction: LD   (HL),B
                          let:8 a232 = a228[7:0] in
                          M[2051] := a232;
                          advance (7)
                          #027F
                          #instruction: DEC  HL
                          advance (5)
                          #0280
                          #instruction: LD   (HL),A
                          let:8 a233 = a216 in
                          M[2050] := a233;
                          advance (7)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a234 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := a216;
                          B := a228[7:0];
                          C := a212;
                          D := 00;
                          E := 10;
                          H := a234[15:0][15:8];
                          L := a234[15:0][7:0];
                          SPH := a141[15:8];
                          SPL := a141[7:0];
                          FlagS := a228[7:0][7];
                          FlagZ := is_zero(a228[7:0]);
                          FlagA := a231[7:0][4];
                          FlagP := parity(a228[7:0]);
                          FlagCY := a234[16];
                          jump (024B);
                        } else {
                          advance (10)
                          #027C
                          #instruction: DEC  A
                          let:8 a235 = a216 in
                          let:16 a236 = addWithCarry(!true,a235,~00) in
                          let:8 a237 = (a235 & 0F) in
                          let:8 a238 = (~00 & 0F) in
                          let:16 a239 = addWithCarry(!true,a237,a238) in
                          advance (5)
                          #027D
                          #instruction: DEC  B
                          let:8 a240 = a223[7:0] in
                          let:16 a241 = addWithCarry(!true,a240,~00) in
                          let:8 a242 = (a240 & 0F) in
                          let:8 a243 = (~00 & 0F) in
                          let:16 a244 = addWithCarry(!true,a242,a243) in
                          advance (5)
                          #027E
                          #instruction: LD   (HL),B
                          let:8 a245 = a241[7:0] in
                          M[2051] := a245;
                          advance (7)
                          #027F
                          #instruction: DEC  HL
                          advance (5)
                          #0280
                          #instruction: LD   (HL),A
                          let:8 a246 = a236[7:0] in
                          M[2050] := a246;
                          advance (7)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a247 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := a236[7:0];
                          B := a241[7:0];
                          C := a212;
                          D := 00;
                          E := 10;
                          H := a247[15:0][15:8];
                          L := a247[15:0][7:0];
                          SPH := a141[15:8];
                          SPL := a141[7:0];
                          FlagS := a241[7:0][7];
                          FlagZ := is_zero(a241[7:0]);
                          FlagA := a244[7:0][4];
                          FlagP := parity(a241[7:0]);
                          FlagCY := a247[16];
                          jump (024B);
                        }
                      } else {
                        advance (10)
                        #025C
                        #instruction: INC  HL
                        advance (5)
                        #025D
                        #instruction: LD   A,(HL)
                        let:8 a248 = M[2052] in
                        advance (7)
                        #025E
                        #instruction: AND  A
                        let:8 a249 = a248 in
                        let:8 a250 = a248 in
                        let:8 a251 = (a249 & a250) in
                        let:8 a252 = (a249 | a250) in
                        advance (4)
                        #025F
                        #instruction: JP   NZ,0288
                        if (!is_zero(a251)) {
                          advance (10)
                          #0288
                          #instruction: DEC  (HL)
                          let:8 a253 = M[2052] in
                          let:16 a254 = addWithCarry(!true,a253,~00) in
                          let:8 a255 = (a253 & 0F) in
                          let:8 a256 = (~00 & 0F) in
                          let:16 a257 = addWithCarry(!true,a255,a256) in
                          M[2052] := a254[7:0];
                          advance (10)
                          #0289
                          #instruction: DEC  HL
                          advance (5)
                          #028A
                          #instruction: DEC  HL
                          advance (5)
                          #028B
                          #instruction: JP   0281
                          advance (10)
                          #0281
                          #instruction: LD   DE,0010
                          advance (10)
                          #0284
                          #instruction: ADD  HL,DE
                          let:17 a258 = add17(0010,2050) in
                          advance (10)
                          #0285
                          #instruction: JP   024B
                          advance (10)
                          A := a251;
                          B := a211;
                          C := a212;
                          D := 00;
                          E := 10;
                          H := a258[15:0][15:8];
                          L := a258[15:0][7:0];
                          SPH := a141[15:8];
                          SPL := a141[7:0];
                          FlagS := a254[7:0][7];
                          FlagZ := is_zero(a254[7:0]);
                          FlagA := a257[7:0][4];
                          FlagP := parity(a254[7:0]);
                          FlagCY := a258[16];
                          jump (024B);
                        } else {
                          advance (10)
                          #0262
                          #instruction: INC  HL
                          advance (5)
                          #0263
                          #instruction: LD   E,(HL)
                          let:8 a259 = M[2053] in
                          advance (7)
                          #0264
                          #instruction: INC  HL
                          advance (5)
                          #0265
                          #instruction: LD   D,(HL)
                          let:8 a260 = M[2054] in
                          advance (7)
                          #0266
                          #instruction: PUSH HL
                          let:8 a261 = a141[15:8] in
                          let:8 a262 = a141[7:0] in
                          let:16 a263 = (-1 + (a261,a262)) in
                          M[a263] := 20;
                          let:8 a264 = a263[15:8] in
                          let:8 a265 = a263[7:0] in
                          let:16 a266 = (-1 + (a264,a265)) in
                          M[a266] := 54;
                          advance (11)
                          #0267
                          #instruction: EX   DE,HL
                          let:8 a267 = a260 in
                          let:8 a268 = a259 in
                          advance (4)
                          #0268
                          #instruction: PUSH HL
                          let:8 a269 = a267 in
                          let:8 a270 = a268 in
                          let:8 a271 = a266[15:8] in
                          let:8 a272 = a266[7:0] in
                          let:16 a273 = (-1 + (a271,a272)) in
                          M[a273] := a269;
                          let:8 a274 = a273[15:8] in
                          let:8 a275 = a273[7:0] in
                          let:16 a276 = (-1 + (a274,a275)) in
                          M[a276] := a270;
                          advance (11)
                          #0269
                          #instruction: LD   HL,026F
                          advance (10)
                          #026C
                          #instruction: EX   (SP),HL
                          let:8 a277 = a276[15:8] in
                          let:8 a278 = a276[7:0] in
                          let:16 a279 = (1 + (a277,a278)) in
                          let:8 a280 = M[(a277,a278)] in
                          let:8 a281 = M[a279] in
                          M[(a277,a278)] := 6F;
                          M[a279] := 02;
                          advance (18)
                          #026D
                          #instruction: PUSH DE
                          let:8 a282 = a276[15:8] in
                          let:8 a283 = a276[7:0] in
                          let:16 a284 = (-1 + (a282,a283)) in
                          M[a284] := 20;
                          let:8 a285 = a284[15:8] in
                          let:8 a286 = a284[7:0] in
                          let:16 a287 = (-1 + (a285,a286)) in
                          M[a287] := 54;
                          advance (11)
                          #026E
                          #instruction: JP   (HL)
                          let:8 a288 = a281 in
                          let:8 a289 = a280 in
                          advance (5)
                          A := a251;
                          B := a211;
                          C := a212;
                          D := 20;
                          E := 54;
                          H := a281;
                          L := a280;
                          SPH := a287[15:8];
                          SPL := a287[7:0];
                          FlagS := a251[7];
                          FlagZ := is_zero(a251);
                          FlagA := a252[3];
                          FlagP := parity(a251);
                          FlagCY := false;
                          jump ((a288,a289));
                        }
                      }
                    }
                  }
                } else {
                  advance (10)
                  #0ACE
                  #instruction: RET
                  let:8 a290 = a141[15:8] in
                  let:8 a291 = a141[7:0] in
                  let:16 a292 = (1 + (a290,a291)) in
                  let:8 a293 = M[(a290,a291)] in
                  let:8 a294 = a292[15:8] in
                  let:8 a295 = a292[7:0] in
                  let:16 a296 = (1 + (a294,a295)) in
                  let:8 a297 = M[(a294,a295)] in
                  advance (10)
                  A := updateBit((a190 >> 01),7,a190[0]);
                  SPH := a296[15:8];
                  SPL := a296[7:0];
                  FlagS := a85[7];
                  FlagZ := is_zero(a85);
                  FlagA := a86[3];
                  FlagP := parity(a85);
                  FlagCY := a190[0];
                  jump ((a297,a293));
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0026
      #instruction: LD   A,(20EA)
      let:8 a298 = M[20EA] in
      advance (13)
      #0029
      #instruction: AND  A
      let:8 a299 = a298 in
      let:8 a300 = a298 in
      let:8 a301 = (a299 & a300) in
      let:8 a302 = (a299 | a300) in
      advance (4)
      #002A
      #instruction: JP   Z,0042
      if (is_zero(a301)) {
        advance (10)
        #0042
        #instruction: LD   A,(20E9)
        let:8 a303 = M[20E9] in
        advance (13)
        #0045
        #instruction: AND  A
        let:8 a304 = a303 in
        let:8 a305 = a303 in
        let:8 a306 = (a304 & a305) in
        let:8 a307 = (a304 | a305) in
        advance (4)
        #0046
        #instruction: JP   Z,0082
        if (is_zero(a306)) {
          advance (10)
          #0082
          #instruction: POP  HL
          let:8 a308 = SPH in
          let:8 a309 = SPL in
          let:16 a310 = (1 + (a308,a309)) in
          let:8 a311 = M[(a308,a309)] in
          let:8 a312 = a310[15:8] in
          let:8 a313 = a310[7:0] in
          let:16 a314 = (1 + (a312,a313)) in
          let:8 a315 = M[(a312,a313)] in
          advance (10)
          #0083
          #instruction: POP  DE
          let:8 a316 = a314[15:8] in
          let:8 a317 = a314[7:0] in
          let:16 a318 = (1 + (a316,a317)) in
          let:8 a319 = M[(a316,a317)] in
          let:8 a320 = a318[15:8] in
          let:8 a321 = a318[7:0] in
          let:16 a322 = (1 + (a320,a321)) in
          let:8 a323 = M[(a320,a321)] in
          advance (10)
          #0084
          #instruction: POP  BC
          let:8 a324 = a322[15:8] in
          let:8 a325 = a322[7:0] in
          let:16 a326 = (1 + (a324,a325)) in
          let:8 a327 = M[(a324,a325)] in
          let:8 a328 = a326[15:8] in
          let:8 a329 = a326[7:0] in
          let:16 a330 = (1 + (a328,a329)) in
          let:8 a331 = M[(a328,a329)] in
          advance (10)
          #0085
          #instruction: POP  PSW
          let:8 a332 = a330[15:8] in
          let:8 a333 = a330[7:0] in
          let:16 a334 = (1 + (a332,a333)) in
          let:8 a335 = M[(a332,a333)] in
          let:8 a336 = a334[15:8] in
          let:8 a337 = a334[7:0] in
          let:16 a338 = (1 + (a336,a337)) in
          let:8 a339 = M[(a336,a337)] in
          advance (10)
          #0086
          #instruction: EI
          enable_interrupts()
          advance (4)
          #0087
          #instruction: RET
          let:8 a340 = a338[15:8] in
          let:8 a341 = a338[7:0] in
          let:16 a342 = (1 + (a340,a341)) in
          let:8 a343 = M[(a340,a341)] in
          let:8 a344 = a342[15:8] in
          let:8 a345 = a342[7:0] in
          let:16 a346 = (1 + (a344,a345)) in
          let:8 a347 = M[(a344,a345)] in
          advance (10)
          A := a339;
          B := a331;
          C := a327;
          D := a323;
          E := a319;
          H := a315;
          L := a311;
          SPH := a346[15:8];
          SPL := a346[7:0];
          FlagS := a335[7];
          FlagZ := a335[6];
          FlagA := a335[4];
          FlagP := a335[2];
          FlagCY := a335[0];
          jump ((a347,a343));
        } else {
          advance (10)
          #0049
          #instruction: LD   A,(20EF)
          let:8 a348 = M[20EF] in
          advance (13)
          #004C
          #instruction: AND  A
          let:8 a349 = a348 in
          let:8 a350 = a348 in
          let:8 a351 = (a349 & a350) in
          let:8 a352 = (a349 | a350) in
          advance (4)
          #004D
          #instruction: JP   NZ,006F
          if (!is_zero(a351)) {
            advance (10)
            #006F
            #instruction: CALL 1740
            let:8 a353 = SPH in
            let:8 a354 = SPL in
            let:16 a355 = (-1 + (a353,a354)) in
            M[a355] := 00;
            let:8 a356 = a355[15:8] in
            let:8 a357 = a355[7:0] in
            let:16 a358 = (-1 + (a356,a357)) in
            M[a358] := 72;
            #return-to: 0072
            advance (17)
            #1740
            #instruction: LD   HL,209B
            advance (10)
            #1743
            #instruction: DEC  (HL)
            let:8 a359 = M[209B] in
            let:16 a360 = addWithCarry(!true,a359,~00) in
            let:8 a361 = (a359 & 0F) in
            let:8 a362 = (~00 & 0F) in
            let:16 a363 = addWithCarry(!true,a361,a362) in
            M[209B] := a360[7:0];
            advance (10)
            #1744
            #instruction: CALL Z,176D
            if (is_zero(a360[7:0])) {
              let:8 a364 = a358[15:8] in
              let:8 a365 = a358[7:0] in
              let:16 a366 = (-1 + (a364,a365)) in
              M[a366] := 17;
              let:8 a367 = a366[15:8] in
              let:8 a368 = a366[7:0] in
              let:16 a369 = (-1 + (a367,a368)) in
              M[a369] := 47;
              #return-to: 1747
              advance (17)
              #176D
              #instruction: LD   A,(2098)
              let:8 a370 = M[2098] in
              advance (13)
              #1770
              #instruction: AND  30
              let:8 a371 = a370 in
              let:8 a372 = (30 & a371) in
              let:8 a373 = (30 | a371) in
              advance (7)
              #1772
              #instruction: OUT  05
              let:8 a374 = a372 in
              sound_control(FleetMovement1,a374[0]);
              sound_control(FleetMovement2,a374[1]);
              sound_control(FleetMovement3,a374[2]);
              sound_control(FleetMovement4,a374[3]);
              sound_control(UfoHit,a374[4]);
              advance (10)
              #1774
              #instruction: RET
              let:8 a375 = a369[15:8] in
              let:8 a376 = a369[7:0] in
              let:16 a377 = (1 + (a375,a376)) in
              let:8 a378 = M[(a375,a376)] in
              let:8 a379 = a377[15:8] in
              let:8 a380 = a377[7:0] in
              let:16 a381 = (1 + (a379,a380)) in
              let:8 a382 = M[(a379,a380)] in
              advance (10)
              A := a372;
              H := 20;
              L := 9B;
              SPH := a381[15:8];
              SPL := a381[7:0];
              FlagS := a372[7];
              FlagZ := is_zero(a372);
              FlagA := a373[3];
              FlagP := parity(a372);
              FlagCY := false;
              jump ((a382,a378));
            } else {
              advance (11)
              A := a351;
              H := 20;
              L := 9B;
              SPH := a358[15:8];
              SPL := a358[7:0];
              FlagS := a360[7:0][7];
              FlagZ := is_zero(a360[7:0]);
              FlagA := a363[7:0][4];
              FlagP := parity(a360[7:0]);
              FlagCY := false;
              jump (1747);
            }
          } else {
            advance (10)
            #0050
            #instruction: LD   A,(20EB)
            let:8 a383 = M[20EB] in
            advance (13)
            #0053
            #instruction: AND  A
            let:8 a384 = a383 in
            let:8 a385 = a383 in
            let:8 a386 = (a384 & a385) in
            let:8 a387 = (a384 | a385) in
            advance (4)
            #0054
            #instruction: JP   NZ,005D
            if (!is_zero(a386)) {
              advance (10)
              #005D
              #instruction: LD   A,(2093)
              let:8 a388 = M[2093] in
              advance (13)
              #0060
              #instruction: AND  A
              let:8 a389 = a388 in
              let:8 a390 = a388 in
              let:8 a391 = (a389 & a390) in
              let:8 a392 = (a389 | a390) in
              advance (4)
              #0061
              #instruction: JP   NZ,0082
              if (!is_zero(a391)) {
                advance (10)
                #0082
                #instruction: POP  HL
                let:8 a393 = SPH in
                let:8 a394 = SPL in
                let:16 a395 = (1 + (a393,a394)) in
                let:8 a396 = M[(a393,a394)] in
                let:8 a397 = a395[15:8] in
                let:8 a398 = a395[7:0] in
                let:16 a399 = (1 + (a397,a398)) in
                let:8 a400 = M[(a397,a398)] in
                advance (10)
                #0083
                #instruction: POP  DE
                let:8 a401 = a399[15:8] in
                let:8 a402 = a399[7:0] in
                let:16 a403 = (1 + (a401,a402)) in
                let:8 a404 = M[(a401,a402)] in
                let:8 a405 = a403[15:8] in
                let:8 a406 = a403[7:0] in
                let:16 a407 = (1 + (a405,a406)) in
                let:8 a408 = M[(a405,a406)] in
                advance (10)
                #0084
                #instruction: POP  BC
                let:8 a409 = a407[15:8] in
                let:8 a410 = a407[7:0] in
                let:16 a411 = (1 + (a409,a410)) in
                let:8 a412 = M[(a409,a410)] in
                let:8 a413 = a411[15:8] in
                let:8 a414 = a411[7:0] in
                let:16 a415 = (1 + (a413,a414)) in
                let:8 a416 = M[(a413,a414)] in
                advance (10)
                #0085
                #instruction: POP  PSW
                let:8 a417 = a415[15:8] in
                let:8 a418 = a415[7:0] in
                let:16 a419 = (1 + (a417,a418)) in
                let:8 a420 = M[(a417,a418)] in
                let:8 a421 = a419[15:8] in
                let:8 a422 = a419[7:0] in
                let:16 a423 = (1 + (a421,a422)) in
                let:8 a424 = M[(a421,a422)] in
                advance (10)
                #0086
                #instruction: EI
                enable_interrupts()
                advance (4)
                #0087
                #instruction: RET
                let:8 a425 = a423[15:8] in
                let:8 a426 = a423[7:0] in
                let:16 a427 = (1 + (a425,a426)) in
                let:8 a428 = M[(a425,a426)] in
                let:8 a429 = a427[15:8] in
                let:8 a430 = a427[7:0] in
                let:16 a431 = (1 + (a429,a430)) in
                let:8 a432 = M[(a429,a430)] in
                advance (10)
                A := a424;
                B := a416;
                C := a412;
                D := a408;
                E := a404;
                H := a400;
                L := a396;
                SPH := a431[15:8];
                SPL := a431[7:0];
                FlagS := a420[7];
                FlagZ := a420[6];
                FlagA := a420[4];
                FlagP := a420[2];
                FlagCY := a420[0];
                jump ((a432,a428));
              } else {
                advance (10)
                #0064
                #instruction: JP   0765
                advance (10)
                #0765
                #instruction: LD   A,01
                advance (7)
                #0767
                #instruction: LD   (2093),A
                M[2093] := 01;
                advance (13)
                #076A
                #instruction: LD   SP,2400
                advance (10)
                #076D
                #instruction: EI
                enable_interrupts()
                advance (4)
                #076E
                #instruction: CALL 1979
                M[23FF] := 07;
                M[23FE] := 71;
                #return-to: 0771
                advance (17)
                #1979
                #instruction: CALL 19D7
                M[23FD] := 19;
                M[23FC] := 7C;
                #return-to: 197C
                advance (17)
                #19D7
                #instruction: XOR  A
                let:8 a433 = (01 ^ 01) in
                advance (4)
                #19D8
                #instruction: JP   19D3
                advance (10)
                #19D3
                #instruction: LD   (20E9),A
                let:8 a434 = a433 in
                M[20E9] := a434;
                advance (13)
                #19D6
                #instruction: RET
                let:8 a435 = M[23FC] in
                let:8 a436 = M[23FD] in
                advance (10)
                A := a433;
                SPH := 23;
                SPL := FE;
                FlagS := a433[7];
                FlagZ := is_zero(a433);
                FlagA := false;
                FlagP := parity(a433);
                FlagCY := false;
                jump ((a436,a435));
              }
            } else {
              advance (10)
              #0057
              #instruction: CALL 0ABF
              let:8 a437 = SPH in
              let:8 a438 = SPL in
              let:16 a439 = (-1 + (a437,a438)) in
              M[a439] := 00;
              let:8 a440 = a439[15:8] in
              let:8 a441 = a439[7:0] in
              let:16 a442 = (-1 + (a440,a441)) in
              M[a442] := 5A;
              #return-to: 005A
              advance (17)
              #0ABF
              #instruction: LD   A,(20C1)
              let:8 a443 = M[20C1] in
              advance (13)
              #0AC2
              #instruction: RRCA
              let:8 a444 = a443 in
              advance (4)
              #0AC3
              #instruction: JP   CY,0ABB
              if (a444[0]) {
                advance (10)
                #0ABB
                #instruction: POP  HL
                let:8 a445 = a442[15:8] in
                let:8 a446 = a442[7:0] in
                let:16 a447 = (1 + (a445,a446)) in
                let:8 a448 = M[(a445,a446)] in
                let:8 a449 = a447[15:8] in
                let:8 a450 = a447[7:0] in
                let:16 a451 = (1 + (a449,a450)) in
                let:8 a452 = M[(a449,a450)] in
                advance (10)
                #0ABC
                #instruction: JP   0072
                advance (10)
                A := updateBit((a444 >> 01),7,a444[0]);
                H := a452;
                L := a448;
                SPH := a451[15:8];
                SPL := a451[7:0];
                FlagS := a386[7];
                FlagZ := is_zero(a386);
                FlagA := a387[3];
                FlagP := parity(a386);
                FlagCY := a444[0];
                jump (0072);
              } else {
                advance (10)
                #0AC6
                #instruction: RRCA
                let:8 a453 = updateBit((a444 >> 01),7,a444[0]) in
                advance (4)
                #0AC7
                #instruction: JP   CY,1868
                if (a453[0]) {
                  advance (10)
                  #1868
                  #instruction: LD   HL,20C2
                  advance (10)
                  #186B
                  #instruction: INC  (HL)
                  let:8 a454 = M[20C2] in
                  let:16 a455 = addWithCarry(true,a454,00) in
                  let:8 a456 = (a454 & 0F) in
                  let:8 a457 = (00 & 0F) in
                  let:16 a458 = addWithCarry(true,a456,a457) in
                  M[20C2] := a455[7:0];
                  advance (10)
                  #186C
                  #instruction: INC  HL
                  advance (5)
                  #186D
                  #instruction: LD   C,(HL)
                  let:8 a459 = M[20C3] in
                  advance (7)
                  #186E
                  #instruction: CALL 01D9
                  let:8 a460 = a442[15:8] in
                  let:8 a461 = a442[7:0] in
                  let:16 a462 = (-1 + (a460,a461)) in
                  M[a462] := 18;
                  let:8 a463 = a462[15:8] in
                  let:8 a464 = a462[7:0] in
                  let:16 a465 = (-1 + (a463,a464)) in
                  M[a465] := 71;
                  #return-to: 1871
                  advance (17)
                  #01D9
                  #instruction: INC  HL
                  advance (5)
                  #01DA
                  #instruction: LD   B,(HL)
                  let:8 a466 = M[20C4] in
                  advance (7)
                  #01DB
                  #instruction: INC  HL
                  advance (5)
                  #01DC
                  #instruction: LD   A,C
                  let:8 a467 = a459 in
                  advance (5)
                  #01DD
                  #instruction: ADD  (HL)
                  let:8 a468 = M[20C5] in
                  let:8 a469 = a467 in
                  let:16 a470 = addWithCarry(false,a468,a469) in
                  let:8 a471 = (a468 & 0F) in
                  let:8 a472 = (a469 & 0F) in
                  let:16 a473 = addWithCarry(false,a471,a472) in
                  advance (7)
                  #01DE
                  #instruction: LD   (HL),A
                  let:8 a474 = a470[7:0] in
                  M[20C5] := a474;
                  advance (7)
                  #01DF
                  #instruction: INC  HL
                  advance (5)
                  #01E0
                  #instruction: LD   A,B
                  let:8 a475 = a466 in
                  advance (5)
                  #01E1
                  #instruction: ADD  (HL)
                  let:8 a476 = M[20C6] in
                  let:8 a477 = a475 in
                  let:16 a478 = addWithCarry(false,a476,a477) in
                  let:8 a479 = (a476 & 0F) in
                  let:8 a480 = (a477 & 0F) in
                  let:16 a481 = addWithCarry(false,a479,a480) in
                  advance (7)
                  #01E2
                  #instruction: LD   (HL),A
                  let:8 a482 = a478[7:0] in
                  M[20C6] := a482;
                  advance (7)
                  #01E3
                  #instruction: RET
                  let:8 a483 = a465[15:8] in
                  let:8 a484 = a465[7:0] in
                  let:16 a485 = (1 + (a483,a484)) in
                  let:8 a486 = M[(a483,a484)] in
                  let:8 a487 = a485[15:8] in
                  let:8 a488 = a485[7:0] in
                  let:16 a489 = (1 + (a487,a488)) in
                  let:8 a490 = M[(a487,a488)] in
                  advance (10)
                  A := a478[7:0];
                  B := a466;
                  C := a459;
                  H := 20;
                  L := C6;
                  SPH := a489[15:8];
                  SPL := a489[7:0];
                  FlagS := a478[7:0][7];
                  FlagZ := is_zero(a478[7:0]);
                  FlagA := a481[7:0][4];
                  FlagP := parity(a478[7:0]);
                  FlagCY := a478[15:8][0];
                  jump ((a490,a486));
                } else {
                  advance (10)
                  #0ACA
                  #instruction: RRCA
                  let:8 a491 = updateBit((a453 >> 01),7,a453[0]) in
                  advance (4)
                  #0ACB
                  #instruction: JP   CY,0AAB
                  if (a491[0]) {
                    advance (10)
                    #0AAB
                    #instruction: LD   HL,2050
                    advance (10)
                    #0AAE
                    #instruction: JP   024B
                    advance (10)
                    #024B
                    #instruction: LD   A,(HL)
                    let:8 a492 = M[2050] in
                    advance (7)
                    #024C
                    #instruction: CP   FF
                    let:8 a493 = a492 in
                    let:16 a494 = addWithCarry(!false,a493,~FF) in
                    let:8 a495 = (a493 & 0F) in
                    let:8 a496 = (~FF & 0F) in
                    let:16 a497 = addWithCarry(!false,a495,a496) in
                    advance (7)
                    #024E
                    #instruction: RET  Z
                    if (is_zero(a494[7:0])) {
                      let:8 a498 = a442[15:8] in
                      let:8 a499 = a442[7:0] in
                      let:16 a500 = (1 + (a498,a499)) in
                      let:8 a501 = M[(a498,a499)] in
                      let:8 a502 = a500[15:8] in
                      let:8 a503 = a500[7:0] in
                      let:16 a504 = (1 + (a502,a503)) in
                      let:8 a505 = M[(a502,a503)] in
                      advance (11)
                      A := a492;
                      H := 20;
                      L := 50;
                      SPH := a504[15:8];
                      SPL := a504[7:0];
                      FlagS := a494[7:0][7];
                      FlagZ := is_zero(a494[7:0]);
                      FlagA := a497[7:0][4];
                      FlagP := parity(a494[7:0]);
                      FlagCY := !a494[15:8][0];
                      jump ((a505,a501));
                    } else {
                      advance (5)
                      #024F
                      #instruction: CP   FE
                      let:8 a506 = a492 in
                      let:16 a507 = addWithCarry(!false,a506,~FE) in
                      let:8 a508 = (a506 & 0F) in
                      let:8 a509 = (~FE & 0F) in
                      let:16 a510 = addWithCarry(!false,a508,a509) in
                      advance (7)
                      #0251
                      #instruction: JP   Z,0281
                      if (is_zero(a507[7:0])) {
                        advance (10)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a511 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a492;
                        D := 00;
                        E := 10;
                        H := a511[15:0][15:8];
                        L := a511[15:0][7:0];
                        SPH := a442[15:8];
                        SPL := a442[7:0];
                        FlagS := a507[7:0][7];
                        FlagZ := is_zero(a507[7:0]);
                        FlagA := a510[7:0][4];
                        FlagP := parity(a507[7:0]);
                        FlagCY := a511[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #0254
                        #instruction: INC  HL
                        advance (5)
                        #0255
                        #instruction: LD   B,(HL)
                        let:8 a512 = M[2051] in
                        advance (7)
                        #0256
                        #instruction: LD   C,A
                        let:8 a513 = a492 in
                        advance (5)
                        #0257
                        #instruction: OR   B
                        let:8 a514 = a512 in
                        let:8 a515 = a492 in
                        let:8 a516 = (a514 | a515) in
                        advance (4)
                        #0258
                        #instruction: LD   A,C
                        let:8 a517 = a513 in
                        advance (5)
                        #0259
                        #instruction: JP   NZ,0277
                        if (!is_zero(a516)) {
                          advance (10)
                          #0277
                          #instruction: DEC  B
                          let:8 a518 = a512 in
                          let:16 a519 = addWithCarry(!true,a518,~00) in
                          let:8 a520 = (a518 & 0F) in
                          let:8 a521 = (~00 & 0F) in
                          let:16 a522 = addWithCarry(!true,a520,a521) in
                          advance (5)
                          #0278
                          #instruction: INC  B
                          let:8 a523 = a519[7:0] in
                          let:16 a524 = addWithCarry(true,a523,00) in
                          let:8 a525 = (a523 & 0F) in
                          let:8 a526 = (00 & 0F) in
                          let:16 a527 = addWithCarry(true,a525,a526) in
                          advance (5)
                          #0279
                          #instruction: JP   NZ,027D
                          if (!is_zero(a524[7:0])) {
                            advance (10)
                            #027D
                            #instruction: DEC  B
                            let:8 a528 = a524[7:0] in
                            let:16 a529 = addWithCarry(!true,a528,~00) in
                            let:8 a530 = (a528 & 0F) in
                            let:8 a531 = (~00 & 0F) in
                            let:16 a532 = addWithCarry(!true,a530,a531) in
                            advance (5)
                            #027E
                            #instruction: LD   (HL),B
                            let:8 a533 = a529[7:0] in
                            M[2051] := a533;
                            advance (7)
                            #027F
                            #instruction: DEC  HL
                            advance (5)
                            #0280
                            #instruction: LD   (HL),A
                            let:8 a534 = a517 in
                            M[2050] := a534;
                            advance (7)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a535 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := a517;
                            B := a529[7:0];
                            C := a513;
                            D := 00;
                            E := 10;
                            H := a535[15:0][15:8];
                            L := a535[15:0][7:0];
                            SPH := a442[15:8];
                            SPL := a442[7:0];
                            FlagS := a529[7:0][7];
                            FlagZ := is_zero(a529[7:0]);
                            FlagA := a532[7:0][4];
                            FlagP := parity(a529[7:0]);
                            FlagCY := a535[16];
                            jump (024B);
                          } else {
                            advance (10)
                            #027C
                            #instruction: DEC  A
                            let:8 a536 = a517 in
                            let:16 a537 = addWithCarry(!true,a536,~00) in
                            let:8 a538 = (a536 & 0F) in
                            let:8 a539 = (~00 & 0F) in
                            let:16 a540 = addWithCarry(!true,a538,a539) in
                            advance (5)
                            #027D
                            #instruction: DEC  B
                            let:8 a541 = a524[7:0] in
                            let:16 a542 = addWithCarry(!true,a541,~00) in
                            let:8 a543 = (a541 & 0F) in
                            let:8 a544 = (~00 & 0F) in
                            let:16 a545 = addWithCarry(!true,a543,a544) in
                            advance (5)
                            #027E
                            #instruction: LD   (HL),B
                            let:8 a546 = a542[7:0] in
                            M[2051] := a546;
                            advance (7)
                            #027F
                            #instruction: DEC  HL
                            advance (5)
                            #0280
                            #instruction: LD   (HL),A
                            let:8 a547 = a537[7:0] in
                            M[2050] := a547;
                            advance (7)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a548 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := a537[7:0];
                            B := a542[7:0];
                            C := a513;
                            D := 00;
                            E := 10;
                            H := a548[15:0][15:8];
                            L := a548[15:0][7:0];
                            SPH := a442[15:8];
                            SPL := a442[7:0];
                            FlagS := a542[7:0][7];
                            FlagZ := is_zero(a542[7:0]);
                            FlagA := a545[7:0][4];
                            FlagP := parity(a542[7:0]);
                            FlagCY := a548[16];
                            jump (024B);
                          }
                        } else {
                          advance (10)
                          #025C
                          #instruction: INC  HL
                          advance (5)
                          #025D
                          #instruction: LD   A,(HL)
                          let:8 a549 = M[2052] in
                          advance (7)
                          #025E
                          #instruction: AND  A
                          let:8 a550 = a549 in
                          let:8 a551 = a549 in
                          let:8 a552 = (a550 & a551) in
                          let:8 a553 = (a550 | a551) in
                          advance (4)
                          #025F
                          #instruction: JP   NZ,0288
                          if (!is_zero(a552)) {
                            advance (10)
                            #0288
                            #instruction: DEC  (HL)
                            let:8 a554 = M[2052] in
                            let:16 a555 = addWithCarry(!true,a554,~00) in
                            let:8 a556 = (a554 & 0F) in
                            let:8 a557 = (~00 & 0F) in
                            let:16 a558 = addWithCarry(!true,a556,a557) in
                            M[2052] := a555[7:0];
                            advance (10)
                            #0289
                            #instruction: DEC  HL
                            advance (5)
                            #028A
                            #instruction: DEC  HL
                            advance (5)
                            #028B
                            #instruction: JP   0281
                            advance (10)
                            #0281
                            #instruction: LD   DE,0010
                            advance (10)
                            #0284
                            #instruction: ADD  HL,DE
                            let:17 a559 = add17(0010,2050) in
                            advance (10)
                            #0285
                            #instruction: JP   024B
                            advance (10)
                            A := a552;
                            B := a512;
                            C := a513;
                            D := 00;
                            E := 10;
                            H := a559[15:0][15:8];
                            L := a559[15:0][7:0];
                            SPH := a442[15:8];
                            SPL := a442[7:0];
                            FlagS := a555[7:0][7];
                            FlagZ := is_zero(a555[7:0]);
                            FlagA := a558[7:0][4];
                            FlagP := parity(a555[7:0]);
                            FlagCY := a559[16];
                            jump (024B);
                          } else {
                            advance (10)
                            #0262
                            #instruction: INC  HL
                            advance (5)
                            #0263
                            #instruction: LD   E,(HL)
                            let:8 a560 = M[2053] in
                            advance (7)
                            #0264
                            #instruction: INC  HL
                            advance (5)
                            #0265
                            #instruction: LD   D,(HL)
                            let:8 a561 = M[2054] in
                            advance (7)
                            #0266
                            #instruction: PUSH HL
                            let:8 a562 = a442[15:8] in
                            let:8 a563 = a442[7:0] in
                            let:16 a564 = (-1 + (a562,a563)) in
                            M[a564] := 20;
                            let:8 a565 = a564[15:8] in
                            let:8 a566 = a564[7:0] in
                            let:16 a567 = (-1 + (a565,a566)) in
                            M[a567] := 54;
                            advance (11)
                            #0267
                            #instruction: EX   DE,HL
                            let:8 a568 = a561 in
                            let:8 a569 = a560 in
                            advance (4)
                            #0268
                            #instruction: PUSH HL
                            let:8 a570 = a568 in
                            let:8 a571 = a569 in
                            let:8 a572 = a567[15:8] in
                            let:8 a573 = a567[7:0] in
                            let:16 a574 = (-1 + (a572,a573)) in
                            M[a574] := a570;
                            let:8 a575 = a574[15:8] in
                            let:8 a576 = a574[7:0] in
                            let:16 a577 = (-1 + (a575,a576)) in
                            M[a577] := a571;
                            advance (11)
                            #0269
                            #instruction: LD   HL,026F
                            advance (10)
                            #026C
                            #instruction: EX   (SP),HL
                            let:8 a578 = a577[15:8] in
                            let:8 a579 = a577[7:0] in
                            let:16 a580 = (1 + (a578,a579)) in
                            let:8 a581 = M[(a578,a579)] in
                            let:8 a582 = M[a580] in
                            M[(a578,a579)] := 6F;
                            M[a580] := 02;
                            advance (18)
                            #026D
                            #instruction: PUSH DE
                            let:8 a583 = a577[15:8] in
                            let:8 a584 = a577[7:0] in
                            let:16 a585 = (-1 + (a583,a584)) in
                            M[a585] := 20;
                            let:8 a586 = a585[15:8] in
                            let:8 a587 = a585[7:0] in
                            let:16 a588 = (-1 + (a586,a587)) in
                            M[a588] := 54;
                            advance (11)
                            #026E
                            #instruction: JP   (HL)
                            let:8 a589 = a582 in
                            let:8 a590 = a581 in
                            advance (5)
                            A := a552;
                            B := a512;
                            C := a513;
                            D := 20;
                            E := 54;
                            H := a582;
                            L := a581;
                            SPH := a588[15:8];
                            SPL := a588[7:0];
                            FlagS := a552[7];
                            FlagZ := is_zero(a552);
                            FlagA := a553[3];
                            FlagP := parity(a552);
                            FlagCY := false;
                            jump ((a589,a590));
                          }
                        }
                      }
                    }
                  } else {
                    advance (10)
                    #0ACE
                    #instruction: RET
                    let:8 a591 = a442[15:8] in
                    let:8 a592 = a442[7:0] in
                    let:16 a593 = (1 + (a591,a592)) in
                    let:8 a594 = M[(a591,a592)] in
                    let:8 a595 = a593[15:8] in
                    let:8 a596 = a593[7:0] in
                    let:16 a597 = (1 + (a595,a596)) in
                    let:8 a598 = M[(a595,a596)] in
                    advance (10)
                    A := updateBit((a491 >> 01),7,a491[0]);
                    SPH := a597[15:8];
                    SPL := a597[7:0];
                    FlagS := a386[7];
                    FlagZ := is_zero(a386);
                    FlagA := a387[3];
                    FlagP := parity(a386);
                    FlagCY := a491[0];
                    jump ((a598,a594));
                  }
                }
              }
            }
          }
        }
      } else {
        advance (10)
        #002D
        #instruction: LD   A,(20EB)
        let:8 a599 = M[20EB] in
        advance (13)
        #0030
        #instruction: CP   99
        let:8 a600 = a599 in
        let:16 a601 = addWithCarry(!false,a600,~99) in
        let:8 a602 = (a600 & 0F) in
        let:8 a603 = (~99 & 0F) in
        let:16 a604 = addWithCarry(!false,a602,a603) in
        advance (7)
        #0032
        #instruction: JP   Z,003E
        if (is_zero(a601[7:0])) {
          advance (10)
          A := a599;
          FlagS := a601[7:0][7];
          FlagZ := is_zero(a601[7:0]);
          FlagA := a604[7:0][4];
          FlagP := parity(a601[7:0]);
          FlagCY := !a601[15:8][0];
          jump (003E);
        } else {
          advance (10)
          #0035
          #instruction: ADD  01
          let:8 a605 = a599 in
          let:16 a606 = addWithCarry(false,01,a605) in
          let:8 a607 = (01 & 0F) in
          let:8 a608 = (a605 & 0F) in
          let:16 a609 = addWithCarry(false,a607,a608) in
          advance (7)
          #0037
          #instruction: DAA
          let:8 a610 = a606[7:0] in
          let:8 a611 = (a610 & 0F) in
          let:16 a612 = addWithCarry(false,a611,06) in
          let:16 a613 = addWithCarry(((((a611[1] || a611[2]) && a611[3]) || a609[7:0][4]) ? a612[7:0] : a611)[4],(a610 >> 04),00) in
          let:16 a614 = addWithCarry(false,a613[7:0],06) in
          let:8 a615 = (((((a611[1] || a611[2]) && a611[3]) || a609[7:0][4]) ? a612[7:0] : a611) & 0F) in
          let:8 a616 = ((((((a613[7:0][1] || a613[7:0][2]) && a613[7:0][3]) || a606[15:8][0]) ? a614[7:0] : a613[7:0]) << 04) | a615) in
          advance (4)
          #0038
          #instruction: LD   (20EB),A
          let:8 a617 = a616 in
          M[20EB] := a617;
          advance (13)
          #003B
          #instruction: CALL 1947
          let:8 a618 = SPH in
          let:8 a619 = SPL in
          let:16 a620 = (-1 + (a618,a619)) in
          M[a620] := 00;
          let:8 a621 = a620[15:8] in
          let:8 a622 = a620[7:0] in
          let:16 a623 = (-1 + (a621,a622)) in
          M[a623] := 3E;
          #return-to: 003E
          advance (17)
          #1947
          #instruction: LD   A,(20EB)
          let:8 a624 = M[20EB] in
          advance (13)
          #194A
          #instruction: LD   HL,3C01
          advance (10)
          #194D
          #instruction: JP   09B2
          advance (10)
          #09B2
          #instruction: PUSH DE
          let:8 a625 = D in
          let:8 a626 = E in
          let:8 a627 = a623[15:8] in
          let:8 a628 = a623[7:0] in
          let:16 a629 = (-1 + (a627,a628)) in
          M[a629] := a625;
          let:8 a630 = a629[15:8] in
          let:8 a631 = a629[7:0] in
          let:16 a632 = (-1 + (a630,a631)) in
          M[a632] := a626;
          advance (11)
          #09B3
          #instruction: PUSH PSW
          let:8 a633 = a624 in
          let:8 a634 = a632[15:8] in
          let:8 a635 = a632[7:0] in
          let:16 a636 = (-1 + (a634,a635)) in
          M[a636] := a633;
          let:8 a637 = a636[15:8] in
          let:8 a638 = a636[7:0] in
          let:16 a639 = (-1 + (a637,a638)) in
          M[a639] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a616[7]),6,is_zero(a616)),4,((((a611[1] || a611[2]) && a611[3]) || a609[7:0][4]) ? a612[7:0] : a611)[4]),2,parity(a616)),0,(((((a613[7:0][1] || a613[7:0][2]) && a613[7:0][3]) || a606[15:8][0]) ? a614[7:0] : a613[7:0])[4] || a606[15:8][0]));
          advance (11)
          #09B4
          #instruction: RRCA
          let:8 a640 = a624 in
          advance (4)
          #09B5
          #instruction: RRCA
          let:8 a641 = updateBit((a640 >> 01),7,a640[0]) in
          advance (4)
          #09B6
          #instruction: RRCA
          let:8 a642 = updateBit((a641 >> 01),7,a641[0]) in
          advance (4)
          #09B7
          #instruction: RRCA
          let:8 a643 = updateBit((a642 >> 01),7,a642[0]) in
          advance (4)
          #09B8
          #instruction: AND  0F
          let:8 a644 = updateBit((a643 >> 01),7,a643[0]) in
          let:8 a645 = (0F & a644) in
          let:8 a646 = (0F | a644) in
          advance (7)
          #09BA
          #instruction: CALL 09C5
          let:8 a647 = a639[15:8] in
          let:8 a648 = a639[7:0] in
          let:16 a649 = (-1 + (a647,a648)) in
          M[a649] := 09;
          let:8 a650 = a649[15:8] in
          let:8 a651 = a649[7:0] in
          let:16 a652 = (-1 + (a650,a651)) in
          M[a652] := BD;
          #return-to: 09BD
          advance (17)
          #09C5
          #instruction: ADD  1A
          let:8 a653 = a645 in
          let:16 a654 = addWithCarry(false,1A,a653) in
          let:8 a655 = (1A & 0F) in
          let:8 a656 = (a653 & 0F) in
          let:16 a657 = addWithCarry(false,a655,a656) in
          advance (7)
          #09C7
          #instruction: JP   08FF
          advance (10)
          #08FF
          #instruction: LD   DE,1E00
          advance (10)
          #0902
          #instruction: PUSH HL
          let:8 a658 = a652[15:8] in
          let:8 a659 = a652[7:0] in
          let:16 a660 = (-1 + (a658,a659)) in
          M[a660] := 3C;
          let:8 a661 = a660[15:8] in
          let:8 a662 = a660[7:0] in
          let:16 a663 = (-1 + (a661,a662)) in
          M[a663] := 01;
          advance (11)
          #0903
          #instruction: LD   H,00
          advance (7)
          #0905
          #instruction: LD   L,A
          let:8 a664 = a654[7:0] in
          advance (5)
          #0906
          #instruction: ADD  HL,HL
          let:8 a665 = a664 in
          let:8 a666 = a664 in
          let:17 a667 = add17((00,a665),(00,a666)) in
          advance (10)
          #0907
          #instruction: ADD  HL,HL
          let:8 a668 = a667[15:0][15:8] in
          let:8 a669 = a667[15:0][7:0] in
          let:8 a670 = a667[15:0][15:8] in
          let:8 a671 = a667[15:0][7:0] in
          let:17 a672 = add17((a668,a669),(a670,a671)) in
          advance (10)
          #0908
          #instruction: ADD  HL,HL
          let:8 a673 = a672[15:0][15:8] in
          let:8 a674 = a672[15:0][7:0] in
          let:8 a675 = a672[15:0][15:8] in
          let:8 a676 = a672[15:0][7:0] in
          let:17 a677 = add17((a673,a674),(a675,a676)) in
          advance (10)
          #0909
          #instruction: ADD  HL,DE
          let:8 a678 = a677[15:0][15:8] in
          let:8 a679 = a677[15:0][7:0] in
          let:17 a680 = add17(1E00,(a678,a679)) in
          advance (10)
          #090A
          #instruction: EX   DE,HL
          let:8 a681 = a680[15:0][15:8] in
          let:8 a682 = a680[15:0][7:0] in
          advance (4)
          #090B
          #instruction: POP  HL
          let:8 a683 = a663[15:8] in
          let:8 a684 = a663[7:0] in
          let:16 a685 = (1 + (a683,a684)) in
          let:8 a686 = M[(a683,a684)] in
          let:8 a687 = a685[15:8] in
          let:8 a688 = a685[7:0] in
          let:16 a689 = (1 + (a687,a688)) in
          let:8 a690 = M[(a687,a688)] in
          advance (10)
          #090C
          #instruction: LD   B,08
          advance (7)
          #090E
          #instruction: OUT  06
          let:8 a691 = a654[7:0] in
          unknown_output(6,a691);
          advance (10)
          #0910
          #instruction: JP   1439
          advance (10)
          #1439
          #instruction: PUSH BC
          let:8 a692 = C in
          let:8 a693 = a689[15:8] in
          let:8 a694 = a689[7:0] in
          let:16 a695 = (-1 + (a693,a694)) in
          M[a695] := 08;
          let:8 a696 = a695[15:8] in
          let:8 a697 = a695[7:0] in
          let:16 a698 = (-1 + (a696,a697)) in
          M[a698] := a692;
          advance (11)
          #143A
          #instruction: LD   A,(DE)
          let:8 a699 = a681 in
          let:8 a700 = a682 in
          let:8 a701 = M[(a699,a700)] in
          advance (7)
          #143B
          #instruction: LD   (HL),A
          let:8 a702 = a701 in
          let:8 a703 = a690 in
          let:8 a704 = a686 in
          M[(a703,a704)] := a702;
          advance (7)
          #143C
          #instruction: INC  DE
          let:8 a705 = a681 in
          let:8 a706 = a682 in
          let:16 a707 = (1 + (a705,a706)) in
          advance (5)
          #143D
          #instruction: LD   BC,0020
          advance (10)
          #1440
          #instruction: ADD  HL,BC
          let:8 a708 = a690 in
          let:8 a709 = a686 in
          let:17 a710 = add17(0020,(a708,a709)) in
          advance (10)
          #1441
          #instruction: POP  BC
          let:8 a711 = a698[15:8] in
          let:8 a712 = a698[7:0] in
          let:16 a713 = (1 + (a711,a712)) in
          let:8 a714 = M[(a711,a712)] in
          let:8 a715 = a713[15:8] in
          let:8 a716 = a713[7:0] in
          let:16 a717 = (1 + (a715,a716)) in
          let:8 a718 = M[(a715,a716)] in
          advance (10)
          #1442
          #instruction: DEC  B
          let:8 a719 = a718 in
          let:16 a720 = addWithCarry(!true,a719,~00) in
          let:8 a721 = (a719 & 0F) in
          let:8 a722 = (~00 & 0F) in
          let:16 a723 = addWithCarry(!true,a721,a722) in
          advance (5)
          #1443
          #instruction: JP   NZ,1439
          if (!is_zero(a720[7:0])) {
            advance (10)
            A := a701;
            B := a720[7:0];
            C := a714;
            D := a707[15:8];
            E := a707[7:0];
            H := a710[15:0][15:8];
            L := a710[15:0][7:0];
            SPH := a717[15:8];
            SPL := a717[7:0];
            FlagS := a720[7:0][7];
            FlagZ := is_zero(a720[7:0]);
            FlagA := a723[7:0][4];
            FlagP := parity(a720[7:0]);
            FlagCY := a710[16];
            jump (1439);
          } else {
            advance (10)
            #1446
            #instruction: RET
            let:8 a724 = a717[15:8] in
            let:8 a725 = a717[7:0] in
            let:16 a726 = (1 + (a724,a725)) in
            let:8 a727 = M[(a724,a725)] in
            let:8 a728 = a726[15:8] in
            let:8 a729 = a726[7:0] in
            let:16 a730 = (1 + (a728,a729)) in
            let:8 a731 = M[(a728,a729)] in
            advance (10)
            A := a701;
            B := a720[7:0];
            C := a714;
            D := a707[15:8];
            E := a707[7:0];
            H := a710[15:0][15:8];
            L := a710[15:0][7:0];
            SPH := a730[15:8];
            SPL := a730[7:0];
            FlagS := a720[7:0][7];
            FlagZ := is_zero(a720[7:0]);
            FlagA := a723[7:0][4];
            FlagP := parity(a720[7:0]);
            FlagCY := a710[16];
            jump ((a731,a727));
          }
        }
      }
    }

003E:

    #003E
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #003F
    #instruction: LD   (20EA),A
    let:8 a4 = a3 in
    M[20EA] := a4;
    advance (13)
    #0042
    #instruction: LD   A,(20E9)
    let:8 a5 = M[20E9] in
    advance (13)
    #0045
    #instruction: AND  A
    let:8 a6 = a5 in
    let:8 a7 = a5 in
    let:8 a8 = (a6 & a7) in
    let:8 a9 = (a6 | a7) in
    advance (4)
    #0046
    #instruction: JP   Z,0082
    if (is_zero(a8)) {
      advance (10)
      #0082
      #instruction: POP  HL
      let:8 a10 = SPH in
      let:8 a11 = SPL in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      let:8 a14 = a12[15:8] in
      let:8 a15 = a12[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      advance (10)
      #0083
      #instruction: POP  DE
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      let:8 a22 = a20[15:8] in
      let:8 a23 = a20[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      advance (10)
      #0084
      #instruction: POP  BC
      let:8 a26 = a24[15:8] in
      let:8 a27 = a24[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      let:8 a30 = a28[15:8] in
      let:8 a31 = a28[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      let:8 a33 = M[(a30,a31)] in
      advance (10)
      #0085
      #instruction: POP  PSW
      let:8 a34 = a32[15:8] in
      let:8 a35 = a32[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      #0086
      #instruction: EI
      enable_interrupts()
      advance (4)
      #0087
      #instruction: RET
      let:8 a42 = a40[15:8] in
      let:8 a43 = a40[7:0] in
      let:16 a44 = (1 + (a42,a43)) in
      let:8 a45 = M[(a42,a43)] in
      let:8 a46 = a44[15:8] in
      let:8 a47 = a44[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      advance (10)
      A := a41;
      B := a33;
      C := a29;
      D := a25;
      E := a21;
      H := a17;
      L := a13;
      SPH := a48[15:8];
      SPL := a48[7:0];
      FlagS := a37[7];
      FlagZ := a37[6];
      FlagA := a37[4];
      FlagP := a37[2];
      FlagCY := a37[0];
      jump ((a49,a45));
    } else {
      advance (10)
      #0049
      #instruction: LD   A,(20EF)
      let:8 a50 = M[20EF] in
      advance (13)
      #004C
      #instruction: AND  A
      let:8 a51 = a50 in
      let:8 a52 = a50 in
      let:8 a53 = (a51 & a52) in
      let:8 a54 = (a51 | a52) in
      advance (4)
      #004D
      #instruction: JP   NZ,006F
      if (!is_zero(a53)) {
        advance (10)
        #006F
        #instruction: CALL 1740
        let:8 a55 = SPH in
        let:8 a56 = SPL in
        let:16 a57 = (-1 + (a55,a56)) in
        M[a57] := 00;
        let:8 a58 = a57[15:8] in
        let:8 a59 = a57[7:0] in
        let:16 a60 = (-1 + (a58,a59)) in
        M[a60] := 72;
        #return-to: 0072
        advance (17)
        #1740
        #instruction: LD   HL,209B
        advance (10)
        #1743
        #instruction: DEC  (HL)
        let:8 a61 = M[209B] in
        let:16 a62 = addWithCarry(!true,a61,~00) in
        let:8 a63 = (a61 & 0F) in
        let:8 a64 = (~00 & 0F) in
        let:16 a65 = addWithCarry(!true,a63,a64) in
        M[209B] := a62[7:0];
        advance (10)
        #1744
        #instruction: CALL Z,176D
        if (is_zero(a62[7:0])) {
          let:8 a66 = a60[15:8] in
          let:8 a67 = a60[7:0] in
          let:16 a68 = (-1 + (a66,a67)) in
          M[a68] := 17;
          let:8 a69 = a68[15:8] in
          let:8 a70 = a68[7:0] in
          let:16 a71 = (-1 + (a69,a70)) in
          M[a71] := 47;
          #return-to: 1747
          advance (17)
          #176D
          #instruction: LD   A,(2098)
          let:8 a72 = M[2098] in
          advance (13)
          #1770
          #instruction: AND  30
          let:8 a73 = a72 in
          let:8 a74 = (30 & a73) in
          let:8 a75 = (30 | a73) in
          advance (7)
          #1772
          #instruction: OUT  05
          let:8 a76 = a74 in
          sound_control(FleetMovement1,a76[0]);
          sound_control(FleetMovement2,a76[1]);
          sound_control(FleetMovement3,a76[2]);
          sound_control(FleetMovement4,a76[3]);
          sound_control(UfoHit,a76[4]);
          advance (10)
          #1774
          #instruction: RET
          let:8 a77 = a71[15:8] in
          let:8 a78 = a71[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          let:8 a81 = a79[15:8] in
          let:8 a82 = a79[7:0] in
          let:16 a83 = (1 + (a81,a82)) in
          let:8 a84 = M[(a81,a82)] in
          advance (10)
          A := a74;
          H := 20;
          L := 9B;
          SPH := a83[15:8];
          SPL := a83[7:0];
          FlagS := a74[7];
          FlagZ := is_zero(a74);
          FlagA := a75[3];
          FlagP := parity(a74);
          FlagCY := false;
          jump ((a84,a80));
        } else {
          advance (11)
          A := a53;
          H := 20;
          L := 9B;
          SPH := a60[15:8];
          SPL := a60[7:0];
          FlagS := a62[7:0][7];
          FlagZ := is_zero(a62[7:0]);
          FlagA := a65[7:0][4];
          FlagP := parity(a62[7:0]);
          FlagCY := false;
          jump (1747);
        }
      } else {
        advance (10)
        #0050
        #instruction: LD   A,(20EB)
        let:8 a85 = M[20EB] in
        advance (13)
        #0053
        #instruction: AND  A
        let:8 a86 = a85 in
        let:8 a87 = a85 in
        let:8 a88 = (a86 & a87) in
        let:8 a89 = (a86 | a87) in
        advance (4)
        #0054
        #instruction: JP   NZ,005D
        if (!is_zero(a88)) {
          advance (10)
          #005D
          #instruction: LD   A,(2093)
          let:8 a90 = M[2093] in
          advance (13)
          #0060
          #instruction: AND  A
          let:8 a91 = a90 in
          let:8 a92 = a90 in
          let:8 a93 = (a91 & a92) in
          let:8 a94 = (a91 | a92) in
          advance (4)
          #0061
          #instruction: JP   NZ,0082
          if (!is_zero(a93)) {
            advance (10)
            #0082
            #instruction: POP  HL
            let:8 a95 = SPH in
            let:8 a96 = SPL in
            let:16 a97 = (1 + (a95,a96)) in
            let:8 a98 = M[(a95,a96)] in
            let:8 a99 = a97[15:8] in
            let:8 a100 = a97[7:0] in
            let:16 a101 = (1 + (a99,a100)) in
            let:8 a102 = M[(a99,a100)] in
            advance (10)
            #0083
            #instruction: POP  DE
            let:8 a103 = a101[15:8] in
            let:8 a104 = a101[7:0] in
            let:16 a105 = (1 + (a103,a104)) in
            let:8 a106 = M[(a103,a104)] in
            let:8 a107 = a105[15:8] in
            let:8 a108 = a105[7:0] in
            let:16 a109 = (1 + (a107,a108)) in
            let:8 a110 = M[(a107,a108)] in
            advance (10)
            #0084
            #instruction: POP  BC
            let:8 a111 = a109[15:8] in
            let:8 a112 = a109[7:0] in
            let:16 a113 = (1 + (a111,a112)) in
            let:8 a114 = M[(a111,a112)] in
            let:8 a115 = a113[15:8] in
            let:8 a116 = a113[7:0] in
            let:16 a117 = (1 + (a115,a116)) in
            let:8 a118 = M[(a115,a116)] in
            advance (10)
            #0085
            #instruction: POP  PSW
            let:8 a119 = a117[15:8] in
            let:8 a120 = a117[7:0] in
            let:16 a121 = (1 + (a119,a120)) in
            let:8 a122 = M[(a119,a120)] in
            let:8 a123 = a121[15:8] in
            let:8 a124 = a121[7:0] in
            let:16 a125 = (1 + (a123,a124)) in
            let:8 a126 = M[(a123,a124)] in
            advance (10)
            #0086
            #instruction: EI
            enable_interrupts()
            advance (4)
            #0087
            #instruction: RET
            let:8 a127 = a125[15:8] in
            let:8 a128 = a125[7:0] in
            let:16 a129 = (1 + (a127,a128)) in
            let:8 a130 = M[(a127,a128)] in
            let:8 a131 = a129[15:8] in
            let:8 a132 = a129[7:0] in
            let:16 a133 = (1 + (a131,a132)) in
            let:8 a134 = M[(a131,a132)] in
            advance (10)
            A := a126;
            B := a118;
            C := a114;
            D := a110;
            E := a106;
            H := a102;
            L := a98;
            SPH := a133[15:8];
            SPL := a133[7:0];
            FlagS := a122[7];
            FlagZ := a122[6];
            FlagA := a122[4];
            FlagP := a122[2];
            FlagCY := a122[0];
            jump ((a134,a130));
          } else {
            advance (10)
            #0064
            #instruction: JP   0765
            advance (10)
            #0765
            #instruction: LD   A,01
            advance (7)
            #0767
            #instruction: LD   (2093),A
            M[2093] := 01;
            advance (13)
            #076A
            #instruction: LD   SP,2400
            advance (10)
            #076D
            #instruction: EI
            enable_interrupts()
            advance (4)
            #076E
            #instruction: CALL 1979
            M[23FF] := 07;
            M[23FE] := 71;
            #return-to: 0771
            advance (17)
            #1979
            #instruction: CALL 19D7
            M[23FD] := 19;
            M[23FC] := 7C;
            #return-to: 197C
            advance (17)
            #19D7
            #instruction: XOR  A
            let:8 a135 = (01 ^ 01) in
            advance (4)
            #19D8
            #instruction: JP   19D3
            advance (10)
            #19D3
            #instruction: LD   (20E9),A
            let:8 a136 = a135 in
            M[20E9] := a136;
            advance (13)
            #19D6
            #instruction: RET
            let:8 a137 = M[23FC] in
            let:8 a138 = M[23FD] in
            advance (10)
            A := a135;
            SPH := 23;
            SPL := FE;
            FlagS := a135[7];
            FlagZ := is_zero(a135);
            FlagA := false;
            FlagP := parity(a135);
            FlagCY := false;
            jump ((a138,a137));
          }
        } else {
          advance (10)
          #0057
          #instruction: CALL 0ABF
          let:8 a139 = SPH in
          let:8 a140 = SPL in
          let:16 a141 = (-1 + (a139,a140)) in
          M[a141] := 00;
          let:8 a142 = a141[15:8] in
          let:8 a143 = a141[7:0] in
          let:16 a144 = (-1 + (a142,a143)) in
          M[a144] := 5A;
          #return-to: 005A
          advance (17)
          #0ABF
          #instruction: LD   A,(20C1)
          let:8 a145 = M[20C1] in
          advance (13)
          #0AC2
          #instruction: RRCA
          let:8 a146 = a145 in
          advance (4)
          #0AC3
          #instruction: JP   CY,0ABB
          if (a146[0]) {
            advance (10)
            #0ABB
            #instruction: POP  HL
            let:8 a147 = a144[15:8] in
            let:8 a148 = a144[7:0] in
            let:16 a149 = (1 + (a147,a148)) in
            let:8 a150 = M[(a147,a148)] in
            let:8 a151 = a149[15:8] in
            let:8 a152 = a149[7:0] in
            let:16 a153 = (1 + (a151,a152)) in
            let:8 a154 = M[(a151,a152)] in
            advance (10)
            #0ABC
            #instruction: JP   0072
            advance (10)
            A := updateBit((a146 >> 01),7,a146[0]);
            H := a154;
            L := a150;
            SPH := a153[15:8];
            SPL := a153[7:0];
            FlagS := a88[7];
            FlagZ := is_zero(a88);
            FlagA := a89[3];
            FlagP := parity(a88);
            FlagCY := a146[0];
            jump (0072);
          } else {
            advance (10)
            #0AC6
            #instruction: RRCA
            let:8 a155 = updateBit((a146 >> 01),7,a146[0]) in
            advance (4)
            #0AC7
            #instruction: JP   CY,1868
            if (a155[0]) {
              advance (10)
              #1868
              #instruction: LD   HL,20C2
              advance (10)
              #186B
              #instruction: INC  (HL)
              let:8 a156 = M[20C2] in
              let:16 a157 = addWithCarry(true,a156,00) in
              let:8 a158 = (a156 & 0F) in
              let:8 a159 = (00 & 0F) in
              let:16 a160 = addWithCarry(true,a158,a159) in
              M[20C2] := a157[7:0];
              advance (10)
              #186C
              #instruction: INC  HL
              advance (5)
              #186D
              #instruction: LD   C,(HL)
              let:8 a161 = M[20C3] in
              advance (7)
              #186E
              #instruction: CALL 01D9
              let:8 a162 = a144[15:8] in
              let:8 a163 = a144[7:0] in
              let:16 a164 = (-1 + (a162,a163)) in
              M[a164] := 18;
              let:8 a165 = a164[15:8] in
              let:8 a166 = a164[7:0] in
              let:16 a167 = (-1 + (a165,a166)) in
              M[a167] := 71;
              #return-to: 1871
              advance (17)
              #01D9
              #instruction: INC  HL
              advance (5)
              #01DA
              #instruction: LD   B,(HL)
              let:8 a168 = M[20C4] in
              advance (7)
              #01DB
              #instruction: INC  HL
              advance (5)
              #01DC
              #instruction: LD   A,C
              let:8 a169 = a161 in
              advance (5)
              #01DD
              #instruction: ADD  (HL)
              let:8 a170 = M[20C5] in
              let:8 a171 = a169 in
              let:16 a172 = addWithCarry(false,a170,a171) in
              let:8 a173 = (a170 & 0F) in
              let:8 a174 = (a171 & 0F) in
              let:16 a175 = addWithCarry(false,a173,a174) in
              advance (7)
              #01DE
              #instruction: LD   (HL),A
              let:8 a176 = a172[7:0] in
              M[20C5] := a176;
              advance (7)
              #01DF
              #instruction: INC  HL
              advance (5)
              #01E0
              #instruction: LD   A,B
              let:8 a177 = a168 in
              advance (5)
              #01E1
              #instruction: ADD  (HL)
              let:8 a178 = M[20C6] in
              let:8 a179 = a177 in
              let:16 a180 = addWithCarry(false,a178,a179) in
              let:8 a181 = (a178 & 0F) in
              let:8 a182 = (a179 & 0F) in
              let:16 a183 = addWithCarry(false,a181,a182) in
              advance (7)
              #01E2
              #instruction: LD   (HL),A
              let:8 a184 = a180[7:0] in
              M[20C6] := a184;
              advance (7)
              #01E3
              #instruction: RET
              let:8 a185 = a167[15:8] in
              let:8 a186 = a167[7:0] in
              let:16 a187 = (1 + (a185,a186)) in
              let:8 a188 = M[(a185,a186)] in
              let:8 a189 = a187[15:8] in
              let:8 a190 = a187[7:0] in
              let:16 a191 = (1 + (a189,a190)) in
              let:8 a192 = M[(a189,a190)] in
              advance (10)
              A := a180[7:0];
              B := a168;
              C := a161;
              H := 20;
              L := C6;
              SPH := a191[15:8];
              SPL := a191[7:0];
              FlagS := a180[7:0][7];
              FlagZ := is_zero(a180[7:0]);
              FlagA := a183[7:0][4];
              FlagP := parity(a180[7:0]);
              FlagCY := a180[15:8][0];
              jump ((a192,a188));
            } else {
              advance (10)
              #0ACA
              #instruction: RRCA
              let:8 a193 = updateBit((a155 >> 01),7,a155[0]) in
              advance (4)
              #0ACB
              #instruction: JP   CY,0AAB
              if (a193[0]) {
                advance (10)
                #0AAB
                #instruction: LD   HL,2050
                advance (10)
                #0AAE
                #instruction: JP   024B
                advance (10)
                #024B
                #instruction: LD   A,(HL)
                let:8 a194 = M[2050] in
                advance (7)
                #024C
                #instruction: CP   FF
                let:8 a195 = a194 in
                let:16 a196 = addWithCarry(!false,a195,~FF) in
                let:8 a197 = (a195 & 0F) in
                let:8 a198 = (~FF & 0F) in
                let:16 a199 = addWithCarry(!false,a197,a198) in
                advance (7)
                #024E
                #instruction: RET  Z
                if (is_zero(a196[7:0])) {
                  let:8 a200 = a144[15:8] in
                  let:8 a201 = a144[7:0] in
                  let:16 a202 = (1 + (a200,a201)) in
                  let:8 a203 = M[(a200,a201)] in
                  let:8 a204 = a202[15:8] in
                  let:8 a205 = a202[7:0] in
                  let:16 a206 = (1 + (a204,a205)) in
                  let:8 a207 = M[(a204,a205)] in
                  advance (11)
                  A := a194;
                  H := 20;
                  L := 50;
                  SPH := a206[15:8];
                  SPL := a206[7:0];
                  FlagS := a196[7:0][7];
                  FlagZ := is_zero(a196[7:0]);
                  FlagA := a199[7:0][4];
                  FlagP := parity(a196[7:0]);
                  FlagCY := !a196[15:8][0];
                  jump ((a207,a203));
                } else {
                  advance (5)
                  #024F
                  #instruction: CP   FE
                  let:8 a208 = a194 in
                  let:16 a209 = addWithCarry(!false,a208,~FE) in
                  let:8 a210 = (a208 & 0F) in
                  let:8 a211 = (~FE & 0F) in
                  let:16 a212 = addWithCarry(!false,a210,a211) in
                  advance (7)
                  #0251
                  #instruction: JP   Z,0281
                  if (is_zero(a209[7:0])) {
                    advance (10)
                    #0281
                    #instruction: LD   DE,0010
                    advance (10)
                    #0284
                    #instruction: ADD  HL,DE
                    let:17 a213 = add17(0010,2050) in
                    advance (10)
                    #0285
                    #instruction: JP   024B
                    advance (10)
                    A := a194;
                    D := 00;
                    E := 10;
                    H := a213[15:0][15:8];
                    L := a213[15:0][7:0];
                    SPH := a144[15:8];
                    SPL := a144[7:0];
                    FlagS := a209[7:0][7];
                    FlagZ := is_zero(a209[7:0]);
                    FlagA := a212[7:0][4];
                    FlagP := parity(a209[7:0]);
                    FlagCY := a213[16];
                    jump (024B);
                  } else {
                    advance (10)
                    #0254
                    #instruction: INC  HL
                    advance (5)
                    #0255
                    #instruction: LD   B,(HL)
                    let:8 a214 = M[2051] in
                    advance (7)
                    #0256
                    #instruction: LD   C,A
                    let:8 a215 = a194 in
                    advance (5)
                    #0257
                    #instruction: OR   B
                    let:8 a216 = a214 in
                    let:8 a217 = a194 in
                    let:8 a218 = (a216 | a217) in
                    advance (4)
                    #0258
                    #instruction: LD   A,C
                    let:8 a219 = a215 in
                    advance (5)
                    #0259
                    #instruction: JP   NZ,0277
                    if (!is_zero(a218)) {
                      advance (10)
                      #0277
                      #instruction: DEC  B
                      let:8 a220 = a214 in
                      let:16 a221 = addWithCarry(!true,a220,~00) in
                      let:8 a222 = (a220 & 0F) in
                      let:8 a223 = (~00 & 0F) in
                      let:16 a224 = addWithCarry(!true,a222,a223) in
                      advance (5)
                      #0278
                      #instruction: INC  B
                      let:8 a225 = a221[7:0] in
                      let:16 a226 = addWithCarry(true,a225,00) in
                      let:8 a227 = (a225 & 0F) in
                      let:8 a228 = (00 & 0F) in
                      let:16 a229 = addWithCarry(true,a227,a228) in
                      advance (5)
                      #0279
                      #instruction: JP   NZ,027D
                      if (!is_zero(a226[7:0])) {
                        advance (10)
                        #027D
                        #instruction: DEC  B
                        let:8 a230 = a226[7:0] in
                        let:16 a231 = addWithCarry(!true,a230,~00) in
                        let:8 a232 = (a230 & 0F) in
                        let:8 a233 = (~00 & 0F) in
                        let:16 a234 = addWithCarry(!true,a232,a233) in
                        advance (5)
                        #027E
                        #instruction: LD   (HL),B
                        let:8 a235 = a231[7:0] in
                        M[2051] := a235;
                        advance (7)
                        #027F
                        #instruction: DEC  HL
                        advance (5)
                        #0280
                        #instruction: LD   (HL),A
                        let:8 a236 = a219 in
                        M[2050] := a236;
                        advance (7)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a237 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a219;
                        B := a231[7:0];
                        C := a215;
                        D := 00;
                        E := 10;
                        H := a237[15:0][15:8];
                        L := a237[15:0][7:0];
                        SPH := a144[15:8];
                        SPL := a144[7:0];
                        FlagS := a231[7:0][7];
                        FlagZ := is_zero(a231[7:0]);
                        FlagA := a234[7:0][4];
                        FlagP := parity(a231[7:0]);
                        FlagCY := a237[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #027C
                        #instruction: DEC  A
                        let:8 a238 = a219 in
                        let:16 a239 = addWithCarry(!true,a238,~00) in
                        let:8 a240 = (a238 & 0F) in
                        let:8 a241 = (~00 & 0F) in
                        let:16 a242 = addWithCarry(!true,a240,a241) in
                        advance (5)
                        #027D
                        #instruction: DEC  B
                        let:8 a243 = a226[7:0] in
                        let:16 a244 = addWithCarry(!true,a243,~00) in
                        let:8 a245 = (a243 & 0F) in
                        let:8 a246 = (~00 & 0F) in
                        let:16 a247 = addWithCarry(!true,a245,a246) in
                        advance (5)
                        #027E
                        #instruction: LD   (HL),B
                        let:8 a248 = a244[7:0] in
                        M[2051] := a248;
                        advance (7)
                        #027F
                        #instruction: DEC  HL
                        advance (5)
                        #0280
                        #instruction: LD   (HL),A
                        let:8 a249 = a239[7:0] in
                        M[2050] := a249;
                        advance (7)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a250 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a239[7:0];
                        B := a244[7:0];
                        C := a215;
                        D := 00;
                        E := 10;
                        H := a250[15:0][15:8];
                        L := a250[15:0][7:0];
                        SPH := a144[15:8];
                        SPL := a144[7:0];
                        FlagS := a244[7:0][7];
                        FlagZ := is_zero(a244[7:0]);
                        FlagA := a247[7:0][4];
                        FlagP := parity(a244[7:0]);
                        FlagCY := a250[16];
                        jump (024B);
                      }
                    } else {
                      advance (10)
                      #025C
                      #instruction: INC  HL
                      advance (5)
                      #025D
                      #instruction: LD   A,(HL)
                      let:8 a251 = M[2052] in
                      advance (7)
                      #025E
                      #instruction: AND  A
                      let:8 a252 = a251 in
                      let:8 a253 = a251 in
                      let:8 a254 = (a252 & a253) in
                      let:8 a255 = (a252 | a253) in
                      advance (4)
                      #025F
                      #instruction: JP   NZ,0288
                      if (!is_zero(a254)) {
                        advance (10)
                        #0288
                        #instruction: DEC  (HL)
                        let:8 a256 = M[2052] in
                        let:16 a257 = addWithCarry(!true,a256,~00) in
                        let:8 a258 = (a256 & 0F) in
                        let:8 a259 = (~00 & 0F) in
                        let:16 a260 = addWithCarry(!true,a258,a259) in
                        M[2052] := a257[7:0];
                        advance (10)
                        #0289
                        #instruction: DEC  HL
                        advance (5)
                        #028A
                        #instruction: DEC  HL
                        advance (5)
                        #028B
                        #instruction: JP   0281
                        advance (10)
                        #0281
                        #instruction: LD   DE,0010
                        advance (10)
                        #0284
                        #instruction: ADD  HL,DE
                        let:17 a261 = add17(0010,2050) in
                        advance (10)
                        #0285
                        #instruction: JP   024B
                        advance (10)
                        A := a254;
                        B := a214;
                        C := a215;
                        D := 00;
                        E := 10;
                        H := a261[15:0][15:8];
                        L := a261[15:0][7:0];
                        SPH := a144[15:8];
                        SPL := a144[7:0];
                        FlagS := a257[7:0][7];
                        FlagZ := is_zero(a257[7:0]);
                        FlagA := a260[7:0][4];
                        FlagP := parity(a257[7:0]);
                        FlagCY := a261[16];
                        jump (024B);
                      } else {
                        advance (10)
                        #0262
                        #instruction: INC  HL
                        advance (5)
                        #0263
                        #instruction: LD   E,(HL)
                        let:8 a262 = M[2053] in
                        advance (7)
                        #0264
                        #instruction: INC  HL
                        advance (5)
                        #0265
                        #instruction: LD   D,(HL)
                        let:8 a263 = M[2054] in
                        advance (7)
                        #0266
                        #instruction: PUSH HL
                        let:8 a264 = a144[15:8] in
                        let:8 a265 = a144[7:0] in
                        let:16 a266 = (-1 + (a264,a265)) in
                        M[a266] := 20;
                        let:8 a267 = a266[15:8] in
                        let:8 a268 = a266[7:0] in
                        let:16 a269 = (-1 + (a267,a268)) in
                        M[a269] := 54;
                        advance (11)
                        #0267
                        #instruction: EX   DE,HL
                        let:8 a270 = a263 in
                        let:8 a271 = a262 in
                        advance (4)
                        #0268
                        #instruction: PUSH HL
                        let:8 a272 = a270 in
                        let:8 a273 = a271 in
                        let:8 a274 = a269[15:8] in
                        let:8 a275 = a269[7:0] in
                        let:16 a276 = (-1 + (a274,a275)) in
                        M[a276] := a272;
                        let:8 a277 = a276[15:8] in
                        let:8 a278 = a276[7:0] in
                        let:16 a279 = (-1 + (a277,a278)) in
                        M[a279] := a273;
                        advance (11)
                        #0269
                        #instruction: LD   HL,026F
                        advance (10)
                        #026C
                        #instruction: EX   (SP),HL
                        let:8 a280 = a279[15:8] in
                        let:8 a281 = a279[7:0] in
                        let:16 a282 = (1 + (a280,a281)) in
                        let:8 a283 = M[(a280,a281)] in
                        let:8 a284 = M[a282] in
                        M[(a280,a281)] := 6F;
                        M[a282] := 02;
                        advance (18)
                        #026D
                        #instruction: PUSH DE
                        let:8 a285 = a279[15:8] in
                        let:8 a286 = a279[7:0] in
                        let:16 a287 = (-1 + (a285,a286)) in
                        M[a287] := 20;
                        let:8 a288 = a287[15:8] in
                        let:8 a289 = a287[7:0] in
                        let:16 a290 = (-1 + (a288,a289)) in
                        M[a290] := 54;
                        advance (11)
                        #026E
                        #instruction: JP   (HL)
                        let:8 a291 = a284 in
                        let:8 a292 = a283 in
                        advance (5)
                        A := a254;
                        B := a214;
                        C := a215;
                        D := 20;
                        E := 54;
                        H := a284;
                        L := a283;
                        SPH := a290[15:8];
                        SPL := a290[7:0];
                        FlagS := a254[7];
                        FlagZ := is_zero(a254);
                        FlagA := a255[3];
                        FlagP := parity(a254);
                        FlagCY := false;
                        jump ((a291,a292));
                      }
                    }
                  }
                }
              } else {
                advance (10)
                #0ACE
                #instruction: RET
                let:8 a293 = a144[15:8] in
                let:8 a294 = a144[7:0] in
                let:16 a295 = (1 + (a293,a294)) in
                let:8 a296 = M[(a293,a294)] in
                let:8 a297 = a295[15:8] in
                let:8 a298 = a295[7:0] in
                let:16 a299 = (1 + (a297,a298)) in
                let:8 a300 = M[(a297,a298)] in
                advance (10)
                A := updateBit((a193 >> 01),7,a193[0]);
                SPH := a299[15:8];
                SPL := a299[7:0];
                FlagS := a88[7];
                FlagZ := is_zero(a88);
                FlagA := a89[3];
                FlagP := parity(a88);
                FlagCY := a193[0];
                jump ((a300,a296));
              }
            }
          }
        }
      }
    }

005A:

    #005A
    #instruction: JP   0082
    advance (10)
    #0082
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0083
    #instruction: POP  DE
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0084
    #instruction: POP  BC
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    let:8 a29 = a27[15:8] in
    let:8 a30 = a27[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    let:8 a32 = M[(a29,a30)] in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:8 a33 = a31[15:8] in
    let:8 a34 = a31[7:0] in
    let:16 a35 = (1 + (a33,a34)) in
    let:8 a36 = M[(a33,a34)] in
    let:8 a37 = a35[15:8] in
    let:8 a38 = a35[7:0] in
    let:16 a39 = (1 + (a37,a38)) in
    let:8 a40 = M[(a37,a38)] in
    advance (10)
    A := a32;
    B := a24;
    C := a20;
    D := a16;
    E := a12;
    H := a8;
    L := a4;
    SPH := a39[15:8];
    SPL := a39[7:0];
    FlagS := a28[7];
    FlagZ := a28[6];
    FlagA := a28[4];
    FlagP := a28[2];
    FlagCY := a28[0];
    jump ((a40,a36));

0072:

    #0072
    #instruction: LD   A,(2032)
    let:8 a1 = M[2032] in
    advance (13)
    #0075
    #instruction: LD   (2080),A
    let:8 a2 = a1 in
    M[2080] := a2;
    advance (13)
    #0078
    #instruction: CALL 0100
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 00;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 7B;
    #return-to: 007B
    advance (17)
    #0100
    #instruction: LD   HL,2002
    advance (10)
    #0103
    #instruction: LD   A,(HL)
    let:8 a9 = M[2002] in
    advance (7)
    #0104
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #0105
    #instruction: JP   NZ,1538
    if (!is_zero(a12)) {
      advance (10)
      #1538
      #instruction: LD   HL,2003
      advance (10)
      #153B
      #instruction: DEC  (HL)
      let:8 a14 = M[2003] in
      let:16 a15 = addWithCarry(!true,a14,~00) in
      let:8 a16 = (a14 & 0F) in
      let:8 a17 = (~00 & 0F) in
      let:16 a18 = addWithCarry(!true,a16,a17) in
      M[2003] := a15[7:0];
      advance (10)
      #153C
      #instruction: RET  NZ
      if (!is_zero(a15[7:0])) {
        let:8 a19 = a8[15:8] in
        let:8 a20 = a8[7:0] in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        let:8 a23 = a21[15:8] in
        let:8 a24 = a21[7:0] in
        let:16 a25 = (1 + (a23,a24)) in
        let:8 a26 = M[(a23,a24)] in
        advance (11)
        A := a12;
        H := 20;
        L := 03;
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a15[7:0][7];
        FlagZ := is_zero(a15[7:0]);
        FlagA := a18[7:0][4];
        FlagP := parity(a15[7:0]);
        FlagCY := false;
        jump ((a26,a22));
      } else {
        advance (5)
        #153D
        #instruction: LD   HL,(2064)
        let:8 a27 = M[2064] in
        let:8 a28 = M[2065] in
        advance (16)
        #1540
        #instruction: LD   B,10
        advance (7)
        #1542
        #instruction: CALL 1424
        let:8 a29 = a8[15:8] in
        let:8 a30 = a8[7:0] in
        let:16 a31 = (-1 + (a29,a30)) in
        M[a31] := 15;
        let:8 a32 = a31[15:8] in
        let:8 a33 = a31[7:0] in
        let:16 a34 = (-1 + (a32,a33)) in
        M[a34] := 45;
        #return-to: 1545
        advance (17)
        #1424
        #instruction: CALL 1474
        let:8 a35 = a34[15:8] in
        let:8 a36 = a34[7:0] in
        let:16 a37 = (-1 + (a35,a36)) in
        M[a37] := 14;
        let:8 a38 = a37[15:8] in
        let:8 a39 = a37[7:0] in
        let:16 a40 = (-1 + (a38,a39)) in
        M[a40] := 27;
        #return-to: 1427
        advance (17)
        #1474
        #instruction: LD   A,L
        let:8 a41 = a27 in
        advance (5)
        #1475
        #instruction: AND  07
        let:8 a42 = a41 in
        let:8 a43 = (07 & a42) in
        let:8 a44 = (07 | a42) in
        advance (7)
        #1477
        #instruction: OUT  02
        let:8 a45 = a43 in
        advance (10)
        #1479
        #instruction: JP   1A47
        advance (10)
        #1A47
        #instruction: PUSH BC
        let:8 a46 = C in
        let:8 a47 = a40[15:8] in
        let:8 a48 = a40[7:0] in
        let:16 a49 = (-1 + (a47,a48)) in
        M[a49] := 10;
        let:8 a50 = a49[15:8] in
        let:8 a51 = a49[7:0] in
        let:16 a52 = (-1 + (a50,a51)) in
        M[a52] := a46;
        advance (11)
        #1A48
        #instruction: LD   B,03
        advance (7)
        #1A4A
        #instruction: LD   A,H
        let:8 a53 = a28 in
        advance (5)
        #1A4B
        #instruction: RAR
        let:8 a54 = a53 in
        advance (4)
        #1A4C
        #instruction: LD   H,A
        let:8 a55 = updateBit((a54 >> 01),7,false) in
        advance (5)
        #1A4D
        #instruction: LD   A,L
        let:8 a56 = a27 in
        advance (5)
        #1A4E
        #instruction: RAR
        let:8 a57 = a56 in
        advance (4)
        #1A4F
        #instruction: LD   L,A
        let:8 a58 = updateBit((a57 >> 01),7,a54[0]) in
        advance (5)
        #1A50
        #instruction: DEC  B
        let:16 a59 = addWithCarry(!true,03,~00) in
        let:8 a60 = (03 & 0F) in
        let:8 a61 = (~00 & 0F) in
        let:16 a62 = addWithCarry(!true,a60,a61) in
        advance (5)
        #1A51
        #instruction: JP   NZ,1A4A
        if (!is_zero(a59[7:0])) {
          advance (10)
          A := updateBit((a57 >> 01),7,a54[0]);
          B := a59[7:0];
          H := a55;
          L := a58;
          SPH := a52[15:8];
          SPL := a52[7:0];
          FlagS := a59[7:0][7];
          FlagZ := is_zero(a59[7:0]);
          FlagA := a62[7:0][4];
          FlagP := parity(a59[7:0]);
          FlagCY := a57[0];
          Shifter_OFF := a45;
          jump (1A4A);
        } else {
          advance (10)
          #1A54
          #instruction: LD   A,H
          let:8 a63 = a55 in
          advance (5)
          #1A55
          #instruction: AND  3F
          let:8 a64 = a63 in
          let:8 a65 = (3F & a64) in
          let:8 a66 = (3F | a64) in
          advance (7)
          #1A57
          #instruction: OR   20
          let:8 a67 = a65 in
          let:8 a68 = (20 | a67) in
          advance (7)
          #1A59
          #instruction: LD   H,A
          let:8 a69 = a68 in
          advance (5)
          #1A5A
          #instruction: POP  BC
          let:8 a70 = a52[15:8] in
          let:8 a71 = a52[7:0] in
          let:16 a72 = (1 + (a70,a71)) in
          let:8 a73 = M[(a70,a71)] in
          let:8 a74 = a72[15:8] in
          let:8 a75 = a72[7:0] in
          let:16 a76 = (1 + (a74,a75)) in
          let:8 a77 = M[(a74,a75)] in
          advance (10)
          #1A5B
          #instruction: RET
          let:8 a78 = a76[15:8] in
          let:8 a79 = a76[7:0] in
          let:16 a80 = (1 + (a78,a79)) in
          let:8 a81 = M[(a78,a79)] in
          let:8 a82 = a80[15:8] in
          let:8 a83 = a80[7:0] in
          let:16 a84 = (1 + (a82,a83)) in
          let:8 a85 = M[(a82,a83)] in
          advance (10)
          A := a68;
          B := a77;
          C := a73;
          H := a69;
          L := a58;
          SPH := a84[15:8];
          SPL := a84[7:0];
          FlagS := a68[7];
          FlagZ := is_zero(a68);
          FlagA := false;
          FlagP := parity(a68);
          FlagCY := false;
          Shifter_OFF := a45;
          jump ((a85,a81));
        }
      }
    } else {
      advance (10)
      #0108
      #instruction: PUSH HL
      let:8 a86 = a8[15:8] in
      let:8 a87 = a8[7:0] in
      let:16 a88 = (-1 + (a86,a87)) in
      M[a88] := 20;
      let:8 a89 = a88[15:8] in
      let:8 a90 = a88[7:0] in
      let:16 a91 = (-1 + (a89,a90)) in
      M[a91] := 02;
      advance (11)
      #0109
      #instruction: LD   A,(2006)
      let:8 a92 = M[2006] in
      advance (13)
      #010C
      #instruction: LD   L,A
      let:8 a93 = a92 in
      advance (5)
      #010D
      #instruction: LD   A,(2067)
      let:8 a94 = M[2067] in
      advance (13)
      #0110
      #instruction: LD   H,A
      let:8 a95 = a94 in
      advance (5)
      #0111
      #instruction: LD   A,(HL)
      let:8 a96 = a95 in
      let:8 a97 = a93 in
      let:8 a98 = M[(a96,a97)] in
      advance (7)
      #0112
      #instruction: AND  A
      let:8 a99 = a98 in
      let:8 a100 = a98 in
      let:8 a101 = (a99 & a100) in
      let:8 a102 = (a99 | a100) in
      advance (4)
      #0113
      #instruction: POP  HL
      let:8 a103 = a91[15:8] in
      let:8 a104 = a91[7:0] in
      let:16 a105 = (1 + (a103,a104)) in
      let:8 a106 = M[(a103,a104)] in
      let:8 a107 = a105[15:8] in
      let:8 a108 = a105[7:0] in
      let:16 a109 = (1 + (a107,a108)) in
      let:8 a110 = M[(a107,a108)] in
      advance (10)
      #0114
      #instruction: JP   Z,0136
      if (is_zero(a101)) {
        advance (10)
        A := a101;
        H := a110;
        L := a106;
        SPH := a109[15:8];
        SPL := a109[7:0];
        FlagS := a101[7];
        FlagZ := is_zero(a101);
        FlagA := a102[3];
        FlagP := parity(a101);
        FlagCY := false;
        jump (0136);
      } else {
        advance (10)
        #0117
        #instruction: INC  HL
        let:8 a111 = a110 in
        let:8 a112 = a106 in
        let:16 a113 = (1 + (a111,a112)) in
        advance (5)
        #0118
        #instruction: INC  HL
        let:8 a114 = a113[15:8] in
        let:8 a115 = a113[7:0] in
        let:16 a116 = (1 + (a114,a115)) in
        advance (5)
        #0119
        #instruction: LD   A,(HL)
        let:8 a117 = a116[15:8] in
        let:8 a118 = a116[7:0] in
        let:8 a119 = M[(a117,a118)] in
        advance (7)
        #011A
        #instruction: INC  HL
        let:8 a120 = a116[15:8] in
        let:8 a121 = a116[7:0] in
        let:16 a122 = (1 + (a120,a121)) in
        advance (5)
        #011B
        #instruction: LD   B,(HL)
        let:8 a123 = a122[15:8] in
        let:8 a124 = a122[7:0] in
        let:8 a125 = M[(a123,a124)] in
        advance (7)
        #011C
        #instruction: AND  FE
        let:8 a126 = a119 in
        let:8 a127 = (FE & a126) in
        let:8 a128 = (FE | a126) in
        advance (7)
        #011E
        #instruction: RLCA
        let:8 a129 = a127 in
        advance (4)
        #011F
        #instruction: RLCA
        let:8 a130 = updateBit((a129 << 01),0,a129[7]) in
        advance (4)
        #0120
        #instruction: RLCA
        let:8 a131 = updateBit((a130 << 01),0,a130[7]) in
        advance (4)
        #0121
        #instruction: LD   E,A
        let:8 a132 = updateBit((a131 << 01),0,a131[7]) in
        advance (5)
        #0122
        #instruction: LD   D,00
        advance (7)
        #0124
        #instruction: LD   HL,1C00
        advance (10)
        #0127
        #instruction: ADD  HL,DE
        let:8 a133 = a132 in
        let:17 a134 = add17((00,a133),1C00) in
        advance (10)
        #0128
        #instruction: EX   DE,HL
        let:8 a135 = a132 in
        let:8 a136 = a134[15:0][15:8] in
        let:8 a137 = a134[15:0][7:0] in
        advance (4)
        #0129
        #instruction: LD   A,B
        let:8 a138 = a125 in
        advance (5)
        #012A
        #instruction: AND  A
        let:8 a139 = a138 in
        let:8 a140 = a138 in
        let:8 a141 = (a139 & a140) in
        let:8 a142 = (a139 | a140) in
        advance (4)
        #012B
        #instruction: CALL NZ,013B
        if (!is_zero(a141)) {
          let:8 a143 = a109[15:8] in
          let:8 a144 = a109[7:0] in
          let:16 a145 = (-1 + (a143,a144)) in
          M[a145] := 01;
          let:8 a146 = a145[15:8] in
          let:8 a147 = a145[7:0] in
          let:16 a148 = (-1 + (a146,a147)) in
          M[a148] := 2E;
          #return-to: 012E
          advance (17)
          #013B
          #instruction: LD   HL,0030
          advance (10)
          #013E
          #instruction: ADD  HL,DE
          let:8 a149 = a136 in
          let:8 a150 = a137 in
          let:17 a151 = add17((a149,a150),0030) in
          advance (10)
          #013F
          #instruction: EX   DE,HL
          let:8 a152 = a136 in
          let:8 a153 = a137 in
          let:8 a154 = a151[15:0][15:8] in
          let:8 a155 = a151[15:0][7:0] in
          advance (4)
          #0140
          #instruction: RET
          let:8 a156 = a148[15:8] in
          let:8 a157 = a148[7:0] in
          let:16 a158 = (1 + (a156,a157)) in
          let:8 a159 = M[(a156,a157)] in
          let:8 a160 = a158[15:8] in
          let:8 a161 = a158[7:0] in
          let:16 a162 = (1 + (a160,a161)) in
          let:8 a163 = M[(a160,a161)] in
          advance (10)
          A := a141;
          B := a125;
          D := a154;
          E := a155;
          H := a152;
          L := a153;
          SPH := a162[15:8];
          SPL := a162[7:0];
          FlagS := a141[7];
          FlagZ := is_zero(a141);
          FlagA := a142[3];
          FlagP := parity(a141);
          FlagCY := a151[16];
          jump ((a163,a159));
        } else {
          advance (11)
          A := a141;
          B := a125;
          D := a136;
          E := a137;
          H := 00;
          L := a135;
          SPH := a109[15:8];
          SPL := a109[7:0];
          FlagS := a141[7];
          FlagZ := is_zero(a141);
          FlagA := a142[3];
          FlagP := parity(a141);
          FlagCY := false;
          jump (012E);
        }
      }
    }

007B:

    #007B
    #instruction: CALL 0248
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7E;
    #return-to: 007E
    advance (17)
    #0248
    #instruction: LD   HL,2010
    advance (10)
    #024B
    #instruction: LD   A,(HL)
    let:8 a7 = M[2010] in
    advance (7)
    #024C
    #instruction: CP   FF
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~FF) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~FF & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #024E
    #instruction: RET  Z
    if (is_zero(a9[7:0])) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      H := 20;
      L := 10;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #024F
      #instruction: CP   FE
      let:8 a21 = a7 in
      let:16 a22 = addWithCarry(!false,a21,~FE) in
      let:8 a23 = (a21 & 0F) in
      let:8 a24 = (~FE & 0F) in
      let:16 a25 = addWithCarry(!false,a23,a24) in
      advance (7)
      #0251
      #instruction: JP   Z,0281
      if (is_zero(a22[7:0])) {
        advance (10)
        #0281
        #instruction: LD   DE,0010
        advance (10)
        #0284
        #instruction: ADD  HL,DE
        let:17 a26 = add17(0010,2010) in
        advance (10)
        #0285
        #instruction: JP   024B
        advance (10)
        A := a7;
        D := 00;
        E := 10;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a22[7:0][7];
        FlagZ := is_zero(a22[7:0]);
        FlagA := a25[7:0][4];
        FlagP := parity(a22[7:0]);
        FlagCY := a26[16];
        jump (024B);
      } else {
        advance (10)
        #0254
        #instruction: INC  HL
        advance (5)
        #0255
        #instruction: LD   B,(HL)
        let:8 a27 = M[2011] in
        advance (7)
        #0256
        #instruction: LD   C,A
        let:8 a28 = a7 in
        advance (5)
        #0257
        #instruction: OR   B
        let:8 a29 = a27 in
        let:8 a30 = a7 in
        let:8 a31 = (a29 | a30) in
        advance (4)
        #0258
        #instruction: LD   A,C
        let:8 a32 = a28 in
        advance (5)
        #0259
        #instruction: JP   NZ,0277
        if (!is_zero(a31)) {
          advance (10)
          #0277
          #instruction: DEC  B
          let:8 a33 = a27 in
          let:16 a34 = addWithCarry(!true,a33,~00) in
          let:8 a35 = (a33 & 0F) in
          let:8 a36 = (~00 & 0F) in
          let:16 a37 = addWithCarry(!true,a35,a36) in
          advance (5)
          #0278
          #instruction: INC  B
          let:8 a38 = a34[7:0] in
          let:16 a39 = addWithCarry(true,a38,00) in
          let:8 a40 = (a38 & 0F) in
          let:8 a41 = (00 & 0F) in
          let:16 a42 = addWithCarry(true,a40,a41) in
          advance (5)
          #0279
          #instruction: JP   NZ,027D
          if (!is_zero(a39[7:0])) {
            advance (10)
            #027D
            #instruction: DEC  B
            let:8 a43 = a39[7:0] in
            let:16 a44 = addWithCarry(!true,a43,~00) in
            let:8 a45 = (a43 & 0F) in
            let:8 a46 = (~00 & 0F) in
            let:16 a47 = addWithCarry(!true,a45,a46) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            let:8 a48 = a44[7:0] in
            M[2011] := a48;
            advance (7)
            #027F
            #instruction: DEC  HL
            advance (5)
            #0280
            #instruction: LD   (HL),A
            let:8 a49 = a32 in
            M[2010] := a49;
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a50 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a32;
            B := a44[7:0];
            C := a28;
            D := 00;
            E := 10;
            H := a50[15:0][15:8];
            L := a50[15:0][7:0];
            SPH := a6[15:8];
            SPL := a6[7:0];
            FlagS := a44[7:0][7];
            FlagZ := is_zero(a44[7:0]);
            FlagA := a47[7:0][4];
            FlagP := parity(a44[7:0]);
            FlagCY := a50[16];
            jump (024B);
          } else {
            advance (10)
            #027C
            #instruction: DEC  A
            let:8 a51 = a32 in
            let:16 a52 = addWithCarry(!true,a51,~00) in
            let:8 a53 = (a51 & 0F) in
            let:8 a54 = (~00 & 0F) in
            let:16 a55 = addWithCarry(!true,a53,a54) in
            advance (5)
            #027D
            #instruction: DEC  B
            let:8 a56 = a39[7:0] in
            let:16 a57 = addWithCarry(!true,a56,~00) in
            let:8 a58 = (a56 & 0F) in
            let:8 a59 = (~00 & 0F) in
            let:16 a60 = addWithCarry(!true,a58,a59) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            let:8 a61 = a57[7:0] in
            M[2011] := a61;
            advance (7)
            #027F
            #instruction: DEC  HL
            advance (5)
            #0280
            #instruction: LD   (HL),A
            let:8 a62 = a52[7:0] in
            M[2010] := a62;
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a63 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a52[7:0];
            B := a57[7:0];
            C := a28;
            D := 00;
            E := 10;
            H := a63[15:0][15:8];
            L := a63[15:0][7:0];
            SPH := a6[15:8];
            SPL := a6[7:0];
            FlagS := a57[7:0][7];
            FlagZ := is_zero(a57[7:0]);
            FlagA := a60[7:0][4];
            FlagP := parity(a57[7:0]);
            FlagCY := a63[16];
            jump (024B);
          }
        } else {
          advance (10)
          #025C
          #instruction: INC  HL
          advance (5)
          #025D
          #instruction: LD   A,(HL)
          let:8 a64 = M[2012] in
          advance (7)
          #025E
          #instruction: AND  A
          let:8 a65 = a64 in
          let:8 a66 = a64 in
          let:8 a67 = (a65 & a66) in
          let:8 a68 = (a65 | a66) in
          advance (4)
          #025F
          #instruction: JP   NZ,0288
          if (!is_zero(a67)) {
            advance (10)
            #0288
            #instruction: DEC  (HL)
            let:8 a69 = M[2012] in
            let:16 a70 = addWithCarry(!true,a69,~00) in
            let:8 a71 = (a69 & 0F) in
            let:8 a72 = (~00 & 0F) in
            let:16 a73 = addWithCarry(!true,a71,a72) in
            M[2012] := a70[7:0];
            advance (10)
            #0289
            #instruction: DEC  HL
            advance (5)
            #028A
            #instruction: DEC  HL
            advance (5)
            #028B
            #instruction: JP   0281
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:17 a74 = add17(0010,2010) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a67;
            B := a27;
            C := a28;
            D := 00;
            E := 10;
            H := a74[15:0][15:8];
            L := a74[15:0][7:0];
            SPH := a6[15:8];
            SPL := a6[7:0];
            FlagS := a70[7:0][7];
            FlagZ := is_zero(a70[7:0]);
            FlagA := a73[7:0][4];
            FlagP := parity(a70[7:0]);
            FlagCY := a74[16];
            jump (024B);
          } else {
            advance (10)
            #0262
            #instruction: INC  HL
            advance (5)
            #0263
            #instruction: LD   E,(HL)
            let:8 a75 = M[2013] in
            advance (7)
            #0264
            #instruction: INC  HL
            advance (5)
            #0265
            #instruction: LD   D,(HL)
            let:8 a76 = M[2014] in
            advance (7)
            #0266
            #instruction: PUSH HL
            let:8 a77 = a6[15:8] in
            let:8 a78 = a6[7:0] in
            let:16 a79 = (-1 + (a77,a78)) in
            M[a79] := 20;
            let:8 a80 = a79[15:8] in
            let:8 a81 = a79[7:0] in
            let:16 a82 = (-1 + (a80,a81)) in
            M[a82] := 14;
            advance (11)
            #0267
            #instruction: EX   DE,HL
            let:8 a83 = a76 in
            let:8 a84 = a75 in
            advance (4)
            #0268
            #instruction: PUSH HL
            let:8 a85 = a83 in
            let:8 a86 = a84 in
            let:8 a87 = a82[15:8] in
            let:8 a88 = a82[7:0] in
            let:16 a89 = (-1 + (a87,a88)) in
            M[a89] := a85;
            let:8 a90 = a89[15:8] in
            let:8 a91 = a89[7:0] in
            let:16 a92 = (-1 + (a90,a91)) in
            M[a92] := a86;
            advance (11)
            #0269
            #instruction: LD   HL,026F
            advance (10)
            #026C
            #instruction: EX   (SP),HL
            let:8 a93 = a92[15:8] in
            let:8 a94 = a92[7:0] in
            let:16 a95 = (1 + (a93,a94)) in
            let:8 a96 = M[(a93,a94)] in
            let:8 a97 = M[a95] in
            M[(a93,a94)] := 6F;
            M[a95] := 02;
            advance (18)
            #026D
            #instruction: PUSH DE
            let:8 a98 = a92[15:8] in
            let:8 a99 = a92[7:0] in
            let:16 a100 = (-1 + (a98,a99)) in
            M[a100] := 20;
            let:8 a101 = a100[15:8] in
            let:8 a102 = a100[7:0] in
            let:16 a103 = (-1 + (a101,a102)) in
            M[a103] := 14;
            advance (11)
            #026E
            #instruction: JP   (HL)
            let:8 a104 = a97 in
            let:8 a105 = a96 in
            advance (5)
            A := a67;
            B := a27;
            C := a28;
            D := 20;
            E := 14;
            H := a97;
            L := a96;
            SPH := a103[15:8];
            SPL := a103[7:0];
            FlagS := a67[7];
            FlagZ := is_zero(a67);
            FlagA := a68[3];
            FlagP := parity(a67);
            FlagCY := false;
            jump ((a104,a105));
          }
        }
      }
    }

007E:

    #007E
    #instruction: CALL 0913
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 81;
    #return-to: 0081
    advance (17)
    #0913
    #instruction: LD   A,(2009)
    let:8 a7 = M[2009] in
    advance (13)
    #0916
    #instruction: CP   78
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~78) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~78 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #0918
    #instruction: RET  NC
    if (!!a9[15:8][0]) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #0919
      #instruction: LD   HL,(2091)
      let:8 a21 = M[2091] in
      let:8 a22 = M[2092] in
      advance (16)
      #091C
      #instruction: LD   A,L
      let:8 a23 = a21 in
      advance (5)
      #091D
      #instruction: OR   H
      let:8 a24 = a22 in
      let:8 a25 = a23 in
      let:8 a26 = (a24 | a25) in
      advance (4)
      #091E
      #instruction: JP   NZ,0929
      if (!is_zero(a26)) {
        advance (10)
        #0929
        #instruction: DEC  HL
        let:8 a27 = a22 in
        let:8 a28 = a21 in
        let:16 a29 = (-1 + (a27,a28)) in
        advance (5)
        #092A
        #instruction: LD   (2091),HL
        let:8 a30 = a29[7:0] in
        M[2091] := a30;
        let:8 a31 = a29[15:8] in
        M[2092] := a31;
        advance (16)
        #092D
        #instruction: RET
        let:8 a32 = a6[15:8] in
        let:8 a33 = a6[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        let:8 a36 = a34[15:8] in
        let:8 a37 = a34[7:0] in
        let:16 a38 = (1 + (a36,a37)) in
        let:8 a39 = M[(a36,a37)] in
        advance (10)
        A := a26;
        H := a29[15:8];
        L := a29[7:0];
        SPH := a38[15:8];
        SPL := a38[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := false;
        FlagP := parity(a26);
        FlagCY := false;
        jump ((a39,a35));
      } else {
        advance (10)
        #0921
        #instruction: LD   HL,0600
        advance (10)
        #0924
        #instruction: LD   A,01
        advance (7)
        #0926
        #instruction: LD   (2083),A
        M[2083] := 01;
        advance (13)
        #0929
        #instruction: DEC  HL
        advance (5)
        #092A
        #instruction: LD   (2091),HL
        M[2091] := FF;
        M[2092] := 05;
        advance (16)
        #092D
        #instruction: RET
        let:8 a40 = a6[15:8] in
        let:8 a41 = a6[7:0] in
        let:16 a42 = (1 + (a40,a41)) in
        let:8 a43 = M[(a40,a41)] in
        let:8 a44 = a42[15:8] in
        let:8 a45 = a42[7:0] in
        let:16 a46 = (1 + (a44,a45)) in
        let:8 a47 = M[(a44,a45)] in
        advance (10)
        A := 01;
        H := 05;
        L := FF;
        SPH := a46[15:8];
        SPL := a46[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := false;
        FlagP := parity(a26);
        FlagCY := false;
        jump ((a47,a43));
      }
    }

0081:

    #0081
    #instruction: NOP
    advance (4)
    #0082
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0083
    #instruction: POP  DE
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0084
    #instruction: POP  BC
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    let:8 a29 = a27[15:8] in
    let:8 a30 = a27[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    let:8 a32 = M[(a29,a30)] in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:8 a33 = a31[15:8] in
    let:8 a34 = a31[7:0] in
    let:16 a35 = (1 + (a33,a34)) in
    let:8 a36 = M[(a33,a34)] in
    let:8 a37 = a35[15:8] in
    let:8 a38 = a35[7:0] in
    let:16 a39 = (1 + (a37,a38)) in
    let:8 a40 = M[(a37,a38)] in
    advance (10)
    A := a32;
    B := a24;
    C := a20;
    D := a16;
    E := a12;
    H := a8;
    L := a4;
    SPH := a39[15:8];
    SPL := a39[7:0];
    FlagS := a28[7];
    FlagZ := a28[6];
    FlagA := a28[4];
    FlagP := a28[2];
    FlagCY := a28[0];
    jump ((a40,a36));

00AB:

    #00AB
    #instruction: CALL 0141
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 00;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := AE;
    #return-to: 00AE
    advance (17)
    #0141
    #instruction: LD   A,(2068)
    let:8 a7 = M[2068] in
    advance (13)
    #0144
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0145
    #instruction: RET  Z
    if (is_zero(a10)) {
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (11)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    } else {
      advance (5)
      #0146
      #instruction: LD   A,(2000)
      let:8 a20 = M[2000] in
      advance (13)
      #0149
      #instruction: AND  A
      let:8 a21 = a20 in
      let:8 a22 = a20 in
      let:8 a23 = (a21 & a22) in
      let:8 a24 = (a21 | a22) in
      advance (4)
      #014A
      #instruction: RET  NZ
      if (!is_zero(a23)) {
        let:8 a25 = a6[15:8] in
        let:8 a26 = a6[7:0] in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        let:8 a29 = a27[15:8] in
        let:8 a30 = a27[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        advance (11)
        A := a23;
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a23[7];
        FlagZ := is_zero(a23);
        FlagA := a24[3];
        FlagP := parity(a23);
        FlagCY := false;
        jump ((a32,a28));
      } else {
        advance (5)
        #014B
        #instruction: LD   A,(2067)
        let:8 a33 = M[2067] in
        advance (13)
        #014E
        #instruction: LD   H,A
        let:8 a34 = a33 in
        advance (5)
        #014F
        #instruction: LD   A,(2006)
        let:8 a35 = M[2006] in
        advance (13)
        #0152
        #instruction: LD   D,02
        advance (7)
        #0154
        #instruction: INC  A
        let:8 a36 = a35 in
        let:16 a37 = addWithCarry(true,a36,00) in
        let:8 a38 = (a36 & 0F) in
        let:8 a39 = (00 & 0F) in
        let:16 a40 = addWithCarry(true,a38,a39) in
        advance (5)
        #0155
        #instruction: CP   37
        let:8 a41 = a37[7:0] in
        let:16 a42 = addWithCarry(!false,a41,~37) in
        let:8 a43 = (a41 & 0F) in
        let:8 a44 = (~37 & 0F) in
        let:16 a45 = addWithCarry(!false,a43,a44) in
        advance (7)
        #0157
        #instruction: CALL Z,01A1
        if (is_zero(a42[7:0])) {
          let:8 a46 = a6[15:8] in
          let:8 a47 = a6[7:0] in
          let:16 a48 = (-1 + (a46,a47)) in
          M[a48] := 01;
          let:8 a49 = a48[15:8] in
          let:8 a50 = a48[7:0] in
          let:16 a51 = (-1 + (a49,a50)) in
          M[a51] := 5A;
          #return-to: 015A
          advance (17)
          #01A1
          #instruction: DEC  D
          let:16 a52 = addWithCarry(!true,02,~00) in
          let:8 a53 = (02 & 0F) in
          let:8 a54 = (~00 & 0F) in
          let:16 a55 = addWithCarry(!true,a53,a54) in
          advance (5)
          #01A2
          #instruction: JP   Z,01CD
          if (is_zero(a52[7:0])) {
            advance (10)
            #01CD
            #instruction: POP  HL
            let:8 a56 = a51[15:8] in
            let:8 a57 = a51[7:0] in
            let:16 a58 = (1 + (a56,a57)) in
            let:8 a59 = M[(a56,a57)] in
            let:8 a60 = a58[15:8] in
            let:8 a61 = a58[7:0] in
            let:16 a62 = (1 + (a60,a61)) in
            let:8 a63 = M[(a60,a61)] in
            advance (10)
            #01CE
            #instruction: RET
            let:8 a64 = a62[15:8] in
            let:8 a65 = a62[7:0] in
            let:16 a66 = (1 + (a64,a65)) in
            let:8 a67 = M[(a64,a65)] in
            let:8 a68 = a66[15:8] in
            let:8 a69 = a66[7:0] in
            let:16 a70 = (1 + (a68,a69)) in
            let:8 a71 = M[(a68,a69)] in
            advance (10)
            A := a37[7:0];
            D := a52[7:0];
            H := a63;
            L := a59;
            SPH := a70[15:8];
            SPL := a70[7:0];
            FlagS := a52[7:0][7];
            FlagZ := is_zero(a52[7:0]);
            FlagA := a55[7:0][4];
            FlagP := parity(a52[7:0]);
            FlagCY := !a42[15:8][0];
            jump ((a71,a67));
          } else {
            advance (10)
            #01A5
            #instruction: LD   HL,2006
            advance (10)
            #01A8
            #instruction: LD   (HL),00
            M[2006] := 00;
            advance (10)
            #01AA
            #instruction: INC  HL
            advance (5)
            #01AB
            #instruction: LD   C,(HL)
            let:8 a72 = M[2007] in
            advance (7)
            #01AC
            #instruction: LD   (HL),00
            M[2007] := 00;
            advance (10)
            #01AE
            #instruction: CALL 01D9
            let:8 a73 = a51[15:8] in
            let:8 a74 = a51[7:0] in
            let:16 a75 = (-1 + (a73,a74)) in
            M[a75] := 01;
            let:8 a76 = a75[15:8] in
            let:8 a77 = a75[7:0] in
            let:16 a78 = (-1 + (a76,a77)) in
            M[a78] := B1;
            #return-to: 01B1
            advance (17)
            #01D9
            #instruction: INC  HL
            advance (5)
            #01DA
            #instruction: LD   B,(HL)
            let:8 a79 = M[2008] in
            advance (7)
            #01DB
            #instruction: INC  HL
            advance (5)
            #01DC
            #instruction: LD   A,C
            let:8 a80 = a72 in
            advance (5)
            #01DD
            #instruction: ADD  (HL)
            let:8 a81 = M[2009] in
            let:8 a82 = a80 in
            let:16 a83 = addWithCarry(false,a81,a82) in
            let:8 a84 = (a81 & 0F) in
            let:8 a85 = (a82 & 0F) in
            let:16 a86 = addWithCarry(false,a84,a85) in
            advance (7)
            #01DE
            #instruction: LD   (HL),A
            let:8 a87 = a83[7:0] in
            M[2009] := a87;
            advance (7)
            #01DF
            #instruction: INC  HL
            advance (5)
            #01E0
            #instruction: LD   A,B
            let:8 a88 = a79 in
            advance (5)
            #01E1
            #instruction: ADD  (HL)
            let:8 a89 = M[200A] in
            let:8 a90 = a88 in
            let:16 a91 = addWithCarry(false,a89,a90) in
            let:8 a92 = (a89 & 0F) in
            let:8 a93 = (a90 & 0F) in
            let:16 a94 = addWithCarry(false,a92,a93) in
            advance (7)
            #01E2
            #instruction: LD   (HL),A
            let:8 a95 = a91[7:0] in
            M[200A] := a95;
            advance (7)
            #01E3
            #instruction: RET
            let:8 a96 = a78[15:8] in
            let:8 a97 = a78[7:0] in
            let:16 a98 = (1 + (a96,a97)) in
            let:8 a99 = M[(a96,a97)] in
            let:8 a100 = a98[15:8] in
            let:8 a101 = a98[7:0] in
            let:16 a102 = (1 + (a100,a101)) in
            let:8 a103 = M[(a100,a101)] in
            advance (10)
            A := a91[7:0];
            B := a79;
            C := a72;
            D := a52[7:0];
            H := 20;
            L := 0A;
            SPH := a102[15:8];
            SPL := a102[7:0];
            FlagS := a91[7:0][7];
            FlagZ := is_zero(a91[7:0]);
            FlagA := a94[7:0][4];
            FlagP := parity(a91[7:0]);
            FlagCY := a91[15:8][0];
            jump ((a103,a99));
          }
        } else {
          advance (11)
          A := a37[7:0];
          D := 02;
          H := a34;
          SPH := a6[15:8];
          SPL := a6[7:0];
          FlagS := a42[7:0][7];
          FlagZ := is_zero(a42[7:0]);
          FlagA := a45[7:0][4];
          FlagP := parity(a42[7:0]);
          FlagCY := !a42[15:8][0];
          jump (015A);
        }
      }
    }

00AE:

    #00AE
    #instruction: JP   0082
    advance (10)
    #0082
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0083
    #instruction: POP  DE
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0084
    #instruction: POP  BC
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0085
    #instruction: POP  PSW
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    let:8 a29 = a27[15:8] in
    let:8 a30 = a27[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    let:8 a32 = M[(a29,a30)] in
    advance (10)
    #0086
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0087
    #instruction: RET
    let:8 a33 = a31[15:8] in
    let:8 a34 = a31[7:0] in
    let:16 a35 = (1 + (a33,a34)) in
    let:8 a36 = M[(a33,a34)] in
    let:8 a37 = a35[15:8] in
    let:8 a38 = a35[7:0] in
    let:16 a39 = (1 + (a37,a38)) in
    let:8 a40 = M[(a37,a38)] in
    advance (10)
    A := a32;
    B := a24;
    C := a20;
    D := a16;
    E := a12;
    H := a8;
    L := a4;
    SPH := a39[15:8];
    SPL := a39[7:0];
    FlagS := a28[7];
    FlagZ := a28[6];
    FlagA := a28[4];
    FlagP := a28[2];
    FlagCY := a28[0];
    jump ((a40,a36));

00B4:

    #00B4
    #instruction: PUSH HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #00B5
    #instruction: LD   A,(HL)
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = M[(a9,a10)] in
    advance (7)
    #00B6
    #instruction: INC  HL
    let:8 a12 = H in
    let:8 a13 = L in
    let:16 a14 = (1 + (a12,a13)) in
    advance (5)
    #00B7
    #instruction: LD   H,(HL)
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:8 a17 = M[(a15,a16)] in
    advance (7)
    #00B8
    #instruction: LD   L,A
    let:8 a18 = a11 in
    advance (5)
    #00B9
    #instruction: LD   (2009),HL
    let:8 a19 = a18 in
    M[2009] := a19;
    let:8 a20 = a17 in
    M[200A] := a20;
    advance (16)
    #00BC
    #instruction: LD   (200B),HL
    let:8 a21 = a18 in
    M[200B] := a21;
    let:8 a22 = a17 in
    M[200C] := a22;
    advance (16)
    #00BF
    #instruction: POP  HL
    let:8 a23 = a8[15:8] in
    let:8 a24 = a8[7:0] in
    let:16 a25 = (1 + (a23,a24)) in
    let:8 a26 = M[(a23,a24)] in
    let:8 a27 = a25[15:8] in
    let:8 a28 = a25[7:0] in
    let:16 a29 = (1 + (a27,a28)) in
    let:8 a30 = M[(a27,a28)] in
    advance (10)
    #00C0
    #instruction: DEC  HL
    let:8 a31 = a30 in
    let:8 a32 = a26 in
    let:16 a33 = (-1 + (a31,a32)) in
    advance (5)
    #00C1
    #instruction: LD   A,(HL)
    let:8 a34 = a33[15:8] in
    let:8 a35 = a33[7:0] in
    let:8 a36 = M[(a34,a35)] in
    advance (7)
    #00C2
    #instruction: CP   03
    let:8 a37 = a36 in
    let:16 a38 = addWithCarry(!false,a37,~03) in
    let:8 a39 = (a37 & 0F) in
    let:8 a40 = (~03 & 0F) in
    let:16 a41 = addWithCarry(!false,a39,a40) in
    advance (7)
    #00C4
    #instruction: JP   NZ,00C8
    if (!is_zero(a38[7:0])) {
      advance (10)
      #00C8
      #instruction: LD   (2008),A
      let:8 a42 = a36 in
      M[2008] := a42;
      advance (13)
      #00CB
      #instruction: CP   FE
      let:8 a43 = a36 in
      let:16 a44 = addWithCarry(!false,a43,~FE) in
      let:8 a45 = (a43 & 0F) in
      let:8 a46 = (~FE & 0F) in
      let:16 a47 = addWithCarry(!false,a45,a46) in
      advance (7)
      #00CD
      #instruction: LD   A,00
      advance (7)
      #00CF
      #instruction: JP   NZ,00D3
      if (!is_zero(a44[7:0])) {
        advance (10)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := 00;
        advance (13)
        #00D6
        #instruction: RET
        let:8 a48 = a29[15:8] in
        let:8 a49 = a29[7:0] in
        let:16 a50 = (1 + (a48,a49)) in
        let:8 a51 = M[(a48,a49)] in
        let:8 a52 = a50[15:8] in
        let:8 a53 = a50[7:0] in
        let:16 a54 = (1 + (a52,a53)) in
        let:8 a55 = M[(a52,a53)] in
        advance (10)
        A := 00;
        H := a33[15:8];
        L := a33[7:0];
        SPH := a54[15:8];
        SPL := a54[7:0];
        FlagS := a44[7:0][7];
        FlagZ := is_zero(a44[7:0]);
        FlagA := a47[7:0][4];
        FlagP := parity(a44[7:0]);
        FlagCY := !a44[15:8][0];
        jump ((a55,a51));
      } else {
        advance (10)
        #00D2
        #instruction: INC  A
        let:16 a56 = addWithCarry(true,00,00) in
        let:8 a57 = (00 & 0F) in
        let:8 a58 = (00 & 0F) in
        let:16 a59 = addWithCarry(true,a57,a58) in
        advance (5)
        #00D3
        #instruction: LD   (200D),A
        let:8 a60 = a56[7:0] in
        M[200D] := a60;
        advance (13)
        #00D6
        #instruction: RET
        let:8 a61 = a29[15:8] in
        let:8 a62 = a29[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        let:8 a65 = a63[15:8] in
        let:8 a66 = a63[7:0] in
        let:16 a67 = (1 + (a65,a66)) in
        let:8 a68 = M[(a65,a66)] in
        advance (10)
        A := a56[7:0];
        H := a33[15:8];
        L := a33[7:0];
        SPH := a67[15:8];
        SPL := a67[7:0];
        FlagS := a56[7:0][7];
        FlagZ := is_zero(a56[7:0]);
        FlagA := a59[7:0][4];
        FlagP := parity(a56[7:0]);
        FlagCY := !a44[15:8][0];
        jump ((a68,a64));
      }
    } else {
      advance (10)
      #00C7
      #instruction: DEC  A
      let:8 a69 = a36 in
      let:16 a70 = addWithCarry(!true,a69,~00) in
      let:8 a71 = (a69 & 0F) in
      let:8 a72 = (~00 & 0F) in
      let:16 a73 = addWithCarry(!true,a71,a72) in
      advance (5)
      #00C8
      #instruction: LD   (2008),A
      let:8 a74 = a70[7:0] in
      M[2008] := a74;
      advance (13)
      #00CB
      #instruction: CP   FE
      let:8 a75 = a70[7:0] in
      let:16 a76 = addWithCarry(!false,a75,~FE) in
      let:8 a77 = (a75 & 0F) in
      let:8 a78 = (~FE & 0F) in
      let:16 a79 = addWithCarry(!false,a77,a78) in
      advance (7)
      #00CD
      #instruction: LD   A,00
      advance (7)
      #00CF
      #instruction: JP   NZ,00D3
      if (!is_zero(a76[7:0])) {
        advance (10)
        #00D3
        #instruction: LD   (200D),A
        M[200D] := 00;
        advance (13)
        #00D6
        #instruction: RET
        let:8 a80 = a29[15:8] in
        let:8 a81 = a29[7:0] in
        let:16 a82 = (1 + (a80,a81)) in
        let:8 a83 = M[(a80,a81)] in
        let:8 a84 = a82[15:8] in
        let:8 a85 = a82[7:0] in
        let:16 a86 = (1 + (a84,a85)) in
        let:8 a87 = M[(a84,a85)] in
        advance (10)
        A := 00;
        H := a33[15:8];
        L := a33[7:0];
        SPH := a86[15:8];
        SPL := a86[7:0];
        FlagS := a76[7:0][7];
        FlagZ := is_zero(a76[7:0]);
        FlagA := a79[7:0][4];
        FlagP := parity(a76[7:0]);
        FlagCY := !a76[15:8][0];
        jump ((a87,a83));
      } else {
        advance (10)
        #00D2
        #instruction: INC  A
        let:16 a88 = addWithCarry(true,00,00) in
        let:8 a89 = (00 & 0F) in
        let:8 a90 = (00 & 0F) in
        let:16 a91 = addWithCarry(true,a89,a90) in
        advance (5)
        #00D3
        #instruction: LD   (200D),A
        let:8 a92 = a88[7:0] in
        M[200D] := a92;
        advance (13)
        #00D6
        #instruction: RET
        let:8 a93 = a29[15:8] in
        let:8 a94 = a29[7:0] in
        let:16 a95 = (1 + (a93,a94)) in
        let:8 a96 = M[(a93,a94)] in
        let:8 a97 = a95[15:8] in
        let:8 a98 = a95[7:0] in
        let:16 a99 = (1 + (a97,a98)) in
        let:8 a100 = M[(a97,a98)] in
        advance (10)
        A := a88[7:0];
        H := a33[15:8];
        L := a33[7:0];
        SPH := a99[15:8];
        SPL := a99[7:0];
        FlagS := a88[7:0][7];
        FlagZ := is_zero(a88[7:0]);
        FlagA := a91[7:0][4];
        FlagP := parity(a88[7:0]);
        FlagCY := !a76[15:8][0];
        jump ((a100,a96));
      }
    }

012E:

    #012E
    #instruction: LD   HL,(200B)
    let:8 a1 = M[200B] in
    let:8 a2 = M[200C] in
    advance (16)
    #0131
    #instruction: LD   B,10
    advance (7)
    #0133
    #instruction: CALL 15D3
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 01;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 36;
    #return-to: 0136
    advance (17)
    #15D3
    #instruction: CALL 1474
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := 15;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a15 = a1 in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a16 = a15 in
    let:8 a17 = (07 & a16) in
    let:8 a18 = (07 | a16) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a19 = a17 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a20 = C in
    let:8 a21 = a14[15:8] in
    let:8 a22 = a14[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := 10;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a27 = a2 in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a28 = a27 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a29 = updateBit((a28 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a30 = a1 in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a31 = a30 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a32 = updateBit((a31 >> 01),7,a28[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a33 = addWithCarry(!true,03,~00) in
    let:8 a34 = (03 & 0F) in
    let:8 a35 = (~00 & 0F) in
    let:16 a36 = addWithCarry(!true,a34,a35) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a33[7:0])) {
      advance (10)
      A := updateBit((a31 >> 01),7,a28[0]);
      B := a33[7:0];
      H := a29;
      L := a32;
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a33[7:0][7];
      FlagZ := is_zero(a33[7:0]);
      FlagA := a36[7:0][4];
      FlagP := parity(a33[7:0]);
      FlagCY := a31[0];
      Shifter_OFF := a19;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a37 = a29 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a38 = a37 in
      let:8 a39 = (3F & a38) in
      let:8 a40 = (3F | a38) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a41 = a39 in
      let:8 a42 = (20 | a41) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a43 = a42 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a44 = a26[15:8] in
      let:8 a45 = a26[7:0] in
      let:16 a46 = (1 + (a44,a45)) in
      let:8 a47 = M[(a44,a45)] in
      let:8 a48 = a46[15:8] in
      let:8 a49 = a46[7:0] in
      let:16 a50 = (1 + (a48,a49)) in
      let:8 a51 = M[(a48,a49)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a52 = a50[15:8] in
      let:8 a53 = a50[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      advance (10)
      A := a42;
      B := a51;
      C := a47;
      H := a43;
      L := a32;
      SPH := a58[15:8];
      SPL := a58[7:0];
      FlagS := a42[7];
      FlagZ := is_zero(a42);
      FlagA := false;
      FlagP := parity(a42);
      FlagCY := false;
      Shifter_OFF := a19;
      jump ((a59,a55));
    }

0136:

    #0136
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0137
    #instruction: LD   (2000),A
    let:8 a4 = a3 in
    M[2000] := a4;
    advance (13)
    #013A
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a3;
    SPH := a11[15:8];
    SPL := a11[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a12,a8));

015A:

    #015A
    #instruction: LD   L,A
    let:8 a1 = A in
    advance (5)
    #015B
    #instruction: LD   B,(HL)
    let:8 a2 = H in
    let:8 a3 = a1 in
    let:8 a4 = M[(a2,a3)] in
    advance (7)
    #015C
    #instruction: DEC  B
    let:8 a5 = a4 in
    let:16 a6 = addWithCarry(!true,a5,~00) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~00 & 0F) in
    let:16 a9 = addWithCarry(!true,a7,a8) in
    advance (5)
    #015D
    #instruction: JP   NZ,0154
    if (!is_zero(a6[7:0])) {
      advance (10)
      #0154
      #instruction: INC  A
      let:8 a10 = A in
      let:16 a11 = addWithCarry(true,a10,00) in
      let:8 a12 = (a10 & 0F) in
      let:8 a13 = (00 & 0F) in
      let:16 a14 = addWithCarry(true,a12,a13) in
      advance (5)
      #0155
      #instruction: CP   37
      let:8 a15 = a11[7:0] in
      let:16 a16 = addWithCarry(!false,a15,~37) in
      let:8 a17 = (a15 & 0F) in
      let:8 a18 = (~37 & 0F) in
      let:16 a19 = addWithCarry(!false,a17,a18) in
      advance (7)
      #0157
      #instruction: CALL Z,01A1
      if (is_zero(a16[7:0])) {
        let:8 a20 = SPH in
        let:8 a21 = SPL in
        let:16 a22 = (-1 + (a20,a21)) in
        M[a22] := 01;
        let:8 a23 = a22[15:8] in
        let:8 a24 = a22[7:0] in
        let:16 a25 = (-1 + (a23,a24)) in
        M[a25] := 5A;
        #return-to: 015A
        advance (17)
        #01A1
        #instruction: DEC  D
        let:8 a26 = D in
        let:16 a27 = addWithCarry(!true,a26,~00) in
        let:8 a28 = (a26 & 0F) in
        let:8 a29 = (~00 & 0F) in
        let:16 a30 = addWithCarry(!true,a28,a29) in
        advance (5)
        #01A2
        #instruction: JP   Z,01CD
        if (is_zero(a27[7:0])) {
          advance (10)
          #01CD
          #instruction: POP  HL
          let:8 a31 = a25[15:8] in
          let:8 a32 = a25[7:0] in
          let:16 a33 = (1 + (a31,a32)) in
          let:8 a34 = M[(a31,a32)] in
          let:8 a35 = a33[15:8] in
          let:8 a36 = a33[7:0] in
          let:16 a37 = (1 + (a35,a36)) in
          let:8 a38 = M[(a35,a36)] in
          advance (10)
          #01CE
          #instruction: RET
          let:8 a39 = a37[15:8] in
          let:8 a40 = a37[7:0] in
          let:16 a41 = (1 + (a39,a40)) in
          let:8 a42 = M[(a39,a40)] in
          let:8 a43 = a41[15:8] in
          let:8 a44 = a41[7:0] in
          let:16 a45 = (1 + (a43,a44)) in
          let:8 a46 = M[(a43,a44)] in
          advance (10)
          A := a11[7:0];
          B := a6[7:0];
          D := a27[7:0];
          H := a38;
          L := a34;
          SPH := a45[15:8];
          SPL := a45[7:0];
          FlagS := a27[7:0][7];
          FlagZ := is_zero(a27[7:0]);
          FlagA := a30[7:0][4];
          FlagP := parity(a27[7:0]);
          FlagCY := !a16[15:8][0];
          jump ((a46,a42));
        } else {
          advance (10)
          #01A5
          #instruction: LD   HL,2006
          advance (10)
          #01A8
          #instruction: LD   (HL),00
          M[2006] := 00;
          advance (10)
          #01AA
          #instruction: INC  HL
          advance (5)
          #01AB
          #instruction: LD   C,(HL)
          let:8 a47 = M[2007] in
          advance (7)
          #01AC
          #instruction: LD   (HL),00
          M[2007] := 00;
          advance (10)
          #01AE
          #instruction: CALL 01D9
          let:8 a48 = a25[15:8] in
          let:8 a49 = a25[7:0] in
          let:16 a50 = (-1 + (a48,a49)) in
          M[a50] := 01;
          let:8 a51 = a50[15:8] in
          let:8 a52 = a50[7:0] in
          let:16 a53 = (-1 + (a51,a52)) in
          M[a53] := B1;
          #return-to: 01B1
          advance (17)
          #01D9
          #instruction: INC  HL
          advance (5)
          #01DA
          #instruction: LD   B,(HL)
          let:8 a54 = M[2008] in
          advance (7)
          #01DB
          #instruction: INC  HL
          advance (5)
          #01DC
          #instruction: LD   A,C
          let:8 a55 = a47 in
          advance (5)
          #01DD
          #instruction: ADD  (HL)
          let:8 a56 = M[2009] in
          let:8 a57 = a55 in
          let:16 a58 = addWithCarry(false,a56,a57) in
          let:8 a59 = (a56 & 0F) in
          let:8 a60 = (a57 & 0F) in
          let:16 a61 = addWithCarry(false,a59,a60) in
          advance (7)
          #01DE
          #instruction: LD   (HL),A
          let:8 a62 = a58[7:0] in
          M[2009] := a62;
          advance (7)
          #01DF
          #instruction: INC  HL
          advance (5)
          #01E0
          #instruction: LD   A,B
          let:8 a63 = a54 in
          advance (5)
          #01E1
          #instruction: ADD  (HL)
          let:8 a64 = M[200A] in
          let:8 a65 = a63 in
          let:16 a66 = addWithCarry(false,a64,a65) in
          let:8 a67 = (a64 & 0F) in
          let:8 a68 = (a65 & 0F) in
          let:16 a69 = addWithCarry(false,a67,a68) in
          advance (7)
          #01E2
          #instruction: LD   (HL),A
          let:8 a70 = a66[7:0] in
          M[200A] := a70;
          advance (7)
          #01E3
          #instruction: RET
          let:8 a71 = a53[15:8] in
          let:8 a72 = a53[7:0] in
          let:16 a73 = (1 + (a71,a72)) in
          let:8 a74 = M[(a71,a72)] in
          let:8 a75 = a73[15:8] in
          let:8 a76 = a73[7:0] in
          let:16 a77 = (1 + (a75,a76)) in
          let:8 a78 = M[(a75,a76)] in
          advance (10)
          A := a66[7:0];
          B := a54;
          C := a47;
          D := a27[7:0];
          H := 20;
          L := 0A;
          SPH := a77[15:8];
          SPL := a77[7:0];
          FlagS := a66[7:0][7];
          FlagZ := is_zero(a66[7:0]);
          FlagA := a69[7:0][4];
          FlagP := parity(a66[7:0]);
          FlagCY := a66[15:8][0];
          jump ((a78,a74));
        }
      } else {
        advance (11)
        A := a11[7:0];
        B := a6[7:0];
        L := a1;
        FlagS := a16[7:0][7];
        FlagZ := is_zero(a16[7:0]);
        FlagA := a19[7:0][4];
        FlagP := parity(a16[7:0]);
        FlagCY := !a16[15:8][0];
        jump (015A);
      }
    } else {
      advance (10)
      #0160
      #instruction: LD   (2006),A
      let:8 a79 = A in
      M[2006] := a79;
      advance (13)
      #0163
      #instruction: CALL 017A
      let:8 a80 = SPH in
      let:8 a81 = SPL in
      let:16 a82 = (-1 + (a80,a81)) in
      M[a82] := 01;
      let:8 a83 = a82[15:8] in
      let:8 a84 = a82[7:0] in
      let:16 a85 = (-1 + (a83,a84)) in
      M[a85] := 66;
      #return-to: 0166
      advance (17)
      #017A
      #instruction: LD   D,00
      advance (7)
      #017C
      #instruction: LD   A,L
      let:8 a86 = a1 in
      advance (5)
      #017D
      #instruction: LD   HL,2009
      advance (10)
      #0180
      #instruction: LD   B,(HL)
      let:8 a87 = M[2009] in
      advance (7)
      #0181
      #instruction: INC  HL
      advance (5)
      #0182
      #instruction: LD   C,(HL)
      let:8 a88 = M[200A] in
      advance (7)
      #0183
      #instruction: CP   0B
      let:8 a89 = a86 in
      let:16 a90 = addWithCarry(!false,a89,~0B) in
      let:8 a91 = (a89 & 0F) in
      let:8 a92 = (~0B & 0F) in
      let:16 a93 = addWithCarry(!false,a91,a92) in
      advance (7)
      #0185
      #instruction: JP   MI,0194
      if (a90[7:0][7]) {
        advance (10)
        #0194
        #instruction: LD   L,B
        let:8 a94 = a87 in
        advance (5)
        #0195
        #instruction: AND  A
        let:8 a95 = a86 in
        let:8 a96 = a86 in
        let:8 a97 = (a95 & a96) in
        let:8 a98 = (a95 | a96) in
        advance (4)
        #0196
        #instruction: RET  Z
        if (is_zero(a97)) {
          let:8 a99 = a85[15:8] in
          let:8 a100 = a85[7:0] in
          let:16 a101 = (1 + (a99,a100)) in
          let:8 a102 = M[(a99,a100)] in
          let:8 a103 = a101[15:8] in
          let:8 a104 = a101[7:0] in
          let:16 a105 = (1 + (a103,a104)) in
          let:8 a106 = M[(a103,a104)] in
          advance (11)
          A := a97;
          B := a87;
          C := a88;
          D := 00;
          H := 20;
          L := a94;
          SPH := a105[15:8];
          SPL := a105[7:0];
          FlagS := a97[7];
          FlagZ := is_zero(a97);
          FlagA := a98[3];
          FlagP := parity(a97);
          FlagCY := false;
          jump ((a106,a102));
        } else {
          advance (5)
          #0197
          #instruction: LD   E,A
          let:8 a107 = a97 in
          advance (5)
          #0198
          #instruction: LD   A,C
          let:8 a108 = a88 in
          advance (5)
          #0199
          #instruction: ADD  10
          let:8 a109 = a108 in
          let:16 a110 = addWithCarry(false,10,a109) in
          let:8 a111 = (10 & 0F) in
          let:8 a112 = (a109 & 0F) in
          let:16 a113 = addWithCarry(false,a111,a112) in
          advance (7)
          #019B
          #instruction: LD   C,A
          let:8 a114 = a110[7:0] in
          advance (5)
          #019C
          #instruction: LD   A,E
          let:8 a115 = a107 in
          advance (5)
          #019D
          #instruction: DEC  A
          let:8 a116 = a115 in
          let:16 a117 = addWithCarry(!true,a116,~00) in
          let:8 a118 = (a116 & 0F) in
          let:8 a119 = (~00 & 0F) in
          let:16 a120 = addWithCarry(!true,a118,a119) in
          advance (5)
          #019E
          #instruction: JP   0195
          advance (10)
          A := a117[7:0];
          B := a87;
          C := a114;
          D := 00;
          E := a107;
          H := 20;
          L := a94;
          SPH := a85[15:8];
          SPL := a85[7:0];
          FlagS := a117[7:0][7];
          FlagZ := is_zero(a117[7:0]);
          FlagA := a120[7:0][4];
          FlagP := parity(a117[7:0]);
          FlagCY := a110[15:8][0];
          jump (0195);
        }
      } else {
        advance (10)
        #0188
        #instruction: SBC  0B
        let:8 a121 = a86 in
        let:16 a122 = addWithCarry(!!a90[15:8][0],a121,~0B) in
        let:8 a123 = (a121 & 0F) in
        let:8 a124 = (~0B & 0F) in
        let:16 a125 = addWithCarry(!!a90[15:8][0],a123,a124) in
        advance (7)
        #018A
        #instruction: LD   E,A
        let:8 a126 = a122[7:0] in
        advance (5)
        #018B
        #instruction: LD   A,B
        let:8 a127 = a87 in
        advance (5)
        #018C
        #instruction: ADD  10
        let:8 a128 = a127 in
        let:16 a129 = addWithCarry(false,10,a128) in
        let:8 a130 = (10 & 0F) in
        let:8 a131 = (a128 & 0F) in
        let:16 a132 = addWithCarry(false,a130,a131) in
        advance (7)
        #018E
        #instruction: LD   B,A
        let:8 a133 = a129[7:0] in
        advance (5)
        #018F
        #instruction: LD   A,E
        let:8 a134 = a126 in
        advance (5)
        #0190
        #instruction: INC  D
        let:16 a135 = addWithCarry(true,00,00) in
        let:8 a136 = (00 & 0F) in
        let:8 a137 = (00 & 0F) in
        let:16 a138 = addWithCarry(true,a136,a137) in
        advance (5)
        #0191
        #instruction: JP   0183
        advance (10)
        A := a134;
        B := a133;
        C := a88;
        D := a135[7:0];
        E := a126;
        H := 20;
        L := 0A;
        SPH := a85[15:8];
        SPL := a85[7:0];
        FlagS := a135[7:0][7];
        FlagZ := is_zero(a135[7:0]);
        FlagA := a138[7:0][4];
        FlagP := parity(a135[7:0]);
        FlagCY := a129[15:8][0];
        jump (0183);
      }
    }

0166:

    #0166
    #instruction: LD   H,C
    let:8 a1 = C in
    advance (5)
    #0167
    #instruction: LD   (200B),HL
    let:8 a2 = L in
    M[200B] := a2;
    let:8 a3 = a1 in
    M[200C] := a3;
    advance (16)
    #016A
    #instruction: LD   A,L
    let:8 a4 = L in
    advance (5)
    #016B
    #instruction: CP   28
    let:8 a5 = a4 in
    let:16 a6 = addWithCarry(!false,a5,~28) in
    let:8 a7 = (a5 & 0F) in
    let:8 a8 = (~28 & 0F) in
    let:16 a9 = addWithCarry(!false,a7,a8) in
    advance (7)
    #016D
    #instruction: JP   CY,1971
    if (!a6[15:8][0]) {
      advance (10)
      #1971
      #instruction: LD   A,01
      advance (7)
      #1973
      #instruction: LD   (206D),A
      M[206D] := 01;
      advance (13)
      #1976
      #instruction: JP   16E6
      advance (10)
      #16E6
      #instruction: LD   SP,2400
      advance (10)
      #16E9
      #instruction: EI
      enable_interrupts()
      advance (4)
      #16EA
      #instruction: XOR  A
      let:8 a10 = (01 ^ 01) in
      advance (4)
      #16EB
      #instruction: LD   (2015),A
      let:8 a11 = a10 in
      M[2015] := a11;
      advance (13)
      #16EE
      #instruction: CALL 14D8
      M[23FF] := 16;
      M[23FE] := F1;
      #return-to: 16F1
      advance (17)
      #14D8
      #instruction: LD   A,(2025)
      let:8 a12 = M[2025] in
      advance (13)
      #14DB
      #instruction: CP   05
      let:8 a13 = a12 in
      let:16 a14 = addWithCarry(!false,a13,~05) in
      let:8 a15 = (a13 & 0F) in
      let:8 a16 = (~05 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #14DD
      #instruction: RET  Z
      if (is_zero(a14[7:0])) {
        let:8 a18 = M[23FE] in
        let:8 a19 = M[23FF] in
        advance (11)
        A := a12;
        H := a1;
        SPH := 24;
        SPL := 00;
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a19,a18));
      } else {
        advance (5)
        #14DE
        #instruction: CP   02
        let:8 a20 = a12 in
        let:16 a21 = addWithCarry(!false,a20,~02) in
        let:8 a22 = (a20 & 0F) in
        let:8 a23 = (~02 & 0F) in
        let:16 a24 = addWithCarry(!false,a22,a23) in
        advance (7)
        #14E0
        #instruction: RET  NZ
        if (!is_zero(a21[7:0])) {
          let:8 a25 = M[23FE] in
          let:8 a26 = M[23FF] in
          advance (11)
          A := a12;
          H := a1;
          SPH := 24;
          SPL := 00;
          FlagS := a21[7:0][7];
          FlagZ := is_zero(a21[7:0]);
          FlagA := a24[7:0][4];
          FlagP := parity(a21[7:0]);
          FlagCY := !a21[15:8][0];
          jump ((a26,a25));
        } else {
          advance (5)
          #14E1
          #instruction: LD   A,(2029)
          let:8 a27 = M[2029] in
          advance (13)
          #14E4
          #instruction: CP   D8
          let:8 a28 = a27 in
          let:16 a29 = addWithCarry(!false,a28,~D8) in
          let:8 a30 = (a28 & 0F) in
          let:8 a31 = (~D8 & 0F) in
          let:16 a32 = addWithCarry(!false,a30,a31) in
          advance (7)
          #14E6
          #instruction: LD   B,A
          let:8 a33 = a27 in
          advance (5)
          #14E7
          #instruction: JP   NC,1530
          if (!!a29[15:8][0]) {
            advance (10)
            #1530
            #instruction: LD   A,03
            advance (7)
            #1532
            #instruction: LD   (2025),A
            M[2025] := 03;
            advance (13)
            #1535
            #instruction: JP   154A
            advance (10)
            #154A
            #instruction: XOR  A
            let:8 a34 = (03 ^ 03) in
            advance (4)
            #154B
            #instruction: LD   (2002),A
            let:8 a35 = a34 in
            M[2002] := a35;
            advance (13)
            #154E
            #instruction: LD   B,F7
            advance (7)
            #1550
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            let:8 a36 = M[2094] in
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a37 = a36 in
            let:8 a38 = (F7 & a37) in
            let:8 a39 = (F7 | a37) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            let:8 a40 = a38 in
            M[2094] := a40;
            advance (13)
            #19E3
            #instruction: OUT  03
            let:8 a41 = a38 in
            sound_control(Ufo,a41[0]);
            sound_control(Shot,a41[1]);
            sound_control(PlayerDie,a41[2]);
            sound_control(InvaderDie,a41[3]);
            sound_control(ExtraLife,a41[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:8 a42 = M[23FE] in
            let:8 a43 = M[23FF] in
            advance (10)
            A := a38;
            B := F7;
            H := a1;
            SPH := 24;
            SPL := 00;
            FlagS := a38[7];
            FlagZ := is_zero(a38);
            FlagA := a39[3];
            FlagP := parity(a38);
            FlagCY := false;
            jump ((a43,a42));
          } else {
            advance (10)
            #14EA
            #instruction: LD   A,(2002)
            let:8 a44 = M[2002] in
            advance (13)
            #14ED
            #instruction: AND  A
            let:8 a45 = a44 in
            let:8 a46 = a44 in
            let:8 a47 = (a45 & a46) in
            let:8 a48 = (a45 | a46) in
            advance (4)
            #14EE
            #instruction: RET  Z
            if (is_zero(a47)) {
              let:8 a49 = M[23FE] in
              let:8 a50 = M[23FF] in
              advance (11)
              A := a47;
              B := a33;
              H := a1;
              SPH := 24;
              SPL := 00;
              FlagS := a47[7];
              FlagZ := is_zero(a47);
              FlagA := a48[3];
              FlagP := parity(a47);
              FlagCY := false;
              jump ((a50,a49));
            } else {
              advance (5)
              #14EF
              #instruction: LD   A,B
              let:8 a51 = a33 in
              advance (5)
              #14F0
              #instruction: CP   CE
              let:8 a52 = a51 in
              let:16 a53 = addWithCarry(!false,a52,~CE) in
              let:8 a54 = (a52 & 0F) in
              let:8 a55 = (~CE & 0F) in
              let:16 a56 = addWithCarry(!false,a54,a55) in
              advance (7)
              #14F2
              #instruction: JP   NC,1579
              if (!!a53[15:8][0]) {
                advance (10)
                #1579
                #instruction: LD   A,01
                advance (7)
                #157B
                #instruction: LD   (2085),A
                M[2085] := 01;
                advance (13)
                #157E
                #instruction: JP   1545
                advance (10)
                A := 01;
                B := a33;
                H := a1;
                SPH := 23;
                SPL := FE;
                FlagS := a53[7:0][7];
                FlagZ := is_zero(a53[7:0]);
                FlagA := a56[7:0][4];
                FlagP := parity(a53[7:0]);
                FlagCY := !a53[15:8][0];
                jump (1545);
              } else {
                advance (10)
                #14F5
                #instruction: ADD  06
                let:8 a57 = a51 in
                let:16 a58 = addWithCarry(false,06,a57) in
                let:8 a59 = (06 & 0F) in
                let:8 a60 = (a57 & 0F) in
                let:16 a61 = addWithCarry(false,a59,a60) in
                advance (7)
                #14F7
                #instruction: LD   B,A
                let:8 a62 = a58[7:0] in
                advance (5)
                #14F8
                #instruction: LD   A,(2009)
                let:8 a63 = M[2009] in
                advance (13)
                #14FB
                #instruction: CP   90
                let:8 a64 = a63 in
                let:16 a65 = addWithCarry(!false,a64,~90) in
                let:8 a66 = (a64 & 0F) in
                let:8 a67 = (~90 & 0F) in
                let:16 a68 = addWithCarry(!false,a66,a67) in
                advance (7)
                #14FD
                #instruction: JP   NC,1504
                if (!!a65[15:8][0]) {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  let:8 a69 = a62 in
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  M[23FD] := 15;
                  M[23FC] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  let:8 a70 = M[2009] in
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  let:8 a71 = a69 in
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  M[23FB] := 15;
                  M[23FA] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a72 = a70 in
                  let:8 a73 = a71 in
                  let:16 a74 = addWithCarry(!false,a72,~a73) in
                  let:8 a75 = (a72 & 0F) in
                  let:8 a76 = (~a73 & 0F) in
                  let:16 a77 = addWithCarry(!false,a75,a76) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a74[15:8][0]) {
                    M[23F9] := 15;
                    M[23F8] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a78 = addWithCarry(true,00,00) in
                    let:8 a79 = (00 & 0F) in
                    let:8 a80 = (00 & 0F) in
                    let:16 a81 = addWithCarry(true,a79,a80) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a82 = a70 in
                    let:16 a83 = addWithCarry(false,10,a82) in
                    let:8 a84 = (10 & 0F) in
                    let:8 a85 = (a82 & 0F) in
                    let:16 a86 = addWithCarry(false,a84,a85) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a83[7:0][7]) {
                      advance (10)
                      A := a83[7:0];
                      B := a62;
                      C := a78[7:0];
                      H := a71;
                      L := a69;
                      SPH := 23;
                      SPL := F8;
                      FlagS := a83[7:0][7];
                      FlagZ := is_zero(a83[7:0]);
                      FlagA := a86[7:0][4];
                      FlagP := parity(a83[7:0]);
                      FlagCY := a83[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a87 = M[23F8] in
                      let:8 a88 = M[23F9] in
                      advance (10)
                      A := a83[7:0];
                      B := a62;
                      C := a78[7:0];
                      H := a71;
                      L := a69;
                      SPH := 23;
                      SPL := FA;
                      FlagS := a83[7:0][7];
                      FlagZ := is_zero(a83[7:0]);
                      FlagA := a86[7:0][4];
                      FlagP := parity(a83[7:0]);
                      FlagCY := a83[15:8][0];
                      jump ((a88,a87));
                    }
                  } else {
                    advance (11)
                    A := a70;
                    B := a62;
                    C := 00;
                    H := a71;
                    L := a69;
                    SPH := 23;
                    SPL := FA;
                    FlagS := a74[7:0][7];
                    FlagZ := is_zero(a74[7:0]);
                    FlagA := a77[7:0][4];
                    FlagP := parity(a74[7:0]);
                    FlagCY := !a74[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #1500
                  #instruction: CP   B
                  let:8 a89 = a63 in
                  let:8 a90 = a62 in
                  let:16 a91 = addWithCarry(!false,a89,~a90) in
                  let:8 a92 = (a89 & 0F) in
                  let:8 a93 = (~a90 & 0F) in
                  let:16 a94 = addWithCarry(!false,a92,a93) in
                  advance (4)
                  #1501
                  #instruction: JP   NC,1530
                  if (!!a91[15:8][0]) {
                    advance (10)
                    #1530
                    #instruction: LD   A,03
                    advance (7)
                    #1532
                    #instruction: LD   (2025),A
                    M[2025] := 03;
                    advance (13)
                    #1535
                    #instruction: JP   154A
                    advance (10)
                    #154A
                    #instruction: XOR  A
                    let:8 a95 = (03 ^ 03) in
                    advance (4)
                    #154B
                    #instruction: LD   (2002),A
                    let:8 a96 = a95 in
                    M[2002] := a96;
                    advance (13)
                    #154E
                    #instruction: LD   B,F7
                    advance (7)
                    #1550
                    #instruction: JP   19DC
                    advance (10)
                    #19DC
                    #instruction: LD   A,(2094)
                    let:8 a97 = M[2094] in
                    advance (13)
                    #19DF
                    #instruction: AND  B
                    let:8 a98 = a97 in
                    let:8 a99 = (F7 & a98) in
                    let:8 a100 = (F7 | a98) in
                    advance (4)
                    #19E0
                    #instruction: LD   (2094),A
                    let:8 a101 = a99 in
                    M[2094] := a101;
                    advance (13)
                    #19E3
                    #instruction: OUT  03
                    let:8 a102 = a99 in
                    sound_control(Ufo,a102[0]);
                    sound_control(Shot,a102[1]);
                    sound_control(PlayerDie,a102[2]);
                    sound_control(InvaderDie,a102[3]);
                    sound_control(ExtraLife,a102[4]);
                    advance (10)
                    #19E5
                    #instruction: RET
                    let:8 a103 = M[23FE] in
                    let:8 a104 = M[23FF] in
                    advance (10)
                    A := a99;
                    B := F7;
                    H := a1;
                    SPH := 24;
                    SPL := 00;
                    FlagS := a99[7];
                    FlagZ := is_zero(a99);
                    FlagA := a100[3];
                    FlagP := parity(a99);
                    FlagCY := false;
                    jump ((a104,a103));
                  } else {
                    advance (10)
                    #1504
                    #instruction: LD   L,B
                    let:8 a105 = a62 in
                    advance (5)
                    #1505
                    #instruction: CALL 1562
                    M[23FD] := 15;
                    M[23FC] := 08;
                    #return-to: 1508
                    advance (17)
                    #1562
                    #instruction: LD   A,(2009)
                    let:8 a106 = M[2009] in
                    advance (13)
                    #1565
                    #instruction: LD   H,L
                    let:8 a107 = a105 in
                    advance (5)
                    #1566
                    #instruction: CALL 1554
                    M[23FB] := 15;
                    M[23FA] := 69;
                    #return-to: 1569
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:8 a108 = a106 in
                    let:8 a109 = a107 in
                    let:16 a110 = addWithCarry(!false,a108,~a109) in
                    let:8 a111 = (a108 & 0F) in
                    let:8 a112 = (~a109 & 0F) in
                    let:16 a113 = addWithCarry(!false,a111,a112) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a110[15:8][0]) {
                      M[23F9] := 15;
                      M[23F8] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a114 = addWithCarry(true,00,00) in
                      let:8 a115 = (00 & 0F) in
                      let:8 a116 = (00 & 0F) in
                      let:16 a117 = addWithCarry(true,a115,a116) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:8 a118 = a106 in
                      let:16 a119 = addWithCarry(false,10,a118) in
                      let:8 a120 = (10 & 0F) in
                      let:8 a121 = (a118 & 0F) in
                      let:16 a122 = addWithCarry(false,a120,a121) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a119[7:0][7]) {
                        advance (10)
                        A := a119[7:0];
                        B := a62;
                        C := a114[7:0];
                        H := a107;
                        L := a105;
                        SPH := 23;
                        SPL := F8;
                        FlagS := a119[7:0][7];
                        FlagZ := is_zero(a119[7:0]);
                        FlagA := a122[7:0][4];
                        FlagP := parity(a119[7:0]);
                        FlagCY := a119[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:8 a123 = M[23F8] in
                        let:8 a124 = M[23F9] in
                        advance (10)
                        A := a119[7:0];
                        B := a62;
                        C := a114[7:0];
                        H := a107;
                        L := a105;
                        SPH := 23;
                        SPL := FA;
                        FlagS := a119[7:0][7];
                        FlagZ := is_zero(a119[7:0]);
                        FlagA := a122[7:0][4];
                        FlagP := parity(a119[7:0]);
                        FlagCY := a119[15:8][0];
                        jump ((a124,a123));
                      }
                    } else {
                      advance (11)
                      A := a106;
                      B := a62;
                      C := 00;
                      H := a107;
                      L := a105;
                      SPH := 23;
                      SPL := FA;
                      FlagS := a110[7:0][7];
                      FlagZ := is_zero(a110[7:0]);
                      FlagA := a113[7:0][4];
                      FlagP := parity(a110[7:0]);
                      FlagCY := !a110[15:8][0];
                      jump (155A);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0170
      #instruction: LD   A,D
      let:8 a125 = D in
      advance (5)
      #0171
      #instruction: LD   (2004),A
      let:8 a126 = a125 in
      M[2004] := a126;
      advance (13)
      #0174
      #instruction: LD   A,01
      advance (7)
      #0176
      #instruction: LD   (2000),A
      M[2000] := 01;
      advance (13)
      #0179
      #instruction: RET
      let:8 a127 = SPH in
      let:8 a128 = SPL in
      let:16 a129 = (1 + (a127,a128)) in
      let:8 a130 = M[(a127,a128)] in
      let:8 a131 = a129[15:8] in
      let:8 a132 = a129[7:0] in
      let:16 a133 = (1 + (a131,a132)) in
      let:8 a134 = M[(a131,a132)] in
      advance (10)
      A := 01;
      H := a1;
      SPH := a133[15:8];
      SPL := a133[7:0];
      FlagS := a6[7:0][7];
      FlagZ := is_zero(a6[7:0]);
      FlagA := a9[7:0][4];
      FlagP := parity(a6[7:0]);
      FlagCY := !a6[15:8][0];
      jump ((a134,a130));
    }

01B1:

    #01B1
    #instruction: LD   HL,2005
    advance (10)
    #01B4
    #instruction: LD   A,(HL)
    let:8 a1 = M[2005] in
    advance (7)
    #01B5
    #instruction: INC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    advance (5)
    #01B6
    #instruction: AND  01
    let:8 a7 = a3[7:0] in
    let:8 a8 = (01 & a7) in
    let:8 a9 = (01 | a7) in
    advance (7)
    #01B8
    #instruction: LD   (HL),A
    let:8 a10 = a8 in
    M[2005] := a10;
    advance (7)
    #01B9
    #instruction: XOR  A
    let:8 a11 = a8 in
    let:8 a12 = a8 in
    let:8 a13 = (a11 ^ a12) in
    advance (4)
    #01BA
    #instruction: LD   HL,2067
    advance (10)
    #01BD
    #instruction: LD   H,(HL)
    let:8 a14 = M[2067] in
    advance (7)
    #01BE
    #instruction: RET
    let:8 a15 = SPH in
    let:8 a16 = SPL in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a13;
    H := a14;
    L := 67;
    SPH := a21[15:8];
    SPL := a21[7:0];
    FlagS := a13[7];
    FlagZ := is_zero(a13);
    FlagA := false;
    FlagP := parity(a13);
    FlagCY := false;
    jump ((a22,a18));

0203:

    #0203
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0204
    #instruction: DEC  C
    let:8 a9 = C in
    let:16 a10 = addWithCarry(!true,a9,~00) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~00 & 0F) in
    let:16 a13 = addWithCarry(!true,a11,a12) in
    advance (5)
    #0205
    #instruction: JP   NZ,01FD
    if (!is_zero(a10[7:0])) {
      advance (10)
      #01FD
      #instruction: PUSH DE
      let:8 a14 = a8 in
      let:8 a15 = a4 in
      let:8 a16 = a7[15:8] in
      let:8 a17 = a7[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := a14;
      let:8 a19 = a18[15:8] in
      let:8 a20 = a18[7:0] in
      let:16 a21 = (-1 + (a19,a20)) in
      M[a21] := a15;
      advance (11)
      #01FE
      #instruction: LD   B,2C
      advance (7)
      #0200
      #instruction: CALL 1A32
      let:8 a22 = a21[15:8] in
      let:8 a23 = a21[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 02;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 03;
      #return-to: 0203
      advance (17)
      #1A32
      #instruction: LD   A,(DE)
      let:8 a28 = a8 in
      let:8 a29 = a4 in
      let:8 a30 = M[(a28,a29)] in
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      let:8 a31 = a30 in
      let:8 a32 = H in
      let:8 a33 = L in
      M[(a32,a33)] := a31;
      advance (7)
      #1A34
      #instruction: INC  HL
      let:8 a34 = H in
      let:8 a35 = L in
      let:16 a36 = (1 + (a34,a35)) in
      advance (5)
      #1A35
      #instruction: INC  DE
      let:8 a37 = a8 in
      let:8 a38 = a4 in
      let:16 a39 = (1 + (a37,a38)) in
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a40 = addWithCarry(!true,2C,~00) in
      let:8 a41 = (2C & 0F) in
      let:8 a42 = (~00 & 0F) in
      let:16 a43 = addWithCarry(!true,a41,a42) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a40[7:0])) {
        advance (10)
        A := a30;
        B := a40[7:0];
        C := a10[7:0];
        D := a39[15:8];
        E := a39[7:0];
        H := a36[15:8];
        L := a36[7:0];
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a40[7:0][7];
        FlagZ := is_zero(a40[7:0]);
        FlagA := a43[7:0][4];
        FlagP := parity(a40[7:0]);
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a44 = a27[15:8] in
        let:8 a45 = a27[7:0] in
        let:16 a46 = (1 + (a44,a45)) in
        let:8 a47 = M[(a44,a45)] in
        let:8 a48 = a46[15:8] in
        let:8 a49 = a46[7:0] in
        let:16 a50 = (1 + (a48,a49)) in
        let:8 a51 = M[(a48,a49)] in
        advance (10)
        A := a30;
        B := a40[7:0];
        C := a10[7:0];
        D := a39[15:8];
        E := a39[7:0];
        H := a36[15:8];
        L := a36[7:0];
        SPH := a50[15:8];
        SPL := a50[7:0];
        FlagS := a40[7:0][7];
        FlagZ := is_zero(a40[7:0]);
        FlagA := a43[7:0][4];
        FlagP := parity(a40[7:0]);
        jump ((a51,a47));
      }
    } else {
      advance (10)
      #0208
      #instruction: RET
      let:8 a52 = a7[15:8] in
      let:8 a53 = a7[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      advance (10)
      C := a10[7:0];
      D := a8;
      E := a4;
      SPH := a58[15:8];
      SPL := a58[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      jump ((a59,a55));
    }

0235:

    #0235
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0236
    #instruction: POP  PSW
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0237
    #instruction: DEC  A
    let:8 a17 = a16 in
    let:16 a18 = addWithCarry(!true,a17,~00) in
    let:8 a19 = (a17 & 0F) in
    let:8 a20 = (~00 & 0F) in
    let:16 a21 = addWithCarry(!true,a19,a20) in
    advance (5)
    #0238
    #instruction: RET  Z
    if (is_zero(a18[7:0])) {
      let:8 a22 = a15[15:8] in
      let:8 a23 = a15[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      let:8 a26 = a24[15:8] in
      let:8 a27 = a24[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      advance (11)
      A := a18[7:0];
      B := a8;
      C := a4;
      SPH := a28[15:8];
      SPL := a28[7:0];
      FlagS := a18[7:0][7];
      FlagZ := is_zero(a18[7:0]);
      FlagA := a21[7:0][4];
      FlagP := parity(a18[7:0]);
      FlagCY := a12[0];
      jump ((a29,a25));
    } else {
      advance (5)
      #0239
      #instruction: PUSH DE
      let:8 a30 = D in
      let:8 a31 = E in
      let:8 a32 = a15[15:8] in
      let:8 a33 = a15[7:0] in
      let:16 a34 = (-1 + (a32,a33)) in
      M[a34] := a30;
      let:8 a35 = a34[15:8] in
      let:8 a36 = a34[7:0] in
      let:16 a37 = (-1 + (a35,a36)) in
      M[a37] := a31;
      advance (11)
      #023A
      #instruction: LD   DE,02E0
      advance (10)
      #023D
      #instruction: ADD  HL,DE
      let:8 a38 = H in
      let:8 a39 = L in
      let:17 a40 = add17(02E0,(a38,a39)) in
      advance (10)
      #023E
      #instruction: POP  DE
      let:8 a41 = a37[15:8] in
      let:8 a42 = a37[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      #023F
      #instruction: JP   0229
      advance (10)
      #0229
      #instruction: PUSH PSW
      let:8 a49 = a18[7:0] in
      let:8 a50 = a47[15:8] in
      let:8 a51 = a47[7:0] in
      let:16 a52 = (-1 + (a50,a51)) in
      M[a52] := a49;
      let:8 a53 = a52[15:8] in
      let:8 a54 = a52[7:0] in
      let:16 a55 = (-1 + (a53,a54)) in
      M[a55] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a18[7:0][7]),6,is_zero(a18[7:0])),4,a21[7:0][4]),2,parity(a18[7:0])),0,a40[16]);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:8 a56 = a8 in
      let:8 a57 = a4 in
      let:8 a58 = a55[15:8] in
      let:8 a59 = a55[7:0] in
      let:16 a60 = (-1 + (a58,a59)) in
      M[a60] := a56;
      let:8 a61 = a60[15:8] in
      let:8 a62 = a60[7:0] in
      let:16 a63 = (-1 + (a61,a62)) in
      M[a63] := a57;
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      let:8 a64 = M[2081] in
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a65 = a64 in
      let:8 a66 = a64 in
      let:8 a67 = (a65 & a66) in
      let:8 a68 = (a65 | a66) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a67)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:8 a69 = a63[15:8] in
        let:8 a70 = a63[7:0] in
        let:16 a71 = (-1 + (a69,a70)) in
        M[a71] := 02;
        let:8 a72 = a71[15:8] in
        let:8 a73 = a71[7:0] in
        let:16 a74 = (-1 + (a72,a73)) in
        M[a74] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:8 a75 = a8 in
        let:8 a76 = a4 in
        let:8 a77 = a74[15:8] in
        let:8 a78 = a74[7:0] in
        let:16 a79 = (-1 + (a77,a78)) in
        M[a79] := a75;
        let:8 a80 = a79[15:8] in
        let:8 a81 = a79[7:0] in
        let:16 a82 = (-1 + (a80,a81)) in
        M[a82] := a76;
        advance (11)
        #147D
        #instruction: PUSH HL
        let:8 a83 = a40[15:0][15:8] in
        let:8 a84 = a40[15:0][7:0] in
        let:8 a85 = a82[15:8] in
        let:8 a86 = a82[7:0] in
        let:16 a87 = (-1 + (a85,a86)) in
        M[a87] := a83;
        let:8 a88 = a87[15:8] in
        let:8 a89 = a87[7:0] in
        let:16 a90 = (-1 + (a88,a89)) in
        M[a90] := a84;
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        let:8 a91 = a40[15:0][15:8] in
        let:8 a92 = a40[15:0][7:0] in
        let:8 a93 = M[(a91,a92)] in
        advance (7)
        #147F
        #instruction: LD   (DE),A
        let:8 a94 = a48 in
        let:8 a95 = a44 in
        let:8 a96 = a93 in
        M[(a94,a95)] := a96;
        advance (7)
        #1480
        #instruction: INC  DE
        let:8 a97 = a48 in
        let:8 a98 = a44 in
        let:16 a99 = (1 + (a97,a98)) in
        advance (5)
        #1481
        #instruction: INC  HL
        let:8 a100 = a40[15:0][15:8] in
        let:8 a101 = a40[15:0][7:0] in
        let:16 a102 = (1 + (a100,a101)) in
        advance (5)
        #1482
        #instruction: DEC  C
        let:8 a103 = a4 in
        let:16 a104 = addWithCarry(!true,a103,~00) in
        let:8 a105 = (a103 & 0F) in
        let:8 a106 = (~00 & 0F) in
        let:16 a107 = addWithCarry(!true,a105,a106) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a104[7:0])) {
          advance (10)
          A := a93;
          B := a8;
          C := a104[7:0];
          D := a99[15:8];
          E := a99[7:0];
          H := a102[15:8];
          L := a102[7:0];
          SPH := a90[15:8];
          SPL := a90[7:0];
          FlagS := a104[7:0][7];
          FlagZ := is_zero(a104[7:0]);
          FlagA := a107[7:0][4];
          FlagP := parity(a104[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:8 a108 = a90[15:8] in
          let:8 a109 = a90[7:0] in
          let:16 a110 = (1 + (a108,a109)) in
          let:8 a111 = M[(a108,a109)] in
          let:8 a112 = a110[15:8] in
          let:8 a113 = a110[7:0] in
          let:16 a114 = (1 + (a112,a113)) in
          let:8 a115 = M[(a112,a113)] in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:8 a116 = a115 in
          let:8 a117 = a111 in
          let:17 a118 = add17(0020,(a116,a117)) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:8 a119 = a114[15:8] in
          let:8 a120 = a114[7:0] in
          let:16 a121 = (1 + (a119,a120)) in
          let:8 a122 = M[(a119,a120)] in
          let:8 a123 = a121[15:8] in
          let:8 a124 = a121[7:0] in
          let:16 a125 = (1 + (a123,a124)) in
          let:8 a126 = M[(a123,a124)] in
          advance (10)
          #148C
          #instruction: DEC  B
          let:8 a127 = a126 in
          let:16 a128 = addWithCarry(!true,a127,~00) in
          let:8 a129 = (a127 & 0F) in
          let:8 a130 = (~00 & 0F) in
          let:16 a131 = addWithCarry(!true,a129,a130) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a128[7:0])) {
            advance (10)
            A := a93;
            B := a128[7:0];
            C := a122;
            D := a99[15:8];
            E := a99[7:0];
            H := a118[15:0][15:8];
            L := a118[15:0][7:0];
            SPH := a125[15:8];
            SPL := a125[7:0];
            FlagS := a128[7:0][7];
            FlagZ := is_zero(a128[7:0]);
            FlagA := a131[7:0][4];
            FlagP := parity(a128[7:0]);
            FlagCY := a118[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:8 a132 = a125[15:8] in
            let:8 a133 = a125[7:0] in
            let:16 a134 = (1 + (a132,a133)) in
            let:8 a135 = M[(a132,a133)] in
            let:8 a136 = a134[15:8] in
            let:8 a137 = a134[7:0] in
            let:16 a138 = (1 + (a136,a137)) in
            let:8 a139 = M[(a136,a137)] in
            advance (10)
            A := a93;
            B := a128[7:0];
            C := a122;
            D := a99[15:8];
            E := a99[7:0];
            H := a118[15:0][15:8];
            L := a118[15:0][7:0];
            SPH := a138[15:8];
            SPL := a138[7:0];
            FlagS := a128[7:0][7];
            FlagZ := is_zero(a128[7:0]);
            FlagA := a131[7:0][4];
            FlagP := parity(a128[7:0]);
            FlagCY := a118[16];
            jump ((a139,a135));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:8 a140 = a63[15:8] in
        let:8 a141 = a63[7:0] in
        let:16 a142 = (-1 + (a140,a141)) in
        M[a142] := 02;
        let:8 a143 = a142[15:8] in
        let:8 a144 = a142[7:0] in
        let:16 a145 = (-1 + (a143,a144)) in
        M[a145] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:8 a146 = a8 in
        let:8 a147 = a4 in
        let:8 a148 = a145[15:8] in
        let:8 a149 = a145[7:0] in
        let:16 a150 = (-1 + (a148,a149)) in
        M[a150] := a146;
        let:8 a151 = a150[15:8] in
        let:8 a152 = a150[7:0] in
        let:16 a153 = (-1 + (a151,a152)) in
        M[a153] := a147;
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:8 a154 = a40[15:0][15:8] in
        let:8 a155 = a40[15:0][7:0] in
        let:8 a156 = a153[15:8] in
        let:8 a157 = a153[7:0] in
        let:16 a158 = (-1 + (a156,a157)) in
        M[a158] := a154;
        let:8 a159 = a158[15:8] in
        let:8 a160 = a158[7:0] in
        let:16 a161 = (-1 + (a159,a160)) in
        M[a161] := a155;
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        let:8 a162 = a48 in
        let:8 a163 = a44 in
        let:8 a164 = M[(a162,a163)] in
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a165 = a40[15:0][15:8] in
        let:8 a166 = a40[15:0][7:0] in
        let:8 a167 = M[(a165,a166)] in
        let:8 a168 = a164 in
        let:8 a169 = (a167 | a168) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        let:8 a170 = a169 in
        let:8 a171 = a40[15:0][15:8] in
        let:8 a172 = a40[15:0][7:0] in
        M[(a171,a172)] := a170;
        advance (7)
        #1A6E
        #instruction: INC  DE
        let:8 a173 = a48 in
        let:8 a174 = a44 in
        let:16 a175 = (1 + (a173,a174)) in
        advance (5)
        #1A6F
        #instruction: INC  HL
        let:8 a176 = a40[15:0][15:8] in
        let:8 a177 = a40[15:0][7:0] in
        let:16 a178 = (1 + (a176,a177)) in
        advance (5)
        #1A70
        #instruction: DEC  C
        let:8 a179 = a4 in
        let:16 a180 = addWithCarry(!true,a179,~00) in
        let:8 a181 = (a179 & 0F) in
        let:8 a182 = (~00 & 0F) in
        let:16 a183 = addWithCarry(!true,a181,a182) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a180[7:0])) {
          advance (10)
          A := a169;
          B := a8;
          C := a180[7:0];
          D := a175[15:8];
          E := a175[7:0];
          H := a178[15:8];
          L := a178[7:0];
          SPH := a161[15:8];
          SPL := a161[7:0];
          FlagS := a180[7:0][7];
          FlagZ := is_zero(a180[7:0]);
          FlagA := a183[7:0][4];
          FlagP := parity(a180[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:8 a184 = a161[15:8] in
          let:8 a185 = a161[7:0] in
          let:16 a186 = (1 + (a184,a185)) in
          let:8 a187 = M[(a184,a185)] in
          let:8 a188 = a186[15:8] in
          let:8 a189 = a186[7:0] in
          let:16 a190 = (1 + (a188,a189)) in
          let:8 a191 = M[(a188,a189)] in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:8 a192 = a191 in
          let:8 a193 = a187 in
          let:17 a194 = add17(0020,(a192,a193)) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:8 a195 = a190[15:8] in
          let:8 a196 = a190[7:0] in
          let:16 a197 = (1 + (a195,a196)) in
          let:8 a198 = M[(a195,a196)] in
          let:8 a199 = a197[15:8] in
          let:8 a200 = a197[7:0] in
          let:16 a201 = (1 + (a199,a200)) in
          let:8 a202 = M[(a199,a200)] in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:8 a203 = a202 in
          let:16 a204 = addWithCarry(!true,a203,~00) in
          let:8 a205 = (a203 & 0F) in
          let:8 a206 = (~00 & 0F) in
          let:16 a207 = addWithCarry(!true,a205,a206) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a204[7:0])) {
            advance (10)
            A := a169;
            B := a204[7:0];
            C := a198;
            D := a175[15:8];
            E := a175[7:0];
            H := a194[15:0][15:8];
            L := a194[15:0][7:0];
            SPH := a201[15:8];
            SPL := a201[7:0];
            FlagS := a204[7:0][7];
            FlagZ := is_zero(a204[7:0]);
            FlagA := a207[7:0][4];
            FlagP := parity(a204[7:0]);
            FlagCY := a194[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:8 a208 = a201[15:8] in
            let:8 a209 = a201[7:0] in
            let:16 a210 = (1 + (a208,a209)) in
            let:8 a211 = M[(a208,a209)] in
            let:8 a212 = a210[15:8] in
            let:8 a213 = a210[7:0] in
            let:16 a214 = (1 + (a212,a213)) in
            let:8 a215 = M[(a212,a213)] in
            advance (10)
            A := a169;
            B := a204[7:0];
            C := a198;
            D := a175[15:8];
            E := a175[7:0];
            H := a194[15:0][15:8];
            L := a194[15:0][7:0];
            SPH := a214[15:8];
            SPL := a214[7:0];
            FlagS := a204[7:0][7];
            FlagZ := is_zero(a204[7:0]);
            FlagA := a207[7:0][4];
            FlagP := parity(a204[7:0]);
            FlagCY := a194[16];
            jump ((a215,a211));
          }
        }
      }
    }

0245:

    #0245
    #instruction: JP   0235
    advance (10)
    jump (0235);

026F:

    #026F
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0270
    #instruction: LD   DE,000C
    advance (10)
    #0273
    #instruction: ADD  HL,DE
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:17 a11 = add17(000C,(a9,a10)) in
    advance (10)
    #0274
    #instruction: JP   024B
    advance (10)
    #024B
    #instruction: LD   A,(HL)
    let:8 a12 = a11[15:0][15:8] in
    let:8 a13 = a11[15:0][7:0] in
    let:8 a14 = M[(a12,a13)] in
    advance (7)
    #024C
    #instruction: CP   FF
    let:8 a15 = a14 in
    let:16 a16 = addWithCarry(!false,a15,~FF) in
    let:8 a17 = (a15 & 0F) in
    let:8 a18 = (~FF & 0F) in
    let:16 a19 = addWithCarry(!false,a17,a18) in
    advance (7)
    #024E
    #instruction: RET  Z
    if (is_zero(a16[7:0])) {
      let:8 a20 = a7[15:8] in
      let:8 a21 = a7[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      let:8 a24 = a22[15:8] in
      let:8 a25 = a22[7:0] in
      let:16 a26 = (1 + (a24,a25)) in
      let:8 a27 = M[(a24,a25)] in
      advance (11)
      A := a14;
      D := 00;
      E := 0C;
      H := a11[15:0][15:8];
      L := a11[15:0][7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a16[7:0][7];
      FlagZ := is_zero(a16[7:0]);
      FlagA := a19[7:0][4];
      FlagP := parity(a16[7:0]);
      FlagCY := !a16[15:8][0];
      jump ((a27,a23));
    } else {
      advance (5)
      #024F
      #instruction: CP   FE
      let:8 a28 = a14 in
      let:16 a29 = addWithCarry(!false,a28,~FE) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~FE & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #0251
      #instruction: JP   Z,0281
      if (is_zero(a29[7:0])) {
        advance (10)
        #0281
        #instruction: LD   DE,0010
        advance (10)
        #0284
        #instruction: ADD  HL,DE
        let:8 a33 = a11[15:0][15:8] in
        let:8 a34 = a11[15:0][7:0] in
        let:17 a35 = add17(0010,(a33,a34)) in
        advance (10)
        #0285
        #instruction: JP   024B
        advance (10)
        A := a14;
        D := 00;
        E := 10;
        H := a35[15:0][15:8];
        L := a35[15:0][7:0];
        SPH := a7[15:8];
        SPL := a7[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := a35[16];
        jump (024B);
      } else {
        advance (10)
        #0254
        #instruction: INC  HL
        let:8 a36 = a11[15:0][15:8] in
        let:8 a37 = a11[15:0][7:0] in
        let:16 a38 = (1 + (a36,a37)) in
        advance (5)
        #0255
        #instruction: LD   B,(HL)
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:8 a41 = M[(a39,a40)] in
        advance (7)
        #0256
        #instruction: LD   C,A
        let:8 a42 = a14 in
        advance (5)
        #0257
        #instruction: OR   B
        let:8 a43 = a41 in
        let:8 a44 = a14 in
        let:8 a45 = (a43 | a44) in
        advance (4)
        #0258
        #instruction: LD   A,C
        let:8 a46 = a42 in
        advance (5)
        #0259
        #instruction: JP   NZ,0277
        if (!is_zero(a45)) {
          advance (10)
          #0277
          #instruction: DEC  B
          let:8 a47 = a41 in
          let:16 a48 = addWithCarry(!true,a47,~00) in
          let:8 a49 = (a47 & 0F) in
          let:8 a50 = (~00 & 0F) in
          let:16 a51 = addWithCarry(!true,a49,a50) in
          advance (5)
          #0278
          #instruction: INC  B
          let:8 a52 = a48[7:0] in
          let:16 a53 = addWithCarry(true,a52,00) in
          let:8 a54 = (a52 & 0F) in
          let:8 a55 = (00 & 0F) in
          let:16 a56 = addWithCarry(true,a54,a55) in
          advance (5)
          #0279
          #instruction: JP   NZ,027D
          if (!is_zero(a53[7:0])) {
            advance (10)
            #027D
            #instruction: DEC  B
            let:8 a57 = a53[7:0] in
            let:16 a58 = addWithCarry(!true,a57,~00) in
            let:8 a59 = (a57 & 0F) in
            let:8 a60 = (~00 & 0F) in
            let:16 a61 = addWithCarry(!true,a59,a60) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            let:8 a62 = a58[7:0] in
            let:8 a63 = a38[15:8] in
            let:8 a64 = a38[7:0] in
            M[(a63,a64)] := a62;
            advance (7)
            #027F
            #instruction: DEC  HL
            let:8 a65 = a38[15:8] in
            let:8 a66 = a38[7:0] in
            let:16 a67 = (-1 + (a65,a66)) in
            advance (5)
            #0280
            #instruction: LD   (HL),A
            let:8 a68 = a46 in
            let:8 a69 = a67[15:8] in
            let:8 a70 = a67[7:0] in
            M[(a69,a70)] := a68;
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:8 a71 = a67[15:8] in
            let:8 a72 = a67[7:0] in
            let:17 a73 = add17(0010,(a71,a72)) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a46;
            B := a58[7:0];
            C := a42;
            D := 00;
            E := 10;
            H := a73[15:0][15:8];
            L := a73[15:0][7:0];
            SPH := a7[15:8];
            SPL := a7[7:0];
            FlagS := a58[7:0][7];
            FlagZ := is_zero(a58[7:0]);
            FlagA := a61[7:0][4];
            FlagP := parity(a58[7:0]);
            FlagCY := a73[16];
            jump (024B);
          } else {
            advance (10)
            #027C
            #instruction: DEC  A
            let:8 a74 = a46 in
            let:16 a75 = addWithCarry(!true,a74,~00) in
            let:8 a76 = (a74 & 0F) in
            let:8 a77 = (~00 & 0F) in
            let:16 a78 = addWithCarry(!true,a76,a77) in
            advance (5)
            #027D
            #instruction: DEC  B
            let:8 a79 = a53[7:0] in
            let:16 a80 = addWithCarry(!true,a79,~00) in
            let:8 a81 = (a79 & 0F) in
            let:8 a82 = (~00 & 0F) in
            let:16 a83 = addWithCarry(!true,a81,a82) in
            advance (5)
            #027E
            #instruction: LD   (HL),B
            let:8 a84 = a80[7:0] in
            let:8 a85 = a38[15:8] in
            let:8 a86 = a38[7:0] in
            M[(a85,a86)] := a84;
            advance (7)
            #027F
            #instruction: DEC  HL
            let:8 a87 = a38[15:8] in
            let:8 a88 = a38[7:0] in
            let:16 a89 = (-1 + (a87,a88)) in
            advance (5)
            #0280
            #instruction: LD   (HL),A
            let:8 a90 = a75[7:0] in
            let:8 a91 = a89[15:8] in
            let:8 a92 = a89[7:0] in
            M[(a91,a92)] := a90;
            advance (7)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:8 a93 = a89[15:8] in
            let:8 a94 = a89[7:0] in
            let:17 a95 = add17(0010,(a93,a94)) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a75[7:0];
            B := a80[7:0];
            C := a42;
            D := 00;
            E := 10;
            H := a95[15:0][15:8];
            L := a95[15:0][7:0];
            SPH := a7[15:8];
            SPL := a7[7:0];
            FlagS := a80[7:0][7];
            FlagZ := is_zero(a80[7:0]);
            FlagA := a83[7:0][4];
            FlagP := parity(a80[7:0]);
            FlagCY := a95[16];
            jump (024B);
          }
        } else {
          advance (10)
          #025C
          #instruction: INC  HL
          let:8 a96 = a38[15:8] in
          let:8 a97 = a38[7:0] in
          let:16 a98 = (1 + (a96,a97)) in
          advance (5)
          #025D
          #instruction: LD   A,(HL)
          let:8 a99 = a98[15:8] in
          let:8 a100 = a98[7:0] in
          let:8 a101 = M[(a99,a100)] in
          advance (7)
          #025E
          #instruction: AND  A
          let:8 a102 = a101 in
          let:8 a103 = a101 in
          let:8 a104 = (a102 & a103) in
          let:8 a105 = (a102 | a103) in
          advance (4)
          #025F
          #instruction: JP   NZ,0288
          if (!is_zero(a104)) {
            advance (10)
            #0288
            #instruction: DEC  (HL)
            let:8 a106 = a98[15:8] in
            let:8 a107 = a98[7:0] in
            let:8 a108 = M[(a106,a107)] in
            let:16 a109 = addWithCarry(!true,a108,~00) in
            let:8 a110 = (a108 & 0F) in
            let:8 a111 = (~00 & 0F) in
            let:16 a112 = addWithCarry(!true,a110,a111) in
            let:8 a113 = a98[15:8] in
            let:8 a114 = a98[7:0] in
            M[(a113,a114)] := a109[7:0];
            advance (10)
            #0289
            #instruction: DEC  HL
            let:8 a115 = a98[15:8] in
            let:8 a116 = a98[7:0] in
            let:16 a117 = (-1 + (a115,a116)) in
            advance (5)
            #028A
            #instruction: DEC  HL
            let:8 a118 = a117[15:8] in
            let:8 a119 = a117[7:0] in
            let:16 a120 = (-1 + (a118,a119)) in
            advance (5)
            #028B
            #instruction: JP   0281
            advance (10)
            #0281
            #instruction: LD   DE,0010
            advance (10)
            #0284
            #instruction: ADD  HL,DE
            let:8 a121 = a120[15:8] in
            let:8 a122 = a120[7:0] in
            let:17 a123 = add17(0010,(a121,a122)) in
            advance (10)
            #0285
            #instruction: JP   024B
            advance (10)
            A := a104;
            B := a41;
            C := a42;
            D := 00;
            E := 10;
            H := a123[15:0][15:8];
            L := a123[15:0][7:0];
            SPH := a7[15:8];
            SPL := a7[7:0];
            FlagS := a109[7:0][7];
            FlagZ := is_zero(a109[7:0]);
            FlagA := a112[7:0][4];
            FlagP := parity(a109[7:0]);
            FlagCY := a123[16];
            jump (024B);
          } else {
            advance (10)
            #0262
            #instruction: INC  HL
            let:8 a124 = a98[15:8] in
            let:8 a125 = a98[7:0] in
            let:16 a126 = (1 + (a124,a125)) in
            advance (5)
            #0263
            #instruction: LD   E,(HL)
            let:8 a127 = a126[15:8] in
            let:8 a128 = a126[7:0] in
            let:8 a129 = M[(a127,a128)] in
            advance (7)
            #0264
            #instruction: INC  HL
            let:8 a130 = a126[15:8] in
            let:8 a131 = a126[7:0] in
            let:16 a132 = (1 + (a130,a131)) in
            advance (5)
            #0265
            #instruction: LD   D,(HL)
            let:8 a133 = a132[15:8] in
            let:8 a134 = a132[7:0] in
            let:8 a135 = M[(a133,a134)] in
            advance (7)
            #0266
            #instruction: PUSH HL
            let:8 a136 = a132[15:8] in
            let:8 a137 = a132[7:0] in
            let:8 a138 = a7[15:8] in
            let:8 a139 = a7[7:0] in
            let:16 a140 = (-1 + (a138,a139)) in
            M[a140] := a136;
            let:8 a141 = a140[15:8] in
            let:8 a142 = a140[7:0] in
            let:16 a143 = (-1 + (a141,a142)) in
            M[a143] := a137;
            advance (11)
            #0267
            #instruction: EX   DE,HL
            let:8 a144 = a135 in
            let:8 a145 = a129 in
            let:8 a146 = a132[15:8] in
            let:8 a147 = a132[7:0] in
            advance (4)
            #0268
            #instruction: PUSH HL
            let:8 a148 = a144 in
            let:8 a149 = a145 in
            let:8 a150 = a143[15:8] in
            let:8 a151 = a143[7:0] in
            let:16 a152 = (-1 + (a150,a151)) in
            M[a152] := a148;
            let:8 a153 = a152[15:8] in
            let:8 a154 = a152[7:0] in
            let:16 a155 = (-1 + (a153,a154)) in
            M[a155] := a149;
            advance (11)
            #0269
            #instruction: LD   HL,026F
            advance (10)
            #026C
            #instruction: EX   (SP),HL
            let:8 a156 = a155[15:8] in
            let:8 a157 = a155[7:0] in
            let:16 a158 = (1 + (a156,a157)) in
            let:8 a159 = M[(a156,a157)] in
            let:8 a160 = M[a158] in
            M[(a156,a157)] := 6F;
            M[a158] := 02;
            advance (18)
            #026D
            #instruction: PUSH DE
            let:8 a161 = a146 in
            let:8 a162 = a147 in
            let:8 a163 = a155[15:8] in
            let:8 a164 = a155[7:0] in
            let:16 a165 = (-1 + (a163,a164)) in
            M[a165] := a161;
            let:8 a166 = a165[15:8] in
            let:8 a167 = a165[7:0] in
            let:16 a168 = (-1 + (a166,a167)) in
            M[a168] := a162;
            advance (11)
            #026E
            #instruction: JP   (HL)
            let:8 a169 = a160 in
            let:8 a170 = a159 in
            advance (5)
            A := a104;
            B := a41;
            C := a42;
            D := a146;
            E := a147;
            H := a160;
            L := a159;
            SPH := a168[15:8];
            SPL := a168[7:0];
            FlagS := a104[7];
            FlagZ := is_zero(a104);
            FlagA := a105[3];
            FlagP := parity(a104);
            FlagCY := false;
            jump ((a169,a170));
          }
        }
      }
    }

028E:

    #028E
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #028F
    #instruction: INC  HL
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #0290
    #instruction: LD   A,(HL)
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:8 a14 = M[(a12,a13)] in
    advance (7)
    #0291
    #instruction: CP   FF
    let:8 a15 = a14 in
    let:16 a16 = addWithCarry(!false,a15,~FF) in
    let:8 a17 = (a15 & 0F) in
    let:8 a18 = (~FF & 0F) in
    let:16 a19 = addWithCarry(!false,a17,a18) in
    advance (7)
    #0293
    #instruction: JP   Z,033B
    if (is_zero(a16[7:0])) {
      advance (10)
      #033B
      #instruction: LD   HL,2068
      advance (10)
      #033E
      #instruction: LD   (HL),01
      M[2068] := 01;
      advance (10)
      #0340
      #instruction: INC  HL
      advance (5)
      #0341
      #instruction: LD   A,(HL)
      let:8 a20 = M[2069] in
      advance (7)
      #0342
      #instruction: AND  A
      let:8 a21 = a20 in
      let:8 a22 = a20 in
      let:8 a23 = (a21 & a22) in
      let:8 a24 = (a21 | a22) in
      advance (4)
      #0343
      #instruction: JP   03B0
      advance (10)
      #03B0
      #instruction: JP   NZ,034A
      if (!is_zero(a23)) {
        advance (10)
        #034A
        #instruction: LD   A,(201B)
        let:8 a25 = M[201B] in
        advance (13)
        #034D
        #instruction: LD   B,A
        let:8 a26 = a25 in
        advance (5)
        #034E
        #instruction: LD   A,(20EF)
        let:8 a27 = M[20EF] in
        advance (13)
        #0351
        #instruction: AND  A
        let:8 a28 = a27 in
        let:8 a29 = a27 in
        let:8 a30 = (a28 & a29) in
        let:8 a31 = (a28 | a29) in
        advance (4)
        #0352
        #instruction: JP   NZ,0363
        if (!is_zero(a30)) {
          advance (10)
          #0363
          #instruction: CALL 17C0
          let:8 a32 = a7[15:8] in
          let:8 a33 = a7[7:0] in
          let:16 a34 = (-1 + (a32,a33)) in
          M[a34] := 03;
          let:8 a35 = a34[15:8] in
          let:8 a36 = a34[7:0] in
          let:16 a37 = (-1 + (a35,a36)) in
          M[a37] := 66;
          #return-to: 0366
          advance (17)
          #17C0
          #instruction: LD   A,(2067)
          let:8 a38 = M[2067] in
          advance (13)
          #17C3
          #instruction: RRCA
          let:8 a39 = a38 in
          advance (4)
          #17C4
          #instruction: JP   NC,17CA
          if (!a39[0]) {
            advance (10)
            #17CA
            #instruction: IN   02
            advance (10)
            #17CC
            #instruction: RET
            let:8 a40 = a37[15:8] in
            let:8 a41 = a37[7:0] in
            let:16 a42 = (1 + (a40,a41)) in
            let:8 a43 = M[(a40,a41)] in
            let:8 a44 = a42[15:8] in
            let:8 a45 = a42[7:0] in
            let:16 a46 = (1 + (a44,a45)) in
            let:8 a47 = M[(a44,a45)] in
            advance (10)
            A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
            B := a26;
            H := 20;
            L := 69;
            SPH := a46[15:8];
            SPL := a46[7:0];
            FlagS := a30[7];
            FlagZ := is_zero(a30);
            FlagA := a31[3];
            FlagP := parity(a30);
            FlagCY := a39[0];
            jump ((a47,a43));
          } else {
            advance (10)
            #17C7
            #instruction: IN   01
            advance (10)
            #17C9
            #instruction: RET
            let:8 a48 = a37[15:8] in
            let:8 a49 = a37[7:0] in
            let:16 a50 = (1 + (a48,a49)) in
            let:8 a51 = M[(a48,a49)] in
            let:8 a52 = a50[15:8] in
            let:8 a53 = a50[7:0] in
            let:16 a54 = (1 + (a52,a53)) in
            let:8 a55 = M[(a52,a53)] in
            advance (10)
            A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
            B := a26;
            H := 20;
            L := 69;
            SPH := a54[15:8];
            SPL := a54[7:0];
            FlagS := a30[7];
            FlagZ := is_zero(a30);
            FlagA := a31[3];
            FlagP := parity(a30);
            FlagCY := a39[0];
            jump ((a55,a51));
          }
        } else {
          advance (10)
          #0355
          #instruction: LD   A,(201D)
          let:8 a56 = M[201D] in
          advance (13)
          #0358
          #instruction: RRCA
          let:8 a57 = a56 in
          advance (4)
          #0359
          #instruction: JP   CY,0381
          if (a57[0]) {
            advance (10)
            #0381
            #instruction: LD   A,B
            let:8 a58 = a26 in
            advance (5)
            #0382
            #instruction: CP   D9
            let:8 a59 = a58 in
            let:16 a60 = addWithCarry(!false,a59,~D9) in
            let:8 a61 = (a59 & 0F) in
            let:8 a62 = (~D9 & 0F) in
            let:16 a63 = addWithCarry(!false,a61,a62) in
            advance (7)
            #0384
            #instruction: JP   Z,036F
            if (is_zero(a60[7:0])) {
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:8 a64 = a7[15:8] in
              let:8 a65 = a7[7:0] in
              let:16 a66 = (-1 + (a64,a65)) in
              M[a66] := 03;
              let:8 a67 = a66[15:8] in
              let:8 a68 = a66[7:0] in
              let:16 a69 = (-1 + (a67,a68)) in
              M[a69] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              let:8 a70 = M[2018] in
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              let:8 a71 = M[2019] in
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              let:8 a72 = M[201A] in
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              let:8 a73 = M[201B] in
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              let:8 a74 = M[201C] in
              advance (7)
              #1A44
              #instruction: LD   H,C
              let:8 a75 = a73 in
              advance (5)
              #1A45
              #instruction: LD   L,A
              let:8 a76 = a72 in
              advance (5)
              #1A46
              #instruction: RET
              let:8 a77 = a69[15:8] in
              let:8 a78 = a69[7:0] in
              let:16 a79 = (1 + (a77,a78)) in
              let:8 a80 = M[(a77,a78)] in
              let:8 a81 = a79[15:8] in
              let:8 a82 = a79[7:0] in
              let:16 a83 = (1 + (a81,a82)) in
              let:8 a84 = M[(a81,a82)] in
              advance (10)
              A := a72;
              B := a74;
              C := a73;
              D := a71;
              E := a70;
              H := a75;
              L := a76;
              SPH := a83[15:8];
              SPL := a83[7:0];
              FlagS := a60[7:0][7];
              FlagZ := is_zero(a60[7:0]);
              FlagA := a63[7:0][4];
              FlagP := parity(a60[7:0]);
              FlagCY := !a60[15:8][0];
              jump ((a84,a80));
            } else {
              advance (10)
              #0387
              #instruction: INC  A
              let:8 a85 = a58 in
              let:16 a86 = addWithCarry(true,a85,00) in
              let:8 a87 = (a85 & 0F) in
              let:8 a88 = (00 & 0F) in
              let:16 a89 = addWithCarry(true,a87,a88) in
              advance (5)
              #0388
              #instruction: LD   (201B),A
              let:8 a90 = a86[7:0] in
              M[201B] := a90;
              advance (13)
              #038B
              #instruction: JP   036F
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:8 a91 = a7[15:8] in
              let:8 a92 = a7[7:0] in
              let:16 a93 = (-1 + (a91,a92)) in
              M[a93] := 03;
              let:8 a94 = a93[15:8] in
              let:8 a95 = a93[7:0] in
              let:16 a96 = (-1 + (a94,a95)) in
              M[a96] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              let:8 a97 = M[2018] in
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              let:8 a98 = M[2019] in
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              let:8 a99 = M[201A] in
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              let:8 a100 = M[201B] in
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              let:8 a101 = M[201C] in
              advance (7)
              #1A44
              #instruction: LD   H,C
              let:8 a102 = a100 in
              advance (5)
              #1A45
              #instruction: LD   L,A
              let:8 a103 = a99 in
              advance (5)
              #1A46
              #instruction: RET
              let:8 a104 = a96[15:8] in
              let:8 a105 = a96[7:0] in
              let:16 a106 = (1 + (a104,a105)) in
              let:8 a107 = M[(a104,a105)] in
              let:8 a108 = a106[15:8] in
              let:8 a109 = a106[7:0] in
              let:16 a110 = (1 + (a108,a109)) in
              let:8 a111 = M[(a108,a109)] in
              advance (10)
              A := a99;
              B := a101;
              C := a100;
              D := a98;
              E := a97;
              H := a102;
              L := a103;
              SPH := a110[15:8];
              SPL := a110[7:0];
              FlagS := a86[7:0][7];
              FlagZ := is_zero(a86[7:0]);
              FlagA := a89[7:0][4];
              FlagP := parity(a86[7:0]);
              FlagCY := !a60[15:8][0];
              jump ((a111,a107));
            }
          } else {
            advance (10)
            #035C
            #instruction: RRCA
            let:8 a112 = updateBit((a57 >> 01),7,a57[0]) in
            advance (4)
            #035D
            #instruction: JP   CY,038E
            if (a112[0]) {
              advance (10)
              #038E
              #instruction: LD   A,B
              let:8 a113 = a26 in
              advance (5)
              #038F
              #instruction: CP   30
              let:8 a114 = a113 in
              let:16 a115 = addWithCarry(!false,a114,~30) in
              let:8 a116 = (a114 & 0F) in
              let:8 a117 = (~30 & 0F) in
              let:16 a118 = addWithCarry(!false,a116,a117) in
              advance (7)
              #0391
              #instruction: JP   Z,036F
              if (is_zero(a115[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a119 = a7[15:8] in
                let:8 a120 = a7[7:0] in
                let:16 a121 = (-1 + (a119,a120)) in
                M[a121] := 03;
                let:8 a122 = a121[15:8] in
                let:8 a123 = a121[7:0] in
                let:16 a124 = (-1 + (a122,a123)) in
                M[a124] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a125 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a126 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a127 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a128 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a129 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a130 = a128 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a131 = a127 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a132 = a124[15:8] in
                let:8 a133 = a124[7:0] in
                let:16 a134 = (1 + (a132,a133)) in
                let:8 a135 = M[(a132,a133)] in
                let:8 a136 = a134[15:8] in
                let:8 a137 = a134[7:0] in
                let:16 a138 = (1 + (a136,a137)) in
                let:8 a139 = M[(a136,a137)] in
                advance (10)
                A := a127;
                B := a129;
                C := a128;
                D := a126;
                E := a125;
                H := a130;
                L := a131;
                SPH := a138[15:8];
                SPL := a138[7:0];
                FlagS := a115[7:0][7];
                FlagZ := is_zero(a115[7:0]);
                FlagA := a118[7:0][4];
                FlagP := parity(a115[7:0]);
                FlagCY := !a115[15:8][0];
                jump ((a139,a135));
              } else {
                advance (10)
                #0394
                #instruction: DEC  A
                let:8 a140 = a113 in
                let:16 a141 = addWithCarry(!true,a140,~00) in
                let:8 a142 = (a140 & 0F) in
                let:8 a143 = (~00 & 0F) in
                let:16 a144 = addWithCarry(!true,a142,a143) in
                advance (5)
                #0395
                #instruction: LD   (201B),A
                let:8 a145 = a141[7:0] in
                M[201B] := a145;
                advance (13)
                #0398
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a146 = a7[15:8] in
                let:8 a147 = a7[7:0] in
                let:16 a148 = (-1 + (a146,a147)) in
                M[a148] := 03;
                let:8 a149 = a148[15:8] in
                let:8 a150 = a148[7:0] in
                let:16 a151 = (-1 + (a149,a150)) in
                M[a151] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a152 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a153 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a154 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a155 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a156 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a157 = a155 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a158 = a154 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a159 = a151[15:8] in
                let:8 a160 = a151[7:0] in
                let:16 a161 = (1 + (a159,a160)) in
                let:8 a162 = M[(a159,a160)] in
                let:8 a163 = a161[15:8] in
                let:8 a164 = a161[7:0] in
                let:16 a165 = (1 + (a163,a164)) in
                let:8 a166 = M[(a163,a164)] in
                advance (10)
                A := a154;
                B := a156;
                C := a155;
                D := a153;
                E := a152;
                H := a157;
                L := a158;
                SPH := a165[15:8];
                SPL := a165[7:0];
                FlagS := a141[7:0][7];
                FlagZ := is_zero(a141[7:0]);
                FlagA := a144[7:0][4];
                FlagP := parity(a141[7:0]);
                FlagCY := !a115[15:8][0];
                jump ((a166,a162));
              }
            } else {
              advance (10)
              #0360
              #instruction: JP   036F
              advance (10)
              #036F
              #instruction: LD   HL,2018
              advance (10)
              #0372
              #instruction: CALL 1A3B
              let:8 a167 = a7[15:8] in
              let:8 a168 = a7[7:0] in
              let:16 a169 = (-1 + (a167,a168)) in
              M[a169] := 03;
              let:8 a170 = a169[15:8] in
              let:8 a171 = a169[7:0] in
              let:16 a172 = (-1 + (a170,a171)) in
              M[a172] := 75;
              #return-to: 0375
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              let:8 a173 = M[2018] in
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              let:8 a174 = M[2019] in
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              let:8 a175 = M[201A] in
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              let:8 a176 = M[201B] in
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              let:8 a177 = M[201C] in
              advance (7)
              #1A44
              #instruction: LD   H,C
              let:8 a178 = a176 in
              advance (5)
              #1A45
              #instruction: LD   L,A
              let:8 a179 = a175 in
              advance (5)
              #1A46
              #instruction: RET
              let:8 a180 = a172[15:8] in
              let:8 a181 = a172[7:0] in
              let:16 a182 = (1 + (a180,a181)) in
              let:8 a183 = M[(a180,a181)] in
              let:8 a184 = a182[15:8] in
              let:8 a185 = a182[7:0] in
              let:16 a186 = (1 + (a184,a185)) in
              let:8 a187 = M[(a184,a185)] in
              advance (10)
              A := a175;
              B := a177;
              C := a176;
              D := a174;
              E := a173;
              H := a178;
              L := a179;
              SPH := a186[15:8];
              SPL := a186[7:0];
              FlagS := a30[7];
              FlagZ := is_zero(a30);
              FlagA := a31[3];
              FlagP := parity(a30);
              FlagCY := a112[0];
              jump ((a187,a183));
            }
          }
        }
      } else {
        advance (10)
        #03B3
        #instruction: INC  HL
        advance (5)
        #03B4
        #instruction: DEC  (HL)
        let:8 a188 = M[206A] in
        let:16 a189 = addWithCarry(!true,a188,~00) in
        let:8 a190 = (a188 & 0F) in
        let:8 a191 = (~00 & 0F) in
        let:16 a192 = addWithCarry(!true,a190,a191) in
        M[206A] := a189[7:0];
        advance (10)
        #03B5
        #instruction: JP   NZ,034A
        if (!is_zero(a189[7:0])) {
          advance (10)
          #034A
          #instruction: LD   A,(201B)
          let:8 a193 = M[201B] in
          advance (13)
          #034D
          #instruction: LD   B,A
          let:8 a194 = a193 in
          advance (5)
          #034E
          #instruction: LD   A,(20EF)
          let:8 a195 = M[20EF] in
          advance (13)
          #0351
          #instruction: AND  A
          let:8 a196 = a195 in
          let:8 a197 = a195 in
          let:8 a198 = (a196 & a197) in
          let:8 a199 = (a196 | a197) in
          advance (4)
          #0352
          #instruction: JP   NZ,0363
          if (!is_zero(a198)) {
            advance (10)
            #0363
            #instruction: CALL 17C0
            let:8 a200 = a7[15:8] in
            let:8 a201 = a7[7:0] in
            let:16 a202 = (-1 + (a200,a201)) in
            M[a202] := 03;
            let:8 a203 = a202[15:8] in
            let:8 a204 = a202[7:0] in
            let:16 a205 = (-1 + (a203,a204)) in
            M[a205] := 66;
            #return-to: 0366
            advance (17)
            #17C0
            #instruction: LD   A,(2067)
            let:8 a206 = M[2067] in
            advance (13)
            #17C3
            #instruction: RRCA
            let:8 a207 = a206 in
            advance (4)
            #17C4
            #instruction: JP   NC,17CA
            if (!a207[0]) {
              advance (10)
              #17CA
              #instruction: IN   02
              advance (10)
              #17CC
              #instruction: RET
              let:8 a208 = a205[15:8] in
              let:8 a209 = a205[7:0] in
              let:16 a210 = (1 + (a208,a209)) in
              let:8 a211 = M[(a208,a209)] in
              let:8 a212 = a210[15:8] in
              let:8 a213 = a210[7:0] in
              let:16 a214 = (1 + (a212,a213)) in
              let:8 a215 = M[(a212,a213)] in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
              B := a194;
              H := 20;
              L := 6A;
              SPH := a214[15:8];
              SPL := a214[7:0];
              FlagS := a198[7];
              FlagZ := is_zero(a198);
              FlagA := a199[3];
              FlagP := parity(a198);
              FlagCY := a207[0];
              jump ((a215,a211));
            } else {
              advance (10)
              #17C7
              #instruction: IN   01
              advance (10)
              #17C9
              #instruction: RET
              let:8 a216 = a205[15:8] in
              let:8 a217 = a205[7:0] in
              let:16 a218 = (1 + (a216,a217)) in
              let:8 a219 = M[(a216,a217)] in
              let:8 a220 = a218[15:8] in
              let:8 a221 = a218[7:0] in
              let:16 a222 = (1 + (a220,a221)) in
              let:8 a223 = M[(a220,a221)] in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
              B := a194;
              H := 20;
              L := 6A;
              SPH := a222[15:8];
              SPL := a222[7:0];
              FlagS := a198[7];
              FlagZ := is_zero(a198);
              FlagA := a199[3];
              FlagP := parity(a198);
              FlagCY := a207[0];
              jump ((a223,a219));
            }
          } else {
            advance (10)
            #0355
            #instruction: LD   A,(201D)
            let:8 a224 = M[201D] in
            advance (13)
            #0358
            #instruction: RRCA
            let:8 a225 = a224 in
            advance (4)
            #0359
            #instruction: JP   CY,0381
            if (a225[0]) {
              advance (10)
              #0381
              #instruction: LD   A,B
              let:8 a226 = a194 in
              advance (5)
              #0382
              #instruction: CP   D9
              let:8 a227 = a226 in
              let:16 a228 = addWithCarry(!false,a227,~D9) in
              let:8 a229 = (a227 & 0F) in
              let:8 a230 = (~D9 & 0F) in
              let:16 a231 = addWithCarry(!false,a229,a230) in
              advance (7)
              #0384
              #instruction: JP   Z,036F
              if (is_zero(a228[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a232 = a7[15:8] in
                let:8 a233 = a7[7:0] in
                let:16 a234 = (-1 + (a232,a233)) in
                M[a234] := 03;
                let:8 a235 = a234[15:8] in
                let:8 a236 = a234[7:0] in
                let:16 a237 = (-1 + (a235,a236)) in
                M[a237] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a238 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a239 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a240 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a241 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a242 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a243 = a241 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a244 = a240 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a245 = a237[15:8] in
                let:8 a246 = a237[7:0] in
                let:16 a247 = (1 + (a245,a246)) in
                let:8 a248 = M[(a245,a246)] in
                let:8 a249 = a247[15:8] in
                let:8 a250 = a247[7:0] in
                let:16 a251 = (1 + (a249,a250)) in
                let:8 a252 = M[(a249,a250)] in
                advance (10)
                A := a240;
                B := a242;
                C := a241;
                D := a239;
                E := a238;
                H := a243;
                L := a244;
                SPH := a251[15:8];
                SPL := a251[7:0];
                FlagS := a228[7:0][7];
                FlagZ := is_zero(a228[7:0]);
                FlagA := a231[7:0][4];
                FlagP := parity(a228[7:0]);
                FlagCY := !a228[15:8][0];
                jump ((a252,a248));
              } else {
                advance (10)
                #0387
                #instruction: INC  A
                let:8 a253 = a226 in
                let:16 a254 = addWithCarry(true,a253,00) in
                let:8 a255 = (a253 & 0F) in
                let:8 a256 = (00 & 0F) in
                let:16 a257 = addWithCarry(true,a255,a256) in
                advance (5)
                #0388
                #instruction: LD   (201B),A
                let:8 a258 = a254[7:0] in
                M[201B] := a258;
                advance (13)
                #038B
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a259 = a7[15:8] in
                let:8 a260 = a7[7:0] in
                let:16 a261 = (-1 + (a259,a260)) in
                M[a261] := 03;
                let:8 a262 = a261[15:8] in
                let:8 a263 = a261[7:0] in
                let:16 a264 = (-1 + (a262,a263)) in
                M[a264] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a265 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a266 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a267 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a268 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a269 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a270 = a268 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a271 = a267 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a272 = a264[15:8] in
                let:8 a273 = a264[7:0] in
                let:16 a274 = (1 + (a272,a273)) in
                let:8 a275 = M[(a272,a273)] in
                let:8 a276 = a274[15:8] in
                let:8 a277 = a274[7:0] in
                let:16 a278 = (1 + (a276,a277)) in
                let:8 a279 = M[(a276,a277)] in
                advance (10)
                A := a267;
                B := a269;
                C := a268;
                D := a266;
                E := a265;
                H := a270;
                L := a271;
                SPH := a278[15:8];
                SPL := a278[7:0];
                FlagS := a254[7:0][7];
                FlagZ := is_zero(a254[7:0]);
                FlagA := a257[7:0][4];
                FlagP := parity(a254[7:0]);
                FlagCY := !a228[15:8][0];
                jump ((a279,a275));
              }
            } else {
              advance (10)
              #035C
              #instruction: RRCA
              let:8 a280 = updateBit((a225 >> 01),7,a225[0]) in
              advance (4)
              #035D
              #instruction: JP   CY,038E
              if (a280[0]) {
                advance (10)
                #038E
                #instruction: LD   A,B
                let:8 a281 = a194 in
                advance (5)
                #038F
                #instruction: CP   30
                let:8 a282 = a281 in
                let:16 a283 = addWithCarry(!false,a282,~30) in
                let:8 a284 = (a282 & 0F) in
                let:8 a285 = (~30 & 0F) in
                let:16 a286 = addWithCarry(!false,a284,a285) in
                advance (7)
                #0391
                #instruction: JP   Z,036F
                if (is_zero(a283[7:0])) {
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:8 a287 = a7[15:8] in
                  let:8 a288 = a7[7:0] in
                  let:16 a289 = (-1 + (a287,a288)) in
                  M[a289] := 03;
                  let:8 a290 = a289[15:8] in
                  let:8 a291 = a289[7:0] in
                  let:16 a292 = (-1 + (a290,a291)) in
                  M[a292] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  let:8 a293 = M[2018] in
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  let:8 a294 = M[2019] in
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  let:8 a295 = M[201A] in
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  let:8 a296 = M[201B] in
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  let:8 a297 = M[201C] in
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  let:8 a298 = a296 in
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  let:8 a299 = a295 in
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:8 a300 = a292[15:8] in
                  let:8 a301 = a292[7:0] in
                  let:16 a302 = (1 + (a300,a301)) in
                  let:8 a303 = M[(a300,a301)] in
                  let:8 a304 = a302[15:8] in
                  let:8 a305 = a302[7:0] in
                  let:16 a306 = (1 + (a304,a305)) in
                  let:8 a307 = M[(a304,a305)] in
                  advance (10)
                  A := a295;
                  B := a297;
                  C := a296;
                  D := a294;
                  E := a293;
                  H := a298;
                  L := a299;
                  SPH := a306[15:8];
                  SPL := a306[7:0];
                  FlagS := a283[7:0][7];
                  FlagZ := is_zero(a283[7:0]);
                  FlagA := a286[7:0][4];
                  FlagP := parity(a283[7:0]);
                  FlagCY := !a283[15:8][0];
                  jump ((a307,a303));
                } else {
                  advance (10)
                  #0394
                  #instruction: DEC  A
                  let:8 a308 = a281 in
                  let:16 a309 = addWithCarry(!true,a308,~00) in
                  let:8 a310 = (a308 & 0F) in
                  let:8 a311 = (~00 & 0F) in
                  let:16 a312 = addWithCarry(!true,a310,a311) in
                  advance (5)
                  #0395
                  #instruction: LD   (201B),A
                  let:8 a313 = a309[7:0] in
                  M[201B] := a313;
                  advance (13)
                  #0398
                  #instruction: JP   036F
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:8 a314 = a7[15:8] in
                  let:8 a315 = a7[7:0] in
                  let:16 a316 = (-1 + (a314,a315)) in
                  M[a316] := 03;
                  let:8 a317 = a316[15:8] in
                  let:8 a318 = a316[7:0] in
                  let:16 a319 = (-1 + (a317,a318)) in
                  M[a319] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  let:8 a320 = M[2018] in
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  let:8 a321 = M[2019] in
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  let:8 a322 = M[201A] in
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  let:8 a323 = M[201B] in
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  let:8 a324 = M[201C] in
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  let:8 a325 = a323 in
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  let:8 a326 = a322 in
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:8 a327 = a319[15:8] in
                  let:8 a328 = a319[7:0] in
                  let:16 a329 = (1 + (a327,a328)) in
                  let:8 a330 = M[(a327,a328)] in
                  let:8 a331 = a329[15:8] in
                  let:8 a332 = a329[7:0] in
                  let:16 a333 = (1 + (a331,a332)) in
                  let:8 a334 = M[(a331,a332)] in
                  advance (10)
                  A := a322;
                  B := a324;
                  C := a323;
                  D := a321;
                  E := a320;
                  H := a325;
                  L := a326;
                  SPH := a333[15:8];
                  SPL := a333[7:0];
                  FlagS := a309[7:0][7];
                  FlagZ := is_zero(a309[7:0]);
                  FlagA := a312[7:0][4];
                  FlagP := parity(a309[7:0]);
                  FlagCY := !a283[15:8][0];
                  jump ((a334,a330));
                }
              } else {
                advance (10)
                #0360
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a335 = a7[15:8] in
                let:8 a336 = a7[7:0] in
                let:16 a337 = (-1 + (a335,a336)) in
                M[a337] := 03;
                let:8 a338 = a337[15:8] in
                let:8 a339 = a337[7:0] in
                let:16 a340 = (-1 + (a338,a339)) in
                M[a340] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a341 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a342 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a343 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a344 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a345 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a346 = a344 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a347 = a343 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a348 = a340[15:8] in
                let:8 a349 = a340[7:0] in
                let:16 a350 = (1 + (a348,a349)) in
                let:8 a351 = M[(a348,a349)] in
                let:8 a352 = a350[15:8] in
                let:8 a353 = a350[7:0] in
                let:16 a354 = (1 + (a352,a353)) in
                let:8 a355 = M[(a352,a353)] in
                advance (10)
                A := a343;
                B := a345;
                C := a344;
                D := a342;
                E := a341;
                H := a346;
                L := a347;
                SPH := a354[15:8];
                SPL := a354[7:0];
                FlagS := a198[7];
                FlagZ := is_zero(a198);
                FlagA := a199[3];
                FlagP := parity(a198);
                FlagCY := a280[0];
                jump ((a355,a351));
              }
            }
          }
        } else {
          advance (10)
          #03B8
          #instruction: JP   0346
          advance (10)
          #0346
          #instruction: NOP
          advance (4)
          #0347
          #instruction: DEC  HL
          advance (5)
          #0348
          #instruction: LD   (HL),01
          M[2069] := 01;
          advance (10)
          #034A
          #instruction: LD   A,(201B)
          let:8 a356 = M[201B] in
          advance (13)
          #034D
          #instruction: LD   B,A
          let:8 a357 = a356 in
          advance (5)
          #034E
          #instruction: LD   A,(20EF)
          let:8 a358 = M[20EF] in
          advance (13)
          #0351
          #instruction: AND  A
          let:8 a359 = a358 in
          let:8 a360 = a358 in
          let:8 a361 = (a359 & a360) in
          let:8 a362 = (a359 | a360) in
          advance (4)
          #0352
          #instruction: JP   NZ,0363
          if (!is_zero(a361)) {
            advance (10)
            #0363
            #instruction: CALL 17C0
            let:8 a363 = a7[15:8] in
            let:8 a364 = a7[7:0] in
            let:16 a365 = (-1 + (a363,a364)) in
            M[a365] := 03;
            let:8 a366 = a365[15:8] in
            let:8 a367 = a365[7:0] in
            let:16 a368 = (-1 + (a366,a367)) in
            M[a368] := 66;
            #return-to: 0366
            advance (17)
            #17C0
            #instruction: LD   A,(2067)
            let:8 a369 = M[2067] in
            advance (13)
            #17C3
            #instruction: RRCA
            let:8 a370 = a369 in
            advance (4)
            #17C4
            #instruction: JP   NC,17CA
            if (!a370[0]) {
              advance (10)
              #17CA
              #instruction: IN   02
              advance (10)
              #17CC
              #instruction: RET
              let:8 a371 = a368[15:8] in
              let:8 a372 = a368[7:0] in
              let:16 a373 = (1 + (a371,a372)) in
              let:8 a374 = M[(a371,a372)] in
              let:8 a375 = a373[15:8] in
              let:8 a376 = a373[7:0] in
              let:16 a377 = (1 + (a375,a376)) in
              let:8 a378 = M[(a375,a376)] in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
              B := a357;
              H := 20;
              L := 69;
              SPH := a377[15:8];
              SPL := a377[7:0];
              FlagS := a361[7];
              FlagZ := is_zero(a361);
              FlagA := a362[3];
              FlagP := parity(a361);
              FlagCY := a370[0];
              jump ((a378,a374));
            } else {
              advance (10)
              #17C7
              #instruction: IN   01
              advance (10)
              #17C9
              #instruction: RET
              let:8 a379 = a368[15:8] in
              let:8 a380 = a368[7:0] in
              let:16 a381 = (1 + (a379,a380)) in
              let:8 a382 = M[(a379,a380)] in
              let:8 a383 = a381[15:8] in
              let:8 a384 = a381[7:0] in
              let:16 a385 = (1 + (a383,a384)) in
              let:8 a386 = M[(a383,a384)] in
              advance (10)
              A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
              B := a357;
              H := 20;
              L := 69;
              SPH := a385[15:8];
              SPL := a385[7:0];
              FlagS := a361[7];
              FlagZ := is_zero(a361);
              FlagA := a362[3];
              FlagP := parity(a361);
              FlagCY := a370[0];
              jump ((a386,a382));
            }
          } else {
            advance (10)
            #0355
            #instruction: LD   A,(201D)
            let:8 a387 = M[201D] in
            advance (13)
            #0358
            #instruction: RRCA
            let:8 a388 = a387 in
            advance (4)
            #0359
            #instruction: JP   CY,0381
            if (a388[0]) {
              advance (10)
              #0381
              #instruction: LD   A,B
              let:8 a389 = a357 in
              advance (5)
              #0382
              #instruction: CP   D9
              let:8 a390 = a389 in
              let:16 a391 = addWithCarry(!false,a390,~D9) in
              let:8 a392 = (a390 & 0F) in
              let:8 a393 = (~D9 & 0F) in
              let:16 a394 = addWithCarry(!false,a392,a393) in
              advance (7)
              #0384
              #instruction: JP   Z,036F
              if (is_zero(a391[7:0])) {
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a395 = a7[15:8] in
                let:8 a396 = a7[7:0] in
                let:16 a397 = (-1 + (a395,a396)) in
                M[a397] := 03;
                let:8 a398 = a397[15:8] in
                let:8 a399 = a397[7:0] in
                let:16 a400 = (-1 + (a398,a399)) in
                M[a400] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a401 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a402 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a403 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a404 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a405 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a406 = a404 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a407 = a403 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a408 = a400[15:8] in
                let:8 a409 = a400[7:0] in
                let:16 a410 = (1 + (a408,a409)) in
                let:8 a411 = M[(a408,a409)] in
                let:8 a412 = a410[15:8] in
                let:8 a413 = a410[7:0] in
                let:16 a414 = (1 + (a412,a413)) in
                let:8 a415 = M[(a412,a413)] in
                advance (10)
                A := a403;
                B := a405;
                C := a404;
                D := a402;
                E := a401;
                H := a406;
                L := a407;
                SPH := a414[15:8];
                SPL := a414[7:0];
                FlagS := a391[7:0][7];
                FlagZ := is_zero(a391[7:0]);
                FlagA := a394[7:0][4];
                FlagP := parity(a391[7:0]);
                FlagCY := !a391[15:8][0];
                jump ((a415,a411));
              } else {
                advance (10)
                #0387
                #instruction: INC  A
                let:8 a416 = a389 in
                let:16 a417 = addWithCarry(true,a416,00) in
                let:8 a418 = (a416 & 0F) in
                let:8 a419 = (00 & 0F) in
                let:16 a420 = addWithCarry(true,a418,a419) in
                advance (5)
                #0388
                #instruction: LD   (201B),A
                let:8 a421 = a417[7:0] in
                M[201B] := a421;
                advance (13)
                #038B
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a422 = a7[15:8] in
                let:8 a423 = a7[7:0] in
                let:16 a424 = (-1 + (a422,a423)) in
                M[a424] := 03;
                let:8 a425 = a424[15:8] in
                let:8 a426 = a424[7:0] in
                let:16 a427 = (-1 + (a425,a426)) in
                M[a427] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a428 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a429 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a430 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a431 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a432 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a433 = a431 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a434 = a430 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a435 = a427[15:8] in
                let:8 a436 = a427[7:0] in
                let:16 a437 = (1 + (a435,a436)) in
                let:8 a438 = M[(a435,a436)] in
                let:8 a439 = a437[15:8] in
                let:8 a440 = a437[7:0] in
                let:16 a441 = (1 + (a439,a440)) in
                let:8 a442 = M[(a439,a440)] in
                advance (10)
                A := a430;
                B := a432;
                C := a431;
                D := a429;
                E := a428;
                H := a433;
                L := a434;
                SPH := a441[15:8];
                SPL := a441[7:0];
                FlagS := a417[7:0][7];
                FlagZ := is_zero(a417[7:0]);
                FlagA := a420[7:0][4];
                FlagP := parity(a417[7:0]);
                FlagCY := !a391[15:8][0];
                jump ((a442,a438));
              }
            } else {
              advance (10)
              #035C
              #instruction: RRCA
              let:8 a443 = updateBit((a388 >> 01),7,a388[0]) in
              advance (4)
              #035D
              #instruction: JP   CY,038E
              if (a443[0]) {
                advance (10)
                #038E
                #instruction: LD   A,B
                let:8 a444 = a357 in
                advance (5)
                #038F
                #instruction: CP   30
                let:8 a445 = a444 in
                let:16 a446 = addWithCarry(!false,a445,~30) in
                let:8 a447 = (a445 & 0F) in
                let:8 a448 = (~30 & 0F) in
                let:16 a449 = addWithCarry(!false,a447,a448) in
                advance (7)
                #0391
                #instruction: JP   Z,036F
                if (is_zero(a446[7:0])) {
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:8 a450 = a7[15:8] in
                  let:8 a451 = a7[7:0] in
                  let:16 a452 = (-1 + (a450,a451)) in
                  M[a452] := 03;
                  let:8 a453 = a452[15:8] in
                  let:8 a454 = a452[7:0] in
                  let:16 a455 = (-1 + (a453,a454)) in
                  M[a455] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  let:8 a456 = M[2018] in
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  let:8 a457 = M[2019] in
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  let:8 a458 = M[201A] in
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  let:8 a459 = M[201B] in
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  let:8 a460 = M[201C] in
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  let:8 a461 = a459 in
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  let:8 a462 = a458 in
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:8 a463 = a455[15:8] in
                  let:8 a464 = a455[7:0] in
                  let:16 a465 = (1 + (a463,a464)) in
                  let:8 a466 = M[(a463,a464)] in
                  let:8 a467 = a465[15:8] in
                  let:8 a468 = a465[7:0] in
                  let:16 a469 = (1 + (a467,a468)) in
                  let:8 a470 = M[(a467,a468)] in
                  advance (10)
                  A := a458;
                  B := a460;
                  C := a459;
                  D := a457;
                  E := a456;
                  H := a461;
                  L := a462;
                  SPH := a469[15:8];
                  SPL := a469[7:0];
                  FlagS := a446[7:0][7];
                  FlagZ := is_zero(a446[7:0]);
                  FlagA := a449[7:0][4];
                  FlagP := parity(a446[7:0]);
                  FlagCY := !a446[15:8][0];
                  jump ((a470,a466));
                } else {
                  advance (10)
                  #0394
                  #instruction: DEC  A
                  let:8 a471 = a444 in
                  let:16 a472 = addWithCarry(!true,a471,~00) in
                  let:8 a473 = (a471 & 0F) in
                  let:8 a474 = (~00 & 0F) in
                  let:16 a475 = addWithCarry(!true,a473,a474) in
                  advance (5)
                  #0395
                  #instruction: LD   (201B),A
                  let:8 a476 = a472[7:0] in
                  M[201B] := a476;
                  advance (13)
                  #0398
                  #instruction: JP   036F
                  advance (10)
                  #036F
                  #instruction: LD   HL,2018
                  advance (10)
                  #0372
                  #instruction: CALL 1A3B
                  let:8 a477 = a7[15:8] in
                  let:8 a478 = a7[7:0] in
                  let:16 a479 = (-1 + (a477,a478)) in
                  M[a479] := 03;
                  let:8 a480 = a479[15:8] in
                  let:8 a481 = a479[7:0] in
                  let:16 a482 = (-1 + (a480,a481)) in
                  M[a482] := 75;
                  #return-to: 0375
                  advance (17)
                  #1A3B
                  #instruction: LD   E,(HL)
                  let:8 a483 = M[2018] in
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  let:8 a484 = M[2019] in
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  let:8 a485 = M[201A] in
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  let:8 a486 = M[201B] in
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  let:8 a487 = M[201C] in
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  let:8 a488 = a486 in
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  let:8 a489 = a485 in
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:8 a490 = a482[15:8] in
                  let:8 a491 = a482[7:0] in
                  let:16 a492 = (1 + (a490,a491)) in
                  let:8 a493 = M[(a490,a491)] in
                  let:8 a494 = a492[15:8] in
                  let:8 a495 = a492[7:0] in
                  let:16 a496 = (1 + (a494,a495)) in
                  let:8 a497 = M[(a494,a495)] in
                  advance (10)
                  A := a485;
                  B := a487;
                  C := a486;
                  D := a484;
                  E := a483;
                  H := a488;
                  L := a489;
                  SPH := a496[15:8];
                  SPL := a496[7:0];
                  FlagS := a472[7:0][7];
                  FlagZ := is_zero(a472[7:0]);
                  FlagA := a475[7:0][4];
                  FlagP := parity(a472[7:0]);
                  FlagCY := !a446[15:8][0];
                  jump ((a497,a493));
                }
              } else {
                advance (10)
                #0360
                #instruction: JP   036F
                advance (10)
                #036F
                #instruction: LD   HL,2018
                advance (10)
                #0372
                #instruction: CALL 1A3B
                let:8 a498 = a7[15:8] in
                let:8 a499 = a7[7:0] in
                let:16 a500 = (-1 + (a498,a499)) in
                M[a500] := 03;
                let:8 a501 = a500[15:8] in
                let:8 a502 = a500[7:0] in
                let:16 a503 = (-1 + (a501,a502)) in
                M[a503] := 75;
                #return-to: 0375
                advance (17)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a504 = M[2018] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a505 = M[2019] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a506 = M[201A] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a507 = M[201B] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a508 = M[201C] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a509 = a507 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a510 = a506 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a511 = a503[15:8] in
                let:8 a512 = a503[7:0] in
                let:16 a513 = (1 + (a511,a512)) in
                let:8 a514 = M[(a511,a512)] in
                let:8 a515 = a513[15:8] in
                let:8 a516 = a513[7:0] in
                let:16 a517 = (1 + (a515,a516)) in
                let:8 a518 = M[(a515,a516)] in
                advance (10)
                A := a506;
                B := a508;
                C := a507;
                D := a505;
                E := a504;
                H := a509;
                L := a510;
                SPH := a517[15:8];
                SPL := a517[7:0];
                FlagS := a361[7];
                FlagZ := is_zero(a361);
                FlagA := a362[3];
                FlagP := parity(a361);
                FlagCY := a443[0];
                jump ((a518,a514));
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #0296
      #instruction: INC  HL
      let:8 a519 = a11[15:8] in
      let:8 a520 = a11[7:0] in
      let:16 a521 = (1 + (a519,a520)) in
      advance (5)
      #0297
      #instruction: DEC  (HL)
      let:8 a522 = a521[15:8] in
      let:8 a523 = a521[7:0] in
      let:8 a524 = M[(a522,a523)] in
      let:16 a525 = addWithCarry(!true,a524,~00) in
      let:8 a526 = (a524 & 0F) in
      let:8 a527 = (~00 & 0F) in
      let:16 a528 = addWithCarry(!true,a526,a527) in
      let:8 a529 = a521[15:8] in
      let:8 a530 = a521[7:0] in
      M[(a529,a530)] := a525[7:0];
      advance (10)
      #0298
      #instruction: RET  NZ
      if (!is_zero(a525[7:0])) {
        let:8 a531 = a7[15:8] in
        let:8 a532 = a7[7:0] in
        let:16 a533 = (1 + (a531,a532)) in
        let:8 a534 = M[(a531,a532)] in
        let:8 a535 = a533[15:8] in
        let:8 a536 = a533[7:0] in
        let:16 a537 = (1 + (a535,a536)) in
        let:8 a538 = M[(a535,a536)] in
        advance (11)
        A := a14;
        H := a521[15:8];
        L := a521[7:0];
        SPH := a537[15:8];
        SPL := a537[7:0];
        FlagS := a525[7:0][7];
        FlagZ := is_zero(a525[7:0]);
        FlagA := a528[7:0][4];
        FlagP := parity(a525[7:0]);
        FlagCY := !a16[15:8][0];
        jump ((a538,a534));
      } else {
        advance (5)
        #0299
        #instruction: LD   B,A
        let:8 a539 = a14 in
        advance (5)
        #029A
        #instruction: XOR  A
        let:8 a540 = a14 in
        let:8 a541 = a14 in
        let:8 a542 = (a540 ^ a541) in
        advance (4)
        #029B
        #instruction: LD   (2068),A
        let:8 a543 = a542 in
        M[2068] := a543;
        advance (13)
        #029E
        #instruction: LD   (2069),A
        let:8 a544 = a542 in
        M[2069] := a544;
        advance (13)
        #02A1
        #instruction: LD   A,30
        advance (7)
        #02A3
        #instruction: LD   (206A),A
        M[206A] := 30;
        advance (13)
        #02A6
        #instruction: LD   A,B
        let:8 a545 = a539 in
        advance (5)
        #02A7
        #instruction: LD   (HL),05
        let:8 a546 = a521[15:8] in
        let:8 a547 = a521[7:0] in
        M[(a546,a547)] := 05;
        advance (10)
        #02A9
        #instruction: INC  HL
        let:8 a548 = a521[15:8] in
        let:8 a549 = a521[7:0] in
        let:16 a550 = (1 + (a548,a549)) in
        advance (5)
        #02AA
        #instruction: DEC  (HL)
        let:8 a551 = a550[15:8] in
        let:8 a552 = a550[7:0] in
        let:8 a553 = M[(a551,a552)] in
        let:16 a554 = addWithCarry(!true,a553,~00) in
        let:8 a555 = (a553 & 0F) in
        let:8 a556 = (~00 & 0F) in
        let:16 a557 = addWithCarry(!true,a555,a556) in
        let:8 a558 = a550[15:8] in
        let:8 a559 = a550[7:0] in
        M[(a558,a559)] := a554[7:0];
        advance (10)
        #02AB
        #instruction: JP   NZ,039B
        if (!is_zero(a554[7:0])) {
          advance (10)
          #039B
          #instruction: INC  A
          let:8 a560 = a545 in
          let:16 a561 = addWithCarry(true,a560,00) in
          let:8 a562 = (a560 & 0F) in
          let:8 a563 = (00 & 0F) in
          let:16 a564 = addWithCarry(true,a562,a563) in
          advance (5)
          #039C
          #instruction: AND  01
          let:8 a565 = a561[7:0] in
          let:8 a566 = (01 & a565) in
          let:8 a567 = (01 | a565) in
          advance (7)
          #039E
          #instruction: LD   (2015),A
          let:8 a568 = a566 in
          M[2015] := a568;
          advance (13)
          #03A1
          #instruction: RLCA
          let:8 a569 = a566 in
          advance (4)
          #03A2
          #instruction: RLCA
          let:8 a570 = updateBit((a569 << 01),0,a569[7]) in
          advance (4)
          #03A3
          #instruction: RLCA
          let:8 a571 = updateBit((a570 << 01),0,a570[7]) in
          advance (4)
          #03A4
          #instruction: RLCA
          let:8 a572 = updateBit((a571 << 01),0,a571[7]) in
          advance (4)
          #03A5
          #instruction: LD   HL,1C70
          advance (10)
          #03A8
          #instruction: ADD  L
          let:8 a573 = updateBit((a572 << 01),0,a572[7]) in
          let:16 a574 = addWithCarry(false,70,a573) in
          let:8 a575 = (70 & 0F) in
          let:8 a576 = (a573 & 0F) in
          let:16 a577 = addWithCarry(false,a575,a576) in
          advance (4)
          #03A9
          #instruction: LD   L,A
          let:8 a578 = a574[7:0] in
          advance (5)
          #03AA
          #instruction: LD   (2018),HL
          let:8 a579 = a578 in
          M[2018] := a579;
          M[2019] := 1C;
          advance (16)
          #03AD
          #instruction: JP   036F
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:8 a580 = a7[15:8] in
          let:8 a581 = a7[7:0] in
          let:16 a582 = (-1 + (a580,a581)) in
          M[a582] := 03;
          let:8 a583 = a582[15:8] in
          let:8 a584 = a582[7:0] in
          let:16 a585 = (-1 + (a583,a584)) in
          M[a585] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a586 = M[2018] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a587 = M[2019] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a588 = M[201A] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a589 = M[201B] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a590 = M[201C] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a591 = a589 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a592 = a588 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a593 = a585[15:8] in
          let:8 a594 = a585[7:0] in
          let:16 a595 = (1 + (a593,a594)) in
          let:8 a596 = M[(a593,a594)] in
          let:8 a597 = a595[15:8] in
          let:8 a598 = a595[7:0] in
          let:16 a599 = (1 + (a597,a598)) in
          let:8 a600 = M[(a597,a598)] in
          advance (10)
          A := a588;
          B := a590;
          C := a589;
          D := a587;
          E := a586;
          H := a591;
          L := a592;
          SPH := a599[15:8];
          SPL := a599[7:0];
          FlagS := a574[7:0][7];
          FlagZ := is_zero(a574[7:0]);
          FlagA := a577[7:0][4];
          FlagP := parity(a574[7:0]);
          FlagCY := a574[15:8][0];
          jump ((a600,a596));
        } else {
          advance (10)
          #02AE
          #instruction: LD   HL,(201A)
          let:8 a601 = M[201A] in
          let:8 a602 = M[201B] in
          advance (16)
          #02B1
          #instruction: LD   B,10
          advance (7)
          #02B3
          #instruction: CALL 1424
          let:8 a603 = a7[15:8] in
          let:8 a604 = a7[7:0] in
          let:16 a605 = (-1 + (a603,a604)) in
          M[a605] := 02;
          let:8 a606 = a605[15:8] in
          let:8 a607 = a605[7:0] in
          let:16 a608 = (-1 + (a606,a607)) in
          M[a608] := B6;
          #return-to: 02B6
          advance (17)
          #1424
          #instruction: CALL 1474
          let:8 a609 = a608[15:8] in
          let:8 a610 = a608[7:0] in
          let:16 a611 = (-1 + (a609,a610)) in
          M[a611] := 14;
          let:8 a612 = a611[15:8] in
          let:8 a613 = a611[7:0] in
          let:16 a614 = (-1 + (a612,a613)) in
          M[a614] := 27;
          #return-to: 1427
          advance (17)
          #1474
          #instruction: LD   A,L
          let:8 a615 = a601 in
          advance (5)
          #1475
          #instruction: AND  07
          let:8 a616 = a615 in
          let:8 a617 = (07 & a616) in
          let:8 a618 = (07 | a616) in
          advance (7)
          #1477
          #instruction: OUT  02
          let:8 a619 = a617 in
          advance (10)
          #1479
          #instruction: JP   1A47
          advance (10)
          #1A47
          #instruction: PUSH BC
          let:8 a620 = C in
          let:8 a621 = a614[15:8] in
          let:8 a622 = a614[7:0] in
          let:16 a623 = (-1 + (a621,a622)) in
          M[a623] := 10;
          let:8 a624 = a623[15:8] in
          let:8 a625 = a623[7:0] in
          let:16 a626 = (-1 + (a624,a625)) in
          M[a626] := a620;
          advance (11)
          #1A48
          #instruction: LD   B,03
          advance (7)
          #1A4A
          #instruction: LD   A,H
          let:8 a627 = a602 in
          advance (5)
          #1A4B
          #instruction: RAR
          let:8 a628 = a627 in
          advance (4)
          #1A4C
          #instruction: LD   H,A
          let:8 a629 = updateBit((a628 >> 01),7,false) in
          advance (5)
          #1A4D
          #instruction: LD   A,L
          let:8 a630 = a601 in
          advance (5)
          #1A4E
          #instruction: RAR
          let:8 a631 = a630 in
          advance (4)
          #1A4F
          #instruction: LD   L,A
          let:8 a632 = updateBit((a631 >> 01),7,a628[0]) in
          advance (5)
          #1A50
          #instruction: DEC  B
          let:16 a633 = addWithCarry(!true,03,~00) in
          let:8 a634 = (03 & 0F) in
          let:8 a635 = (~00 & 0F) in
          let:16 a636 = addWithCarry(!true,a634,a635) in
          advance (5)
          #1A51
          #instruction: JP   NZ,1A4A
          if (!is_zero(a633[7:0])) {
            advance (10)
            A := updateBit((a631 >> 01),7,a628[0]);
            B := a633[7:0];
            H := a629;
            L := a632;
            SPH := a626[15:8];
            SPL := a626[7:0];
            FlagS := a633[7:0][7];
            FlagZ := is_zero(a633[7:0]);
            FlagA := a636[7:0][4];
            FlagP := parity(a633[7:0]);
            FlagCY := a631[0];
            Shifter_OFF := a619;
            jump (1A4A);
          } else {
            advance (10)
            #1A54
            #instruction: LD   A,H
            let:8 a637 = a629 in
            advance (5)
            #1A55
            #instruction: AND  3F
            let:8 a638 = a637 in
            let:8 a639 = (3F & a638) in
            let:8 a640 = (3F | a638) in
            advance (7)
            #1A57
            #instruction: OR   20
            let:8 a641 = a639 in
            let:8 a642 = (20 | a641) in
            advance (7)
            #1A59
            #instruction: LD   H,A
            let:8 a643 = a642 in
            advance (5)
            #1A5A
            #instruction: POP  BC
            let:8 a644 = a626[15:8] in
            let:8 a645 = a626[7:0] in
            let:16 a646 = (1 + (a644,a645)) in
            let:8 a647 = M[(a644,a645)] in
            let:8 a648 = a646[15:8] in
            let:8 a649 = a646[7:0] in
            let:16 a650 = (1 + (a648,a649)) in
            let:8 a651 = M[(a648,a649)] in
            advance (10)
            #1A5B
            #instruction: RET
            let:8 a652 = a650[15:8] in
            let:8 a653 = a650[7:0] in
            let:16 a654 = (1 + (a652,a653)) in
            let:8 a655 = M[(a652,a653)] in
            let:8 a656 = a654[15:8] in
            let:8 a657 = a654[7:0] in
            let:16 a658 = (1 + (a656,a657)) in
            let:8 a659 = M[(a656,a657)] in
            advance (10)
            A := a642;
            B := a651;
            C := a647;
            H := a643;
            L := a632;
            SPH := a658[15:8];
            SPL := a658[7:0];
            FlagS := a642[7];
            FlagZ := is_zero(a642);
            FlagA := false;
            FlagP := parity(a642);
            FlagCY := false;
            Shifter_OFF := a619;
            jump ((a659,a655));
          }
        }
      }
    }

02B6:

    #02B6
    #instruction: LD   HL,2010
    advance (10)
    #02B9
    #instruction: LD   DE,1B10
    advance (10)
    #02BC
    #instruction: LD   B,10
    advance (7)
    #02BE
    #instruction: CALL 1A32
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 02C1
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2010] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,10,~00) in
    let:8 a8 = (10 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 11;
      H := 20;
      L := 11;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 11;
      H := 20;
      L := 11;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

02C1:

    #02C1
    #instruction: LD   B,00
    advance (7)
    #02C3
    #instruction: CALL 19DC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C6;
    #return-to: 02C6
    advance (17)
    #19DC
    #instruction: LD   A,(2094)
    let:8 a7 = M[2094] in
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a8 = a7 in
    let:8 a9 = (00 & a8) in
    let:8 a10 = (00 | a8) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    let:8 a11 = a9 in
    M[2094] := a11;
    advance (13)
    #19E3
    #instruction: OUT  03
    let:8 a12 = a9 in
    sound_control(Ufo,a12[0]);
    sound_control(Shot,a12[1]);
    sound_control(PlayerDie,a12[2]);
    sound_control(InvaderDie,a12[3]);
    sound_control(ExtraLife,a12[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a9;
    B := 00;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := a10[3];
    FlagP := parity(a9);
    FlagCY := false;
    jump ((a20,a16));

02C6:

    #02C6
    #instruction: LD   A,(206D)
    let:8 a1 = M[206D] in
    advance (13)
    #02C9
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #02CA
    #instruction: RET  NZ
    if (!is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #02CB
      #instruction: LD   A,(20EF)
      let:8 a14 = M[20EF] in
      advance (13)
      #02CE
      #instruction: AND  A
      let:8 a15 = a14 in
      let:8 a16 = a14 in
      let:8 a17 = (a15 & a16) in
      let:8 a18 = (a15 | a16) in
      advance (4)
      #02CF
      #instruction: RET  Z
      if (is_zero(a17)) {
        let:8 a19 = SPH in
        let:8 a20 = SPL in
        let:16 a21 = (1 + (a19,a20)) in
        let:8 a22 = M[(a19,a20)] in
        let:8 a23 = a21[15:8] in
        let:8 a24 = a21[7:0] in
        let:16 a25 = (1 + (a23,a24)) in
        let:8 a26 = M[(a23,a24)] in
        advance (11)
        A := a17;
        SPH := a25[15:8];
        SPL := a25[7:0];
        FlagS := a17[7];
        FlagZ := is_zero(a17);
        FlagA := a18[3];
        FlagP := parity(a17);
        FlagCY := false;
        jump ((a26,a22));
      } else {
        advance (5)
        #02D0
        #instruction: LD   SP,2400
        advance (10)
        #02D3
        #instruction: EI
        enable_interrupts()
        advance (4)
        #02D4
        #instruction: CALL 19D7
        M[23FF] := 02;
        M[23FE] := D7;
        #return-to: 02D7
        advance (17)
        #19D7
        #instruction: XOR  A
        let:8 a27 = a17 in
        let:8 a28 = a17 in
        let:8 a29 = (a27 ^ a28) in
        advance (4)
        #19D8
        #instruction: JP   19D3
        advance (10)
        #19D3
        #instruction: LD   (20E9),A
        let:8 a30 = a29 in
        M[20E9] := a30;
        advance (13)
        #19D6
        #instruction: RET
        let:8 a31 = M[23FE] in
        let:8 a32 = M[23FF] in
        advance (10)
        A := a29;
        SPH := 24;
        SPL := 00;
        FlagS := a29[7];
        FlagZ := is_zero(a29);
        FlagA := false;
        FlagP := parity(a29);
        FlagCY := false;
        jump ((a32,a31));
      }
    }

02D7:

    #02D7
    #instruction: CALL 092E
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 02DA
    advance (17)
    #092E
    #instruction: CALL 1611
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a13 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a14 = a13 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a15 = a12[15:8] in
    let:8 a16 = a12[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a13;
    H := a14;
    L := 00;
    SPH := a21[15:8];
    SPL := a21[7:0];
    jump ((a22,a18));

02DA:

    #02DA
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    #02DB
    #instruction: JP   Z,166D
    if (is_zero(a3)) {
      advance (10)
      #166D
      #instruction: XOR  A
      let:8 a5 = a3 in
      let:8 a6 = a3 in
      let:8 a7 = (a5 ^ a6) in
      advance (4)
      #166E
      #instruction: CALL 1A8B
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 16;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 71;
      #return-to: 1671
      advance (17)
      #1A8B
      #instruction: LD   HL,2501
      advance (10)
      #1A8E
      #instruction: AND  0F
      let:8 a14 = a7 in
      let:8 a15 = (0F & a14) in
      let:8 a16 = (0F | a14) in
      advance (7)
      #1A90
      #instruction: JP   09C5
      advance (10)
      #09C5
      #instruction: ADD  1A
      let:8 a17 = a15 in
      let:16 a18 = addWithCarry(false,1A,a17) in
      let:8 a19 = (1A & 0F) in
      let:8 a20 = (a17 & 0F) in
      let:16 a21 = addWithCarry(false,a19,a20) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a22 = a13[15:8] in
      let:8 a23 = a13[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 25;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a28 = a18[7:0] in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a29 = a28 in
      let:8 a30 = a28 in
      let:17 a31 = add17((00,a29),(00,a30)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a32 = a31[15:0][15:8] in
      let:8 a33 = a31[15:0][7:0] in
      let:8 a34 = a31[15:0][15:8] in
      let:8 a35 = a31[15:0][7:0] in
      let:17 a36 = add17((a32,a33),(a34,a35)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a37 = a36[15:0][15:8] in
      let:8 a38 = a36[15:0][7:0] in
      let:8 a39 = a36[15:0][15:8] in
      let:8 a40 = a36[15:0][7:0] in
      let:17 a41 = add17((a37,a38),(a39,a40)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a42 = a41[15:0][15:8] in
      let:8 a43 = a41[15:0][7:0] in
      let:17 a44 = add17(1E00,(a42,a43)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a45 = a44[15:0][15:8] in
      let:8 a46 = a44[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a47 = a27[15:8] in
      let:8 a48 = a27[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      let:8 a51 = a49[15:8] in
      let:8 a52 = a49[7:0] in
      let:16 a53 = (1 + (a51,a52)) in
      let:8 a54 = M[(a51,a52)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a55 = a18[7:0] in
      unknown_output(6,a55);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a56 = C in
      let:8 a57 = a53[15:8] in
      let:8 a58 = a53[7:0] in
      let:16 a59 = (-1 + (a57,a58)) in
      M[a59] := 08;
      let:8 a60 = a59[15:8] in
      let:8 a61 = a59[7:0] in
      let:16 a62 = (-1 + (a60,a61)) in
      M[a62] := a56;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a63 = a45 in
      let:8 a64 = a46 in
      let:8 a65 = M[(a63,a64)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a66 = a65 in
      let:8 a67 = a54 in
      let:8 a68 = a50 in
      M[(a67,a68)] := a66;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a69 = a45 in
      let:8 a70 = a46 in
      let:16 a71 = (1 + (a69,a70)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a72 = a54 in
      let:8 a73 = a50 in
      let:17 a74 = add17(0020,(a72,a73)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a75 = a62[15:8] in
      let:8 a76 = a62[7:0] in
      let:16 a77 = (1 + (a75,a76)) in
      let:8 a78 = M[(a75,a76)] in
      let:8 a79 = a77[15:8] in
      let:8 a80 = a77[7:0] in
      let:16 a81 = (1 + (a79,a80)) in
      let:8 a82 = M[(a79,a80)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a83 = a82 in
      let:16 a84 = addWithCarry(!true,a83,~00) in
      let:8 a85 = (a83 & 0F) in
      let:8 a86 = (~00 & 0F) in
      let:16 a87 = addWithCarry(!true,a85,a86) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a84[7:0])) {
        advance (10)
        A := a65;
        B := a84[7:0];
        C := a78;
        D := a71[15:8];
        E := a71[7:0];
        H := a74[15:0][15:8];
        L := a74[15:0][7:0];
        SPH := a81[15:8];
        SPL := a81[7:0];
        FlagS := a84[7:0][7];
        FlagZ := is_zero(a84[7:0]);
        FlagA := a87[7:0][4];
        FlagP := parity(a84[7:0]);
        FlagCY := a74[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a88 = a81[15:8] in
        let:8 a89 = a81[7:0] in
        let:16 a90 = (1 + (a88,a89)) in
        let:8 a91 = M[(a88,a89)] in
        let:8 a92 = a90[15:8] in
        let:8 a93 = a90[7:0] in
        let:16 a94 = (1 + (a92,a93)) in
        let:8 a95 = M[(a92,a93)] in
        advance (10)
        A := a65;
        B := a84[7:0];
        C := a78;
        D := a71[15:8];
        E := a71[7:0];
        H := a74[15:0][15:8];
        L := a74[15:0][7:0];
        SPH := a94[15:8];
        SPL := a94[7:0];
        FlagS := a84[7:0][7];
        FlagZ := is_zero(a84[7:0]);
        FlagA := a87[7:0][4];
        FlagP := parity(a84[7:0]);
        FlagCY := a74[16];
        jump ((a95,a91));
      }
    } else {
      advance (10)
      #02DE
      #instruction: CALL 18E7
      let:8 a96 = SPH in
      let:8 a97 = SPL in
      let:16 a98 = (-1 + (a96,a97)) in
      M[a98] := 02;
      let:8 a99 = a98[15:8] in
      let:8 a100 = a98[7:0] in
      let:16 a101 = (-1 + (a99,a100)) in
      M[a101] := E1;
      #return-to: 02E1
      advance (17)
      #18E7
      #instruction: LD   A,(2067)
      let:8 a102 = M[2067] in
      advance (13)
      #18EA
      #instruction: LD   HL,20E7
      advance (10)
      #18ED
      #instruction: RRCA
      let:8 a103 = a102 in
      advance (4)
      #18EE
      #instruction: RET  NC
      if (!a103[0]) {
        let:8 a104 = a101[15:8] in
        let:8 a105 = a101[7:0] in
        let:16 a106 = (1 + (a104,a105)) in
        let:8 a107 = M[(a104,a105)] in
        let:8 a108 = a106[15:8] in
        let:8 a109 = a106[7:0] in
        let:16 a110 = (1 + (a108,a109)) in
        let:8 a111 = M[(a108,a109)] in
        advance (11)
        A := updateBit((a103 >> 01),7,a103[0]);
        H := 20;
        L := E7;
        SPH := a110[15:8];
        SPL := a110[7:0];
        FlagS := a3[7];
        FlagZ := is_zero(a3);
        FlagA := a4[3];
        FlagP := parity(a3);
        FlagCY := a103[0];
        jump ((a111,a107));
      } else {
        advance (5)
        #18EF
        #instruction: INC  HL
        advance (5)
        #18F0
        #instruction: RET
        let:8 a112 = a101[15:8] in
        let:8 a113 = a101[7:0] in
        let:16 a114 = (1 + (a112,a113)) in
        let:8 a115 = M[(a112,a113)] in
        let:8 a116 = a114[15:8] in
        let:8 a117 = a114[7:0] in
        let:16 a118 = (1 + (a116,a117)) in
        let:8 a119 = M[(a116,a117)] in
        advance (10)
        A := updateBit((a103 >> 01),7,a103[0]);
        H := 20;
        L := E8;
        SPH := a118[15:8];
        SPL := a118[7:0];
        FlagS := a3[7];
        FlagZ := is_zero(a3);
        FlagA := a4[3];
        FlagP := parity(a3);
        FlagCY := a103[0];
        jump ((a119,a115));
      }
    }

02E1:

    #02E1
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #02E2
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #02E3
    #instruction: JP   Z,032C
    if (is_zero(a6)) {
      advance (10)
      #032C
      #instruction: CALL 1A7F
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 03;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 2F;
      #return-to: 032F
      advance (17)
      #1A7F
      #instruction: CALL 092E
      let:8 a14 = a13[15:8] in
      let:8 a15 = a13[7:0] in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 1A;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := 82;
      #return-to: 1A82
      advance (17)
      #092E
      #instruction: CALL 1611
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := 09;
      let:8 a23 = a22[15:8] in
      let:8 a24 = a22[7:0] in
      let:16 a25 = (-1 + (a23,a24)) in
      M[a25] := 31;
      #return-to: 0931
      advance (17)
      #1611
      #instruction: LD   L,00
      advance (7)
      #1613
      #instruction: LD   A,(2067)
      let:8 a26 = M[2067] in
      advance (13)
      #1616
      #instruction: LD   H,A
      let:8 a27 = a26 in
      advance (5)
      #1617
      #instruction: RET
      let:8 a28 = a25[15:8] in
      let:8 a29 = a25[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      A := a26;
      H := a27;
      L := 00;
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a6[7];
      FlagZ := is_zero(a6);
      FlagA := a7[3];
      FlagP := parity(a6);
      FlagCY := false;
      jump ((a35,a31));
    } else {
      advance (10)
      #02E6
      #instruction: LD   A,(20CE)
      let:8 a36 = M[20CE] in
      advance (13)
      #02E9
      #instruction: AND  A
      let:8 a37 = a36 in
      let:8 a38 = a36 in
      let:8 a39 = (a37 & a38) in
      let:8 a40 = (a37 | a38) in
      advance (4)
      #02EA
      #instruction: JP   Z,032C
      if (is_zero(a39)) {
        advance (10)
        #032C
        #instruction: CALL 1A7F
        let:8 a41 = SPH in
        let:8 a42 = SPL in
        let:16 a43 = (-1 + (a41,a42)) in
        M[a43] := 03;
        let:8 a44 = a43[15:8] in
        let:8 a45 = a43[7:0] in
        let:16 a46 = (-1 + (a44,a45)) in
        M[a46] := 2F;
        #return-to: 032F
        advance (17)
        #1A7F
        #instruction: CALL 092E
        let:8 a47 = a46[15:8] in
        let:8 a48 = a46[7:0] in
        let:16 a49 = (-1 + (a47,a48)) in
        M[a49] := 1A;
        let:8 a50 = a49[15:8] in
        let:8 a51 = a49[7:0] in
        let:16 a52 = (-1 + (a50,a51)) in
        M[a52] := 82;
        #return-to: 1A82
        advance (17)
        #092E
        #instruction: CALL 1611
        let:8 a53 = a52[15:8] in
        let:8 a54 = a52[7:0] in
        let:16 a55 = (-1 + (a53,a54)) in
        M[a55] := 09;
        let:8 a56 = a55[15:8] in
        let:8 a57 = a55[7:0] in
        let:16 a58 = (-1 + (a56,a57)) in
        M[a58] := 31;
        #return-to: 0931
        advance (17)
        #1611
        #instruction: LD   L,00
        advance (7)
        #1613
        #instruction: LD   A,(2067)
        let:8 a59 = M[2067] in
        advance (13)
        #1616
        #instruction: LD   H,A
        let:8 a60 = a59 in
        advance (5)
        #1617
        #instruction: RET
        let:8 a61 = a58[15:8] in
        let:8 a62 = a58[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        let:8 a65 = a63[15:8] in
        let:8 a66 = a63[7:0] in
        let:16 a67 = (1 + (a65,a66)) in
        let:8 a68 = M[(a65,a66)] in
        advance (10)
        A := a59;
        H := a60;
        L := 00;
        SPH := a67[15:8];
        SPL := a67[7:0];
        FlagS := a39[7];
        FlagZ := is_zero(a39);
        FlagA := a40[3];
        FlagP := parity(a39);
        FlagCY := false;
        jump ((a68,a64));
      } else {
        advance (10)
        #02ED
        #instruction: LD   A,(2067)
        let:8 a69 = M[2067] in
        advance (13)
        #02F0
        #instruction: PUSH PSW
        let:8 a70 = a69 in
        let:8 a71 = SPH in
        let:8 a72 = SPL in
        let:16 a73 = (-1 + (a71,a72)) in
        M[a73] := a70;
        let:8 a74 = a73[15:8] in
        let:8 a75 = a73[7:0] in
        let:16 a76 = (-1 + (a74,a75)) in
        M[a76] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a39[7]),6,is_zero(a39)),4,a40[3]),2,parity(a39)),0,false);
        advance (11)
        #02F1
        #instruction: RRCA
        let:8 a77 = a69 in
        advance (4)
        #02F2
        #instruction: JP   CY,0332
        if (a77[0]) {
          advance (10)
          #0332
          #instruction: CALL 0209
          let:8 a78 = a76[15:8] in
          let:8 a79 = a76[7:0] in
          let:16 a80 = (-1 + (a78,a79)) in
          M[a80] := 03;
          let:8 a81 = a80[15:8] in
          let:8 a82 = a80[7:0] in
          let:16 a83 = (-1 + (a81,a82)) in
          M[a83] := 35;
          #return-to: 0335
          advance (17)
          #0209
          #instruction: LD   A,01
          advance (7)
          #020B
          #instruction: JP   021B
          advance (10)
          #021B
          #instruction: LD   DE,2142
          advance (10)
          #021E
          #instruction: LD   (2081),A
          M[2081] := 01;
          advance (13)
          #0221
          #instruction: LD   BC,1602
          advance (10)
          #0224
          #instruction: LD   HL,2806
          advance (10)
          #0227
          #instruction: LD   A,04
          advance (7)
          #0229
          #instruction: PUSH PSW
          let:8 a84 = a83[15:8] in
          let:8 a85 = a83[7:0] in
          let:16 a86 = (-1 + (a84,a85)) in
          M[a86] := 04;
          let:8 a87 = a86[15:8] in
          let:8 a88 = a86[7:0] in
          let:16 a89 = (-1 + (a87,a88)) in
          M[a89] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a39[7]),6,is_zero(a39)),4,a40[3]),2,parity(a39)),0,a77[0]);
          advance (11)
          #022A
          #instruction: PUSH BC
          let:8 a90 = a89[15:8] in
          let:8 a91 = a89[7:0] in
          let:16 a92 = (-1 + (a90,a91)) in
          M[a92] := 16;
          let:8 a93 = a92[15:8] in
          let:8 a94 = a92[7:0] in
          let:16 a95 = (-1 + (a93,a94)) in
          M[a95] := 02;
          advance (11)
          #022B
          #instruction: LD   A,(2081)
          let:8 a96 = M[2081] in
          advance (13)
          #022E
          #instruction: AND  A
          let:8 a97 = a96 in
          let:8 a98 = a96 in
          let:8 a99 = (a97 & a98) in
          let:8 a100 = (a97 | a98) in
          advance (4)
          #022F
          #instruction: JP   NZ,0242
          if (!is_zero(a99)) {
            advance (10)
            #0242
            #instruction: CALL 147C
            let:8 a101 = a95[15:8] in
            let:8 a102 = a95[7:0] in
            let:16 a103 = (-1 + (a101,a102)) in
            M[a103] := 02;
            let:8 a104 = a103[15:8] in
            let:8 a105 = a103[7:0] in
            let:16 a106 = (-1 + (a104,a105)) in
            M[a106] := 45;
            #return-to: 0245
            advance (17)
            #147C
            #instruction: PUSH BC
            let:8 a107 = a106[15:8] in
            let:8 a108 = a106[7:0] in
            let:16 a109 = (-1 + (a107,a108)) in
            M[a109] := 16;
            let:8 a110 = a109[15:8] in
            let:8 a111 = a109[7:0] in
            let:16 a112 = (-1 + (a110,a111)) in
            M[a112] := 02;
            advance (11)
            #147D
            #instruction: PUSH HL
            let:8 a113 = a112[15:8] in
            let:8 a114 = a112[7:0] in
            let:16 a115 = (-1 + (a113,a114)) in
            M[a115] := 28;
            let:8 a116 = a115[15:8] in
            let:8 a117 = a115[7:0] in
            let:16 a118 = (-1 + (a116,a117)) in
            M[a118] := 06;
            advance (11)
            #147E
            #instruction: LD   A,(HL)
            let:8 a119 = M[2806] in
            advance (7)
            #147F
            #instruction: LD   (DE),A
            let:8 a120 = a119 in
            M[2142] := a120;
            advance (7)
            #1480
            #instruction: INC  DE
            advance (5)
            #1481
            #instruction: INC  HL
            advance (5)
            #1482
            #instruction: DEC  C
            let:16 a121 = addWithCarry(!true,02,~00) in
            let:8 a122 = (02 & 0F) in
            let:8 a123 = (~00 & 0F) in
            let:16 a124 = addWithCarry(!true,a122,a123) in
            advance (5)
            #1483
            #instruction: JP   NZ,147E
            if (!is_zero(a121[7:0])) {
              advance (10)
              A := a119;
              B := 16;
              C := a121[7:0];
              D := 21;
              E := 43;
              H := 28;
              L := 07;
              SPH := a118[15:8];
              SPL := a118[7:0];
              FlagS := a121[7:0][7];
              FlagZ := is_zero(a121[7:0]);
              FlagA := a124[7:0][4];
              FlagP := parity(a121[7:0]);
              FlagCY := false;
              jump (147E);
            } else {
              advance (10)
              #1486
              #instruction: POP  HL
              let:8 a125 = a118[15:8] in
              let:8 a126 = a118[7:0] in
              let:16 a127 = (1 + (a125,a126)) in
              let:8 a128 = M[(a125,a126)] in
              let:8 a129 = a127[15:8] in
              let:8 a130 = a127[7:0] in
              let:16 a131 = (1 + (a129,a130)) in
              let:8 a132 = M[(a129,a130)] in
              advance (10)
              #1487
              #instruction: LD   BC,0020
              advance (10)
              #148A
              #instruction: ADD  HL,BC
              let:8 a133 = a132 in
              let:8 a134 = a128 in
              let:17 a135 = add17(0020,(a133,a134)) in
              advance (10)
              #148B
              #instruction: POP  BC
              let:8 a136 = a131[15:8] in
              let:8 a137 = a131[7:0] in
              let:16 a138 = (1 + (a136,a137)) in
              let:8 a139 = M[(a136,a137)] in
              let:8 a140 = a138[15:8] in
              let:8 a141 = a138[7:0] in
              let:16 a142 = (1 + (a140,a141)) in
              let:8 a143 = M[(a140,a141)] in
              advance (10)
              #148C
              #instruction: DEC  B
              let:8 a144 = a143 in
              let:16 a145 = addWithCarry(!true,a144,~00) in
              let:8 a146 = (a144 & 0F) in
              let:8 a147 = (~00 & 0F) in
              let:16 a148 = addWithCarry(!true,a146,a147) in
              advance (5)
              #148D
              #instruction: JP   NZ,147C
              if (!is_zero(a145[7:0])) {
                advance (10)
                A := a119;
                B := a145[7:0];
                C := a139;
                D := 21;
                E := 43;
                H := a135[15:0][15:8];
                L := a135[15:0][7:0];
                SPH := a142[15:8];
                SPL := a142[7:0];
                FlagS := a145[7:0][7];
                FlagZ := is_zero(a145[7:0]);
                FlagA := a148[7:0][4];
                FlagP := parity(a145[7:0]);
                FlagCY := a135[16];
                jump (147C);
              } else {
                advance (10)
                #1490
                #instruction: RET
                let:8 a149 = a142[15:8] in
                let:8 a150 = a142[7:0] in
                let:16 a151 = (1 + (a149,a150)) in
                let:8 a152 = M[(a149,a150)] in
                let:8 a153 = a151[15:8] in
                let:8 a154 = a151[7:0] in
                let:16 a155 = (1 + (a153,a154)) in
                let:8 a156 = M[(a153,a154)] in
                advance (10)
                A := a119;
                B := a145[7:0];
                C := a139;
                D := 21;
                E := 43;
                H := a135[15:0][15:8];
                L := a135[15:0][7:0];
                SPH := a155[15:8];
                SPL := a155[7:0];
                FlagS := a145[7:0][7];
                FlagZ := is_zero(a145[7:0]);
                FlagA := a148[7:0][4];
                FlagP := parity(a145[7:0]);
                FlagCY := a135[16];
                jump ((a156,a152));
              }
            }
          } else {
            advance (10)
            #0232
            #instruction: CALL 1A69
            let:8 a157 = a95[15:8] in
            let:8 a158 = a95[7:0] in
            let:16 a159 = (-1 + (a157,a158)) in
            M[a159] := 02;
            let:8 a160 = a159[15:8] in
            let:8 a161 = a159[7:0] in
            let:16 a162 = (-1 + (a160,a161)) in
            M[a162] := 35;
            #return-to: 0235
            advance (17)
            #1A69
            #instruction: PUSH BC
            let:8 a163 = a162[15:8] in
            let:8 a164 = a162[7:0] in
            let:16 a165 = (-1 + (a163,a164)) in
            M[a165] := 16;
            let:8 a166 = a165[15:8] in
            let:8 a167 = a165[7:0] in
            let:16 a168 = (-1 + (a166,a167)) in
            M[a168] := 02;
            advance (11)
            #1A6A
            #instruction: PUSH HL
            let:8 a169 = a168[15:8] in
            let:8 a170 = a168[7:0] in
            let:16 a171 = (-1 + (a169,a170)) in
            M[a171] := 28;
            let:8 a172 = a171[15:8] in
            let:8 a173 = a171[7:0] in
            let:16 a174 = (-1 + (a172,a173)) in
            M[a174] := 06;
            advance (11)
            #1A6B
            #instruction: LD   A,(DE)
            let:8 a175 = M[2142] in
            advance (7)
            #1A6C
            #instruction: OR   (HL)
            let:8 a176 = M[2806] in
            let:8 a177 = a175 in
            let:8 a178 = (a176 | a177) in
            advance (7)
            #1A6D
            #instruction: LD   (HL),A
            let:8 a179 = a178 in
            M[2806] := a179;
            advance (7)
            #1A6E
            #instruction: INC  DE
            advance (5)
            #1A6F
            #instruction: INC  HL
            advance (5)
            #1A70
            #instruction: DEC  C
            let:16 a180 = addWithCarry(!true,02,~00) in
            let:8 a181 = (02 & 0F) in
            let:8 a182 = (~00 & 0F) in
            let:16 a183 = addWithCarry(!true,a181,a182) in
            advance (5)
            #1A71
            #instruction: JP   NZ,1A6B
            if (!is_zero(a180[7:0])) {
              advance (10)
              A := a178;
              B := 16;
              C := a180[7:0];
              D := 21;
              E := 43;
              H := 28;
              L := 07;
              SPH := a174[15:8];
              SPL := a174[7:0];
              FlagS := a180[7:0][7];
              FlagZ := is_zero(a180[7:0]);
              FlagA := a183[7:0][4];
              FlagP := parity(a180[7:0]);
              FlagCY := false;
              jump (1A6B);
            } else {
              advance (10)
              #1A74
              #instruction: POP  HL
              let:8 a184 = a174[15:8] in
              let:8 a185 = a174[7:0] in
              let:16 a186 = (1 + (a184,a185)) in
              let:8 a187 = M[(a184,a185)] in
              let:8 a188 = a186[15:8] in
              let:8 a189 = a186[7:0] in
              let:16 a190 = (1 + (a188,a189)) in
              let:8 a191 = M[(a188,a189)] in
              advance (10)
              #1A75
              #instruction: LD   BC,0020
              advance (10)
              #1A78
              #instruction: ADD  HL,BC
              let:8 a192 = a191 in
              let:8 a193 = a187 in
              let:17 a194 = add17(0020,(a192,a193)) in
              advance (10)
              #1A79
              #instruction: POP  BC
              let:8 a195 = a190[15:8] in
              let:8 a196 = a190[7:0] in
              let:16 a197 = (1 + (a195,a196)) in
              let:8 a198 = M[(a195,a196)] in
              let:8 a199 = a197[15:8] in
              let:8 a200 = a197[7:0] in
              let:16 a201 = (1 + (a199,a200)) in
              let:8 a202 = M[(a199,a200)] in
              advance (10)
              #1A7A
              #instruction: DEC  B
              let:8 a203 = a202 in
              let:16 a204 = addWithCarry(!true,a203,~00) in
              let:8 a205 = (a203 & 0F) in
              let:8 a206 = (~00 & 0F) in
              let:16 a207 = addWithCarry(!true,a205,a206) in
              advance (5)
              #1A7B
              #instruction: JP   NZ,1A69
              if (!is_zero(a204[7:0])) {
                advance (10)
                A := a178;
                B := a204[7:0];
                C := a198;
                D := 21;
                E := 43;
                H := a194[15:0][15:8];
                L := a194[15:0][7:0];
                SPH := a201[15:8];
                SPL := a201[7:0];
                FlagS := a204[7:0][7];
                FlagZ := is_zero(a204[7:0]);
                FlagA := a207[7:0][4];
                FlagP := parity(a204[7:0]);
                FlagCY := a194[16];
                jump (1A69);
              } else {
                advance (10)
                #1A7E
                #instruction: RET
                let:8 a208 = a201[15:8] in
                let:8 a209 = a201[7:0] in
                let:16 a210 = (1 + (a208,a209)) in
                let:8 a211 = M[(a208,a209)] in
                let:8 a212 = a210[15:8] in
                let:8 a213 = a210[7:0] in
                let:16 a214 = (1 + (a212,a213)) in
                let:8 a215 = M[(a212,a213)] in
                advance (10)
                A := a178;
                B := a204[7:0];
                C := a198;
                D := 21;
                E := 43;
                H := a194[15:0][15:8];
                L := a194[15:0][7:0];
                SPH := a214[15:8];
                SPL := a214[7:0];
                FlagS := a204[7:0][7];
                FlagZ := is_zero(a204[7:0]);
                FlagA := a207[7:0][4];
                FlagP := parity(a204[7:0]);
                FlagCY := a194[16];
                jump ((a215,a211));
              }
            }
          }
        } else {
          advance (10)
          #02F5
          #instruction: CALL 020E
          let:8 a216 = a76[15:8] in
          let:8 a217 = a76[7:0] in
          let:16 a218 = (-1 + (a216,a217)) in
          M[a218] := 02;
          let:8 a219 = a218[15:8] in
          let:8 a220 = a218[7:0] in
          let:16 a221 = (-1 + (a219,a220)) in
          M[a221] := F8;
          #return-to: 02F8
          advance (17)
          #020E
          #instruction: LD   A,01
          advance (7)
          #0210
          #instruction: JP   0214
          advance (10)
          #0214
          #instruction: LD   DE,2242
          advance (10)
          #0217
          #instruction: JP   021E
          advance (10)
          #021E
          #instruction: LD   (2081),A
          M[2081] := 01;
          advance (13)
          #0221
          #instruction: LD   BC,1602
          advance (10)
          #0224
          #instruction: LD   HL,2806
          advance (10)
          #0227
          #instruction: LD   A,04
          advance (7)
          #0229
          #instruction: PUSH PSW
          let:8 a222 = a221[15:8] in
          let:8 a223 = a221[7:0] in
          let:16 a224 = (-1 + (a222,a223)) in
          M[a224] := 04;
          let:8 a225 = a224[15:8] in
          let:8 a226 = a224[7:0] in
          let:16 a227 = (-1 + (a225,a226)) in
          M[a227] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a39[7]),6,is_zero(a39)),4,a40[3]),2,parity(a39)),0,a77[0]);
          advance (11)
          #022A
          #instruction: PUSH BC
          let:8 a228 = a227[15:8] in
          let:8 a229 = a227[7:0] in
          let:16 a230 = (-1 + (a228,a229)) in
          M[a230] := 16;
          let:8 a231 = a230[15:8] in
          let:8 a232 = a230[7:0] in
          let:16 a233 = (-1 + (a231,a232)) in
          M[a233] := 02;
          advance (11)
          #022B
          #instruction: LD   A,(2081)
          let:8 a234 = M[2081] in
          advance (13)
          #022E
          #instruction: AND  A
          let:8 a235 = a234 in
          let:8 a236 = a234 in
          let:8 a237 = (a235 & a236) in
          let:8 a238 = (a235 | a236) in
          advance (4)
          #022F
          #instruction: JP   NZ,0242
          if (!is_zero(a237)) {
            advance (10)
            #0242
            #instruction: CALL 147C
            let:8 a239 = a233[15:8] in
            let:8 a240 = a233[7:0] in
            let:16 a241 = (-1 + (a239,a240)) in
            M[a241] := 02;
            let:8 a242 = a241[15:8] in
            let:8 a243 = a241[7:0] in
            let:16 a244 = (-1 + (a242,a243)) in
            M[a244] := 45;
            #return-to: 0245
            advance (17)
            #147C
            #instruction: PUSH BC
            let:8 a245 = a244[15:8] in
            let:8 a246 = a244[7:0] in
            let:16 a247 = (-1 + (a245,a246)) in
            M[a247] := 16;
            let:8 a248 = a247[15:8] in
            let:8 a249 = a247[7:0] in
            let:16 a250 = (-1 + (a248,a249)) in
            M[a250] := 02;
            advance (11)
            #147D
            #instruction: PUSH HL
            let:8 a251 = a250[15:8] in
            let:8 a252 = a250[7:0] in
            let:16 a253 = (-1 + (a251,a252)) in
            M[a253] := 28;
            let:8 a254 = a253[15:8] in
            let:8 a255 = a253[7:0] in
            let:16 a256 = (-1 + (a254,a255)) in
            M[a256] := 06;
            advance (11)
            #147E
            #instruction: LD   A,(HL)
            let:8 a257 = M[2806] in
            advance (7)
            #147F
            #instruction: LD   (DE),A
            let:8 a258 = a257 in
            M[2242] := a258;
            advance (7)
            #1480
            #instruction: INC  DE
            advance (5)
            #1481
            #instruction: INC  HL
            advance (5)
            #1482
            #instruction: DEC  C
            let:16 a259 = addWithCarry(!true,02,~00) in
            let:8 a260 = (02 & 0F) in
            let:8 a261 = (~00 & 0F) in
            let:16 a262 = addWithCarry(!true,a260,a261) in
            advance (5)
            #1483
            #instruction: JP   NZ,147E
            if (!is_zero(a259[7:0])) {
              advance (10)
              A := a257;
              B := 16;
              C := a259[7:0];
              D := 22;
              E := 43;
              H := 28;
              L := 07;
              SPH := a256[15:8];
              SPL := a256[7:0];
              FlagS := a259[7:0][7];
              FlagZ := is_zero(a259[7:0]);
              FlagA := a262[7:0][4];
              FlagP := parity(a259[7:0]);
              FlagCY := false;
              jump (147E);
            } else {
              advance (10)
              #1486
              #instruction: POP  HL
              let:8 a263 = a256[15:8] in
              let:8 a264 = a256[7:0] in
              let:16 a265 = (1 + (a263,a264)) in
              let:8 a266 = M[(a263,a264)] in
              let:8 a267 = a265[15:8] in
              let:8 a268 = a265[7:0] in
              let:16 a269 = (1 + (a267,a268)) in
              let:8 a270 = M[(a267,a268)] in
              advance (10)
              #1487
              #instruction: LD   BC,0020
              advance (10)
              #148A
              #instruction: ADD  HL,BC
              let:8 a271 = a270 in
              let:8 a272 = a266 in
              let:17 a273 = add17(0020,(a271,a272)) in
              advance (10)
              #148B
              #instruction: POP  BC
              let:8 a274 = a269[15:8] in
              let:8 a275 = a269[7:0] in
              let:16 a276 = (1 + (a274,a275)) in
              let:8 a277 = M[(a274,a275)] in
              let:8 a278 = a276[15:8] in
              let:8 a279 = a276[7:0] in
              let:16 a280 = (1 + (a278,a279)) in
              let:8 a281 = M[(a278,a279)] in
              advance (10)
              #148C
              #instruction: DEC  B
              let:8 a282 = a281 in
              let:16 a283 = addWithCarry(!true,a282,~00) in
              let:8 a284 = (a282 & 0F) in
              let:8 a285 = (~00 & 0F) in
              let:16 a286 = addWithCarry(!true,a284,a285) in
              advance (5)
              #148D
              #instruction: JP   NZ,147C
              if (!is_zero(a283[7:0])) {
                advance (10)
                A := a257;
                B := a283[7:0];
                C := a277;
                D := 22;
                E := 43;
                H := a273[15:0][15:8];
                L := a273[15:0][7:0];
                SPH := a280[15:8];
                SPL := a280[7:0];
                FlagS := a283[7:0][7];
                FlagZ := is_zero(a283[7:0]);
                FlagA := a286[7:0][4];
                FlagP := parity(a283[7:0]);
                FlagCY := a273[16];
                jump (147C);
              } else {
                advance (10)
                #1490
                #instruction: RET
                let:8 a287 = a280[15:8] in
                let:8 a288 = a280[7:0] in
                let:16 a289 = (1 + (a287,a288)) in
                let:8 a290 = M[(a287,a288)] in
                let:8 a291 = a289[15:8] in
                let:8 a292 = a289[7:0] in
                let:16 a293 = (1 + (a291,a292)) in
                let:8 a294 = M[(a291,a292)] in
                advance (10)
                A := a257;
                B := a283[7:0];
                C := a277;
                D := 22;
                E := 43;
                H := a273[15:0][15:8];
                L := a273[15:0][7:0];
                SPH := a293[15:8];
                SPL := a293[7:0];
                FlagS := a283[7:0][7];
                FlagZ := is_zero(a283[7:0]);
                FlagA := a286[7:0][4];
                FlagP := parity(a283[7:0]);
                FlagCY := a273[16];
                jump ((a294,a290));
              }
            }
          } else {
            advance (10)
            #0232
            #instruction: CALL 1A69
            let:8 a295 = a233[15:8] in
            let:8 a296 = a233[7:0] in
            let:16 a297 = (-1 + (a295,a296)) in
            M[a297] := 02;
            let:8 a298 = a297[15:8] in
            let:8 a299 = a297[7:0] in
            let:16 a300 = (-1 + (a298,a299)) in
            M[a300] := 35;
            #return-to: 0235
            advance (17)
            #1A69
            #instruction: PUSH BC
            let:8 a301 = a300[15:8] in
            let:8 a302 = a300[7:0] in
            let:16 a303 = (-1 + (a301,a302)) in
            M[a303] := 16;
            let:8 a304 = a303[15:8] in
            let:8 a305 = a303[7:0] in
            let:16 a306 = (-1 + (a304,a305)) in
            M[a306] := 02;
            advance (11)
            #1A6A
            #instruction: PUSH HL
            let:8 a307 = a306[15:8] in
            let:8 a308 = a306[7:0] in
            let:16 a309 = (-1 + (a307,a308)) in
            M[a309] := 28;
            let:8 a310 = a309[15:8] in
            let:8 a311 = a309[7:0] in
            let:16 a312 = (-1 + (a310,a311)) in
            M[a312] := 06;
            advance (11)
            #1A6B
            #instruction: LD   A,(DE)
            let:8 a313 = M[2242] in
            advance (7)
            #1A6C
            #instruction: OR   (HL)
            let:8 a314 = M[2806] in
            let:8 a315 = a313 in
            let:8 a316 = (a314 | a315) in
            advance (7)
            #1A6D
            #instruction: LD   (HL),A
            let:8 a317 = a316 in
            M[2806] := a317;
            advance (7)
            #1A6E
            #instruction: INC  DE
            advance (5)
            #1A6F
            #instruction: INC  HL
            advance (5)
            #1A70
            #instruction: DEC  C
            let:16 a318 = addWithCarry(!true,02,~00) in
            let:8 a319 = (02 & 0F) in
            let:8 a320 = (~00 & 0F) in
            let:16 a321 = addWithCarry(!true,a319,a320) in
            advance (5)
            #1A71
            #instruction: JP   NZ,1A6B
            if (!is_zero(a318[7:0])) {
              advance (10)
              A := a316;
              B := 16;
              C := a318[7:0];
              D := 22;
              E := 43;
              H := 28;
              L := 07;
              SPH := a312[15:8];
              SPL := a312[7:0];
              FlagS := a318[7:0][7];
              FlagZ := is_zero(a318[7:0]);
              FlagA := a321[7:0][4];
              FlagP := parity(a318[7:0]);
              FlagCY := false;
              jump (1A6B);
            } else {
              advance (10)
              #1A74
              #instruction: POP  HL
              let:8 a322 = a312[15:8] in
              let:8 a323 = a312[7:0] in
              let:16 a324 = (1 + (a322,a323)) in
              let:8 a325 = M[(a322,a323)] in
              let:8 a326 = a324[15:8] in
              let:8 a327 = a324[7:0] in
              let:16 a328 = (1 + (a326,a327)) in
              let:8 a329 = M[(a326,a327)] in
              advance (10)
              #1A75
              #instruction: LD   BC,0020
              advance (10)
              #1A78
              #instruction: ADD  HL,BC
              let:8 a330 = a329 in
              let:8 a331 = a325 in
              let:17 a332 = add17(0020,(a330,a331)) in
              advance (10)
              #1A79
              #instruction: POP  BC
              let:8 a333 = a328[15:8] in
              let:8 a334 = a328[7:0] in
              let:16 a335 = (1 + (a333,a334)) in
              let:8 a336 = M[(a333,a334)] in
              let:8 a337 = a335[15:8] in
              let:8 a338 = a335[7:0] in
              let:16 a339 = (1 + (a337,a338)) in
              let:8 a340 = M[(a337,a338)] in
              advance (10)
              #1A7A
              #instruction: DEC  B
              let:8 a341 = a340 in
              let:16 a342 = addWithCarry(!true,a341,~00) in
              let:8 a343 = (a341 & 0F) in
              let:8 a344 = (~00 & 0F) in
              let:16 a345 = addWithCarry(!true,a343,a344) in
              advance (5)
              #1A7B
              #instruction: JP   NZ,1A69
              if (!is_zero(a342[7:0])) {
                advance (10)
                A := a316;
                B := a342[7:0];
                C := a336;
                D := 22;
                E := 43;
                H := a332[15:0][15:8];
                L := a332[15:0][7:0];
                SPH := a339[15:8];
                SPL := a339[7:0];
                FlagS := a342[7:0][7];
                FlagZ := is_zero(a342[7:0]);
                FlagA := a345[7:0][4];
                FlagP := parity(a342[7:0]);
                FlagCY := a332[16];
                jump (1A69);
              } else {
                advance (10)
                #1A7E
                #instruction: RET
                let:8 a346 = a339[15:8] in
                let:8 a347 = a339[7:0] in
                let:16 a348 = (1 + (a346,a347)) in
                let:8 a349 = M[(a346,a347)] in
                let:8 a350 = a348[15:8] in
                let:8 a351 = a348[7:0] in
                let:16 a352 = (1 + (a350,a351)) in
                let:8 a353 = M[(a350,a351)] in
                advance (10)
                A := a316;
                B := a342[7:0];
                C := a336;
                D := 22;
                E := 43;
                H := a332[15:0][15:8];
                L := a332[15:0][7:0];
                SPH := a352[15:8];
                SPL := a352[7:0];
                FlagS := a342[7:0][7];
                FlagZ := is_zero(a342[7:0]);
                FlagA := a345[7:0][4];
                FlagP := parity(a342[7:0]);
                FlagCY := a332[16];
                jump ((a353,a349));
              }
            }
          }
        }
      }
    }

02F8:

    #02F8
    #instruction: CALL 0878
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 02;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FB;
    #return-to: 02FB
    advance (17)
    #0878
    #instruction: LD   A,(2008)
    let:8 a7 = M[2008] in
    advance (13)
    #087B
    #instruction: LD   B,A
    let:8 a8 = a7 in
    advance (5)
    #087C
    #instruction: LD   HL,(2009)
    let:8 a9 = M[2009] in
    let:8 a10 = M[200A] in
    advance (16)
    #087F
    #instruction: EX   DE,HL
    let:8 a11 = D in
    let:8 a12 = E in
    let:8 a13 = a10 in
    let:8 a14 = a9 in
    advance (4)
    #0880
    #instruction: JP   0886
    advance (10)
    #0886
    #instruction: LD   A,(2067)
    let:8 a15 = M[2067] in
    advance (13)
    #0889
    #instruction: LD   H,A
    let:8 a16 = a15 in
    advance (5)
    #088A
    #instruction: LD   L,FC
    advance (7)
    #088C
    #instruction: RET
    let:8 a17 = a6[15:8] in
    let:8 a18 = a6[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    A := a15;
    B := a8;
    D := a13;
    E := a14;
    H := a16;
    L := FC;
    SPH := a23[15:8];
    SPL := a23[7:0];
    jump ((a24,a20));

02FB:

    #02FB
    #instruction: LD   (HL),E
    let:8 a1 = E in
    let:8 a2 = H in
    let:8 a3 = L in
    M[(a2,a3)] := a1;
    advance (7)
    #02FC
    #instruction: INC  HL
    let:8 a4 = H in
    let:8 a5 = L in
    let:16 a6 = (1 + (a4,a5)) in
    advance (5)
    #02FD
    #instruction: LD   (HL),D
    let:8 a7 = D in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    M[(a8,a9)] := a7;
    advance (7)
    #02FE
    #instruction: DEC  HL
    let:8 a10 = a6[15:8] in
    let:8 a11 = a6[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    advance (5)
    #02FF
    #instruction: DEC  HL
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    advance (5)
    #0300
    #instruction: LD   (HL),B
    let:8 a16 = B in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    M[(a17,a18)] := a16;
    advance (7)
    #0301
    #instruction: NOP
    advance (4)
    #0302
    #instruction: CALL 01E4
    let:8 a19 = SPH in
    let:8 a20 = SPL in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 03;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 05;
    #return-to: 0305
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a25 = addWithCarry(!true,C0,~00) in
    let:8 a26 = (C0 & 0F) in
    let:8 a27 = (~00 & 0F) in
    let:16 a28 = addWithCarry(!true,a26,a27) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a25[7:0])) {
      advance (10)
      A := 01;
      B := a25[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a29 = a24[15:8] in
      let:8 a30 = a24[7:0] in
      let:16 a31 = (1 + (a29,a30)) in
      let:8 a32 = M[(a29,a30)] in
      let:8 a33 = a31[15:8] in
      let:8 a34 = a31[7:0] in
      let:16 a35 = (1 + (a33,a34)) in
      let:8 a36 = M[(a33,a34)] in
      advance (10)
      A := 01;
      B := a25[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a35[15:8];
      SPL := a35[7:0];
      FlagS := a25[7:0][7];
      FlagZ := is_zero(a25[7:0]);
      FlagA := a28[7:0][4];
      FlagP := parity(a25[7:0]);
      jump ((a36,a32));
    }

0305:

    #0305
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0306
    #instruction: RRCA
    let:8 a9 = a8 in
    advance (4)
    #0307
    #instruction: LD   A,21
    advance (7)
    #0309
    #instruction: LD   B,00
    advance (7)
    #030B
    #instruction: JP   NC,0312
    if (!a9[0]) {
      advance (10)
      #0312
      #instruction: LD   (2067),A
      M[2067] := 21;
      advance (13)
      #0315
      #instruction: CALL 0AB6
      let:8 a10 = a7[15:8] in
      let:8 a11 = a7[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 03;
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 18;
      #return-to: 0318
      advance (17)
      #0AB6
      #instruction: LD   A,80
      advance (7)
      #0AB8
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 80;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      let:8 a16 = M[20C0] in
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a17 = a16 in
      let:8 a18 = a16 in
      let:8 a19 = (a17 & a18) in
      let:8 a20 = (a17 | a18) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a19)) {
        advance (10)
        A := a19;
        B := 00;
        SPH := a15[15:8];
        SPL := a15[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:8 a21 = a15[15:8] in
        let:8 a22 = a15[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        let:8 a25 = a23[15:8] in
        let:8 a26 = a23[7:0] in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        advance (10)
        A := a19;
        B := 00;
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump ((a28,a24));
      }
    } else {
      advance (10)
      #030E
      #instruction: LD   B,20
      advance (7)
      #0310
      #instruction: LD   A,22
      advance (7)
      #0312
      #instruction: LD   (2067),A
      M[2067] := 22;
      advance (13)
      #0315
      #instruction: CALL 0AB6
      let:8 a29 = a7[15:8] in
      let:8 a30 = a7[7:0] in
      let:16 a31 = (-1 + (a29,a30)) in
      M[a31] := 03;
      let:8 a32 = a31[15:8] in
      let:8 a33 = a31[7:0] in
      let:16 a34 = (-1 + (a32,a33)) in
      M[a34] := 18;
      #return-to: 0318
      advance (17)
      #0AB6
      #instruction: LD   A,80
      advance (7)
      #0AB8
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 80;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      let:8 a35 = M[20C0] in
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a36 = a35 in
      let:8 a37 = a35 in
      let:8 a38 = (a36 & a37) in
      let:8 a39 = (a36 | a37) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a38)) {
        advance (10)
        A := a38;
        B := 20;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a38[7];
        FlagZ := is_zero(a38);
        FlagA := a39[3];
        FlagP := parity(a38);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:8 a40 = a34[15:8] in
        let:8 a41 = a34[7:0] in
        let:16 a42 = (1 + (a40,a41)) in
        let:8 a43 = M[(a40,a41)] in
        let:8 a44 = a42[15:8] in
        let:8 a45 = a42[7:0] in
        let:16 a46 = (1 + (a44,a45)) in
        let:8 a47 = M[(a44,a45)] in
        advance (10)
        A := a38;
        B := 20;
        SPH := a46[15:8];
        SPL := a46[7:0];
        FlagS := a38[7];
        FlagZ := is_zero(a38);
        FlagA := a39[3];
        FlagP := parity(a38);
        FlagCY := false;
        jump ((a47,a43));
      }
    }

0318:

    #0318
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0319
    #instruction: LD   (2011),A
    let:8 a4 = a3 in
    M[2011] := a4;
    advance (13)
    #031C
    #instruction: LD   A,B
    let:8 a5 = B in
    advance (5)
    #031D
    #instruction: OUT  05
    let:8 a6 = a5 in
    sound_control(FleetMovement1,a6[0]);
    sound_control(FleetMovement2,a6[1]);
    sound_control(FleetMovement3,a6[2]);
    sound_control(FleetMovement4,a6[3]);
    sound_control(UfoHit,a6[4]);
    advance (10)
    #031F
    #instruction: INC  A
    let:8 a7 = a5 in
    let:16 a8 = addWithCarry(true,a7,00) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (00 & 0F) in
    let:16 a11 = addWithCarry(true,a9,a10) in
    advance (5)
    #0320
    #instruction: LD   (2098),A
    let:8 a12 = a8[7:0] in
    M[2098] := a12;
    advance (13)
    #0323
    #instruction: CALL 09D6
    let:8 a13 = SPH in
    let:8 a14 = SPL in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 03;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 26;
    #return-to: 0326
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a19 = (1F & 03) in
    let:8 a20 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a21 = a19 in
    let:16 a22 = addWithCarry(!false,a21,~1C) in
    let:8 a23 = (a21 & 0F) in
    let:8 a24 = (~1C & 0F) in
    let:16 a25 = addWithCarry(!false,a23,a24) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a22[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a26 = addWithCarry(!false,24,~40) in
      let:8 a27 = (24 & 0F) in
      let:8 a28 = (~40 & 0F) in
      let:16 a29 = addWithCarry(!false,a27,a28) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a26[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := !a26[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a30 = a18[15:8] in
        let:8 a31 = a18[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        let:8 a34 = a32[15:8] in
        let:8 a35 = a32[7:0] in
        let:16 a36 = (1 + (a34,a35)) in
        let:8 a37 = M[(a34,a35)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagS := a26[7:0][7];
        FlagZ := is_zero(a26[7:0]);
        FlagA := a29[7:0][4];
        FlagP := parity(a26[7:0]);
        FlagCY := !a26[15:8][0];
        jump ((a37,a33));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a38 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a39 = a38[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a40 = a39 in
      let:16 a41 = addWithCarry(!false,a40,~40) in
      let:8 a42 = (a40 & 0F) in
      let:8 a43 = (~40 & 0F) in
      let:16 a44 = addWithCarry(!false,a42,a43) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a41[15:8][0]) {
        advance (10)
        A := a39;
        D := 00;
        E := 06;
        H := a38[15:0][15:8];
        L := a38[15:0][7:0];
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a41[7:0][7];
        FlagZ := is_zero(a41[7:0]);
        FlagA := a44[7:0][4];
        FlagP := parity(a41[7:0]);
        FlagCY := !a41[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a45 = a18[15:8] in
        let:8 a46 = a18[7:0] in
        let:16 a47 = (1 + (a45,a46)) in
        let:8 a48 = M[(a45,a46)] in
        let:8 a49 = a47[15:8] in
        let:8 a50 = a47[7:0] in
        let:16 a51 = (1 + (a49,a50)) in
        let:8 a52 = M[(a49,a50)] in
        advance (10)
        A := a39;
        D := 00;
        E := 06;
        H := a38[15:0][15:8];
        L := a38[15:0][7:0];
        SPH := a51[15:8];
        SPL := a51[7:0];
        FlagS := a41[7:0][7];
        FlagZ := is_zero(a41[7:0]);
        FlagA := a44[7:0][4];
        FlagP := parity(a41[7:0]);
        FlagCY := !a41[15:8][0];
        jump ((a52,a48));
      }
    }

0326:

    #0326
    #instruction: CALL 1A7F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 29;
    #return-to: 0329
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1A;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a19 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a20 = a19 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    advance (10)
    A := a19;
    H := a20;
    L := 00;
    SPH := a27[15:8];
    SPL := a27[7:0];
    jump ((a28,a24));

0329:

    #0329
    #instruction: JP   07F9
    advance (10)
    jump (07F9);

032F:

    #032F
    #instruction: JP   0817
    advance (10)
    jump (0817);

0335:

    #0335
    #instruction: JP   02F8
    advance (10)
    jump (02F8);

0366:

    #0366
    #instruction: RLCA
    let:8 a1 = A in
    advance (4)
    #0367
    #instruction: RLCA
    let:8 a2 = updateBit((a1 << 01),0,a1[7]) in
    advance (4)
    #0368
    #instruction: JP   CY,0381
    if (a2[7]) {
      advance (10)
      #0381
      #instruction: LD   A,B
      let:8 a3 = B in
      advance (5)
      #0382
      #instruction: CP   D9
      let:8 a4 = a3 in
      let:16 a5 = addWithCarry(!false,a4,~D9) in
      let:8 a6 = (a4 & 0F) in
      let:8 a7 = (~D9 & 0F) in
      let:16 a8 = addWithCarry(!false,a6,a7) in
      advance (7)
      #0384
      #instruction: JP   Z,036F
      if (is_zero(a5[7:0])) {
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:8 a9 = SPH in
        let:8 a10 = SPL in
        let:16 a11 = (-1 + (a9,a10)) in
        M[a11] := 03;
        let:8 a12 = a11[15:8] in
        let:8 a13 = a11[7:0] in
        let:16 a14 = (-1 + (a12,a13)) in
        M[a14] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a15 = M[2018] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a16 = M[2019] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a17 = M[201A] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a18 = M[201B] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a19 = M[201C] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a20 = a18 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a21 = a17 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a22 = a14[15:8] in
        let:8 a23 = a14[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        let:8 a26 = a24[15:8] in
        let:8 a27 = a24[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        advance (10)
        A := a17;
        B := a19;
        C := a18;
        D := a16;
        E := a15;
        H := a20;
        L := a21;
        SPH := a28[15:8];
        SPL := a28[7:0];
        FlagS := a5[7:0][7];
        FlagZ := is_zero(a5[7:0]);
        FlagA := a8[7:0][4];
        FlagP := parity(a5[7:0]);
        FlagCY := !a5[15:8][0];
        jump ((a29,a25));
      } else {
        advance (10)
        #0387
        #instruction: INC  A
        let:8 a30 = a3 in
        let:16 a31 = addWithCarry(true,a30,00) in
        let:8 a32 = (a30 & 0F) in
        let:8 a33 = (00 & 0F) in
        let:16 a34 = addWithCarry(true,a32,a33) in
        advance (5)
        #0388
        #instruction: LD   (201B),A
        let:8 a35 = a31[7:0] in
        M[201B] := a35;
        advance (13)
        #038B
        #instruction: JP   036F
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:8 a36 = SPH in
        let:8 a37 = SPL in
        let:16 a38 = (-1 + (a36,a37)) in
        M[a38] := 03;
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a42 = M[2018] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a43 = M[2019] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a44 = M[201A] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a45 = M[201B] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a46 = M[201C] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a47 = a45 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a48 = a44 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a49 = a41[15:8] in
        let:8 a50 = a41[7:0] in
        let:16 a51 = (1 + (a49,a50)) in
        let:8 a52 = M[(a49,a50)] in
        let:8 a53 = a51[15:8] in
        let:8 a54 = a51[7:0] in
        let:16 a55 = (1 + (a53,a54)) in
        let:8 a56 = M[(a53,a54)] in
        advance (10)
        A := a44;
        B := a46;
        C := a45;
        D := a43;
        E := a42;
        H := a47;
        L := a48;
        SPH := a55[15:8];
        SPL := a55[7:0];
        FlagS := a31[7:0][7];
        FlagZ := is_zero(a31[7:0]);
        FlagA := a34[7:0][4];
        FlagP := parity(a31[7:0]);
        FlagCY := !a5[15:8][0];
        jump ((a56,a52));
      }
    } else {
      advance (10)
      #036B
      #instruction: RLCA
      let:8 a57 = updateBit((a2 << 01),0,a2[7]) in
      advance (4)
      #036C
      #instruction: JP   CY,038E
      if (a57[7]) {
        advance (10)
        #038E
        #instruction: LD   A,B
        let:8 a58 = B in
        advance (5)
        #038F
        #instruction: CP   30
        let:8 a59 = a58 in
        let:16 a60 = addWithCarry(!false,a59,~30) in
        let:8 a61 = (a59 & 0F) in
        let:8 a62 = (~30 & 0F) in
        let:16 a63 = addWithCarry(!false,a61,a62) in
        advance (7)
        #0391
        #instruction: JP   Z,036F
        if (is_zero(a60[7:0])) {
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:8 a64 = SPH in
          let:8 a65 = SPL in
          let:16 a66 = (-1 + (a64,a65)) in
          M[a66] := 03;
          let:8 a67 = a66[15:8] in
          let:8 a68 = a66[7:0] in
          let:16 a69 = (-1 + (a67,a68)) in
          M[a69] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a70 = M[2018] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a71 = M[2019] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a72 = M[201A] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a73 = M[201B] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a74 = M[201C] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a75 = a73 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a76 = a72 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a77 = a69[15:8] in
          let:8 a78 = a69[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          let:8 a81 = a79[15:8] in
          let:8 a82 = a79[7:0] in
          let:16 a83 = (1 + (a81,a82)) in
          let:8 a84 = M[(a81,a82)] in
          advance (10)
          A := a72;
          B := a74;
          C := a73;
          D := a71;
          E := a70;
          H := a75;
          L := a76;
          SPH := a83[15:8];
          SPL := a83[7:0];
          FlagS := a60[7:0][7];
          FlagZ := is_zero(a60[7:0]);
          FlagA := a63[7:0][4];
          FlagP := parity(a60[7:0]);
          FlagCY := !a60[15:8][0];
          jump ((a84,a80));
        } else {
          advance (10)
          #0394
          #instruction: DEC  A
          let:8 a85 = a58 in
          let:16 a86 = addWithCarry(!true,a85,~00) in
          let:8 a87 = (a85 & 0F) in
          let:8 a88 = (~00 & 0F) in
          let:16 a89 = addWithCarry(!true,a87,a88) in
          advance (5)
          #0395
          #instruction: LD   (201B),A
          let:8 a90 = a86[7:0] in
          M[201B] := a90;
          advance (13)
          #0398
          #instruction: JP   036F
          advance (10)
          #036F
          #instruction: LD   HL,2018
          advance (10)
          #0372
          #instruction: CALL 1A3B
          let:8 a91 = SPH in
          let:8 a92 = SPL in
          let:16 a93 = (-1 + (a91,a92)) in
          M[a93] := 03;
          let:8 a94 = a93[15:8] in
          let:8 a95 = a93[7:0] in
          let:16 a96 = (-1 + (a94,a95)) in
          M[a96] := 75;
          #return-to: 0375
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a97 = M[2018] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a98 = M[2019] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a99 = M[201A] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a100 = M[201B] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a101 = M[201C] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a102 = a100 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a103 = a99 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a104 = a96[15:8] in
          let:8 a105 = a96[7:0] in
          let:16 a106 = (1 + (a104,a105)) in
          let:8 a107 = M[(a104,a105)] in
          let:8 a108 = a106[15:8] in
          let:8 a109 = a106[7:0] in
          let:16 a110 = (1 + (a108,a109)) in
          let:8 a111 = M[(a108,a109)] in
          advance (10)
          A := a99;
          B := a101;
          C := a100;
          D := a98;
          E := a97;
          H := a102;
          L := a103;
          SPH := a110[15:8];
          SPL := a110[7:0];
          FlagS := a86[7:0][7];
          FlagZ := is_zero(a86[7:0]);
          FlagA := a89[7:0][4];
          FlagP := parity(a86[7:0]);
          FlagCY := !a60[15:8][0];
          jump ((a111,a107));
        }
      } else {
        advance (10)
        #036F
        #instruction: LD   HL,2018
        advance (10)
        #0372
        #instruction: CALL 1A3B
        let:8 a112 = SPH in
        let:8 a113 = SPL in
        let:16 a114 = (-1 + (a112,a113)) in
        M[a114] := 03;
        let:8 a115 = a114[15:8] in
        let:8 a116 = a114[7:0] in
        let:16 a117 = (-1 + (a115,a116)) in
        M[a117] := 75;
        #return-to: 0375
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a118 = M[2018] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a119 = M[2019] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a120 = M[201A] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a121 = M[201B] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a122 = M[201C] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a123 = a121 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a124 = a120 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a125 = a117[15:8] in
        let:8 a126 = a117[7:0] in
        let:16 a127 = (1 + (a125,a126)) in
        let:8 a128 = M[(a125,a126)] in
        let:8 a129 = a127[15:8] in
        let:8 a130 = a127[7:0] in
        let:16 a131 = (1 + (a129,a130)) in
        let:8 a132 = M[(a129,a130)] in
        advance (10)
        A := a120;
        B := a122;
        C := a121;
        D := a119;
        E := a118;
        H := a123;
        L := a124;
        SPH := a131[15:8];
        SPL := a131[7:0];
        FlagCY := a57[7];
        jump ((a132,a128));
      }
    }

0375:

    #0375
    #instruction: CALL 1A47
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 78;
    #return-to: 0378
    advance (17)
    #1A47
    #instruction: PUSH BC
    let:8 a7 = B in
    let:8 a8 = C in
    let:8 a9 = a6[15:8] in
    let:8 a10 = a6[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a7;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := a8;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a15 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a16 = a15 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a17 = updateBit((a16 >> 01),7,FlagCY) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a18 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a19 = a18 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a20 = updateBit((a19 >> 01),7,a16[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a21 = addWithCarry(!true,03,~00) in
    let:8 a22 = (03 & 0F) in
    let:8 a23 = (~00 & 0F) in
    let:16 a24 = addWithCarry(!true,a22,a23) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a21[7:0])) {
      advance (10)
      A := updateBit((a19 >> 01),7,a16[0]);
      B := a21[7:0];
      H := a17;
      L := a20;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a19[0];
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a25 = a17 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a26 = a25 in
      let:8 a27 = (3F & a26) in
      let:8 a28 = (3F | a26) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a29 = a27 in
      let:8 a30 = (20 | a29) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a31 = a30 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a32 = a14[15:8] in
      let:8 a33 = a14[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a40 = a38[15:8] in
      let:8 a41 = a38[7:0] in
      let:16 a42 = (1 + (a40,a41)) in
      let:8 a43 = M[(a40,a41)] in
      let:8 a44 = a42[15:8] in
      let:8 a45 = a42[7:0] in
      let:16 a46 = (1 + (a44,a45)) in
      let:8 a47 = M[(a44,a45)] in
      advance (10)
      A := a30;
      B := a39;
      C := a35;
      H := a31;
      L := a20;
      SPH := a46[15:8];
      SPL := a46[7:0];
      FlagS := a30[7];
      FlagZ := is_zero(a30);
      FlagA := false;
      FlagP := parity(a30);
      FlagCY := false;
      jump ((a47,a43));
    }

0378:

    #0378
    #instruction: CALL 1439
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7B;
    #return-to: 037B
    advance (17)
    #1439
    #instruction: PUSH BC
    let:8 a7 = B in
    let:8 a8 = C in
    let:8 a9 = a6[15:8] in
    let:8 a10 = a6[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a7;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := a8;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a15 = D in
    let:8 a16 = E in
    let:8 a17 = M[(a15,a16)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a18 = a17 in
    let:8 a19 = H in
    let:8 a20 = L in
    M[(a19,a20)] := a18;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a21 = D in
    let:8 a22 = E in
    let:16 a23 = (1 + (a21,a22)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a24 = H in
    let:8 a25 = L in
    let:17 a26 = add17(0020,(a24,a25)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a27 = a14[15:8] in
    let:8 a28 = a14[7:0] in
    let:16 a29 = (1 + (a27,a28)) in
    let:8 a30 = M[(a27,a28)] in
    let:8 a31 = a29[15:8] in
    let:8 a32 = a29[7:0] in
    let:16 a33 = (1 + (a31,a32)) in
    let:8 a34 = M[(a31,a32)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a35 = a34 in
    let:16 a36 = addWithCarry(!true,a35,~00) in
    let:8 a37 = (a35 & 0F) in
    let:8 a38 = (~00 & 0F) in
    let:16 a39 = addWithCarry(!true,a37,a38) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a36[7:0])) {
      advance (10)
      A := a17;
      B := a36[7:0];
      C := a30;
      D := a23[15:8];
      E := a23[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a33[15:8];
      SPL := a33[7:0];
      FlagS := a36[7:0][7];
      FlagZ := is_zero(a36[7:0]);
      FlagA := a39[7:0][4];
      FlagP := parity(a36[7:0]);
      FlagCY := a26[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a40 = a33[15:8] in
      let:8 a41 = a33[7:0] in
      let:16 a42 = (1 + (a40,a41)) in
      let:8 a43 = M[(a40,a41)] in
      let:8 a44 = a42[15:8] in
      let:8 a45 = a42[7:0] in
      let:16 a46 = (1 + (a44,a45)) in
      let:8 a47 = M[(a44,a45)] in
      advance (10)
      A := a17;
      B := a36[7:0];
      C := a30;
      D := a23[15:8];
      E := a23[7:0];
      H := a26[15:0][15:8];
      L := a26[15:0][7:0];
      SPH := a46[15:8];
      SPL := a46[7:0];
      FlagS := a36[7:0][7];
      FlagZ := is_zero(a36[7:0]);
      FlagA := a39[7:0][4];
      FlagP := parity(a36[7:0]);
      FlagCY := a26[16];
      jump ((a47,a43));
    }

037B:

    #037B
    #instruction: LD   A,00
    advance (7)
    #037D
    #instruction: LD   (2012),A
    M[2012] := 00;
    advance (13)
    #0380
    #instruction: RET
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    A := 00;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump ((a8,a4));

03BB:

    #03BB
    #instruction: LD   DE,202A
    advance (10)
    #03BE
    #instruction: CALL 1A06
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 03C1
    advance (17)
    #1A06
    #instruction: LD   HL,2072
    advance (10)
    #1A09
    #instruction: LD   B,(HL)
    let:8 a7 = M[2072] in
    advance (7)
    #1A0A
    #instruction: LD   A,(DE)
    let:8 a8 = M[202A] in
    advance (7)
    #1A0B
    #instruction: AND  80
    let:8 a9 = a8 in
    let:8 a10 = (80 & a9) in
    let:8 a11 = (80 | a9) in
    advance (7)
    #1A0D
    #instruction: XOR  B
    let:8 a12 = a7 in
    let:8 a13 = a10 in
    let:8 a14 = (a12 ^ a13) in
    advance (4)
    #1A0E
    #instruction: RET  NZ
    if (!is_zero(a14)) {
      let:8 a15 = a6[15:8] in
      let:8 a16 = a6[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a14;
      B := a7;
      D := 20;
      E := 2A;
      H := 20;
      L := 72;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a22,a18));
    } else {
      advance (5)
      #1A0F
      #instruction: SCF
      advance (4)
      #1A10
      #instruction: RET
      let:8 a23 = a6[15:8] in
      let:8 a24 = a6[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := a14;
      B := a7;
      D := 20;
      E := 2A;
      H := 20;
      L := 72;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := true;
      jump ((a30,a26));
    }

03C1:

    #03C1
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #03C2
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a9 = a7[15:8] in
      let:8 a10 = a7[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      H := a8;
      L := a4;
      SPH := a15[15:8];
      SPL := a15[7:0];
      jump ((a16,a12));
    } else {
      advance (5)
      #03C3
      #instruction: INC  HL
      let:8 a17 = a8 in
      let:8 a18 = a4 in
      let:16 a19 = (1 + (a17,a18)) in
      advance (5)
      #03C4
      #instruction: LD   A,(HL)
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:8 a22 = M[(a20,a21)] in
      advance (7)
      #03C5
      #instruction: AND  A
      let:8 a23 = a22 in
      let:8 a24 = a22 in
      let:8 a25 = (a23 & a24) in
      let:8 a26 = (a23 | a24) in
      advance (4)
      #03C6
      #instruction: RET  Z
      if (is_zero(a25)) {
        let:8 a27 = a7[15:8] in
        let:8 a28 = a7[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        advance (11)
        A := a25;
        H := a19[15:8];
        L := a19[7:0];
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a25[7];
        FlagZ := is_zero(a25);
        FlagA := a26[3];
        FlagP := parity(a25);
        FlagCY := false;
        jump ((a34,a30));
      } else {
        advance (5)
        #03C7
        #instruction: CP   01
        let:8 a35 = a25 in
        let:16 a36 = addWithCarry(!false,a35,~01) in
        let:8 a37 = (a35 & 0F) in
        let:8 a38 = (~01 & 0F) in
        let:16 a39 = addWithCarry(!false,a37,a38) in
        advance (7)
        #03C9
        #instruction: JP   Z,03FA
        if (is_zero(a36[7:0])) {
          advance (10)
          #03FA
          #instruction: INC  A
          let:8 a40 = a25 in
          let:16 a41 = addWithCarry(true,a40,00) in
          let:8 a42 = (a40 & 0F) in
          let:8 a43 = (00 & 0F) in
          let:16 a44 = addWithCarry(true,a42,a43) in
          advance (5)
          #03FB
          #instruction: LD   (HL),A
          let:8 a45 = a41[7:0] in
          let:8 a46 = a19[15:8] in
          let:8 a47 = a19[7:0] in
          M[(a46,a47)] := a45;
          advance (7)
          #03FC
          #instruction: LD   A,(201B)
          let:8 a48 = M[201B] in
          advance (13)
          #03FF
          #instruction: ADD  08
          let:8 a49 = a48 in
          let:16 a50 = addWithCarry(false,08,a49) in
          let:8 a51 = (08 & 0F) in
          let:8 a52 = (a49 & 0F) in
          let:16 a53 = addWithCarry(false,a51,a52) in
          advance (7)
          #0401
          #instruction: LD   (202A),A
          let:8 a54 = a50[7:0] in
          M[202A] := a54;
          advance (13)
          #0404
          #instruction: CALL 0430
          let:8 a55 = a7[15:8] in
          let:8 a56 = a7[7:0] in
          let:16 a57 = (-1 + (a55,a56)) in
          M[a57] := 04;
          let:8 a58 = a57[15:8] in
          let:8 a59 = a57[7:0] in
          let:16 a60 = (-1 + (a58,a59)) in
          M[a60] := 07;
          #return-to: 0407
          advance (17)
          #0430
          #instruction: LD   HL,2027
          advance (10)
          #0433
          #instruction: JP   1A3B
          advance (10)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a61 = M[2027] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a62 = M[2028] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a63 = M[2029] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a64 = M[202A] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a65 = M[202B] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a66 = a64 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a67 = a63 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a68 = a60[15:8] in
          let:8 a69 = a60[7:0] in
          let:16 a70 = (1 + (a68,a69)) in
          let:8 a71 = M[(a68,a69)] in
          let:8 a72 = a70[15:8] in
          let:8 a73 = a70[7:0] in
          let:16 a74 = (1 + (a72,a73)) in
          let:8 a75 = M[(a72,a73)] in
          advance (10)
          A := a63;
          B := a65;
          C := a64;
          D := a62;
          E := a61;
          H := a66;
          L := a67;
          SPH := a74[15:8];
          SPL := a74[7:0];
          FlagS := a50[7:0][7];
          FlagZ := is_zero(a50[7:0]);
          FlagA := a53[7:0][4];
          FlagP := parity(a50[7:0]);
          FlagCY := a50[15:8][0];
          jump ((a75,a71));
        } else {
          advance (10)
          #03CC
          #instruction: CP   02
          let:8 a76 = a25 in
          let:16 a77 = addWithCarry(!false,a76,~02) in
          let:8 a78 = (a76 & 0F) in
          let:8 a79 = (~02 & 0F) in
          let:16 a80 = addWithCarry(!false,a78,a79) in
          advance (7)
          #03CE
          #instruction: JP   Z,040A
          if (is_zero(a77[7:0])) {
            advance (10)
            #040A
            #instruction: CALL 0430
            let:8 a81 = a7[15:8] in
            let:8 a82 = a7[7:0] in
            let:16 a83 = (-1 + (a81,a82)) in
            M[a83] := 04;
            let:8 a84 = a83[15:8] in
            let:8 a85 = a83[7:0] in
            let:16 a86 = (-1 + (a84,a85)) in
            M[a86] := 0D;
            #return-to: 040D
            advance (17)
            #0430
            #instruction: LD   HL,2027
            advance (10)
            #0433
            #instruction: JP   1A3B
            advance (10)
            #1A3B
            #instruction: LD   E,(HL)
            let:8 a87 = M[2027] in
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            let:8 a88 = M[2028] in
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            let:8 a89 = M[2029] in
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            let:8 a90 = M[202A] in
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            let:8 a91 = M[202B] in
            advance (7)
            #1A44
            #instruction: LD   H,C
            let:8 a92 = a90 in
            advance (5)
            #1A45
            #instruction: LD   L,A
            let:8 a93 = a89 in
            advance (5)
            #1A46
            #instruction: RET
            let:8 a94 = a86[15:8] in
            let:8 a95 = a86[7:0] in
            let:16 a96 = (1 + (a94,a95)) in
            let:8 a97 = M[(a94,a95)] in
            let:8 a98 = a96[15:8] in
            let:8 a99 = a96[7:0] in
            let:16 a100 = (1 + (a98,a99)) in
            let:8 a101 = M[(a98,a99)] in
            advance (10)
            A := a89;
            B := a91;
            C := a90;
            D := a88;
            E := a87;
            H := a92;
            L := a93;
            SPH := a100[15:8];
            SPL := a100[7:0];
            FlagS := a77[7:0][7];
            FlagZ := is_zero(a77[7:0]);
            FlagA := a80[7:0][4];
            FlagP := parity(a77[7:0]);
            FlagCY := !a77[15:8][0];
            jump ((a101,a97));
          } else {
            advance (10)
            #03D1
            #instruction: INC  HL
            let:8 a102 = a19[15:8] in
            let:8 a103 = a19[7:0] in
            let:16 a104 = (1 + (a102,a103)) in
            advance (5)
            #03D2
            #instruction: CP   03
            let:8 a105 = a25 in
            let:16 a106 = addWithCarry(!false,a105,~03) in
            let:8 a107 = (a105 & 0F) in
            let:8 a108 = (~03 & 0F) in
            let:16 a109 = addWithCarry(!false,a107,a108) in
            advance (7)
            #03D4
            #instruction: JP   NZ,042A
            if (!is_zero(a106[7:0])) {
              advance (10)
              #042A
              #instruction: CP   05
              let:8 a110 = a25 in
              let:16 a111 = addWithCarry(!false,a110,~05) in
              let:8 a112 = (a110 & 0F) in
              let:8 a113 = (~05 & 0F) in
              let:16 a114 = addWithCarry(!false,a112,a113) in
              advance (7)
              #042C
              #instruction: RET  Z
              if (is_zero(a111[7:0])) {
                let:8 a115 = a7[15:8] in
                let:8 a116 = a7[7:0] in
                let:16 a117 = (1 + (a115,a116)) in
                let:8 a118 = M[(a115,a116)] in
                let:8 a119 = a117[15:8] in
                let:8 a120 = a117[7:0] in
                let:16 a121 = (1 + (a119,a120)) in
                let:8 a122 = M[(a119,a120)] in
                advance (11)
                A := a25;
                H := a104[15:8];
                L := a104[7:0];
                SPH := a121[15:8];
                SPL := a121[7:0];
                FlagS := a111[7:0][7];
                FlagZ := is_zero(a111[7:0]);
                FlagA := a114[7:0][4];
                FlagP := parity(a111[7:0]);
                FlagCY := !a111[15:8][0];
                jump ((a122,a118));
              } else {
                advance (5)
                #042D
                #instruction: JP   0436
                advance (10)
                #0436
                #instruction: CALL 0430
                let:8 a123 = a7[15:8] in
                let:8 a124 = a7[7:0] in
                let:16 a125 = (-1 + (a123,a124)) in
                M[a125] := 04;
                let:8 a126 = a125[15:8] in
                let:8 a127 = a125[7:0] in
                let:16 a128 = (-1 + (a126,a127)) in
                M[a128] := 39;
                #return-to: 0439
                advance (17)
                #0430
                #instruction: LD   HL,2027
                advance (10)
                #0433
                #instruction: JP   1A3B
                advance (10)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a129 = M[2027] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a130 = M[2028] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a131 = M[2029] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a132 = M[202A] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a133 = M[202B] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a134 = a132 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a135 = a131 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a136 = a128[15:8] in
                let:8 a137 = a128[7:0] in
                let:16 a138 = (1 + (a136,a137)) in
                let:8 a139 = M[(a136,a137)] in
                let:8 a140 = a138[15:8] in
                let:8 a141 = a138[7:0] in
                let:16 a142 = (1 + (a140,a141)) in
                let:8 a143 = M[(a140,a141)] in
                advance (10)
                A := a131;
                B := a133;
                C := a132;
                D := a130;
                E := a129;
                H := a134;
                L := a135;
                SPH := a142[15:8];
                SPL := a142[7:0];
                FlagS := a111[7:0][7];
                FlagZ := is_zero(a111[7:0]);
                FlagA := a114[7:0][4];
                FlagP := parity(a111[7:0]);
                FlagCY := !a111[15:8][0];
                jump ((a143,a139));
              }
            } else {
              advance (10)
              #03D7
              #instruction: DEC  (HL)
              let:8 a144 = a104[15:8] in
              let:8 a145 = a104[7:0] in
              let:8 a146 = M[(a144,a145)] in
              let:16 a147 = addWithCarry(!true,a146,~00) in
              let:8 a148 = (a146 & 0F) in
              let:8 a149 = (~00 & 0F) in
              let:16 a150 = addWithCarry(!true,a148,a149) in
              let:8 a151 = a104[15:8] in
              let:8 a152 = a104[7:0] in
              M[(a151,a152)] := a147[7:0];
              advance (10)
              #03D8
              #instruction: JP   Z,0436
              if (is_zero(a147[7:0])) {
                advance (10)
                #0436
                #instruction: CALL 0430
                let:8 a153 = a7[15:8] in
                let:8 a154 = a7[7:0] in
                let:16 a155 = (-1 + (a153,a154)) in
                M[a155] := 04;
                let:8 a156 = a155[15:8] in
                let:8 a157 = a155[7:0] in
                let:16 a158 = (-1 + (a156,a157)) in
                M[a158] := 39;
                #return-to: 0439
                advance (17)
                #0430
                #instruction: LD   HL,2027
                advance (10)
                #0433
                #instruction: JP   1A3B
                advance (10)
                #1A3B
                #instruction: LD   E,(HL)
                let:8 a159 = M[2027] in
                advance (7)
                #1A3C
                #instruction: INC  HL
                advance (5)
                #1A3D
                #instruction: LD   D,(HL)
                let:8 a160 = M[2028] in
                advance (7)
                #1A3E
                #instruction: INC  HL
                advance (5)
                #1A3F
                #instruction: LD   A,(HL)
                let:8 a161 = M[2029] in
                advance (7)
                #1A40
                #instruction: INC  HL
                advance (5)
                #1A41
                #instruction: LD   C,(HL)
                let:8 a162 = M[202A] in
                advance (7)
                #1A42
                #instruction: INC  HL
                advance (5)
                #1A43
                #instruction: LD   B,(HL)
                let:8 a163 = M[202B] in
                advance (7)
                #1A44
                #instruction: LD   H,C
                let:8 a164 = a162 in
                advance (5)
                #1A45
                #instruction: LD   L,A
                let:8 a165 = a161 in
                advance (5)
                #1A46
                #instruction: RET
                let:8 a166 = a158[15:8] in
                let:8 a167 = a158[7:0] in
                let:16 a168 = (1 + (a166,a167)) in
                let:8 a169 = M[(a166,a167)] in
                let:8 a170 = a168[15:8] in
                let:8 a171 = a168[7:0] in
                let:16 a172 = (1 + (a170,a171)) in
                let:8 a173 = M[(a170,a171)] in
                advance (10)
                A := a161;
                B := a163;
                C := a162;
                D := a160;
                E := a159;
                H := a164;
                L := a165;
                SPH := a172[15:8];
                SPL := a172[7:0];
                FlagS := a147[7:0][7];
                FlagZ := is_zero(a147[7:0]);
                FlagA := a150[7:0][4];
                FlagP := parity(a147[7:0]);
                FlagCY := !a106[15:8][0];
                jump ((a173,a169));
              } else {
                advance (10)
                #03DB
                #instruction: LD   A,(HL)
                let:8 a174 = a104[15:8] in
                let:8 a175 = a104[7:0] in
                let:8 a176 = M[(a174,a175)] in
                advance (7)
                #03DC
                #instruction: CP   0F
                let:8 a177 = a176 in
                let:16 a178 = addWithCarry(!false,a177,~0F) in
                let:8 a179 = (a177 & 0F) in
                let:8 a180 = (~0F & 0F) in
                let:16 a181 = addWithCarry(!false,a179,a180) in
                advance (7)
                #03DE
                #instruction: RET  NZ
                if (!is_zero(a178[7:0])) {
                  let:8 a182 = a7[15:8] in
                  let:8 a183 = a7[7:0] in
                  let:16 a184 = (1 + (a182,a183)) in
                  let:8 a185 = M[(a182,a183)] in
                  let:8 a186 = a184[15:8] in
                  let:8 a187 = a184[7:0] in
                  let:16 a188 = (1 + (a186,a187)) in
                  let:8 a189 = M[(a186,a187)] in
                  advance (11)
                  A := a176;
                  H := a104[15:8];
                  L := a104[7:0];
                  SPH := a188[15:8];
                  SPL := a188[7:0];
                  FlagS := a178[7:0][7];
                  FlagZ := is_zero(a178[7:0]);
                  FlagA := a181[7:0][4];
                  FlagP := parity(a178[7:0]);
                  FlagCY := !a178[15:8][0];
                  jump ((a189,a185));
                } else {
                  advance (5)
                  #03DF
                  #instruction: PUSH HL
                  let:8 a190 = a104[15:8] in
                  let:8 a191 = a104[7:0] in
                  let:8 a192 = a7[15:8] in
                  let:8 a193 = a7[7:0] in
                  let:16 a194 = (-1 + (a192,a193)) in
                  M[a194] := a190;
                  let:8 a195 = a194[15:8] in
                  let:8 a196 = a194[7:0] in
                  let:16 a197 = (-1 + (a195,a196)) in
                  M[a197] := a191;
                  advance (11)
                  #03E0
                  #instruction: CALL 0430
                  let:8 a198 = a197[15:8] in
                  let:8 a199 = a197[7:0] in
                  let:16 a200 = (-1 + (a198,a199)) in
                  M[a200] := 03;
                  let:8 a201 = a200[15:8] in
                  let:8 a202 = a200[7:0] in
                  let:16 a203 = (-1 + (a201,a202)) in
                  M[a203] := E3;
                  #return-to: 03E3
                  advance (17)
                  #0430
                  #instruction: LD   HL,2027
                  advance (10)
                  #0433
                  #instruction: JP   1A3B
                  advance (10)
                  #1A3B
                  #instruction: LD   E,(HL)
                  let:8 a204 = M[2027] in
                  advance (7)
                  #1A3C
                  #instruction: INC  HL
                  advance (5)
                  #1A3D
                  #instruction: LD   D,(HL)
                  let:8 a205 = M[2028] in
                  advance (7)
                  #1A3E
                  #instruction: INC  HL
                  advance (5)
                  #1A3F
                  #instruction: LD   A,(HL)
                  let:8 a206 = M[2029] in
                  advance (7)
                  #1A40
                  #instruction: INC  HL
                  advance (5)
                  #1A41
                  #instruction: LD   C,(HL)
                  let:8 a207 = M[202A] in
                  advance (7)
                  #1A42
                  #instruction: INC  HL
                  advance (5)
                  #1A43
                  #instruction: LD   B,(HL)
                  let:8 a208 = M[202B] in
                  advance (7)
                  #1A44
                  #instruction: LD   H,C
                  let:8 a209 = a207 in
                  advance (5)
                  #1A45
                  #instruction: LD   L,A
                  let:8 a210 = a206 in
                  advance (5)
                  #1A46
                  #instruction: RET
                  let:8 a211 = a203[15:8] in
                  let:8 a212 = a203[7:0] in
                  let:16 a213 = (1 + (a211,a212)) in
                  let:8 a214 = M[(a211,a212)] in
                  let:8 a215 = a213[15:8] in
                  let:8 a216 = a213[7:0] in
                  let:16 a217 = (1 + (a215,a216)) in
                  let:8 a218 = M[(a215,a216)] in
                  advance (10)
                  A := a206;
                  B := a208;
                  C := a207;
                  D := a205;
                  E := a204;
                  H := a209;
                  L := a210;
                  SPH := a217[15:8];
                  SPL := a217[7:0];
                  FlagS := a178[7:0][7];
                  FlagZ := is_zero(a178[7:0]);
                  FlagA := a181[7:0][4];
                  FlagP := parity(a178[7:0]);
                  FlagCY := !a178[15:8][0];
                  jump ((a218,a214));
                }
              }
            }
          }
        }
      }
    }

03E3:

    #03E3
    #instruction: CALL 1452
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 03;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := E6;
    #return-to: 03E6
    advance (17)
    #1452
    #instruction: CALL 1474
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 14;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a13 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a14 = a13 in
    let:8 a15 = (07 & a14) in
    let:8 a16 = (07 | a14) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a17 = a15 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a18 = B in
    let:8 a19 = C in
    let:8 a20 = a12[15:8] in
    let:8 a21 = a12[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := a18;
    let:8 a23 = a22[15:8] in
    let:8 a24 = a22[7:0] in
    let:16 a25 = (-1 + (a23,a24)) in
    M[a25] := a19;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a26 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a27 = a26 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a28 = updateBit((a27 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a29 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a30 = a29 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a31 = updateBit((a30 >> 01),7,a27[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a32 = addWithCarry(!true,03,~00) in
    let:8 a33 = (03 & 0F) in
    let:8 a34 = (~00 & 0F) in
    let:16 a35 = addWithCarry(!true,a33,a34) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a32[7:0])) {
      advance (10)
      A := updateBit((a30 >> 01),7,a27[0]);
      B := a32[7:0];
      H := a28;
      L := a31;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a32[7:0][7];
      FlagZ := is_zero(a32[7:0]);
      FlagA := a35[7:0][4];
      FlagP := parity(a32[7:0]);
      FlagCY := a30[0];
      Shifter_OFF := a17;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a36 = a28 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a37 = a36 in
      let:8 a38 = (3F & a37) in
      let:8 a39 = (3F | a37) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a40 = a38 in
      let:8 a41 = (20 | a40) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a42 = a41 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a43 = a25[15:8] in
      let:8 a44 = a25[7:0] in
      let:16 a45 = (1 + (a43,a44)) in
      let:8 a46 = M[(a43,a44)] in
      let:8 a47 = a45[15:8] in
      let:8 a48 = a45[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a51 = a49[15:8] in
      let:8 a52 = a49[7:0] in
      let:16 a53 = (1 + (a51,a52)) in
      let:8 a54 = M[(a51,a52)] in
      let:8 a55 = a53[15:8] in
      let:8 a56 = a53[7:0] in
      let:16 a57 = (1 + (a55,a56)) in
      let:8 a58 = M[(a55,a56)] in
      advance (10)
      A := a41;
      B := a50;
      C := a46;
      H := a42;
      L := a31;
      SPH := a57[15:8];
      SPL := a57[7:0];
      FlagS := a41[7];
      FlagZ := is_zero(a41);
      FlagA := false;
      FlagP := parity(a41);
      FlagCY := false;
      Shifter_OFF := a17;
      jump ((a58,a54));
    }

03E6:

    #03E6
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #03E7
    #instruction: INC  HL
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #03E8
    #instruction: INC  (HL)
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:8 a14 = M[(a12,a13)] in
    let:16 a15 = addWithCarry(true,a14,00) in
    let:8 a16 = (a14 & 0F) in
    let:8 a17 = (00 & 0F) in
    let:16 a18 = addWithCarry(true,a16,a17) in
    let:8 a19 = a11[15:8] in
    let:8 a20 = a11[7:0] in
    M[(a19,a20)] := a15[7:0];
    advance (10)
    #03E9
    #instruction: INC  HL
    let:8 a21 = a11[15:8] in
    let:8 a22 = a11[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    advance (5)
    #03EA
    #instruction: INC  HL
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (1 + (a24,a25)) in
    advance (5)
    #03EB
    #instruction: DEC  (HL)
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:8 a29 = M[(a27,a28)] in
    let:16 a30 = addWithCarry(!true,a29,~00) in
    let:8 a31 = (a29 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    let:8 a34 = a26[15:8] in
    let:8 a35 = a26[7:0] in
    M[(a34,a35)] := a30[7:0];
    advance (10)
    #03EC
    #instruction: DEC  (HL)
    let:8 a36 = a26[15:8] in
    let:8 a37 = a26[7:0] in
    let:8 a38 = M[(a36,a37)] in
    let:16 a39 = addWithCarry(!true,a38,~00) in
    let:8 a40 = (a38 & 0F) in
    let:8 a41 = (~00 & 0F) in
    let:16 a42 = addWithCarry(!true,a40,a41) in
    let:8 a43 = a26[15:8] in
    let:8 a44 = a26[7:0] in
    M[(a43,a44)] := a39[7:0];
    advance (10)
    #03ED
    #instruction: INC  HL
    let:8 a45 = a26[15:8] in
    let:8 a46 = a26[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    advance (5)
    #03EE
    #instruction: DEC  (HL)
    let:8 a48 = a47[15:8] in
    let:8 a49 = a47[7:0] in
    let:8 a50 = M[(a48,a49)] in
    let:16 a51 = addWithCarry(!true,a50,~00) in
    let:8 a52 = (a50 & 0F) in
    let:8 a53 = (~00 & 0F) in
    let:16 a54 = addWithCarry(!true,a52,a53) in
    let:8 a55 = a47[15:8] in
    let:8 a56 = a47[7:0] in
    M[(a55,a56)] := a51[7:0];
    advance (10)
    #03EF
    #instruction: DEC  (HL)
    let:8 a57 = a47[15:8] in
    let:8 a58 = a47[7:0] in
    let:8 a59 = M[(a57,a58)] in
    let:16 a60 = addWithCarry(!true,a59,~00) in
    let:8 a61 = (a59 & 0F) in
    let:8 a62 = (~00 & 0F) in
    let:16 a63 = addWithCarry(!true,a61,a62) in
    let:8 a64 = a47[15:8] in
    let:8 a65 = a47[7:0] in
    M[(a64,a65)] := a60[7:0];
    advance (10)
    #03F0
    #instruction: DEC  (HL)
    let:8 a66 = a47[15:8] in
    let:8 a67 = a47[7:0] in
    let:8 a68 = M[(a66,a67)] in
    let:16 a69 = addWithCarry(!true,a68,~00) in
    let:8 a70 = (a68 & 0F) in
    let:8 a71 = (~00 & 0F) in
    let:16 a72 = addWithCarry(!true,a70,a71) in
    let:8 a73 = a47[15:8] in
    let:8 a74 = a47[7:0] in
    M[(a73,a74)] := a69[7:0];
    advance (10)
    #03F1
    #instruction: INC  HL
    let:8 a75 = a47[15:8] in
    let:8 a76 = a47[7:0] in
    let:16 a77 = (1 + (a75,a76)) in
    advance (5)
    #03F2
    #instruction: LD   (HL),08
    let:8 a78 = a77[15:8] in
    let:8 a79 = a77[7:0] in
    M[(a78,a79)] := 08;
    advance (10)
    #03F4
    #instruction: CALL 0430
    let:8 a80 = a7[15:8] in
    let:8 a81 = a7[7:0] in
    let:16 a82 = (-1 + (a80,a81)) in
    M[a82] := 03;
    let:8 a83 = a82[15:8] in
    let:8 a84 = a82[7:0] in
    let:16 a85 = (-1 + (a83,a84)) in
    M[a85] := F7;
    #return-to: 03F7
    advance (17)
    #0430
    #instruction: LD   HL,2027
    advance (10)
    #0433
    #instruction: JP   1A3B
    advance (10)
    #1A3B
    #instruction: LD   E,(HL)
    let:8 a86 = M[2027] in
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    let:8 a87 = M[2028] in
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    let:8 a88 = M[2029] in
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    let:8 a89 = M[202A] in
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    let:8 a90 = M[202B] in
    advance (7)
    #1A44
    #instruction: LD   H,C
    let:8 a91 = a89 in
    advance (5)
    #1A45
    #instruction: LD   L,A
    let:8 a92 = a88 in
    advance (5)
    #1A46
    #instruction: RET
    let:8 a93 = a85[15:8] in
    let:8 a94 = a85[7:0] in
    let:16 a95 = (1 + (a93,a94)) in
    let:8 a96 = M[(a93,a94)] in
    let:8 a97 = a95[15:8] in
    let:8 a98 = a95[7:0] in
    let:16 a99 = (1 + (a97,a98)) in
    let:8 a100 = M[(a97,a98)] in
    advance (10)
    A := a88;
    B := a90;
    C := a89;
    D := a87;
    E := a86;
    H := a91;
    L := a92;
    SPH := a99[15:8];
    SPL := a99[7:0];
    FlagS := a69[7:0][7];
    FlagZ := is_zero(a69[7:0]);
    FlagA := a72[7:0][4];
    FlagP := parity(a69[7:0]);
    jump ((a100,a96));

03F7:

    #03F7
    #instruction: JP   1400
    advance (10)
    #1400
    #instruction: NOP
    advance (4)
    #1401
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 04;
    #return-to: 1404
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a7 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a8 = a7 in
    let:8 a9 = (07 & a8) in
    let:8 a10 = (07 | a8) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a11 = a9 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a12 = B in
    let:8 a13 = C in
    let:8 a14 = a6[15:8] in
    let:8 a15 = a6[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a20 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a21 = a20 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a22 = updateBit((a21 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a23 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a24 = a23 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a25 = updateBit((a24 >> 01),7,a21[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a26 = addWithCarry(!true,03,~00) in
    let:8 a27 = (03 & 0F) in
    let:8 a28 = (~00 & 0F) in
    let:16 a29 = addWithCarry(!true,a27,a28) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a26[7:0])) {
      advance (10)
      A := updateBit((a24 >> 01),7,a21[0]);
      B := a26[7:0];
      H := a22;
      L := a25;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a26[7:0][7];
      FlagZ := is_zero(a26[7:0]);
      FlagA := a29[7:0][4];
      FlagP := parity(a26[7:0]);
      FlagCY := a24[0];
      Shifter_OFF := a11;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a30 = a22 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a31 = a30 in
      let:8 a32 = (3F & a31) in
      let:8 a33 = (3F | a31) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a34 = a32 in
      let:8 a35 = (20 | a34) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a36 = a35 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a37 = a19[15:8] in
      let:8 a38 = a19[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      advance (10)
      A := a35;
      B := a44;
      C := a40;
      H := a36;
      L := a25;
      SPH := a51[15:8];
      SPL := a51[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := false;
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_OFF := a11;
      jump ((a52,a48));
    }

0407:

    #0407
    #instruction: JP   1400
    advance (10)
    #1400
    #instruction: NOP
    advance (4)
    #1401
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 04;
    #return-to: 1404
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a7 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a8 = a7 in
    let:8 a9 = (07 & a8) in
    let:8 a10 = (07 | a8) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a11 = a9 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a12 = B in
    let:8 a13 = C in
    let:8 a14 = a6[15:8] in
    let:8 a15 = a6[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a20 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a21 = a20 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a22 = updateBit((a21 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a23 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a24 = a23 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a25 = updateBit((a24 >> 01),7,a21[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a26 = addWithCarry(!true,03,~00) in
    let:8 a27 = (03 & 0F) in
    let:8 a28 = (~00 & 0F) in
    let:16 a29 = addWithCarry(!true,a27,a28) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a26[7:0])) {
      advance (10)
      A := updateBit((a24 >> 01),7,a21[0]);
      B := a26[7:0];
      H := a22;
      L := a25;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a26[7:0][7];
      FlagZ := is_zero(a26[7:0]);
      FlagA := a29[7:0][4];
      FlagP := parity(a26[7:0]);
      FlagCY := a24[0];
      Shifter_OFF := a11;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a30 = a22 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a31 = a30 in
      let:8 a32 = (3F & a31) in
      let:8 a33 = (3F | a31) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a34 = a32 in
      let:8 a35 = (20 | a34) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a36 = a35 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a37 = a19[15:8] in
      let:8 a38 = a19[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      advance (10)
      A := a35;
      B := a44;
      C := a40;
      H := a36;
      L := a25;
      SPH := a51[15:8];
      SPL := a51[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := false;
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_OFF := a11;
      jump ((a52,a48));
    }

040D:

    #040D
    #instruction: PUSH DE
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #040E
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #040F
    #instruction: PUSH BC
    let:8 a17 = B in
    let:8 a18 = C in
    let:8 a19 = a16[15:8] in
    let:8 a20 = a16[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := a17;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := a18;
    advance (11)
    #0410
    #instruction: CALL 1452
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := 04;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := 13;
    #return-to: 0413
    advance (17)
    #1452
    #instruction: CALL 1474
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := 14;
    let:8 a34 = a33[15:8] in
    let:8 a35 = a33[7:0] in
    let:16 a36 = (-1 + (a34,a35)) in
    M[a36] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a37 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a38 = a37 in
    let:8 a39 = (07 & a38) in
    let:8 a40 = (07 | a38) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a41 = a39 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a42 = B in
    let:8 a43 = C in
    let:8 a44 = a36[15:8] in
    let:8 a45 = a36[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := a42;
    let:8 a47 = a46[15:8] in
    let:8 a48 = a46[7:0] in
    let:16 a49 = (-1 + (a47,a48)) in
    M[a49] := a43;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a50 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a51 = a50 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a52 = updateBit((a51 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a53 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a54 = a53 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a55 = updateBit((a54 >> 01),7,a51[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a56 = addWithCarry(!true,03,~00) in
    let:8 a57 = (03 & 0F) in
    let:8 a58 = (~00 & 0F) in
    let:16 a59 = addWithCarry(!true,a57,a58) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a56[7:0])) {
      advance (10)
      A := updateBit((a54 >> 01),7,a51[0]);
      B := a56[7:0];
      H := a52;
      L := a55;
      SPH := a49[15:8];
      SPL := a49[7:0];
      FlagS := a56[7:0][7];
      FlagZ := is_zero(a56[7:0]);
      FlagA := a59[7:0][4];
      FlagP := parity(a56[7:0]);
      FlagCY := a54[0];
      Shifter_OFF := a41;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a60 = a52 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a61 = a60 in
      let:8 a62 = (3F & a61) in
      let:8 a63 = (3F | a61) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a64 = a62 in
      let:8 a65 = (20 | a64) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a66 = a65 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a67 = a49[15:8] in
      let:8 a68 = a49[7:0] in
      let:16 a69 = (1 + (a67,a68)) in
      let:8 a70 = M[(a67,a68)] in
      let:8 a71 = a69[15:8] in
      let:8 a72 = a69[7:0] in
      let:16 a73 = (1 + (a71,a72)) in
      let:8 a74 = M[(a71,a72)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a75 = a73[15:8] in
      let:8 a76 = a73[7:0] in
      let:16 a77 = (1 + (a75,a76)) in
      let:8 a78 = M[(a75,a76)] in
      let:8 a79 = a77[15:8] in
      let:8 a80 = a77[7:0] in
      let:16 a81 = (1 + (a79,a80)) in
      let:8 a82 = M[(a79,a80)] in
      advance (10)
      A := a65;
      B := a74;
      C := a70;
      H := a66;
      L := a55;
      SPH := a81[15:8];
      SPL := a81[7:0];
      FlagS := a65[7];
      FlagZ := is_zero(a65);
      FlagA := false;
      FlagP := parity(a65);
      FlagCY := false;
      Shifter_OFF := a41;
      jump ((a82,a78));
    }

0413:

    #0413
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0414
    #instruction: POP  HL
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    #0415
    #instruction: POP  DE
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    let:8 a21 = a19[15:8] in
    let:8 a22 = a19[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    advance (10)
    #0416
    #instruction: LD   A,(202C)
    let:8 a25 = M[202C] in
    advance (13)
    #0419
    #instruction: ADD  L
    let:8 a26 = a12 in
    let:8 a27 = a25 in
    let:16 a28 = addWithCarry(false,a26,a27) in
    let:8 a29 = (a26 & 0F) in
    let:8 a30 = (a27 & 0F) in
    let:16 a31 = addWithCarry(false,a29,a30) in
    advance (4)
    #041A
    #instruction: LD   L,A
    let:8 a32 = a28[7:0] in
    advance (5)
    #041B
    #instruction: LD   (2029),A
    let:8 a33 = a28[7:0] in
    M[2029] := a33;
    advance (13)
    #041E
    #instruction: CALL 1491
    let:8 a34 = a23[15:8] in
    let:8 a35 = a23[7:0] in
    let:16 a36 = (-1 + (a34,a35)) in
    M[a36] := 04;
    let:8 a37 = a36[15:8] in
    let:8 a38 = a36[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := 21;
    #return-to: 0421
    advance (17)
    #1491
    #instruction: CALL 1474
    let:8 a40 = a39[15:8] in
    let:8 a41 = a39[7:0] in
    let:16 a42 = (-1 + (a40,a41)) in
    M[a42] := 14;
    let:8 a43 = a42[15:8] in
    let:8 a44 = a42[7:0] in
    let:16 a45 = (-1 + (a43,a44)) in
    M[a45] := 94;
    #return-to: 1494
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a46 = a32 in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a47 = a46 in
    let:8 a48 = (07 & a47) in
    let:8 a49 = (07 | a47) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a50 = a48 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a51 = a8 in
    let:8 a52 = a4 in
    let:8 a53 = a45[15:8] in
    let:8 a54 = a45[7:0] in
    let:16 a55 = (-1 + (a53,a54)) in
    M[a55] := a51;
    let:8 a56 = a55[15:8] in
    let:8 a57 = a55[7:0] in
    let:16 a58 = (-1 + (a56,a57)) in
    M[a58] := a52;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a59 = a16 in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a60 = a59 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a61 = updateBit((a60 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a62 = a32 in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a63 = a62 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a64 = updateBit((a63 >> 01),7,a60[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a65 = addWithCarry(!true,03,~00) in
    let:8 a66 = (03 & 0F) in
    let:8 a67 = (~00 & 0F) in
    let:16 a68 = addWithCarry(!true,a66,a67) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a65[7:0])) {
      advance (10)
      A := updateBit((a63 >> 01),7,a60[0]);
      B := a65[7:0];
      C := a4;
      D := a24;
      E := a20;
      H := a61;
      L := a64;
      SPH := a58[15:8];
      SPL := a58[7:0];
      FlagS := a65[7:0][7];
      FlagZ := is_zero(a65[7:0]);
      FlagA := a68[7:0][4];
      FlagP := parity(a65[7:0]);
      FlagCY := a63[0];
      Shifter_OFF := a50;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a69 = a61 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a70 = a69 in
      let:8 a71 = (3F & a70) in
      let:8 a72 = (3F | a70) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a73 = a71 in
      let:8 a74 = (20 | a73) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a75 = a74 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a76 = a58[15:8] in
      let:8 a77 = a58[7:0] in
      let:16 a78 = (1 + (a76,a77)) in
      let:8 a79 = M[(a76,a77)] in
      let:8 a80 = a78[15:8] in
      let:8 a81 = a78[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      let:8 a88 = a86[15:8] in
      let:8 a89 = a86[7:0] in
      let:16 a90 = (1 + (a88,a89)) in
      let:8 a91 = M[(a88,a89)] in
      advance (10)
      A := a74;
      B := a83;
      C := a79;
      D := a24;
      E := a20;
      H := a75;
      L := a64;
      SPH := a90[15:8];
      SPL := a90[7:0];
      FlagS := a74[7];
      FlagZ := is_zero(a74);
      FlagA := false;
      FlagP := parity(a74);
      FlagCY := false;
      Shifter_OFF := a50;
      jump ((a91,a87));
    }

0421:

    #0421
    #instruction: LD   A,(2061)
    let:8 a1 = M[2061] in
    advance (13)
    #0424
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0425
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #0426
      #instruction: LD   (2002),A
      let:8 a14 = a4 in
      M[2002] := a14;
      advance (13)
      #0429
      #instruction: RET
      let:8 a15 = SPH in
      let:8 a16 = SPL in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (10)
      A := a4;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a22,a18));
    }

0439:

    #0439
    #instruction: CALL 1452
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 04;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3C;
    #return-to: 043C
    advance (17)
    #1452
    #instruction: CALL 1474
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 14;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a13 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a14 = a13 in
    let:8 a15 = (07 & a14) in
    let:8 a16 = (07 | a14) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a17 = a15 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a18 = B in
    let:8 a19 = C in
    let:8 a20 = a12[15:8] in
    let:8 a21 = a12[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := a18;
    let:8 a23 = a22[15:8] in
    let:8 a24 = a22[7:0] in
    let:16 a25 = (-1 + (a23,a24)) in
    M[a25] := a19;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a26 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a27 = a26 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a28 = updateBit((a27 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a29 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a30 = a29 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a31 = updateBit((a30 >> 01),7,a27[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a32 = addWithCarry(!true,03,~00) in
    let:8 a33 = (03 & 0F) in
    let:8 a34 = (~00 & 0F) in
    let:16 a35 = addWithCarry(!true,a33,a34) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a32[7:0])) {
      advance (10)
      A := updateBit((a30 >> 01),7,a27[0]);
      B := a32[7:0];
      H := a28;
      L := a31;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a32[7:0][7];
      FlagZ := is_zero(a32[7:0]);
      FlagA := a35[7:0][4];
      FlagP := parity(a32[7:0]);
      FlagCY := a30[0];
      Shifter_OFF := a17;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a36 = a28 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a37 = a36 in
      let:8 a38 = (3F & a37) in
      let:8 a39 = (3F | a37) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a40 = a38 in
      let:8 a41 = (20 | a40) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a42 = a41 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a43 = a25[15:8] in
      let:8 a44 = a25[7:0] in
      let:16 a45 = (1 + (a43,a44)) in
      let:8 a46 = M[(a43,a44)] in
      let:8 a47 = a45[15:8] in
      let:8 a48 = a45[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a51 = a49[15:8] in
      let:8 a52 = a49[7:0] in
      let:16 a53 = (1 + (a51,a52)) in
      let:8 a54 = M[(a51,a52)] in
      let:8 a55 = a53[15:8] in
      let:8 a56 = a53[7:0] in
      let:16 a57 = (1 + (a55,a56)) in
      let:8 a58 = M[(a55,a56)] in
      advance (10)
      A := a41;
      B := a50;
      C := a46;
      H := a42;
      L := a31;
      SPH := a57[15:8];
      SPL := a57[7:0];
      FlagS := a41[7];
      FlagZ := is_zero(a41);
      FlagA := false;
      FlagP := parity(a41);
      FlagCY := false;
      Shifter_OFF := a17;
      jump ((a58,a54));
    }

043C:

    #043C
    #instruction: LD   HL,2025
    advance (10)
    #043F
    #instruction: LD   DE,1B25
    advance (10)
    #0442
    #instruction: LD   B,07
    advance (7)
    #0444
    #instruction: CALL 1A32
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 04;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 47;
    #return-to: 0447
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2025] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,07,~00) in
    let:8 a8 = (07 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 26;
      H := 20;
      L := 26;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 26;
      H := 20;
      L := 26;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0447:

    #0447
    #instruction: LD   HL,(208D)
    let:8 a1 = M[208D] in
    let:8 a2 = M[208E] in
    advance (16)
    #044A
    #instruction: INC  L
    let:8 a3 = a1 in
    let:16 a4 = addWithCarry(true,a3,00) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (00 & 0F) in
    let:16 a7 = addWithCarry(true,a5,a6) in
    advance (5)
    #044B
    #instruction: LD   A,L
    let:8 a8 = a4[7:0] in
    advance (5)
    #044C
    #instruction: CP   63
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(!false,a9,~63) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~63 & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #044E
    #instruction: JP   CY,0453
    if (!a10[15:8][0]) {
      advance (10)
      #0453
      #instruction: LD   (208D),HL
      let:8 a14 = a4[7:0] in
      M[208D] := a14;
      let:8 a15 = a2 in
      M[208E] := a15;
      advance (16)
      #0456
      #instruction: LD   HL,(208F)
      let:8 a16 = M[208F] in
      let:8 a17 = M[2090] in
      advance (16)
      #0459
      #instruction: INC  L
      let:8 a18 = a16 in
      let:16 a19 = addWithCarry(true,a18,00) in
      let:8 a20 = (a18 & 0F) in
      let:8 a21 = (00 & 0F) in
      let:16 a22 = addWithCarry(true,a20,a21) in
      advance (5)
      #045A
      #instruction: LD   (208F),HL
      let:8 a23 = a19[7:0] in
      M[208F] := a23;
      let:8 a24 = a17 in
      M[2090] := a24;
      advance (16)
      #045D
      #instruction: LD   A,(2084)
      let:8 a25 = M[2084] in
      advance (13)
      #0460
      #instruction: AND  A
      let:8 a26 = a25 in
      let:8 a27 = a25 in
      let:8 a28 = (a26 & a27) in
      let:8 a29 = (a26 | a27) in
      advance (4)
      #0461
      #instruction: RET  NZ
      if (!is_zero(a28)) {
        let:8 a30 = SPH in
        let:8 a31 = SPL in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        let:8 a34 = a32[15:8] in
        let:8 a35 = a32[7:0] in
        let:16 a36 = (1 + (a34,a35)) in
        let:8 a37 = M[(a34,a35)] in
        advance (11)
        A := a28;
        H := a17;
        L := a19[7:0];
        SPH := a36[15:8];
        SPL := a36[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := a29[3];
        FlagP := parity(a28);
        FlagCY := false;
        jump ((a37,a33));
      } else {
        advance (5)
        #0462
        #instruction: LD   A,(HL)
        let:8 a38 = a17 in
        let:8 a39 = a19[7:0] in
        let:8 a40 = M[(a38,a39)] in
        advance (7)
        #0463
        #instruction: AND  01
        let:8 a41 = a40 in
        let:8 a42 = (01 & a41) in
        let:8 a43 = (01 | a41) in
        advance (7)
        #0465
        #instruction: LD   BC,0229
        advance (10)
        #0468
        #instruction: JP   NZ,046E
        if (!is_zero(a42)) {
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := 29;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := 02;
          advance (7)
          #0475
          #instruction: RET
          let:8 a44 = SPH in
          let:8 a45 = SPL in
          let:16 a46 = (1 + (a44,a45)) in
          let:8 a47 = M[(a44,a45)] in
          let:8 a48 = a46[15:8] in
          let:8 a49 = a46[7:0] in
          let:16 a50 = (1 + (a48,a49)) in
          let:8 a51 = M[(a48,a49)] in
          advance (10)
          A := a42;
          B := 02;
          C := 29;
          H := 20;
          L := 8C;
          SPH := a50[15:8];
          SPL := a50[7:0];
          FlagS := a42[7];
          FlagZ := is_zero(a42);
          FlagA := a43[3];
          FlagP := parity(a42);
          FlagCY := false;
          jump ((a51,a47));
        } else {
          advance (10)
          #046B
          #instruction: LD   BC,FEE0
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := E0;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := FE;
          advance (7)
          #0475
          #instruction: RET
          let:8 a52 = SPH in
          let:8 a53 = SPL in
          let:16 a54 = (1 + (a52,a53)) in
          let:8 a55 = M[(a52,a53)] in
          let:8 a56 = a54[15:8] in
          let:8 a57 = a54[7:0] in
          let:16 a58 = (1 + (a56,a57)) in
          let:8 a59 = M[(a56,a57)] in
          advance (10)
          A := a42;
          B := FE;
          C := E0;
          H := 20;
          L := 8C;
          SPH := a58[15:8];
          SPL := a58[7:0];
          FlagS := a42[7];
          FlagZ := is_zero(a42);
          FlagA := a43[3];
          FlagP := parity(a42);
          FlagCY := false;
          jump ((a59,a55));
        }
      }
    } else {
      advance (10)
      #0451
      #instruction: LD   L,54
      advance (7)
      #0453
      #instruction: LD   (208D),HL
      M[208D] := 54;
      let:8 a60 = a2 in
      M[208E] := a60;
      advance (16)
      #0456
      #instruction: LD   HL,(208F)
      let:8 a61 = M[208F] in
      let:8 a62 = M[2090] in
      advance (16)
      #0459
      #instruction: INC  L
      let:8 a63 = a61 in
      let:16 a64 = addWithCarry(true,a63,00) in
      let:8 a65 = (a63 & 0F) in
      let:8 a66 = (00 & 0F) in
      let:16 a67 = addWithCarry(true,a65,a66) in
      advance (5)
      #045A
      #instruction: LD   (208F),HL
      let:8 a68 = a64[7:0] in
      M[208F] := a68;
      let:8 a69 = a62 in
      M[2090] := a69;
      advance (16)
      #045D
      #instruction: LD   A,(2084)
      let:8 a70 = M[2084] in
      advance (13)
      #0460
      #instruction: AND  A
      let:8 a71 = a70 in
      let:8 a72 = a70 in
      let:8 a73 = (a71 & a72) in
      let:8 a74 = (a71 | a72) in
      advance (4)
      #0461
      #instruction: RET  NZ
      if (!is_zero(a73)) {
        let:8 a75 = SPH in
        let:8 a76 = SPL in
        let:16 a77 = (1 + (a75,a76)) in
        let:8 a78 = M[(a75,a76)] in
        let:8 a79 = a77[15:8] in
        let:8 a80 = a77[7:0] in
        let:16 a81 = (1 + (a79,a80)) in
        let:8 a82 = M[(a79,a80)] in
        advance (11)
        A := a73;
        H := a62;
        L := a64[7:0];
        SPH := a81[15:8];
        SPL := a81[7:0];
        FlagS := a73[7];
        FlagZ := is_zero(a73);
        FlagA := a74[3];
        FlagP := parity(a73);
        FlagCY := false;
        jump ((a82,a78));
      } else {
        advance (5)
        #0462
        #instruction: LD   A,(HL)
        let:8 a83 = a62 in
        let:8 a84 = a64[7:0] in
        let:8 a85 = M[(a83,a84)] in
        advance (7)
        #0463
        #instruction: AND  01
        let:8 a86 = a85 in
        let:8 a87 = (01 & a86) in
        let:8 a88 = (01 | a86) in
        advance (7)
        #0465
        #instruction: LD   BC,0229
        advance (10)
        #0468
        #instruction: JP   NZ,046E
        if (!is_zero(a87)) {
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := 29;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := 02;
          advance (7)
          #0475
          #instruction: RET
          let:8 a89 = SPH in
          let:8 a90 = SPL in
          let:16 a91 = (1 + (a89,a90)) in
          let:8 a92 = M[(a89,a90)] in
          let:8 a93 = a91[15:8] in
          let:8 a94 = a91[7:0] in
          let:16 a95 = (1 + (a93,a94)) in
          let:8 a96 = M[(a93,a94)] in
          advance (10)
          A := a87;
          B := 02;
          C := 29;
          H := 20;
          L := 8C;
          SPH := a95[15:8];
          SPL := a95[7:0];
          FlagS := a87[7];
          FlagZ := is_zero(a87);
          FlagA := a88[3];
          FlagP := parity(a87);
          FlagCY := false;
          jump ((a96,a92));
        } else {
          advance (10)
          #046B
          #instruction: LD   BC,FEE0
          advance (10)
          #046E
          #instruction: LD   HL,208A
          advance (10)
          #0471
          #instruction: LD   (HL),C
          M[208A] := E0;
          advance (7)
          #0472
          #instruction: INC  HL
          advance (5)
          #0473
          #instruction: INC  HL
          advance (5)
          #0474
          #instruction: LD   (HL),B
          M[208C] := FE;
          advance (7)
          #0475
          #instruction: RET
          let:8 a97 = SPH in
          let:8 a98 = SPL in
          let:16 a99 = (1 + (a97,a98)) in
          let:8 a100 = M[(a97,a98)] in
          let:8 a101 = a99[15:8] in
          let:8 a102 = a99[7:0] in
          let:16 a103 = (1 + (a101,a102)) in
          let:8 a104 = M[(a101,a102)] in
          advance (10)
          A := a87;
          B := FE;
          C := E0;
          H := 20;
          L := 8C;
          SPH := a103[15:8];
          SPL := a103[7:0];
          FlagS := a87[7];
          FlagZ := is_zero(a87);
          FlagA := a88[3];
          FlagP := parity(a87);
          FlagCY := false;
          jump ((a104,a100));
        }
      }
    }

0476:

    #0476
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0477
    #instruction: LD   A,(1B32)
    advance (13)
    #047A
    #instruction: LD   (2032),A
    M[2032] := 02;
    advance (13)
    #047D
    #instruction: LD   HL,(2038)
    let:8 a9 = M[2038] in
    let:8 a10 = M[2039] in
    advance (16)
    #0480
    #instruction: LD   A,L
    let:8 a11 = a9 in
    advance (5)
    #0481
    #instruction: OR   H
    let:8 a12 = a10 in
    let:8 a13 = a11 in
    let:8 a14 = (a12 | a13) in
    advance (4)
    #0482
    #instruction: JP   NZ,048A
    if (!is_zero(a14)) {
      advance (10)
      #048A
      #instruction: LD   DE,2035
      advance (10)
      #048D
      #instruction: LD   A,F9
      advance (7)
      #048F
      #instruction: CALL 0550
      let:8 a15 = a7[15:8] in
      let:8 a16 = a7[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 04;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 92;
      #return-to: 0492
      advance (17)
      #0550
      #instruction: LD   (207F),A
      M[207F] := F9;
      advance (13)
      #0553
      #instruction: LD   HL,2073
      advance (10)
      #0556
      #instruction: LD   B,0B
      advance (7)
      #0558
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      let:8 a21 = M[2035] in
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      let:8 a22 = a21 in
      M[2073] := a22;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a23 = addWithCarry(!true,0B,~00) in
      let:8 a24 = (0B & 0F) in
      let:8 a25 = (~00 & 0F) in
      let:16 a26 = addWithCarry(!true,a24,a25) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a23[7:0])) {
        advance (10)
        A := a21;
        B := a23[7:0];
        D := 20;
        E := 36;
        H := 20;
        L := 74;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a27 = a20[15:8] in
        let:8 a28 = a20[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        advance (10)
        A := a21;
        B := a23[7:0];
        D := 20;
        E := 36;
        H := 20;
        L := 74;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := false;
        jump ((a34,a30));
      }
    } else {
      advance (10)
      #0485
      #instruction: DEC  HL
      let:8 a35 = a10 in
      let:8 a36 = a9 in
      let:16 a37 = (-1 + (a35,a36)) in
      advance (5)
      #0486
      #instruction: LD   (2038),HL
      let:8 a38 = a37[7:0] in
      M[2038] := a38;
      let:8 a39 = a37[15:8] in
      M[2039] := a39;
      advance (16)
      #0489
      #instruction: RET
      let:8 a40 = a7[15:8] in
      let:8 a41 = a7[7:0] in
      let:16 a42 = (1 + (a40,a41)) in
      let:8 a43 = M[(a40,a41)] in
      let:8 a44 = a42[15:8] in
      let:8 a45 = a42[7:0] in
      let:16 a46 = (1 + (a44,a45)) in
      let:8 a47 = M[(a44,a45)] in
      advance (10)
      A := a14;
      H := a37[15:8];
      L := a37[7:0];
      SPH := a46[15:8];
      SPL := a46[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a47,a43));
    }

0492:

    #0492
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    #0495
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #0498
    #instruction: LD   A,(2056)
    let:8 a3 = M[2056] in
    advance (13)
    #049B
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #049E
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 04;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := A1;
    #return-to: 04A1
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    let:8 a11 = M[2073] in
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a12 = a11 in
    let:8 a13 = (80 & a12) in
    let:8 a14 = (80 | a12) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a13)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:8 a15 = a10[15:8] in
      let:8 a16 = a10[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 05;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      let:8 a21 = M[2072] in
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      let:8 a22 = M[207C] in
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a23 = a22 in
      let:8 a24 = (80 & a23) in
      let:8 a25 = (80 | a23) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a26 = a21 in
      let:8 a27 = a24 in
      let:8 a28 = (a26 ^ a27) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a28)) {
        let:8 a29 = a20[15:8] in
        let:8 a30 = a20[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        let:8 a33 = a31[15:8] in
        let:8 a34 = a31[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        advance (11)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := false;
        jump ((a36,a32));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:8 a37 = a20[15:8] in
        let:8 a38 = a20[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := true;
        jump ((a44,a40));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      let:8 a45 = M[20C1] in
      advance (13)
      #056F
      #instruction: CP   04
      let:8 a46 = a45 in
      let:16 a47 = addWithCarry(!false,a46,~04) in
      let:8 a48 = (a46 & 0F) in
      let:8 a49 = (~04 & 0F) in
      let:16 a50 = addWithCarry(!false,a48,a49) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      let:8 a51 = M[2069] in
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a47[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        let:8 a52 = M[2073] in
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a53 = a52 in
        let:8 a54 = (80 | a53) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        let:8 a55 = a54 in
        M[2073] := a55;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:8 a56 = M[2074] in
        let:16 a57 = addWithCarry(true,a56,00) in
        let:8 a58 = (a56 & 0F) in
        let:8 a59 = (00 & 0F) in
        let:16 a60 = addWithCarry(true,a58,a59) in
        M[2074] := a57[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:8 a61 = a10[15:8] in
        let:8 a62 = a10[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        let:8 a65 = a63[15:8] in
        let:8 a66 = a63[7:0] in
        let:16 a67 = (1 + (a65,a66)) in
        let:8 a68 = M[(a65,a66)] in
        advance (10)
        A := a54;
        H := 20;
        L := 74;
        SPH := a67[15:8];
        SPL := a67[7:0];
        FlagS := a57[7:0][7];
        FlagZ := is_zero(a57[7:0]);
        FlagA := a60[7:0][4];
        FlagP := parity(a57[7:0]);
        FlagCY := false;
        jump ((a68,a64));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a69 = a51 in
        let:8 a70 = a51 in
        let:8 a71 = (a69 & a70) in
        let:8 a72 = (a69 | a70) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a71)) {
          let:8 a73 = a10[15:8] in
          let:8 a74 = a10[7:0] in
          let:16 a75 = (1 + (a73,a74)) in
          let:8 a76 = M[(a73,a74)] in
          let:8 a77 = a75[15:8] in
          let:8 a78 = a75[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          advance (11)
          A := a71;
          H := 20;
          L := 73;
          SPH := a79[15:8];
          SPL := a79[7:0];
          FlagS := a71[7];
          FlagZ := is_zero(a71);
          FlagA := a72[3];
          FlagP := parity(a71);
          FlagCY := false;
          jump ((a80,a76));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          let:8 a81 = M[2070] in
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a82 = a81 in
          let:8 a83 = a81 in
          let:8 a84 = (a82 & a83) in
          let:8 a85 = (a82 | a83) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a84)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            let:8 a86 = M[2071] in
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a87 = a86 in
            let:8 a88 = a86 in
            let:8 a89 = (a87 & a88) in
            let:8 a90 = (a87 | a88) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a89)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              let:8 a91 = M[2075] in
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a92 = a91 in
              let:8 a93 = a91 in
              let:8 a94 = (a92 & a93) in
              let:8 a95 = (a92 | a93) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a94)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                let:8 a96 = M[201B] in
                advance (13)
                #061E
                #instruction: ADD  08
                let:8 a97 = a96 in
                let:16 a98 = addWithCarry(false,08,a97) in
                let:8 a99 = (08 & 0F) in
                let:8 a100 = (a97 & 0F) in
                let:16 a101 = addWithCarry(false,a99,a100) in
                advance (7)
                #0620
                #instruction: LD   H,A
                let:8 a102 = a98[7:0] in
                advance (5)
                #0621
                #instruction: CALL 156F
                let:8 a103 = a10[15:8] in
                let:8 a104 = a10[7:0] in
                let:16 a105 = (-1 + (a103,a104)) in
                M[a105] := 06;
                let:8 a106 = a105[15:8] in
                let:8 a107 = a105[7:0] in
                let:16 a108 = (-1 + (a106,a107)) in
                M[a108] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                let:8 a109 = M[200A] in
                advance (13)
                #1572
                #instruction: CALL 1554
                let:8 a110 = a108[15:8] in
                let:8 a111 = a108[7:0] in
                let:16 a112 = (-1 + (a110,a111)) in
                M[a112] := 15;
                let:8 a113 = a112[15:8] in
                let:8 a114 = a112[7:0] in
                let:16 a115 = (-1 + (a113,a114)) in
                M[a115] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:8 a116 = a109 in
                let:8 a117 = a102 in
                let:16 a118 = addWithCarry(!false,a116,~a117) in
                let:8 a119 = (a116 & 0F) in
                let:8 a120 = (~a117 & 0F) in
                let:16 a121 = addWithCarry(!false,a119,a120) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a118[15:8][0]) {
                  let:8 a122 = a115[15:8] in
                  let:8 a123 = a115[7:0] in
                  let:16 a124 = (-1 + (a122,a123)) in
                  M[a124] := 15;
                  let:8 a125 = a124[15:8] in
                  let:8 a126 = a124[7:0] in
                  let:16 a127 = (-1 + (a125,a126)) in
                  M[a127] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a128 = addWithCarry(true,00,00) in
                  let:8 a129 = (00 & 0F) in
                  let:8 a130 = (00 & 0F) in
                  let:16 a131 = addWithCarry(true,a129,a130) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:8 a132 = a109 in
                  let:16 a133 = addWithCarry(false,10,a132) in
                  let:8 a134 = (10 & 0F) in
                  let:8 a135 = (a132 & 0F) in
                  let:16 a136 = addWithCarry(false,a134,a135) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a133[7:0][7]) {
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a127[15:8];
                    SPL := a127[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:8 a137 = a127[15:8] in
                    let:8 a138 = a127[7:0] in
                    let:16 a139 = (1 + (a137,a138)) in
                    let:8 a140 = M[(a137,a138)] in
                    let:8 a141 = a139[15:8] in
                    let:8 a142 = a139[7:0] in
                    let:16 a143 = (1 + (a141,a142)) in
                    let:8 a144 = M[(a141,a142)] in
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a143[15:8];
                    SPL := a143[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump ((a144,a140));
                  }
                } else {
                  advance (11)
                  A := a109;
                  C := 00;
                  H := a102;
                  L := 75;
                  SPH := a115[15:8];
                  SPL := a115[7:0];
                  FlagS := a118[7:0][7];
                  FlagZ := is_zero(a118[7:0]);
                  FlagA := a121[7:0][4];
                  FlagP := parity(a118[7:0]);
                  FlagCY := !a118[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                let:8 a145 = M[2076] in
                let:8 a146 = M[2077] in
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                let:8 a147 = a146 in
                let:8 a148 = a145 in
                let:8 a149 = M[(a147,a148)] in
                advance (7)
                #05A0
                #instruction: INC  HL
                let:8 a150 = a146 in
                let:8 a151 = a145 in
                let:16 a152 = (1 + (a150,a151)) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                let:8 a153 = a152[7:0] in
                M[2076] := a153;
                let:8 a154 = a152[15:8] in
                M[2077] := a154;
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:8 a155 = a10[15:8] in
                let:8 a156 = a10[7:0] in
                let:16 a157 = (-1 + (a155,a156)) in
                M[a157] := 05;
                let:8 a158 = a157[15:8] in
                let:8 a159 = a157[7:0] in
                let:16 a160 = (-1 + (a158,a159)) in
                M[a160] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:8 a161 = a149 in
                let:16 a162 = addWithCarry(!true,a161,~00) in
                let:8 a163 = (a161 & 0F) in
                let:8 a164 = (~00 & 0F) in
                let:16 a165 = addWithCarry(!true,a163,a164) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                let:8 a166 = M[2067] in
                advance (13)
                #0633
                #instruction: LD   H,A
                let:8 a167 = a166 in
                advance (5)
                #0634
                #instruction: LD   L,C
                let:8 a168 = a162[7:0] in
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                let:8 a169 = a167 in
                let:8 a170 = a168 in
                let:8 a171 = M[(a169,a170)] in
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a172 = a171 in
                let:8 a173 = a171 in
                let:8 a174 = (a172 & a173) in
                let:8 a175 = (a172 | a173) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a174)) {
                  let:8 a176 = a160[15:8] in
                  let:8 a177 = a160[7:0] in
                  let:16 a178 = (1 + (a176,a177)) in
                  let:8 a179 = M[(a176,a177)] in
                  let:8 a180 = a178[15:8] in
                  let:8 a181 = a178[7:0] in
                  let:16 a182 = (1 + (a180,a181)) in
                  let:8 a183 = M[(a180,a181)] in
                  advance (11)
                  A := a174;
                  C := a162[7:0];
                  D := 05;
                  H := a167;
                  L := a168;
                  SPH := a182[15:8];
                  SPL := a182[7:0];
                  FlagS := a174[7];
                  FlagZ := is_zero(a174);
                  FlagA := a175[3];
                  FlagP := parity(a174);
                  FlagCY := true;
                  jump ((a183,a179));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  let:8 a184 = a168 in
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:8 a185 = a184 in
                  let:16 a186 = addWithCarry(false,0B,a185) in
                  let:8 a187 = (0B & 0F) in
                  let:8 a188 = (a185 & 0F) in
                  let:16 a189 = addWithCarry(false,a187,a188) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  let:8 a190 = a186[7:0] in
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a191 = addWithCarry(!true,05,~00) in
                  let:8 a192 = (05 & 0F) in
                  let:8 a193 = (~00 & 0F) in
                  let:16 a194 = addWithCarry(!true,a192,a193) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a191[7:0])) {
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a160[15:8];
                    SPL := a160[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:8 a195 = a160[15:8] in
                    let:8 a196 = a160[7:0] in
                    let:16 a197 = (1 + (a195,a196)) in
                    let:8 a198 = M[(a195,a196)] in
                    let:8 a199 = a197[15:8] in
                    let:8 a200 = a197[7:0] in
                    let:16 a201 = (1 + (a199,a200)) in
                    let:8 a202 = M[(a199,a200)] in
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a201[15:8];
                    SPL := a201[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump ((a202,a198));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              let:8 a203 = a89 in
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              let:8 a204 = M[20CF] in
              advance (13)
              #0594
              #instruction: CP   B
              let:8 a205 = a204 in
              let:8 a206 = a203 in
              let:16 a207 = addWithCarry(!false,a205,~a206) in
              let:8 a208 = (a205 & 0F) in
              let:8 a209 = (~a206 & 0F) in
              let:16 a210 = addWithCarry(!false,a208,a209) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a207[15:8][0]) {
                let:8 a211 = a10[15:8] in
                let:8 a212 = a10[7:0] in
                let:16 a213 = (1 + (a211,a212)) in
                let:8 a214 = M[(a211,a212)] in
                let:8 a215 = a213[15:8] in
                let:8 a216 = a213[7:0] in
                let:16 a217 = (1 + (a215,a216)) in
                let:8 a218 = M[(a215,a216)] in
                advance (11)
                A := a204;
                B := a203;
                H := 20;
                L := 74;
                SPH := a217[15:8];
                SPL := a217[7:0];
                FlagS := a207[7:0][7];
                FlagZ := is_zero(a207[7:0]);
                FlagA := a210[7:0][4];
                FlagP := parity(a207[7:0]);
                FlagCY := !a207[15:8][0];
                jump ((a218,a214));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a219 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a220 = a219 in
                let:8 a221 = a219 in
                let:8 a222 = (a220 & a221) in
                let:8 a223 = (a220 | a221) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a222)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a224 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a225 = a224 in
                  let:16 a226 = addWithCarry(false,08,a225) in
                  let:8 a227 = (08 & 0F) in
                  let:8 a228 = (a225 & 0F) in
                  let:16 a229 = addWithCarry(false,a227,a228) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a230 = a226[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a231 = a10[15:8] in
                  let:8 a232 = a10[7:0] in
                  let:16 a233 = (-1 + (a231,a232)) in
                  M[a233] := 06;
                  let:8 a234 = a233[15:8] in
                  let:8 a235 = a233[7:0] in
                  let:16 a236 = (-1 + (a234,a235)) in
                  M[a236] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a237 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a238 = a236[15:8] in
                  let:8 a239 = a236[7:0] in
                  let:16 a240 = (-1 + (a238,a239)) in
                  M[a240] := 15;
                  let:8 a241 = a240[15:8] in
                  let:8 a242 = a240[7:0] in
                  let:16 a243 = (-1 + (a241,a242)) in
                  M[a243] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a244 = a237 in
                  let:8 a245 = a230 in
                  let:16 a246 = addWithCarry(!false,a244,~a245) in
                  let:8 a247 = (a244 & 0F) in
                  let:8 a248 = (~a245 & 0F) in
                  let:16 a249 = addWithCarry(!false,a247,a248) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a246[15:8][0]) {
                    let:8 a250 = a243[15:8] in
                    let:8 a251 = a243[7:0] in
                    let:16 a252 = (-1 + (a250,a251)) in
                    M[a252] := 15;
                    let:8 a253 = a252[15:8] in
                    let:8 a254 = a252[7:0] in
                    let:16 a255 = (-1 + (a253,a254)) in
                    M[a255] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a256 = addWithCarry(true,00,00) in
                    let:8 a257 = (00 & 0F) in
                    let:8 a258 = (00 & 0F) in
                    let:16 a259 = addWithCarry(true,a257,a258) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a260 = a237 in
                    let:16 a261 = addWithCarry(false,10,a260) in
                    let:8 a262 = (10 & 0F) in
                    let:8 a263 = (a260 & 0F) in
                    let:16 a264 = addWithCarry(false,a262,a263) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a261[7:0][7]) {
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a255[15:8];
                      SPL := a255[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a265 = a255[15:8] in
                      let:8 a266 = a255[7:0] in
                      let:16 a267 = (1 + (a265,a266)) in
                      let:8 a268 = M[(a265,a266)] in
                      let:8 a269 = a267[15:8] in
                      let:8 a270 = a267[7:0] in
                      let:16 a271 = (1 + (a269,a270)) in
                      let:8 a272 = M[(a269,a270)] in
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a271[15:8];
                      SPL := a271[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump ((a272,a268));
                    }
                  } else {
                    advance (11)
                    A := a237;
                    B := a203;
                    C := 00;
                    H := a230;
                    L := 75;
                    SPH := a243[15:8];
                    SPL := a243[7:0];
                    FlagS := a246[7:0][7];
                    FlagZ := is_zero(a246[7:0]);
                    FlagA := a249[7:0][4];
                    FlagP := parity(a246[7:0]);
                    FlagCY := !a246[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a273 = M[2076] in
                  let:8 a274 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a275 = a274 in
                  let:8 a276 = a273 in
                  let:8 a277 = M[(a275,a276)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a278 = a274 in
                  let:8 a279 = a273 in
                  let:16 a280 = (1 + (a278,a279)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a281 = a280[7:0] in
                  M[2076] := a281;
                  let:8 a282 = a280[15:8] in
                  M[2077] := a282;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a283 = a10[15:8] in
                  let:8 a284 = a10[7:0] in
                  let:16 a285 = (-1 + (a283,a284)) in
                  M[a285] := 05;
                  let:8 a286 = a285[15:8] in
                  let:8 a287 = a285[7:0] in
                  let:16 a288 = (-1 + (a286,a287)) in
                  M[a288] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a289 = a277 in
                  let:16 a290 = addWithCarry(!true,a289,~00) in
                  let:8 a291 = (a289 & 0F) in
                  let:8 a292 = (~00 & 0F) in
                  let:16 a293 = addWithCarry(!true,a291,a292) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a294 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a295 = a294 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a296 = a290[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a297 = a295 in
                  let:8 a298 = a296 in
                  let:8 a299 = M[(a297,a298)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a300 = a299 in
                  let:8 a301 = a299 in
                  let:8 a302 = (a300 & a301) in
                  let:8 a303 = (a300 | a301) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a302)) {
                    let:8 a304 = a288[15:8] in
                    let:8 a305 = a288[7:0] in
                    let:16 a306 = (1 + (a304,a305)) in
                    let:8 a307 = M[(a304,a305)] in
                    let:8 a308 = a306[15:8] in
                    let:8 a309 = a306[7:0] in
                    let:16 a310 = (1 + (a308,a309)) in
                    let:8 a311 = M[(a308,a309)] in
                    advance (11)
                    A := a302;
                    B := a203;
                    C := a290[7:0];
                    D := 05;
                    H := a295;
                    L := a296;
                    SPH := a310[15:8];
                    SPL := a310[7:0];
                    FlagS := a302[7];
                    FlagZ := is_zero(a302);
                    FlagA := a303[3];
                    FlagP := parity(a302);
                    FlagCY := true;
                    jump ((a311,a307));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a312 = a296 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a313 = a312 in
                    let:16 a314 = addWithCarry(false,0B,a313) in
                    let:8 a315 = (0B & 0F) in
                    let:8 a316 = (a313 & 0F) in
                    let:16 a317 = addWithCarry(false,a315,a316) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a318 = a314[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a319 = addWithCarry(!true,05,~00) in
                    let:8 a320 = (05 & 0F) in
                    let:8 a321 = (~00 & 0F) in
                    let:16 a322 = addWithCarry(!true,a320,a321) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a319[7:0])) {
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a288[15:8];
                      SPL := a288[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a323 = a288[15:8] in
                      let:8 a324 = a288[7:0] in
                      let:16 a325 = (1 + (a323,a324)) in
                      let:8 a326 = M[(a323,a324)] in
                      let:8 a327 = a325[15:8] in
                      let:8 a328 = a325[7:0] in
                      let:16 a329 = (1 + (a327,a328)) in
                      let:8 a330 = M[(a327,a328)] in
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a329[15:8];
                      SPL := a329[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump ((a330,a326));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            let:8 a331 = a84 in
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            let:8 a332 = M[20CF] in
            advance (13)
            #0587
            #instruction: CP   B
            let:8 a333 = a332 in
            let:8 a334 = a331 in
            let:16 a335 = addWithCarry(!false,a333,~a334) in
            let:8 a336 = (a333 & 0F) in
            let:8 a337 = (~a334 & 0F) in
            let:16 a338 = addWithCarry(!false,a336,a337) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a335[15:8][0]) {
              let:8 a339 = a10[15:8] in
              let:8 a340 = a10[7:0] in
              let:16 a341 = (1 + (a339,a340)) in
              let:8 a342 = M[(a339,a340)] in
              let:8 a343 = a341[15:8] in
              let:8 a344 = a341[7:0] in
              let:16 a345 = (1 + (a343,a344)) in
              let:8 a346 = M[(a343,a344)] in
              advance (11)
              A := a332;
              B := a331;
              H := 20;
              L := 74;
              SPH := a345[15:8];
              SPL := a345[7:0];
              FlagS := a335[7:0][7];
              FlagZ := is_zero(a335[7:0]);
              FlagA := a338[7:0][4];
              FlagP := parity(a335[7:0]);
              FlagCY := !a335[15:8][0];
              jump ((a346,a342));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              let:8 a347 = M[2071] in
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a348 = a347 in
              let:8 a349 = a347 in
              let:8 a350 = (a348 & a349) in
              let:8 a351 = (a348 | a349) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a350)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a352 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a353 = a352 in
                let:8 a354 = a352 in
                let:8 a355 = (a353 & a354) in
                let:8 a356 = (a353 | a354) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a355)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a357 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a358 = a357 in
                  let:16 a359 = addWithCarry(false,08,a358) in
                  let:8 a360 = (08 & 0F) in
                  let:8 a361 = (a358 & 0F) in
                  let:16 a362 = addWithCarry(false,a360,a361) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a363 = a359[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a364 = a10[15:8] in
                  let:8 a365 = a10[7:0] in
                  let:16 a366 = (-1 + (a364,a365)) in
                  M[a366] := 06;
                  let:8 a367 = a366[15:8] in
                  let:8 a368 = a366[7:0] in
                  let:16 a369 = (-1 + (a367,a368)) in
                  M[a369] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a370 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a371 = a369[15:8] in
                  let:8 a372 = a369[7:0] in
                  let:16 a373 = (-1 + (a371,a372)) in
                  M[a373] := 15;
                  let:8 a374 = a373[15:8] in
                  let:8 a375 = a373[7:0] in
                  let:16 a376 = (-1 + (a374,a375)) in
                  M[a376] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a377 = a370 in
                  let:8 a378 = a363 in
                  let:16 a379 = addWithCarry(!false,a377,~a378) in
                  let:8 a380 = (a377 & 0F) in
                  let:8 a381 = (~a378 & 0F) in
                  let:16 a382 = addWithCarry(!false,a380,a381) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a379[15:8][0]) {
                    let:8 a383 = a376[15:8] in
                    let:8 a384 = a376[7:0] in
                    let:16 a385 = (-1 + (a383,a384)) in
                    M[a385] := 15;
                    let:8 a386 = a385[15:8] in
                    let:8 a387 = a385[7:0] in
                    let:16 a388 = (-1 + (a386,a387)) in
                    M[a388] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a389 = addWithCarry(true,00,00) in
                    let:8 a390 = (00 & 0F) in
                    let:8 a391 = (00 & 0F) in
                    let:16 a392 = addWithCarry(true,a390,a391) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a393 = a370 in
                    let:16 a394 = addWithCarry(false,10,a393) in
                    let:8 a395 = (10 & 0F) in
                    let:8 a396 = (a393 & 0F) in
                    let:16 a397 = addWithCarry(false,a395,a396) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a394[7:0][7]) {
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a388[15:8];
                      SPL := a388[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a398 = a388[15:8] in
                      let:8 a399 = a388[7:0] in
                      let:16 a400 = (1 + (a398,a399)) in
                      let:8 a401 = M[(a398,a399)] in
                      let:8 a402 = a400[15:8] in
                      let:8 a403 = a400[7:0] in
                      let:16 a404 = (1 + (a402,a403)) in
                      let:8 a405 = M[(a402,a403)] in
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a404[15:8];
                      SPL := a404[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump ((a405,a401));
                    }
                  } else {
                    advance (11)
                    A := a370;
                    B := a331;
                    C := 00;
                    H := a363;
                    L := 75;
                    SPH := a376[15:8];
                    SPL := a376[7:0];
                    FlagS := a379[7:0][7];
                    FlagZ := is_zero(a379[7:0]);
                    FlagA := a382[7:0][4];
                    FlagP := parity(a379[7:0]);
                    FlagCY := !a379[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a406 = M[2076] in
                  let:8 a407 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a408 = a407 in
                  let:8 a409 = a406 in
                  let:8 a410 = M[(a408,a409)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a411 = a407 in
                  let:8 a412 = a406 in
                  let:16 a413 = (1 + (a411,a412)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a414 = a413[7:0] in
                  M[2076] := a414;
                  let:8 a415 = a413[15:8] in
                  M[2077] := a415;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a416 = a10[15:8] in
                  let:8 a417 = a10[7:0] in
                  let:16 a418 = (-1 + (a416,a417)) in
                  M[a418] := 05;
                  let:8 a419 = a418[15:8] in
                  let:8 a420 = a418[7:0] in
                  let:16 a421 = (-1 + (a419,a420)) in
                  M[a421] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a422 = a410 in
                  let:16 a423 = addWithCarry(!true,a422,~00) in
                  let:8 a424 = (a422 & 0F) in
                  let:8 a425 = (~00 & 0F) in
                  let:16 a426 = addWithCarry(!true,a424,a425) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a427 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a428 = a427 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a429 = a423[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a430 = a428 in
                  let:8 a431 = a429 in
                  let:8 a432 = M[(a430,a431)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a433 = a432 in
                  let:8 a434 = a432 in
                  let:8 a435 = (a433 & a434) in
                  let:8 a436 = (a433 | a434) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a435)) {
                    let:8 a437 = a421[15:8] in
                    let:8 a438 = a421[7:0] in
                    let:16 a439 = (1 + (a437,a438)) in
                    let:8 a440 = M[(a437,a438)] in
                    let:8 a441 = a439[15:8] in
                    let:8 a442 = a439[7:0] in
                    let:16 a443 = (1 + (a441,a442)) in
                    let:8 a444 = M[(a441,a442)] in
                    advance (11)
                    A := a435;
                    B := a331;
                    C := a423[7:0];
                    D := 05;
                    H := a428;
                    L := a429;
                    SPH := a443[15:8];
                    SPL := a443[7:0];
                    FlagS := a435[7];
                    FlagZ := is_zero(a435);
                    FlagA := a436[3];
                    FlagP := parity(a435);
                    FlagCY := true;
                    jump ((a444,a440));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a445 = a429 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a446 = a445 in
                    let:16 a447 = addWithCarry(false,0B,a446) in
                    let:8 a448 = (0B & 0F) in
                    let:8 a449 = (a446 & 0F) in
                    let:16 a450 = addWithCarry(false,a448,a449) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a451 = a447[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a452 = addWithCarry(!true,05,~00) in
                    let:8 a453 = (05 & 0F) in
                    let:8 a454 = (~00 & 0F) in
                    let:16 a455 = addWithCarry(!true,a453,a454) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a452[7:0])) {
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a421[15:8];
                      SPL := a421[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a456 = a421[15:8] in
                      let:8 a457 = a421[7:0] in
                      let:16 a458 = (1 + (a456,a457)) in
                      let:8 a459 = M[(a456,a457)] in
                      let:8 a460 = a458[15:8] in
                      let:8 a461 = a458[7:0] in
                      let:16 a462 = (1 + (a460,a461)) in
                      let:8 a463 = M[(a460,a461)] in
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a462[15:8];
                      SPL := a462[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump ((a463,a459));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                let:8 a464 = a350 in
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                let:8 a465 = M[20CF] in
                advance (13)
                #0594
                #instruction: CP   B
                let:8 a466 = a465 in
                let:8 a467 = a464 in
                let:16 a468 = addWithCarry(!false,a466,~a467) in
                let:8 a469 = (a466 & 0F) in
                let:8 a470 = (~a467 & 0F) in
                let:16 a471 = addWithCarry(!false,a469,a470) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a468[15:8][0]) {
                  let:8 a472 = a10[15:8] in
                  let:8 a473 = a10[7:0] in
                  let:16 a474 = (1 + (a472,a473)) in
                  let:8 a475 = M[(a472,a473)] in
                  let:8 a476 = a474[15:8] in
                  let:8 a477 = a474[7:0] in
                  let:16 a478 = (1 + (a476,a477)) in
                  let:8 a479 = M[(a476,a477)] in
                  advance (11)
                  A := a465;
                  B := a464;
                  H := 20;
                  L := 74;
                  SPH := a478[15:8];
                  SPL := a478[7:0];
                  FlagS := a468[7:0][7];
                  FlagZ := is_zero(a468[7:0]);
                  FlagA := a471[7:0][4];
                  FlagP := parity(a468[7:0]);
                  FlagCY := !a468[15:8][0];
                  jump ((a479,a475));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  let:8 a480 = M[2075] in
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a481 = a480 in
                  let:8 a482 = a480 in
                  let:8 a483 = (a481 & a482) in
                  let:8 a484 = (a481 | a482) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a483)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    let:8 a485 = M[201B] in
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:8 a486 = a485 in
                    let:16 a487 = addWithCarry(false,08,a486) in
                    let:8 a488 = (08 & 0F) in
                    let:8 a489 = (a486 & 0F) in
                    let:16 a490 = addWithCarry(false,a488,a489) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    let:8 a491 = a487[7:0] in
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:8 a492 = a10[15:8] in
                    let:8 a493 = a10[7:0] in
                    let:16 a494 = (-1 + (a492,a493)) in
                    M[a494] := 06;
                    let:8 a495 = a494[15:8] in
                    let:8 a496 = a494[7:0] in
                    let:16 a497 = (-1 + (a495,a496)) in
                    M[a497] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    let:8 a498 = M[200A] in
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:8 a499 = a497[15:8] in
                    let:8 a500 = a497[7:0] in
                    let:16 a501 = (-1 + (a499,a500)) in
                    M[a501] := 15;
                    let:8 a502 = a501[15:8] in
                    let:8 a503 = a501[7:0] in
                    let:16 a504 = (-1 + (a502,a503)) in
                    M[a504] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:8 a505 = a498 in
                    let:8 a506 = a491 in
                    let:16 a507 = addWithCarry(!false,a505,~a506) in
                    let:8 a508 = (a505 & 0F) in
                    let:8 a509 = (~a506 & 0F) in
                    let:16 a510 = addWithCarry(!false,a508,a509) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a507[15:8][0]) {
                      let:8 a511 = a504[15:8] in
                      let:8 a512 = a504[7:0] in
                      let:16 a513 = (-1 + (a511,a512)) in
                      M[a513] := 15;
                      let:8 a514 = a513[15:8] in
                      let:8 a515 = a513[7:0] in
                      let:16 a516 = (-1 + (a514,a515)) in
                      M[a516] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a517 = addWithCarry(true,00,00) in
                      let:8 a518 = (00 & 0F) in
                      let:8 a519 = (00 & 0F) in
                      let:16 a520 = addWithCarry(true,a518,a519) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:8 a521 = a498 in
                      let:16 a522 = addWithCarry(false,10,a521) in
                      let:8 a523 = (10 & 0F) in
                      let:8 a524 = (a521 & 0F) in
                      let:16 a525 = addWithCarry(false,a523,a524) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a522[7:0][7]) {
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a516[15:8];
                        SPL := a516[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:8 a526 = a516[15:8] in
                        let:8 a527 = a516[7:0] in
                        let:16 a528 = (1 + (a526,a527)) in
                        let:8 a529 = M[(a526,a527)] in
                        let:8 a530 = a528[15:8] in
                        let:8 a531 = a528[7:0] in
                        let:16 a532 = (1 + (a530,a531)) in
                        let:8 a533 = M[(a530,a531)] in
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a532[15:8];
                        SPL := a532[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump ((a533,a529));
                      }
                    } else {
                      advance (11)
                      A := a498;
                      B := a464;
                      C := 00;
                      H := a491;
                      L := 75;
                      SPH := a504[15:8];
                      SPL := a504[7:0];
                      FlagS := a507[7:0][7];
                      FlagZ := is_zero(a507[7:0]);
                      FlagA := a510[7:0][4];
                      FlagP := parity(a507[7:0]);
                      FlagCY := !a507[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    let:8 a534 = M[2076] in
                    let:8 a535 = M[2077] in
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    let:8 a536 = a535 in
                    let:8 a537 = a534 in
                    let:8 a538 = M[(a536,a537)] in
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:8 a539 = a535 in
                    let:8 a540 = a534 in
                    let:16 a541 = (1 + (a539,a540)) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    let:8 a542 = a541[7:0] in
                    M[2076] := a542;
                    let:8 a543 = a541[15:8] in
                    M[2077] := a543;
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:8 a544 = a10[15:8] in
                    let:8 a545 = a10[7:0] in
                    let:16 a546 = (-1 + (a544,a545)) in
                    M[a546] := 05;
                    let:8 a547 = a546[15:8] in
                    let:8 a548 = a546[7:0] in
                    let:16 a549 = (-1 + (a547,a548)) in
                    M[a549] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:8 a550 = a538 in
                    let:16 a551 = addWithCarry(!true,a550,~00) in
                    let:8 a552 = (a550 & 0F) in
                    let:8 a553 = (~00 & 0F) in
                    let:16 a554 = addWithCarry(!true,a552,a553) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    let:8 a555 = M[2067] in
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    let:8 a556 = a555 in
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    let:8 a557 = a551[7:0] in
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    let:8 a558 = a556 in
                    let:8 a559 = a557 in
                    let:8 a560 = M[(a558,a559)] in
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a561 = a560 in
                    let:8 a562 = a560 in
                    let:8 a563 = (a561 & a562) in
                    let:8 a564 = (a561 | a562) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a563)) {
                      let:8 a565 = a549[15:8] in
                      let:8 a566 = a549[7:0] in
                      let:16 a567 = (1 + (a565,a566)) in
                      let:8 a568 = M[(a565,a566)] in
                      let:8 a569 = a567[15:8] in
                      let:8 a570 = a567[7:0] in
                      let:16 a571 = (1 + (a569,a570)) in
                      let:8 a572 = M[(a569,a570)] in
                      advance (11)
                      A := a563;
                      B := a464;
                      C := a551[7:0];
                      D := 05;
                      H := a556;
                      L := a557;
                      SPH := a571[15:8];
                      SPL := a571[7:0];
                      FlagS := a563[7];
                      FlagZ := is_zero(a563);
                      FlagA := a564[3];
                      FlagP := parity(a563);
                      FlagCY := true;
                      jump ((a572,a568));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      let:8 a573 = a557 in
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:8 a574 = a573 in
                      let:16 a575 = addWithCarry(false,0B,a574) in
                      let:8 a576 = (0B & 0F) in
                      let:8 a577 = (a574 & 0F) in
                      let:16 a578 = addWithCarry(false,a576,a577) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      let:8 a579 = a575[7:0] in
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a580 = addWithCarry(!true,05,~00) in
                      let:8 a581 = (05 & 0F) in
                      let:8 a582 = (~00 & 0F) in
                      let:16 a583 = addWithCarry(!true,a581,a582) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a580[7:0])) {
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a549[15:8];
                        SPL := a549[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:8 a584 = a549[15:8] in
                        let:8 a585 = a549[7:0] in
                        let:16 a586 = (1 + (a584,a585)) in
                        let:8 a587 = M[(a584,a585)] in
                        let:8 a588 = a586[15:8] in
                        let:8 a589 = a586[7:0] in
                        let:16 a590 = (1 + (a588,a589)) in
                        let:8 a591 = M[(a588,a589)] in
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a590[15:8];
                        SPL := a590[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump ((a591,a587));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

04A1:

    #04A1
    #instruction: LD   A,(2078)
    let:8 a1 = M[2078] in
    advance (13)
    #04A4
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #04A5
    #instruction: LD   HL,2035
    advance (10)
    #04A8
    #instruction: JP   NZ,055B
    if (!is_zero(a4)) {
      advance (10)
      #055B
      #instruction: LD   DE,2073
      advance (10)
      #055E
      #instruction: LD   B,0B
      advance (7)
      #0560
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      let:8 a6 = M[2073] in
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      let:8 a7 = a6 in
      M[2035] := a7;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a8 = addWithCarry(!true,0B,~00) in
      let:8 a9 = (0B & 0F) in
      let:8 a10 = (~00 & 0F) in
      let:16 a11 = addWithCarry(!true,a9,a10) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a8[7:0])) {
        advance (10)
        A := a6;
        B := a8[7:0];
        D := 20;
        E := 74;
        H := 20;
        L := 36;
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a12 = SPH in
        let:8 a13 = SPL in
        let:16 a14 = (1 + (a12,a13)) in
        let:8 a15 = M[(a12,a13)] in
        let:8 a16 = a14[15:8] in
        let:8 a17 = a14[7:0] in
        let:16 a18 = (1 + (a16,a17)) in
        let:8 a19 = M[(a16,a17)] in
        advance (10)
        A := a6;
        B := a8[7:0];
        D := 20;
        E := 74;
        H := 20;
        L := 36;
        SPH := a18[15:8];
        SPL := a18[7:0];
        FlagS := a8[7:0][7];
        FlagZ := is_zero(a8[7:0]);
        FlagA := a11[7:0][4];
        FlagP := parity(a8[7:0]);
        FlagCY := false;
        jump ((a19,a15));
      }
    } else {
      advance (10)
      #04AB
      #instruction: LD   DE,1B30
      advance (10)
      #04AE
      #instruction: LD   HL,2030
      advance (10)
      #04B1
      #instruction: LD   B,10
      advance (7)
      #04B3
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[2030] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a20 = addWithCarry(!true,10,~00) in
      let:8 a21 = (10 & 0F) in
      let:8 a22 = (~00 & 0F) in
      let:16 a23 = addWithCarry(!true,a21,a22) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a20[7:0])) {
        advance (10)
        A := 00;
        B := a20[7:0];
        D := 1B;
        E := 31;
        H := 20;
        L := 31;
        FlagS := a20[7:0][7];
        FlagZ := is_zero(a20[7:0]);
        FlagA := a23[7:0][4];
        FlagP := parity(a20[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a24 = SPH in
        let:8 a25 = SPL in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        let:8 a28 = a26[15:8] in
        let:8 a29 = a26[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        advance (10)
        A := 00;
        B := a20[7:0];
        D := 1B;
        E := 31;
        H := 20;
        L := 31;
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a20[7:0][7];
        FlagZ := is_zero(a20[7:0]);
        FlagA := a23[7:0][4];
        FlagP := parity(a20[7:0]);
        FlagCY := false;
        jump ((a31,a27));
      }
    }

04B6:

    #04B6
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #04B7
    #instruction: LD   A,(206E)
    let:8 a9 = M[206E] in
    advance (13)
    #04BA
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #04BB
    #instruction: RET  NZ
    if (!is_zero(a12)) {
      let:8 a14 = a7[15:8] in
      let:8 a15 = a7[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      H := a8;
      L := a4;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #04BC
      #instruction: LD   A,(2080)
      let:8 a22 = M[2080] in
      advance (13)
      #04BF
      #instruction: CP   01
      let:8 a23 = a22 in
      let:16 a24 = addWithCarry(!false,a23,~01) in
      let:8 a25 = (a23 & 0F) in
      let:8 a26 = (~01 & 0F) in
      let:16 a27 = addWithCarry(!false,a25,a26) in
      advance (7)
      #04C1
      #instruction: RET  NZ
      if (!is_zero(a24[7:0])) {
        let:8 a28 = a7[15:8] in
        let:8 a29 = a7[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (11)
        A := a22;
        H := a8;
        L := a4;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump ((a35,a31));
      } else {
        advance (5)
        #04C2
        #instruction: LD   DE,2045
        advance (10)
        #04C5
        #instruction: LD   A,ED
        advance (7)
        #04C7
        #instruction: CALL 0550
        let:8 a36 = a7[15:8] in
        let:8 a37 = a7[7:0] in
        let:16 a38 = (-1 + (a36,a37)) in
        M[a38] := 04;
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := CA;
        #return-to: 04CA
        advance (17)
        #0550
        #instruction: LD   (207F),A
        M[207F] := ED;
        advance (13)
        #0553
        #instruction: LD   HL,2073
        advance (10)
        #0556
        #instruction: LD   B,0B
        advance (7)
        #0558
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a42 = M[2045] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a43 = a42 in
        M[2073] := a43;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a44 = addWithCarry(!true,0B,~00) in
        let:8 a45 = (0B & 0F) in
        let:8 a46 = (~00 & 0F) in
        let:16 a47 = addWithCarry(!true,a45,a46) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a44[7:0])) {
          advance (10)
          A := a42;
          B := a44[7:0];
          D := 20;
          E := 46;
          H := 20;
          L := 74;
          SPH := a41[15:8];
          SPL := a41[7:0];
          FlagS := a44[7:0][7];
          FlagZ := is_zero(a44[7:0]);
          FlagA := a47[7:0][4];
          FlagP := parity(a44[7:0]);
          FlagCY := !a24[15:8][0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a48 = a41[15:8] in
          let:8 a49 = a41[7:0] in
          let:16 a50 = (1 + (a48,a49)) in
          let:8 a51 = M[(a48,a49)] in
          let:8 a52 = a50[15:8] in
          let:8 a53 = a50[7:0] in
          let:16 a54 = (1 + (a52,a53)) in
          let:8 a55 = M[(a52,a53)] in
          advance (10)
          A := a42;
          B := a44[7:0];
          D := 20;
          E := 46;
          H := 20;
          L := 74;
          SPH := a54[15:8];
          SPL := a54[7:0];
          FlagS := a44[7:0][7];
          FlagZ := is_zero(a44[7:0]);
          FlagA := a47[7:0][4];
          FlagP := parity(a44[7:0]);
          FlagCY := !a24[15:8][0];
          jump ((a55,a51));
        }
      }
    }

04CA:

    #04CA
    #instruction: LD   A,(2036)
    let:8 a1 = M[2036] in
    advance (13)
    #04CD
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #04D0
    #instruction: LD   A,(2056)
    let:8 a3 = M[2056] in
    advance (13)
    #04D3
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #04D6
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 04;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := D9;
    #return-to: 04D9
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    let:8 a11 = M[2073] in
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a12 = a11 in
    let:8 a13 = (80 & a12) in
    let:8 a14 = (80 | a12) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a13)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:8 a15 = a10[15:8] in
      let:8 a16 = a10[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 05;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      let:8 a21 = M[2072] in
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      let:8 a22 = M[207C] in
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a23 = a22 in
      let:8 a24 = (80 & a23) in
      let:8 a25 = (80 | a23) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a26 = a21 in
      let:8 a27 = a24 in
      let:8 a28 = (a26 ^ a27) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a28)) {
        let:8 a29 = a20[15:8] in
        let:8 a30 = a20[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        let:8 a33 = a31[15:8] in
        let:8 a34 = a31[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        advance (11)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := false;
        jump ((a36,a32));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:8 a37 = a20[15:8] in
        let:8 a38 = a20[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := true;
        jump ((a44,a40));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      let:8 a45 = M[20C1] in
      advance (13)
      #056F
      #instruction: CP   04
      let:8 a46 = a45 in
      let:16 a47 = addWithCarry(!false,a46,~04) in
      let:8 a48 = (a46 & 0F) in
      let:8 a49 = (~04 & 0F) in
      let:16 a50 = addWithCarry(!false,a48,a49) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      let:8 a51 = M[2069] in
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a47[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        let:8 a52 = M[2073] in
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a53 = a52 in
        let:8 a54 = (80 | a53) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        let:8 a55 = a54 in
        M[2073] := a55;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:8 a56 = M[2074] in
        let:16 a57 = addWithCarry(true,a56,00) in
        let:8 a58 = (a56 & 0F) in
        let:8 a59 = (00 & 0F) in
        let:16 a60 = addWithCarry(true,a58,a59) in
        M[2074] := a57[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:8 a61 = a10[15:8] in
        let:8 a62 = a10[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        let:8 a65 = a63[15:8] in
        let:8 a66 = a63[7:0] in
        let:16 a67 = (1 + (a65,a66)) in
        let:8 a68 = M[(a65,a66)] in
        advance (10)
        A := a54;
        H := 20;
        L := 74;
        SPH := a67[15:8];
        SPL := a67[7:0];
        FlagS := a57[7:0][7];
        FlagZ := is_zero(a57[7:0]);
        FlagA := a60[7:0][4];
        FlagP := parity(a57[7:0]);
        FlagCY := false;
        jump ((a68,a64));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a69 = a51 in
        let:8 a70 = a51 in
        let:8 a71 = (a69 & a70) in
        let:8 a72 = (a69 | a70) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a71)) {
          let:8 a73 = a10[15:8] in
          let:8 a74 = a10[7:0] in
          let:16 a75 = (1 + (a73,a74)) in
          let:8 a76 = M[(a73,a74)] in
          let:8 a77 = a75[15:8] in
          let:8 a78 = a75[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          advance (11)
          A := a71;
          H := 20;
          L := 73;
          SPH := a79[15:8];
          SPL := a79[7:0];
          FlagS := a71[7];
          FlagZ := is_zero(a71);
          FlagA := a72[3];
          FlagP := parity(a71);
          FlagCY := false;
          jump ((a80,a76));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          let:8 a81 = M[2070] in
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a82 = a81 in
          let:8 a83 = a81 in
          let:8 a84 = (a82 & a83) in
          let:8 a85 = (a82 | a83) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a84)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            let:8 a86 = M[2071] in
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a87 = a86 in
            let:8 a88 = a86 in
            let:8 a89 = (a87 & a88) in
            let:8 a90 = (a87 | a88) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a89)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              let:8 a91 = M[2075] in
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a92 = a91 in
              let:8 a93 = a91 in
              let:8 a94 = (a92 & a93) in
              let:8 a95 = (a92 | a93) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a94)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                let:8 a96 = M[201B] in
                advance (13)
                #061E
                #instruction: ADD  08
                let:8 a97 = a96 in
                let:16 a98 = addWithCarry(false,08,a97) in
                let:8 a99 = (08 & 0F) in
                let:8 a100 = (a97 & 0F) in
                let:16 a101 = addWithCarry(false,a99,a100) in
                advance (7)
                #0620
                #instruction: LD   H,A
                let:8 a102 = a98[7:0] in
                advance (5)
                #0621
                #instruction: CALL 156F
                let:8 a103 = a10[15:8] in
                let:8 a104 = a10[7:0] in
                let:16 a105 = (-1 + (a103,a104)) in
                M[a105] := 06;
                let:8 a106 = a105[15:8] in
                let:8 a107 = a105[7:0] in
                let:16 a108 = (-1 + (a106,a107)) in
                M[a108] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                let:8 a109 = M[200A] in
                advance (13)
                #1572
                #instruction: CALL 1554
                let:8 a110 = a108[15:8] in
                let:8 a111 = a108[7:0] in
                let:16 a112 = (-1 + (a110,a111)) in
                M[a112] := 15;
                let:8 a113 = a112[15:8] in
                let:8 a114 = a112[7:0] in
                let:16 a115 = (-1 + (a113,a114)) in
                M[a115] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:8 a116 = a109 in
                let:8 a117 = a102 in
                let:16 a118 = addWithCarry(!false,a116,~a117) in
                let:8 a119 = (a116 & 0F) in
                let:8 a120 = (~a117 & 0F) in
                let:16 a121 = addWithCarry(!false,a119,a120) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a118[15:8][0]) {
                  let:8 a122 = a115[15:8] in
                  let:8 a123 = a115[7:0] in
                  let:16 a124 = (-1 + (a122,a123)) in
                  M[a124] := 15;
                  let:8 a125 = a124[15:8] in
                  let:8 a126 = a124[7:0] in
                  let:16 a127 = (-1 + (a125,a126)) in
                  M[a127] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a128 = addWithCarry(true,00,00) in
                  let:8 a129 = (00 & 0F) in
                  let:8 a130 = (00 & 0F) in
                  let:16 a131 = addWithCarry(true,a129,a130) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:8 a132 = a109 in
                  let:16 a133 = addWithCarry(false,10,a132) in
                  let:8 a134 = (10 & 0F) in
                  let:8 a135 = (a132 & 0F) in
                  let:16 a136 = addWithCarry(false,a134,a135) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a133[7:0][7]) {
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a127[15:8];
                    SPL := a127[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:8 a137 = a127[15:8] in
                    let:8 a138 = a127[7:0] in
                    let:16 a139 = (1 + (a137,a138)) in
                    let:8 a140 = M[(a137,a138)] in
                    let:8 a141 = a139[15:8] in
                    let:8 a142 = a139[7:0] in
                    let:16 a143 = (1 + (a141,a142)) in
                    let:8 a144 = M[(a141,a142)] in
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a143[15:8];
                    SPL := a143[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump ((a144,a140));
                  }
                } else {
                  advance (11)
                  A := a109;
                  C := 00;
                  H := a102;
                  L := 75;
                  SPH := a115[15:8];
                  SPL := a115[7:0];
                  FlagS := a118[7:0][7];
                  FlagZ := is_zero(a118[7:0]);
                  FlagA := a121[7:0][4];
                  FlagP := parity(a118[7:0]);
                  FlagCY := !a118[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                let:8 a145 = M[2076] in
                let:8 a146 = M[2077] in
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                let:8 a147 = a146 in
                let:8 a148 = a145 in
                let:8 a149 = M[(a147,a148)] in
                advance (7)
                #05A0
                #instruction: INC  HL
                let:8 a150 = a146 in
                let:8 a151 = a145 in
                let:16 a152 = (1 + (a150,a151)) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                let:8 a153 = a152[7:0] in
                M[2076] := a153;
                let:8 a154 = a152[15:8] in
                M[2077] := a154;
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:8 a155 = a10[15:8] in
                let:8 a156 = a10[7:0] in
                let:16 a157 = (-1 + (a155,a156)) in
                M[a157] := 05;
                let:8 a158 = a157[15:8] in
                let:8 a159 = a157[7:0] in
                let:16 a160 = (-1 + (a158,a159)) in
                M[a160] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:8 a161 = a149 in
                let:16 a162 = addWithCarry(!true,a161,~00) in
                let:8 a163 = (a161 & 0F) in
                let:8 a164 = (~00 & 0F) in
                let:16 a165 = addWithCarry(!true,a163,a164) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                let:8 a166 = M[2067] in
                advance (13)
                #0633
                #instruction: LD   H,A
                let:8 a167 = a166 in
                advance (5)
                #0634
                #instruction: LD   L,C
                let:8 a168 = a162[7:0] in
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                let:8 a169 = a167 in
                let:8 a170 = a168 in
                let:8 a171 = M[(a169,a170)] in
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a172 = a171 in
                let:8 a173 = a171 in
                let:8 a174 = (a172 & a173) in
                let:8 a175 = (a172 | a173) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a174)) {
                  let:8 a176 = a160[15:8] in
                  let:8 a177 = a160[7:0] in
                  let:16 a178 = (1 + (a176,a177)) in
                  let:8 a179 = M[(a176,a177)] in
                  let:8 a180 = a178[15:8] in
                  let:8 a181 = a178[7:0] in
                  let:16 a182 = (1 + (a180,a181)) in
                  let:8 a183 = M[(a180,a181)] in
                  advance (11)
                  A := a174;
                  C := a162[7:0];
                  D := 05;
                  H := a167;
                  L := a168;
                  SPH := a182[15:8];
                  SPL := a182[7:0];
                  FlagS := a174[7];
                  FlagZ := is_zero(a174);
                  FlagA := a175[3];
                  FlagP := parity(a174);
                  FlagCY := true;
                  jump ((a183,a179));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  let:8 a184 = a168 in
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:8 a185 = a184 in
                  let:16 a186 = addWithCarry(false,0B,a185) in
                  let:8 a187 = (0B & 0F) in
                  let:8 a188 = (a185 & 0F) in
                  let:16 a189 = addWithCarry(false,a187,a188) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  let:8 a190 = a186[7:0] in
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a191 = addWithCarry(!true,05,~00) in
                  let:8 a192 = (05 & 0F) in
                  let:8 a193 = (~00 & 0F) in
                  let:16 a194 = addWithCarry(!true,a192,a193) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a191[7:0])) {
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a160[15:8];
                    SPL := a160[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:8 a195 = a160[15:8] in
                    let:8 a196 = a160[7:0] in
                    let:16 a197 = (1 + (a195,a196)) in
                    let:8 a198 = M[(a195,a196)] in
                    let:8 a199 = a197[15:8] in
                    let:8 a200 = a197[7:0] in
                    let:16 a201 = (1 + (a199,a200)) in
                    let:8 a202 = M[(a199,a200)] in
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a201[15:8];
                    SPL := a201[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump ((a202,a198));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              let:8 a203 = a89 in
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              let:8 a204 = M[20CF] in
              advance (13)
              #0594
              #instruction: CP   B
              let:8 a205 = a204 in
              let:8 a206 = a203 in
              let:16 a207 = addWithCarry(!false,a205,~a206) in
              let:8 a208 = (a205 & 0F) in
              let:8 a209 = (~a206 & 0F) in
              let:16 a210 = addWithCarry(!false,a208,a209) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a207[15:8][0]) {
                let:8 a211 = a10[15:8] in
                let:8 a212 = a10[7:0] in
                let:16 a213 = (1 + (a211,a212)) in
                let:8 a214 = M[(a211,a212)] in
                let:8 a215 = a213[15:8] in
                let:8 a216 = a213[7:0] in
                let:16 a217 = (1 + (a215,a216)) in
                let:8 a218 = M[(a215,a216)] in
                advance (11)
                A := a204;
                B := a203;
                H := 20;
                L := 74;
                SPH := a217[15:8];
                SPL := a217[7:0];
                FlagS := a207[7:0][7];
                FlagZ := is_zero(a207[7:0]);
                FlagA := a210[7:0][4];
                FlagP := parity(a207[7:0]);
                FlagCY := !a207[15:8][0];
                jump ((a218,a214));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a219 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a220 = a219 in
                let:8 a221 = a219 in
                let:8 a222 = (a220 & a221) in
                let:8 a223 = (a220 | a221) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a222)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a224 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a225 = a224 in
                  let:16 a226 = addWithCarry(false,08,a225) in
                  let:8 a227 = (08 & 0F) in
                  let:8 a228 = (a225 & 0F) in
                  let:16 a229 = addWithCarry(false,a227,a228) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a230 = a226[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a231 = a10[15:8] in
                  let:8 a232 = a10[7:0] in
                  let:16 a233 = (-1 + (a231,a232)) in
                  M[a233] := 06;
                  let:8 a234 = a233[15:8] in
                  let:8 a235 = a233[7:0] in
                  let:16 a236 = (-1 + (a234,a235)) in
                  M[a236] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a237 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a238 = a236[15:8] in
                  let:8 a239 = a236[7:0] in
                  let:16 a240 = (-1 + (a238,a239)) in
                  M[a240] := 15;
                  let:8 a241 = a240[15:8] in
                  let:8 a242 = a240[7:0] in
                  let:16 a243 = (-1 + (a241,a242)) in
                  M[a243] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a244 = a237 in
                  let:8 a245 = a230 in
                  let:16 a246 = addWithCarry(!false,a244,~a245) in
                  let:8 a247 = (a244 & 0F) in
                  let:8 a248 = (~a245 & 0F) in
                  let:16 a249 = addWithCarry(!false,a247,a248) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a246[15:8][0]) {
                    let:8 a250 = a243[15:8] in
                    let:8 a251 = a243[7:0] in
                    let:16 a252 = (-1 + (a250,a251)) in
                    M[a252] := 15;
                    let:8 a253 = a252[15:8] in
                    let:8 a254 = a252[7:0] in
                    let:16 a255 = (-1 + (a253,a254)) in
                    M[a255] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a256 = addWithCarry(true,00,00) in
                    let:8 a257 = (00 & 0F) in
                    let:8 a258 = (00 & 0F) in
                    let:16 a259 = addWithCarry(true,a257,a258) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a260 = a237 in
                    let:16 a261 = addWithCarry(false,10,a260) in
                    let:8 a262 = (10 & 0F) in
                    let:8 a263 = (a260 & 0F) in
                    let:16 a264 = addWithCarry(false,a262,a263) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a261[7:0][7]) {
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a255[15:8];
                      SPL := a255[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a265 = a255[15:8] in
                      let:8 a266 = a255[7:0] in
                      let:16 a267 = (1 + (a265,a266)) in
                      let:8 a268 = M[(a265,a266)] in
                      let:8 a269 = a267[15:8] in
                      let:8 a270 = a267[7:0] in
                      let:16 a271 = (1 + (a269,a270)) in
                      let:8 a272 = M[(a269,a270)] in
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a271[15:8];
                      SPL := a271[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump ((a272,a268));
                    }
                  } else {
                    advance (11)
                    A := a237;
                    B := a203;
                    C := 00;
                    H := a230;
                    L := 75;
                    SPH := a243[15:8];
                    SPL := a243[7:0];
                    FlagS := a246[7:0][7];
                    FlagZ := is_zero(a246[7:0]);
                    FlagA := a249[7:0][4];
                    FlagP := parity(a246[7:0]);
                    FlagCY := !a246[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a273 = M[2076] in
                  let:8 a274 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a275 = a274 in
                  let:8 a276 = a273 in
                  let:8 a277 = M[(a275,a276)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a278 = a274 in
                  let:8 a279 = a273 in
                  let:16 a280 = (1 + (a278,a279)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a281 = a280[7:0] in
                  M[2076] := a281;
                  let:8 a282 = a280[15:8] in
                  M[2077] := a282;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a283 = a10[15:8] in
                  let:8 a284 = a10[7:0] in
                  let:16 a285 = (-1 + (a283,a284)) in
                  M[a285] := 05;
                  let:8 a286 = a285[15:8] in
                  let:8 a287 = a285[7:0] in
                  let:16 a288 = (-1 + (a286,a287)) in
                  M[a288] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a289 = a277 in
                  let:16 a290 = addWithCarry(!true,a289,~00) in
                  let:8 a291 = (a289 & 0F) in
                  let:8 a292 = (~00 & 0F) in
                  let:16 a293 = addWithCarry(!true,a291,a292) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a294 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a295 = a294 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a296 = a290[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a297 = a295 in
                  let:8 a298 = a296 in
                  let:8 a299 = M[(a297,a298)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a300 = a299 in
                  let:8 a301 = a299 in
                  let:8 a302 = (a300 & a301) in
                  let:8 a303 = (a300 | a301) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a302)) {
                    let:8 a304 = a288[15:8] in
                    let:8 a305 = a288[7:0] in
                    let:16 a306 = (1 + (a304,a305)) in
                    let:8 a307 = M[(a304,a305)] in
                    let:8 a308 = a306[15:8] in
                    let:8 a309 = a306[7:0] in
                    let:16 a310 = (1 + (a308,a309)) in
                    let:8 a311 = M[(a308,a309)] in
                    advance (11)
                    A := a302;
                    B := a203;
                    C := a290[7:0];
                    D := 05;
                    H := a295;
                    L := a296;
                    SPH := a310[15:8];
                    SPL := a310[7:0];
                    FlagS := a302[7];
                    FlagZ := is_zero(a302);
                    FlagA := a303[3];
                    FlagP := parity(a302);
                    FlagCY := true;
                    jump ((a311,a307));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a312 = a296 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a313 = a312 in
                    let:16 a314 = addWithCarry(false,0B,a313) in
                    let:8 a315 = (0B & 0F) in
                    let:8 a316 = (a313 & 0F) in
                    let:16 a317 = addWithCarry(false,a315,a316) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a318 = a314[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a319 = addWithCarry(!true,05,~00) in
                    let:8 a320 = (05 & 0F) in
                    let:8 a321 = (~00 & 0F) in
                    let:16 a322 = addWithCarry(!true,a320,a321) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a319[7:0])) {
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a288[15:8];
                      SPL := a288[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a323 = a288[15:8] in
                      let:8 a324 = a288[7:0] in
                      let:16 a325 = (1 + (a323,a324)) in
                      let:8 a326 = M[(a323,a324)] in
                      let:8 a327 = a325[15:8] in
                      let:8 a328 = a325[7:0] in
                      let:16 a329 = (1 + (a327,a328)) in
                      let:8 a330 = M[(a327,a328)] in
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a329[15:8];
                      SPL := a329[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump ((a330,a326));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            let:8 a331 = a84 in
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            let:8 a332 = M[20CF] in
            advance (13)
            #0587
            #instruction: CP   B
            let:8 a333 = a332 in
            let:8 a334 = a331 in
            let:16 a335 = addWithCarry(!false,a333,~a334) in
            let:8 a336 = (a333 & 0F) in
            let:8 a337 = (~a334 & 0F) in
            let:16 a338 = addWithCarry(!false,a336,a337) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a335[15:8][0]) {
              let:8 a339 = a10[15:8] in
              let:8 a340 = a10[7:0] in
              let:16 a341 = (1 + (a339,a340)) in
              let:8 a342 = M[(a339,a340)] in
              let:8 a343 = a341[15:8] in
              let:8 a344 = a341[7:0] in
              let:16 a345 = (1 + (a343,a344)) in
              let:8 a346 = M[(a343,a344)] in
              advance (11)
              A := a332;
              B := a331;
              H := 20;
              L := 74;
              SPH := a345[15:8];
              SPL := a345[7:0];
              FlagS := a335[7:0][7];
              FlagZ := is_zero(a335[7:0]);
              FlagA := a338[7:0][4];
              FlagP := parity(a335[7:0]);
              FlagCY := !a335[15:8][0];
              jump ((a346,a342));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              let:8 a347 = M[2071] in
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a348 = a347 in
              let:8 a349 = a347 in
              let:8 a350 = (a348 & a349) in
              let:8 a351 = (a348 | a349) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a350)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a352 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a353 = a352 in
                let:8 a354 = a352 in
                let:8 a355 = (a353 & a354) in
                let:8 a356 = (a353 | a354) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a355)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a357 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a358 = a357 in
                  let:16 a359 = addWithCarry(false,08,a358) in
                  let:8 a360 = (08 & 0F) in
                  let:8 a361 = (a358 & 0F) in
                  let:16 a362 = addWithCarry(false,a360,a361) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a363 = a359[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a364 = a10[15:8] in
                  let:8 a365 = a10[7:0] in
                  let:16 a366 = (-1 + (a364,a365)) in
                  M[a366] := 06;
                  let:8 a367 = a366[15:8] in
                  let:8 a368 = a366[7:0] in
                  let:16 a369 = (-1 + (a367,a368)) in
                  M[a369] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a370 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a371 = a369[15:8] in
                  let:8 a372 = a369[7:0] in
                  let:16 a373 = (-1 + (a371,a372)) in
                  M[a373] := 15;
                  let:8 a374 = a373[15:8] in
                  let:8 a375 = a373[7:0] in
                  let:16 a376 = (-1 + (a374,a375)) in
                  M[a376] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a377 = a370 in
                  let:8 a378 = a363 in
                  let:16 a379 = addWithCarry(!false,a377,~a378) in
                  let:8 a380 = (a377 & 0F) in
                  let:8 a381 = (~a378 & 0F) in
                  let:16 a382 = addWithCarry(!false,a380,a381) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a379[15:8][0]) {
                    let:8 a383 = a376[15:8] in
                    let:8 a384 = a376[7:0] in
                    let:16 a385 = (-1 + (a383,a384)) in
                    M[a385] := 15;
                    let:8 a386 = a385[15:8] in
                    let:8 a387 = a385[7:0] in
                    let:16 a388 = (-1 + (a386,a387)) in
                    M[a388] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a389 = addWithCarry(true,00,00) in
                    let:8 a390 = (00 & 0F) in
                    let:8 a391 = (00 & 0F) in
                    let:16 a392 = addWithCarry(true,a390,a391) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a393 = a370 in
                    let:16 a394 = addWithCarry(false,10,a393) in
                    let:8 a395 = (10 & 0F) in
                    let:8 a396 = (a393 & 0F) in
                    let:16 a397 = addWithCarry(false,a395,a396) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a394[7:0][7]) {
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a388[15:8];
                      SPL := a388[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a398 = a388[15:8] in
                      let:8 a399 = a388[7:0] in
                      let:16 a400 = (1 + (a398,a399)) in
                      let:8 a401 = M[(a398,a399)] in
                      let:8 a402 = a400[15:8] in
                      let:8 a403 = a400[7:0] in
                      let:16 a404 = (1 + (a402,a403)) in
                      let:8 a405 = M[(a402,a403)] in
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a404[15:8];
                      SPL := a404[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump ((a405,a401));
                    }
                  } else {
                    advance (11)
                    A := a370;
                    B := a331;
                    C := 00;
                    H := a363;
                    L := 75;
                    SPH := a376[15:8];
                    SPL := a376[7:0];
                    FlagS := a379[7:0][7];
                    FlagZ := is_zero(a379[7:0]);
                    FlagA := a382[7:0][4];
                    FlagP := parity(a379[7:0]);
                    FlagCY := !a379[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a406 = M[2076] in
                  let:8 a407 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a408 = a407 in
                  let:8 a409 = a406 in
                  let:8 a410 = M[(a408,a409)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a411 = a407 in
                  let:8 a412 = a406 in
                  let:16 a413 = (1 + (a411,a412)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a414 = a413[7:0] in
                  M[2076] := a414;
                  let:8 a415 = a413[15:8] in
                  M[2077] := a415;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a416 = a10[15:8] in
                  let:8 a417 = a10[7:0] in
                  let:16 a418 = (-1 + (a416,a417)) in
                  M[a418] := 05;
                  let:8 a419 = a418[15:8] in
                  let:8 a420 = a418[7:0] in
                  let:16 a421 = (-1 + (a419,a420)) in
                  M[a421] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a422 = a410 in
                  let:16 a423 = addWithCarry(!true,a422,~00) in
                  let:8 a424 = (a422 & 0F) in
                  let:8 a425 = (~00 & 0F) in
                  let:16 a426 = addWithCarry(!true,a424,a425) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a427 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a428 = a427 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a429 = a423[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a430 = a428 in
                  let:8 a431 = a429 in
                  let:8 a432 = M[(a430,a431)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a433 = a432 in
                  let:8 a434 = a432 in
                  let:8 a435 = (a433 & a434) in
                  let:8 a436 = (a433 | a434) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a435)) {
                    let:8 a437 = a421[15:8] in
                    let:8 a438 = a421[7:0] in
                    let:16 a439 = (1 + (a437,a438)) in
                    let:8 a440 = M[(a437,a438)] in
                    let:8 a441 = a439[15:8] in
                    let:8 a442 = a439[7:0] in
                    let:16 a443 = (1 + (a441,a442)) in
                    let:8 a444 = M[(a441,a442)] in
                    advance (11)
                    A := a435;
                    B := a331;
                    C := a423[7:0];
                    D := 05;
                    H := a428;
                    L := a429;
                    SPH := a443[15:8];
                    SPL := a443[7:0];
                    FlagS := a435[7];
                    FlagZ := is_zero(a435);
                    FlagA := a436[3];
                    FlagP := parity(a435);
                    FlagCY := true;
                    jump ((a444,a440));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a445 = a429 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a446 = a445 in
                    let:16 a447 = addWithCarry(false,0B,a446) in
                    let:8 a448 = (0B & 0F) in
                    let:8 a449 = (a446 & 0F) in
                    let:16 a450 = addWithCarry(false,a448,a449) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a451 = a447[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a452 = addWithCarry(!true,05,~00) in
                    let:8 a453 = (05 & 0F) in
                    let:8 a454 = (~00 & 0F) in
                    let:16 a455 = addWithCarry(!true,a453,a454) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a452[7:0])) {
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a421[15:8];
                      SPL := a421[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a456 = a421[15:8] in
                      let:8 a457 = a421[7:0] in
                      let:16 a458 = (1 + (a456,a457)) in
                      let:8 a459 = M[(a456,a457)] in
                      let:8 a460 = a458[15:8] in
                      let:8 a461 = a458[7:0] in
                      let:16 a462 = (1 + (a460,a461)) in
                      let:8 a463 = M[(a460,a461)] in
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a462[15:8];
                      SPL := a462[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump ((a463,a459));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                let:8 a464 = a350 in
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                let:8 a465 = M[20CF] in
                advance (13)
                #0594
                #instruction: CP   B
                let:8 a466 = a465 in
                let:8 a467 = a464 in
                let:16 a468 = addWithCarry(!false,a466,~a467) in
                let:8 a469 = (a466 & 0F) in
                let:8 a470 = (~a467 & 0F) in
                let:16 a471 = addWithCarry(!false,a469,a470) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a468[15:8][0]) {
                  let:8 a472 = a10[15:8] in
                  let:8 a473 = a10[7:0] in
                  let:16 a474 = (1 + (a472,a473)) in
                  let:8 a475 = M[(a472,a473)] in
                  let:8 a476 = a474[15:8] in
                  let:8 a477 = a474[7:0] in
                  let:16 a478 = (1 + (a476,a477)) in
                  let:8 a479 = M[(a476,a477)] in
                  advance (11)
                  A := a465;
                  B := a464;
                  H := 20;
                  L := 74;
                  SPH := a478[15:8];
                  SPL := a478[7:0];
                  FlagS := a468[7:0][7];
                  FlagZ := is_zero(a468[7:0]);
                  FlagA := a471[7:0][4];
                  FlagP := parity(a468[7:0]);
                  FlagCY := !a468[15:8][0];
                  jump ((a479,a475));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  let:8 a480 = M[2075] in
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a481 = a480 in
                  let:8 a482 = a480 in
                  let:8 a483 = (a481 & a482) in
                  let:8 a484 = (a481 | a482) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a483)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    let:8 a485 = M[201B] in
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:8 a486 = a485 in
                    let:16 a487 = addWithCarry(false,08,a486) in
                    let:8 a488 = (08 & 0F) in
                    let:8 a489 = (a486 & 0F) in
                    let:16 a490 = addWithCarry(false,a488,a489) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    let:8 a491 = a487[7:0] in
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:8 a492 = a10[15:8] in
                    let:8 a493 = a10[7:0] in
                    let:16 a494 = (-1 + (a492,a493)) in
                    M[a494] := 06;
                    let:8 a495 = a494[15:8] in
                    let:8 a496 = a494[7:0] in
                    let:16 a497 = (-1 + (a495,a496)) in
                    M[a497] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    let:8 a498 = M[200A] in
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:8 a499 = a497[15:8] in
                    let:8 a500 = a497[7:0] in
                    let:16 a501 = (-1 + (a499,a500)) in
                    M[a501] := 15;
                    let:8 a502 = a501[15:8] in
                    let:8 a503 = a501[7:0] in
                    let:16 a504 = (-1 + (a502,a503)) in
                    M[a504] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:8 a505 = a498 in
                    let:8 a506 = a491 in
                    let:16 a507 = addWithCarry(!false,a505,~a506) in
                    let:8 a508 = (a505 & 0F) in
                    let:8 a509 = (~a506 & 0F) in
                    let:16 a510 = addWithCarry(!false,a508,a509) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a507[15:8][0]) {
                      let:8 a511 = a504[15:8] in
                      let:8 a512 = a504[7:0] in
                      let:16 a513 = (-1 + (a511,a512)) in
                      M[a513] := 15;
                      let:8 a514 = a513[15:8] in
                      let:8 a515 = a513[7:0] in
                      let:16 a516 = (-1 + (a514,a515)) in
                      M[a516] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a517 = addWithCarry(true,00,00) in
                      let:8 a518 = (00 & 0F) in
                      let:8 a519 = (00 & 0F) in
                      let:16 a520 = addWithCarry(true,a518,a519) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:8 a521 = a498 in
                      let:16 a522 = addWithCarry(false,10,a521) in
                      let:8 a523 = (10 & 0F) in
                      let:8 a524 = (a521 & 0F) in
                      let:16 a525 = addWithCarry(false,a523,a524) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a522[7:0][7]) {
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a516[15:8];
                        SPL := a516[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:8 a526 = a516[15:8] in
                        let:8 a527 = a516[7:0] in
                        let:16 a528 = (1 + (a526,a527)) in
                        let:8 a529 = M[(a526,a527)] in
                        let:8 a530 = a528[15:8] in
                        let:8 a531 = a528[7:0] in
                        let:16 a532 = (1 + (a530,a531)) in
                        let:8 a533 = M[(a530,a531)] in
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a532[15:8];
                        SPL := a532[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump ((a533,a529));
                      }
                    } else {
                      advance (11)
                      A := a498;
                      B := a464;
                      C := 00;
                      H := a491;
                      L := 75;
                      SPH := a504[15:8];
                      SPL := a504[7:0];
                      FlagS := a507[7:0][7];
                      FlagZ := is_zero(a507[7:0]);
                      FlagA := a510[7:0][4];
                      FlagP := parity(a507[7:0]);
                      FlagCY := !a507[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    let:8 a534 = M[2076] in
                    let:8 a535 = M[2077] in
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    let:8 a536 = a535 in
                    let:8 a537 = a534 in
                    let:8 a538 = M[(a536,a537)] in
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:8 a539 = a535 in
                    let:8 a540 = a534 in
                    let:16 a541 = (1 + (a539,a540)) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    let:8 a542 = a541[7:0] in
                    M[2076] := a542;
                    let:8 a543 = a541[15:8] in
                    M[2077] := a543;
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:8 a544 = a10[15:8] in
                    let:8 a545 = a10[7:0] in
                    let:16 a546 = (-1 + (a544,a545)) in
                    M[a546] := 05;
                    let:8 a547 = a546[15:8] in
                    let:8 a548 = a546[7:0] in
                    let:16 a549 = (-1 + (a547,a548)) in
                    M[a549] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:8 a550 = a538 in
                    let:16 a551 = addWithCarry(!true,a550,~00) in
                    let:8 a552 = (a550 & 0F) in
                    let:8 a553 = (~00 & 0F) in
                    let:16 a554 = addWithCarry(!true,a552,a553) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    let:8 a555 = M[2067] in
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    let:8 a556 = a555 in
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    let:8 a557 = a551[7:0] in
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    let:8 a558 = a556 in
                    let:8 a559 = a557 in
                    let:8 a560 = M[(a558,a559)] in
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a561 = a560 in
                    let:8 a562 = a560 in
                    let:8 a563 = (a561 & a562) in
                    let:8 a564 = (a561 | a562) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a563)) {
                      let:8 a565 = a549[15:8] in
                      let:8 a566 = a549[7:0] in
                      let:16 a567 = (1 + (a565,a566)) in
                      let:8 a568 = M[(a565,a566)] in
                      let:8 a569 = a567[15:8] in
                      let:8 a570 = a567[7:0] in
                      let:16 a571 = (1 + (a569,a570)) in
                      let:8 a572 = M[(a569,a570)] in
                      advance (11)
                      A := a563;
                      B := a464;
                      C := a551[7:0];
                      D := 05;
                      H := a556;
                      L := a557;
                      SPH := a571[15:8];
                      SPL := a571[7:0];
                      FlagS := a563[7];
                      FlagZ := is_zero(a563);
                      FlagA := a564[3];
                      FlagP := parity(a563);
                      FlagCY := true;
                      jump ((a572,a568));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      let:8 a573 = a557 in
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:8 a574 = a573 in
                      let:16 a575 = addWithCarry(false,0B,a574) in
                      let:8 a576 = (0B & 0F) in
                      let:8 a577 = (a574 & 0F) in
                      let:16 a578 = addWithCarry(false,a576,a577) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      let:8 a579 = a575[7:0] in
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a580 = addWithCarry(!true,05,~00) in
                      let:8 a581 = (05 & 0F) in
                      let:8 a582 = (~00 & 0F) in
                      let:16 a583 = addWithCarry(!true,a581,a582) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a580[7:0])) {
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a549[15:8];
                        SPL := a549[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:8 a584 = a549[15:8] in
                        let:8 a585 = a549[7:0] in
                        let:16 a586 = (1 + (a584,a585)) in
                        let:8 a587 = M[(a584,a585)] in
                        let:8 a588 = a586[15:8] in
                        let:8 a589 = a586[7:0] in
                        let:16 a590 = (1 + (a588,a589)) in
                        let:8 a591 = M[(a588,a589)] in
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a590[15:8];
                        SPL := a590[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump ((a591,a587));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

04D9:

    #04D9
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    #04DC
    #instruction: CP   10
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~10) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~10 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #04DE
    #instruction: JP   CY,04E7
    if (!a3[15:8][0]) {
      advance (10)
      #04E7
      #instruction: LD   A,(2078)
      let:8 a7 = M[2078] in
      advance (13)
      #04EA
      #instruction: AND  A
      let:8 a8 = a7 in
      let:8 a9 = a7 in
      let:8 a10 = (a8 & a9) in
      let:8 a11 = (a8 | a9) in
      advance (4)
      #04EB
      #instruction: LD   HL,2045
      advance (10)
      #04EE
      #instruction: JP   NZ,055B
      if (!is_zero(a10)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a12 = M[2073] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a13 = a12 in
        M[2045] := a13;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a14 = addWithCarry(!true,0B,~00) in
        let:8 a15 = (0B & 0F) in
        let:8 a16 = (~00 & 0F) in
        let:16 a17 = addWithCarry(!true,a15,a16) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a14[7:0])) {
          advance (10)
          A := a12;
          B := a14[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          FlagS := a14[7:0][7];
          FlagZ := is_zero(a14[7:0]);
          FlagA := a17[7:0][4];
          FlagP := parity(a14[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a18 = SPH in
          let:8 a19 = SPL in
          let:16 a20 = (1 + (a18,a19)) in
          let:8 a21 = M[(a18,a19)] in
          let:8 a22 = a20[15:8] in
          let:8 a23 = a20[7:0] in
          let:16 a24 = (1 + (a22,a23)) in
          let:8 a25 = M[(a22,a23)] in
          advance (10)
          A := a12;
          B := a14[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          SPH := a24[15:8];
          SPL := a24[7:0];
          FlagS := a14[7:0][7];
          FlagZ := is_zero(a14[7:0]);
          FlagA := a17[7:0][4];
          FlagP := parity(a14[7:0]);
          FlagCY := false;
          jump ((a25,a21));
        }
      } else {
        advance (10)
        #04F1
        #instruction: LD   DE,1B40
        advance (10)
        #04F4
        #instruction: LD   HL,2040
        advance (10)
        #04F7
        #instruction: LD   B,10
        advance (7)
        #04F9
        #instruction: CALL 1A32
        let:8 a26 = SPH in
        let:8 a27 = SPL in
        let:16 a28 = (-1 + (a26,a27)) in
        M[a28] := 04;
        let:8 a29 = a28[15:8] in
        let:8 a30 = a28[7:0] in
        let:16 a31 = (-1 + (a29,a30)) in
        M[a31] := FC;
        #return-to: 04FC
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2040] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a32 = addWithCarry(!true,10,~00) in
        let:8 a33 = (10 & 0F) in
        let:8 a34 = (~00 & 0F) in
        let:16 a35 = addWithCarry(!true,a33,a34) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a32[7:0])) {
          advance (10)
          A := 00;
          B := a32[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a32[7:0][7];
          FlagZ := is_zero(a32[7:0]);
          FlagA := a35[7:0][4];
          FlagP := parity(a32[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a36 = a31[15:8] in
          let:8 a37 = a31[7:0] in
          let:16 a38 = (1 + (a36,a37)) in
          let:8 a39 = M[(a36,a37)] in
          let:8 a40 = a38[15:8] in
          let:8 a41 = a38[7:0] in
          let:16 a42 = (1 + (a40,a41)) in
          let:8 a43 = M[(a40,a41)] in
          advance (10)
          A := 00;
          B := a32[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a42[15:8];
          SPL := a42[7:0];
          FlagS := a32[7:0][7];
          FlagZ := is_zero(a32[7:0]);
          FlagA := a35[7:0][4];
          FlagP := parity(a32[7:0]);
          FlagCY := false;
          jump ((a43,a39));
        }
      }
    } else {
      advance (10)
      #04E1
      #instruction: LD   A,(1B48)
      advance (13)
      #04E4
      #instruction: LD   (2076),A
      M[2076] := 00;
      advance (13)
      #04E7
      #instruction: LD   A,(2078)
      let:8 a44 = M[2078] in
      advance (13)
      #04EA
      #instruction: AND  A
      let:8 a45 = a44 in
      let:8 a46 = a44 in
      let:8 a47 = (a45 & a46) in
      let:8 a48 = (a45 | a46) in
      advance (4)
      #04EB
      #instruction: LD   HL,2045
      advance (10)
      #04EE
      #instruction: JP   NZ,055B
      if (!is_zero(a47)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a49 = M[2073] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a50 = a49 in
        M[2045] := a50;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a51 = addWithCarry(!true,0B,~00) in
        let:8 a52 = (0B & 0F) in
        let:8 a53 = (~00 & 0F) in
        let:16 a54 = addWithCarry(!true,a52,a53) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a51[7:0])) {
          advance (10)
          A := a49;
          B := a51[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          FlagS := a51[7:0][7];
          FlagZ := is_zero(a51[7:0]);
          FlagA := a54[7:0][4];
          FlagP := parity(a51[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a55 = SPH in
          let:8 a56 = SPL in
          let:16 a57 = (1 + (a55,a56)) in
          let:8 a58 = M[(a55,a56)] in
          let:8 a59 = a57[15:8] in
          let:8 a60 = a57[7:0] in
          let:16 a61 = (1 + (a59,a60)) in
          let:8 a62 = M[(a59,a60)] in
          advance (10)
          A := a49;
          B := a51[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 46;
          SPH := a61[15:8];
          SPL := a61[7:0];
          FlagS := a51[7:0][7];
          FlagZ := is_zero(a51[7:0]);
          FlagA := a54[7:0][4];
          FlagP := parity(a51[7:0]);
          FlagCY := false;
          jump ((a62,a58));
        }
      } else {
        advance (10)
        #04F1
        #instruction: LD   DE,1B40
        advance (10)
        #04F4
        #instruction: LD   HL,2040
        advance (10)
        #04F7
        #instruction: LD   B,10
        advance (7)
        #04F9
        #instruction: CALL 1A32
        let:8 a63 = SPH in
        let:8 a64 = SPL in
        let:16 a65 = (-1 + (a63,a64)) in
        M[a65] := 04;
        let:8 a66 = a65[15:8] in
        let:8 a67 = a65[7:0] in
        let:16 a68 = (-1 + (a66,a67)) in
        M[a68] := FC;
        #return-to: 04FC
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2040] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a69 = addWithCarry(!true,10,~00) in
        let:8 a70 = (10 & 0F) in
        let:8 a71 = (~00 & 0F) in
        let:16 a72 = addWithCarry(!true,a70,a71) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a69[7:0])) {
          advance (10)
          A := 00;
          B := a69[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a68[15:8];
          SPL := a68[7:0];
          FlagS := a69[7:0][7];
          FlagZ := is_zero(a69[7:0]);
          FlagA := a72[7:0][4];
          FlagP := parity(a69[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a73 = a68[15:8] in
          let:8 a74 = a68[7:0] in
          let:16 a75 = (1 + (a73,a74)) in
          let:8 a76 = M[(a73,a74)] in
          let:8 a77 = a75[15:8] in
          let:8 a78 = a75[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          advance (10)
          A := 00;
          B := a69[7:0];
          D := 1B;
          E := 41;
          H := 20;
          L := 41;
          SPH := a79[15:8];
          SPL := a79[7:0];
          FlagS := a69[7:0][7];
          FlagZ := is_zero(a69[7:0]);
          FlagA := a72[7:0][4];
          FlagP := parity(a69[7:0]);
          FlagCY := false;
          jump ((a80,a76));
        }
      }
    }

04FC:

    #04FC
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    #04FF
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0500
    #instruction: JP   NZ,0508
    if (!is_zero(a3[7:0])) {
      advance (10)
      #0508
      #instruction: LD   HL,(2076)
      let:8 a7 = M[2076] in
      let:8 a8 = M[2077] in
      advance (16)
      #050B
      #instruction: JP   067E
      advance (10)
      #067E
      #instruction: LD   (2048),HL
      let:8 a9 = a7 in
      M[2048] := a9;
      let:8 a10 = a8 in
      M[2049] := a10;
      advance (16)
      #0681
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a3[7:0];
      H := a8;
      L := a7;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((a18,a14));
    } else {
      advance (10)
      #0503
      #instruction: LD   A,01
      advance (7)
      #0505
      #instruction: LD   (206E),A
      M[206E] := 01;
      advance (13)
      #0508
      #instruction: LD   HL,(2076)
      let:8 a19 = M[2076] in
      let:8 a20 = M[2077] in
      advance (16)
      #050B
      #instruction: JP   067E
      advance (10)
      #067E
      #instruction: LD   (2048),HL
      let:8 a21 = a19 in
      M[2048] := a21;
      let:8 a22 = a20 in
      M[2049] := a22;
      advance (16)
      #0681
      #instruction: RET
      let:8 a23 = SPH in
      let:8 a24 = SPL in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := 01;
      H := a20;
      L := a19;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      jump ((a30,a26));
    }

050E:

    #050E
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #050F
    #instruction: LD   DE,2055
    advance (10)
    #0512
    #instruction: LD   A,DB
    advance (7)
    #0514
    #instruction: CALL 0550
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := 05;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 17;
    #return-to: 0517
    advance (17)
    #0550
    #instruction: LD   (207F),A
    M[207F] := DB;
    advance (13)
    #0553
    #instruction: LD   HL,2073
    advance (10)
    #0556
    #instruction: LD   B,0B
    advance (7)
    #0558
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    let:8 a15 = M[2055] in
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    let:8 a16 = a15 in
    M[2073] := a16;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a17 = addWithCarry(!true,0B,~00) in
    let:8 a18 = (0B & 0F) in
    let:8 a19 = (~00 & 0F) in
    let:16 a20 = addWithCarry(!true,a18,a19) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a17[7:0])) {
      advance (10)
      A := a15;
      B := a17[7:0];
      D := 20;
      E := 56;
      H := 20;
      L := 74;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a17[7:0][7];
      FlagZ := is_zero(a17[7:0]);
      FlagA := a20[7:0][4];
      FlagP := parity(a17[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a21 = a14[15:8] in
      let:8 a22 = a14[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := a15;
      B := a17[7:0];
      D := 20;
      E := 56;
      H := 20;
      L := 74;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a17[7:0][7];
      FlagZ := is_zero(a17[7:0]);
      FlagA := a20[7:0][4];
      FlagP := parity(a17[7:0]);
      jump ((a28,a24));
    }

0517:

    #0517
    #instruction: LD   A,(2046)
    let:8 a1 = M[2046] in
    advance (13)
    #051A
    #instruction: LD   (2070),A
    let:8 a2 = a1 in
    M[2070] := a2;
    advance (13)
    #051D
    #instruction: LD   A,(2036)
    let:8 a3 = M[2036] in
    advance (13)
    #0520
    #instruction: LD   (2071),A
    let:8 a4 = a3 in
    M[2071] := a4;
    advance (13)
    #0523
    #instruction: CALL 0563
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 05;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 26;
    #return-to: 0526
    advance (17)
    #0563
    #instruction: LD   HL,2073
    advance (10)
    #0566
    #instruction: LD   A,(HL)
    let:8 a11 = M[2073] in
    advance (7)
    #0567
    #instruction: AND  80
    let:8 a12 = a11 in
    let:8 a13 = (80 & a12) in
    let:8 a14 = (80 | a12) in
    advance (7)
    #0569
    #instruction: JP   NZ,05C1
    if (!is_zero(a13)) {
      advance (10)
      #05C1
      #instruction: LD   DE,207C
      advance (10)
      #05C4
      #instruction: CALL 1A06
      let:8 a15 = a10[15:8] in
      let:8 a16 = a10[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 05;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := C7;
      #return-to: 05C7
      advance (17)
      #1A06
      #instruction: LD   HL,2072
      advance (10)
      #1A09
      #instruction: LD   B,(HL)
      let:8 a21 = M[2072] in
      advance (7)
      #1A0A
      #instruction: LD   A,(DE)
      let:8 a22 = M[207C] in
      advance (7)
      #1A0B
      #instruction: AND  80
      let:8 a23 = a22 in
      let:8 a24 = (80 & a23) in
      let:8 a25 = (80 | a23) in
      advance (7)
      #1A0D
      #instruction: XOR  B
      let:8 a26 = a21 in
      let:8 a27 = a24 in
      let:8 a28 = (a26 ^ a27) in
      advance (4)
      #1A0E
      #instruction: RET  NZ
      if (!is_zero(a28)) {
        let:8 a29 = a20[15:8] in
        let:8 a30 = a20[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        let:8 a33 = a31[15:8] in
        let:8 a34 = a31[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        advance (11)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := false;
        jump ((a36,a32));
      } else {
        advance (5)
        #1A0F
        #instruction: SCF
        advance (4)
        #1A10
        #instruction: RET
        let:8 a37 = a20[15:8] in
        let:8 a38 = a20[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a28;
        B := a21;
        D := 20;
        E := 7C;
        H := 20;
        L := 72;
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := true;
        jump ((a44,a40));
      }
    } else {
      advance (10)
      #056C
      #instruction: LD   A,(20C1)
      let:8 a45 = M[20C1] in
      advance (13)
      #056F
      #instruction: CP   04
      let:8 a46 = a45 in
      let:16 a47 = addWithCarry(!false,a46,~04) in
      let:8 a48 = (a46 & 0F) in
      let:8 a49 = (~04 & 0F) in
      let:16 a50 = addWithCarry(!false,a48,a49) in
      advance (7)
      #0571
      #instruction: LD   A,(2069)
      let:8 a51 = M[2069] in
      advance (13)
      #0574
      #instruction: JP   Z,05B7
      if (is_zero(a47[7:0])) {
        advance (10)
        #05B7
        #instruction: LD   HL,2073
        advance (10)
        #05BA
        #instruction: LD   A,(HL)
        let:8 a52 = M[2073] in
        advance (7)
        #05BB
        #instruction: OR   80
        let:8 a53 = a52 in
        let:8 a54 = (80 | a53) in
        advance (7)
        #05BD
        #instruction: LD   (HL),A
        let:8 a55 = a54 in
        M[2073] := a55;
        advance (7)
        #05BE
        #instruction: INC  HL
        advance (5)
        #05BF
        #instruction: INC  (HL)
        let:8 a56 = M[2074] in
        let:16 a57 = addWithCarry(true,a56,00) in
        let:8 a58 = (a56 & 0F) in
        let:8 a59 = (00 & 0F) in
        let:16 a60 = addWithCarry(true,a58,a59) in
        M[2074] := a57[7:0];
        advance (10)
        #05C0
        #instruction: RET
        let:8 a61 = a10[15:8] in
        let:8 a62 = a10[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        let:8 a65 = a63[15:8] in
        let:8 a66 = a63[7:0] in
        let:16 a67 = (1 + (a65,a66)) in
        let:8 a68 = M[(a65,a66)] in
        advance (10)
        A := a54;
        H := 20;
        L := 74;
        SPH := a67[15:8];
        SPL := a67[7:0];
        FlagS := a57[7:0][7];
        FlagZ := is_zero(a57[7:0]);
        FlagA := a60[7:0][4];
        FlagP := parity(a57[7:0]);
        FlagCY := false;
        jump ((a68,a64));
      } else {
        advance (10)
        #0577
        #instruction: AND  A
        let:8 a69 = a51 in
        let:8 a70 = a51 in
        let:8 a71 = (a69 & a70) in
        let:8 a72 = (a69 | a70) in
        advance (4)
        #0578
        #instruction: RET  Z
        if (is_zero(a71)) {
          let:8 a73 = a10[15:8] in
          let:8 a74 = a10[7:0] in
          let:16 a75 = (1 + (a73,a74)) in
          let:8 a76 = M[(a73,a74)] in
          let:8 a77 = a75[15:8] in
          let:8 a78 = a75[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          advance (11)
          A := a71;
          H := 20;
          L := 73;
          SPH := a79[15:8];
          SPL := a79[7:0];
          FlagS := a71[7];
          FlagZ := is_zero(a71);
          FlagA := a72[3];
          FlagP := parity(a71);
          FlagCY := false;
          jump ((a80,a76));
        } else {
          advance (5)
          #0579
          #instruction: INC  HL
          advance (5)
          #057A
          #instruction: LD   (HL),00
          M[2074] := 00;
          advance (10)
          #057C
          #instruction: LD   A,(2070)
          let:8 a81 = M[2070] in
          advance (13)
          #057F
          #instruction: AND  A
          let:8 a82 = a81 in
          let:8 a83 = a81 in
          let:8 a84 = (a82 & a83) in
          let:8 a85 = (a82 | a83) in
          advance (4)
          #0580
          #instruction: JP   Z,0589
          if (is_zero(a84)) {
            advance (10)
            #0589
            #instruction: LD   A,(2071)
            let:8 a86 = M[2071] in
            advance (13)
            #058C
            #instruction: AND  A
            let:8 a87 = a86 in
            let:8 a88 = a86 in
            let:8 a89 = (a87 & a88) in
            let:8 a90 = (a87 | a88) in
            advance (4)
            #058D
            #instruction: JP   Z,0596
            if (is_zero(a89)) {
              advance (10)
              #0596
              #instruction: INC  HL
              advance (5)
              #0597
              #instruction: LD   A,(HL)
              let:8 a91 = M[2075] in
              advance (7)
              #0598
              #instruction: AND  A
              let:8 a92 = a91 in
              let:8 a93 = a91 in
              let:8 a94 = (a92 & a93) in
              let:8 a95 = (a92 | a93) in
              advance (4)
              #0599
              #instruction: JP   Z,061B
              if (is_zero(a94)) {
                advance (10)
                #061B
                #instruction: LD   A,(201B)
                let:8 a96 = M[201B] in
                advance (13)
                #061E
                #instruction: ADD  08
                let:8 a97 = a96 in
                let:16 a98 = addWithCarry(false,08,a97) in
                let:8 a99 = (08 & 0F) in
                let:8 a100 = (a97 & 0F) in
                let:16 a101 = addWithCarry(false,a99,a100) in
                advance (7)
                #0620
                #instruction: LD   H,A
                let:8 a102 = a98[7:0] in
                advance (5)
                #0621
                #instruction: CALL 156F
                let:8 a103 = a10[15:8] in
                let:8 a104 = a10[7:0] in
                let:16 a105 = (-1 + (a103,a104)) in
                M[a105] := 06;
                let:8 a106 = a105[15:8] in
                let:8 a107 = a105[7:0] in
                let:16 a108 = (-1 + (a106,a107)) in
                M[a108] := 24;
                #return-to: 0624
                advance (17)
                #156F
                #instruction: LD   A,(200A)
                let:8 a109 = M[200A] in
                advance (13)
                #1572
                #instruction: CALL 1554
                let:8 a110 = a108[15:8] in
                let:8 a111 = a108[7:0] in
                let:16 a112 = (-1 + (a110,a111)) in
                M[a112] := 15;
                let:8 a113 = a112[15:8] in
                let:8 a114 = a112[7:0] in
                let:16 a115 = (-1 + (a113,a114)) in
                M[a115] := 75;
                #return-to: 1575
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:8 a116 = a109 in
                let:8 a117 = a102 in
                let:16 a118 = addWithCarry(!false,a116,~a117) in
                let:8 a119 = (a116 & 0F) in
                let:8 a120 = (~a117 & 0F) in
                let:16 a121 = addWithCarry(!false,a119,a120) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a118[15:8][0]) {
                  let:8 a122 = a115[15:8] in
                  let:8 a123 = a115[7:0] in
                  let:16 a124 = (-1 + (a122,a123)) in
                  M[a124] := 15;
                  let:8 a125 = a124[15:8] in
                  let:8 a126 = a124[7:0] in
                  let:16 a127 = (-1 + (a125,a126)) in
                  M[a127] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a128 = addWithCarry(true,00,00) in
                  let:8 a129 = (00 & 0F) in
                  let:8 a130 = (00 & 0F) in
                  let:16 a131 = addWithCarry(true,a129,a130) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:8 a132 = a109 in
                  let:16 a133 = addWithCarry(false,10,a132) in
                  let:8 a134 = (10 & 0F) in
                  let:8 a135 = (a132 & 0F) in
                  let:16 a136 = addWithCarry(false,a134,a135) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a133[7:0][7]) {
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a127[15:8];
                    SPL := a127[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:8 a137 = a127[15:8] in
                    let:8 a138 = a127[7:0] in
                    let:16 a139 = (1 + (a137,a138)) in
                    let:8 a140 = M[(a137,a138)] in
                    let:8 a141 = a139[15:8] in
                    let:8 a142 = a139[7:0] in
                    let:16 a143 = (1 + (a141,a142)) in
                    let:8 a144 = M[(a141,a142)] in
                    advance (10)
                    A := a133[7:0];
                    C := a128[7:0];
                    H := a102;
                    L := 75;
                    SPH := a143[15:8];
                    SPL := a143[7:0];
                    FlagS := a133[7:0][7];
                    FlagZ := is_zero(a133[7:0]);
                    FlagA := a136[7:0][4];
                    FlagP := parity(a133[7:0]);
                    FlagCY := a133[15:8][0];
                    jump ((a144,a140));
                  }
                } else {
                  advance (11)
                  A := a109;
                  C := 00;
                  H := a102;
                  L := 75;
                  SPH := a115[15:8];
                  SPL := a115[7:0];
                  FlagS := a118[7:0][7];
                  FlagZ := is_zero(a118[7:0]);
                  FlagA := a121[7:0][4];
                  FlagP := parity(a118[7:0]);
                  FlagCY := !a118[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #059C
                #instruction: LD   HL,(2076)
                let:8 a145 = M[2076] in
                let:8 a146 = M[2077] in
                advance (16)
                #059F
                #instruction: LD   C,(HL)
                let:8 a147 = a146 in
                let:8 a148 = a145 in
                let:8 a149 = M[(a147,a148)] in
                advance (7)
                #05A0
                #instruction: INC  HL
                let:8 a150 = a146 in
                let:8 a151 = a145 in
                let:16 a152 = (1 + (a150,a151)) in
                advance (5)
                #05A1
                #instruction: NOP
                advance (4)
                #05A2
                #instruction: LD   (2076),HL
                let:8 a153 = a152[7:0] in
                M[2076] := a153;
                let:8 a154 = a152[15:8] in
                M[2077] := a154;
                advance (16)
                #05A5
                #instruction: CALL 062F
                let:8 a155 = a10[15:8] in
                let:8 a156 = a10[7:0] in
                let:16 a157 = (-1 + (a155,a156)) in
                M[a157] := 05;
                let:8 a158 = a157[15:8] in
                let:8 a159 = a157[7:0] in
                let:16 a160 = (-1 + (a158,a159)) in
                M[a160] := A8;
                #return-to: 05A8
                advance (17)
                #062F
                #instruction: DEC  C
                let:8 a161 = a149 in
                let:16 a162 = addWithCarry(!true,a161,~00) in
                let:8 a163 = (a161 & 0F) in
                let:8 a164 = (~00 & 0F) in
                let:16 a165 = addWithCarry(!true,a163,a164) in
                advance (5)
                #0630
                #instruction: LD   A,(2067)
                let:8 a166 = M[2067] in
                advance (13)
                #0633
                #instruction: LD   H,A
                let:8 a167 = a166 in
                advance (5)
                #0634
                #instruction: LD   L,C
                let:8 a168 = a162[7:0] in
                advance (5)
                #0635
                #instruction: LD   D,05
                advance (7)
                #0637
                #instruction: LD   A,(HL)
                let:8 a169 = a167 in
                let:8 a170 = a168 in
                let:8 a171 = M[(a169,a170)] in
                advance (7)
                #0638
                #instruction: AND  A
                let:8 a172 = a171 in
                let:8 a173 = a171 in
                let:8 a174 = (a172 & a173) in
                let:8 a175 = (a172 | a173) in
                advance (4)
                #0639
                #instruction: SCF
                advance (4)
                #063A
                #instruction: RET  NZ
                if (!is_zero(a174)) {
                  let:8 a176 = a160[15:8] in
                  let:8 a177 = a160[7:0] in
                  let:16 a178 = (1 + (a176,a177)) in
                  let:8 a179 = M[(a176,a177)] in
                  let:8 a180 = a178[15:8] in
                  let:8 a181 = a178[7:0] in
                  let:16 a182 = (1 + (a180,a181)) in
                  let:8 a183 = M[(a180,a181)] in
                  advance (11)
                  A := a174;
                  C := a162[7:0];
                  D := 05;
                  H := a167;
                  L := a168;
                  SPH := a182[15:8];
                  SPL := a182[7:0];
                  FlagS := a174[7];
                  FlagZ := is_zero(a174);
                  FlagA := a175[3];
                  FlagP := parity(a174);
                  FlagCY := true;
                  jump ((a183,a179));
                } else {
                  advance (5)
                  #063B
                  #instruction: LD   A,L
                  let:8 a184 = a168 in
                  advance (5)
                  #063C
                  #instruction: ADD  0B
                  let:8 a185 = a184 in
                  let:16 a186 = addWithCarry(false,0B,a185) in
                  let:8 a187 = (0B & 0F) in
                  let:8 a188 = (a185 & 0F) in
                  let:16 a189 = addWithCarry(false,a187,a188) in
                  advance (7)
                  #063E
                  #instruction: LD   L,A
                  let:8 a190 = a186[7:0] in
                  advance (5)
                  #063F
                  #instruction: DEC  D
                  let:16 a191 = addWithCarry(!true,05,~00) in
                  let:8 a192 = (05 & 0F) in
                  let:8 a193 = (~00 & 0F) in
                  let:16 a194 = addWithCarry(!true,a192,a193) in
                  advance (5)
                  #0640
                  #instruction: JP   NZ,0637
                  if (!is_zero(a191[7:0])) {
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a160[15:8];
                    SPL := a160[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump (0637);
                  } else {
                    advance (10)
                    #0643
                    #instruction: RET
                    let:8 a195 = a160[15:8] in
                    let:8 a196 = a160[7:0] in
                    let:16 a197 = (1 + (a195,a196)) in
                    let:8 a198 = M[(a195,a196)] in
                    let:8 a199 = a197[15:8] in
                    let:8 a200 = a197[7:0] in
                    let:16 a201 = (1 + (a199,a200)) in
                    let:8 a202 = M[(a199,a200)] in
                    advance (10)
                    A := a186[7:0];
                    C := a162[7:0];
                    D := a191[7:0];
                    H := a167;
                    L := a190;
                    SPH := a201[15:8];
                    SPL := a201[7:0];
                    FlagS := a191[7:0][7];
                    FlagZ := is_zero(a191[7:0]);
                    FlagA := a194[7:0][4];
                    FlagP := parity(a191[7:0]);
                    FlagCY := a186[15:8][0];
                    jump ((a202,a198));
                  }
                }
              }
            } else {
              advance (10)
              #0590
              #instruction: LD   B,A
              let:8 a203 = a89 in
              advance (5)
              #0591
              #instruction: LD   A,(20CF)
              let:8 a204 = M[20CF] in
              advance (13)
              #0594
              #instruction: CP   B
              let:8 a205 = a204 in
              let:8 a206 = a203 in
              let:16 a207 = addWithCarry(!false,a205,~a206) in
              let:8 a208 = (a205 & 0F) in
              let:8 a209 = (~a206 & 0F) in
              let:16 a210 = addWithCarry(!false,a208,a209) in
              advance (4)
              #0595
              #instruction: RET  NC
              if (!!a207[15:8][0]) {
                let:8 a211 = a10[15:8] in
                let:8 a212 = a10[7:0] in
                let:16 a213 = (1 + (a211,a212)) in
                let:8 a214 = M[(a211,a212)] in
                let:8 a215 = a213[15:8] in
                let:8 a216 = a213[7:0] in
                let:16 a217 = (1 + (a215,a216)) in
                let:8 a218 = M[(a215,a216)] in
                advance (11)
                A := a204;
                B := a203;
                H := 20;
                L := 74;
                SPH := a217[15:8];
                SPL := a217[7:0];
                FlagS := a207[7:0][7];
                FlagZ := is_zero(a207[7:0]);
                FlagA := a210[7:0][4];
                FlagP := parity(a207[7:0]);
                FlagCY := !a207[15:8][0];
                jump ((a218,a214));
              } else {
                advance (5)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a219 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a220 = a219 in
                let:8 a221 = a219 in
                let:8 a222 = (a220 & a221) in
                let:8 a223 = (a220 | a221) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a222)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a224 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a225 = a224 in
                  let:16 a226 = addWithCarry(false,08,a225) in
                  let:8 a227 = (08 & 0F) in
                  let:8 a228 = (a225 & 0F) in
                  let:16 a229 = addWithCarry(false,a227,a228) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a230 = a226[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a231 = a10[15:8] in
                  let:8 a232 = a10[7:0] in
                  let:16 a233 = (-1 + (a231,a232)) in
                  M[a233] := 06;
                  let:8 a234 = a233[15:8] in
                  let:8 a235 = a233[7:0] in
                  let:16 a236 = (-1 + (a234,a235)) in
                  M[a236] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a237 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a238 = a236[15:8] in
                  let:8 a239 = a236[7:0] in
                  let:16 a240 = (-1 + (a238,a239)) in
                  M[a240] := 15;
                  let:8 a241 = a240[15:8] in
                  let:8 a242 = a240[7:0] in
                  let:16 a243 = (-1 + (a241,a242)) in
                  M[a243] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a244 = a237 in
                  let:8 a245 = a230 in
                  let:16 a246 = addWithCarry(!false,a244,~a245) in
                  let:8 a247 = (a244 & 0F) in
                  let:8 a248 = (~a245 & 0F) in
                  let:16 a249 = addWithCarry(!false,a247,a248) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a246[15:8][0]) {
                    let:8 a250 = a243[15:8] in
                    let:8 a251 = a243[7:0] in
                    let:16 a252 = (-1 + (a250,a251)) in
                    M[a252] := 15;
                    let:8 a253 = a252[15:8] in
                    let:8 a254 = a252[7:0] in
                    let:16 a255 = (-1 + (a253,a254)) in
                    M[a255] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a256 = addWithCarry(true,00,00) in
                    let:8 a257 = (00 & 0F) in
                    let:8 a258 = (00 & 0F) in
                    let:16 a259 = addWithCarry(true,a257,a258) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a260 = a237 in
                    let:16 a261 = addWithCarry(false,10,a260) in
                    let:8 a262 = (10 & 0F) in
                    let:8 a263 = (a260 & 0F) in
                    let:16 a264 = addWithCarry(false,a262,a263) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a261[7:0][7]) {
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a255[15:8];
                      SPL := a255[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a265 = a255[15:8] in
                      let:8 a266 = a255[7:0] in
                      let:16 a267 = (1 + (a265,a266)) in
                      let:8 a268 = M[(a265,a266)] in
                      let:8 a269 = a267[15:8] in
                      let:8 a270 = a267[7:0] in
                      let:16 a271 = (1 + (a269,a270)) in
                      let:8 a272 = M[(a269,a270)] in
                      advance (10)
                      A := a261[7:0];
                      B := a203;
                      C := a256[7:0];
                      H := a230;
                      L := 75;
                      SPH := a271[15:8];
                      SPL := a271[7:0];
                      FlagS := a261[7:0][7];
                      FlagZ := is_zero(a261[7:0]);
                      FlagA := a264[7:0][4];
                      FlagP := parity(a261[7:0]);
                      FlagCY := a261[15:8][0];
                      jump ((a272,a268));
                    }
                  } else {
                    advance (11)
                    A := a237;
                    B := a203;
                    C := 00;
                    H := a230;
                    L := 75;
                    SPH := a243[15:8];
                    SPL := a243[7:0];
                    FlagS := a246[7:0][7];
                    FlagZ := is_zero(a246[7:0]);
                    FlagA := a249[7:0][4];
                    FlagP := parity(a246[7:0]);
                    FlagCY := !a246[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a273 = M[2076] in
                  let:8 a274 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a275 = a274 in
                  let:8 a276 = a273 in
                  let:8 a277 = M[(a275,a276)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a278 = a274 in
                  let:8 a279 = a273 in
                  let:16 a280 = (1 + (a278,a279)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a281 = a280[7:0] in
                  M[2076] := a281;
                  let:8 a282 = a280[15:8] in
                  M[2077] := a282;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a283 = a10[15:8] in
                  let:8 a284 = a10[7:0] in
                  let:16 a285 = (-1 + (a283,a284)) in
                  M[a285] := 05;
                  let:8 a286 = a285[15:8] in
                  let:8 a287 = a285[7:0] in
                  let:16 a288 = (-1 + (a286,a287)) in
                  M[a288] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a289 = a277 in
                  let:16 a290 = addWithCarry(!true,a289,~00) in
                  let:8 a291 = (a289 & 0F) in
                  let:8 a292 = (~00 & 0F) in
                  let:16 a293 = addWithCarry(!true,a291,a292) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a294 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a295 = a294 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a296 = a290[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a297 = a295 in
                  let:8 a298 = a296 in
                  let:8 a299 = M[(a297,a298)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a300 = a299 in
                  let:8 a301 = a299 in
                  let:8 a302 = (a300 & a301) in
                  let:8 a303 = (a300 | a301) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a302)) {
                    let:8 a304 = a288[15:8] in
                    let:8 a305 = a288[7:0] in
                    let:16 a306 = (1 + (a304,a305)) in
                    let:8 a307 = M[(a304,a305)] in
                    let:8 a308 = a306[15:8] in
                    let:8 a309 = a306[7:0] in
                    let:16 a310 = (1 + (a308,a309)) in
                    let:8 a311 = M[(a308,a309)] in
                    advance (11)
                    A := a302;
                    B := a203;
                    C := a290[7:0];
                    D := 05;
                    H := a295;
                    L := a296;
                    SPH := a310[15:8];
                    SPL := a310[7:0];
                    FlagS := a302[7];
                    FlagZ := is_zero(a302);
                    FlagA := a303[3];
                    FlagP := parity(a302);
                    FlagCY := true;
                    jump ((a311,a307));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a312 = a296 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a313 = a312 in
                    let:16 a314 = addWithCarry(false,0B,a313) in
                    let:8 a315 = (0B & 0F) in
                    let:8 a316 = (a313 & 0F) in
                    let:16 a317 = addWithCarry(false,a315,a316) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a318 = a314[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a319 = addWithCarry(!true,05,~00) in
                    let:8 a320 = (05 & 0F) in
                    let:8 a321 = (~00 & 0F) in
                    let:16 a322 = addWithCarry(!true,a320,a321) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a319[7:0])) {
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a288[15:8];
                      SPL := a288[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a323 = a288[15:8] in
                      let:8 a324 = a288[7:0] in
                      let:16 a325 = (1 + (a323,a324)) in
                      let:8 a326 = M[(a323,a324)] in
                      let:8 a327 = a325[15:8] in
                      let:8 a328 = a325[7:0] in
                      let:16 a329 = (1 + (a327,a328)) in
                      let:8 a330 = M[(a327,a328)] in
                      advance (10)
                      A := a314[7:0];
                      B := a203;
                      C := a290[7:0];
                      D := a319[7:0];
                      H := a295;
                      L := a318;
                      SPH := a329[15:8];
                      SPL := a329[7:0];
                      FlagS := a319[7:0][7];
                      FlagZ := is_zero(a319[7:0]);
                      FlagA := a322[7:0][4];
                      FlagP := parity(a319[7:0]);
                      FlagCY := a314[15:8][0];
                      jump ((a330,a326));
                    }
                  }
                }
              }
            }
          } else {
            advance (10)
            #0583
            #instruction: LD   B,A
            let:8 a331 = a84 in
            advance (5)
            #0584
            #instruction: LD   A,(20CF)
            let:8 a332 = M[20CF] in
            advance (13)
            #0587
            #instruction: CP   B
            let:8 a333 = a332 in
            let:8 a334 = a331 in
            let:16 a335 = addWithCarry(!false,a333,~a334) in
            let:8 a336 = (a333 & 0F) in
            let:8 a337 = (~a334 & 0F) in
            let:16 a338 = addWithCarry(!false,a336,a337) in
            advance (4)
            #0588
            #instruction: RET  NC
            if (!!a335[15:8][0]) {
              let:8 a339 = a10[15:8] in
              let:8 a340 = a10[7:0] in
              let:16 a341 = (1 + (a339,a340)) in
              let:8 a342 = M[(a339,a340)] in
              let:8 a343 = a341[15:8] in
              let:8 a344 = a341[7:0] in
              let:16 a345 = (1 + (a343,a344)) in
              let:8 a346 = M[(a343,a344)] in
              advance (11)
              A := a332;
              B := a331;
              H := 20;
              L := 74;
              SPH := a345[15:8];
              SPL := a345[7:0];
              FlagS := a335[7:0][7];
              FlagZ := is_zero(a335[7:0]);
              FlagA := a338[7:0][4];
              FlagP := parity(a335[7:0]);
              FlagCY := !a335[15:8][0];
              jump ((a346,a342));
            } else {
              advance (5)
              #0589
              #instruction: LD   A,(2071)
              let:8 a347 = M[2071] in
              advance (13)
              #058C
              #instruction: AND  A
              let:8 a348 = a347 in
              let:8 a349 = a347 in
              let:8 a350 = (a348 & a349) in
              let:8 a351 = (a348 | a349) in
              advance (4)
              #058D
              #instruction: JP   Z,0596
              if (is_zero(a350)) {
                advance (10)
                #0596
                #instruction: INC  HL
                advance (5)
                #0597
                #instruction: LD   A,(HL)
                let:8 a352 = M[2075] in
                advance (7)
                #0598
                #instruction: AND  A
                let:8 a353 = a352 in
                let:8 a354 = a352 in
                let:8 a355 = (a353 & a354) in
                let:8 a356 = (a353 | a354) in
                advance (4)
                #0599
                #instruction: JP   Z,061B
                if (is_zero(a355)) {
                  advance (10)
                  #061B
                  #instruction: LD   A,(201B)
                  let:8 a357 = M[201B] in
                  advance (13)
                  #061E
                  #instruction: ADD  08
                  let:8 a358 = a357 in
                  let:16 a359 = addWithCarry(false,08,a358) in
                  let:8 a360 = (08 & 0F) in
                  let:8 a361 = (a358 & 0F) in
                  let:16 a362 = addWithCarry(false,a360,a361) in
                  advance (7)
                  #0620
                  #instruction: LD   H,A
                  let:8 a363 = a359[7:0] in
                  advance (5)
                  #0621
                  #instruction: CALL 156F
                  let:8 a364 = a10[15:8] in
                  let:8 a365 = a10[7:0] in
                  let:16 a366 = (-1 + (a364,a365)) in
                  M[a366] := 06;
                  let:8 a367 = a366[15:8] in
                  let:8 a368 = a366[7:0] in
                  let:16 a369 = (-1 + (a367,a368)) in
                  M[a369] := 24;
                  #return-to: 0624
                  advance (17)
                  #156F
                  #instruction: LD   A,(200A)
                  let:8 a370 = M[200A] in
                  advance (13)
                  #1572
                  #instruction: CALL 1554
                  let:8 a371 = a369[15:8] in
                  let:8 a372 = a369[7:0] in
                  let:16 a373 = (-1 + (a371,a372)) in
                  M[a373] := 15;
                  let:8 a374 = a373[15:8] in
                  let:8 a375 = a373[7:0] in
                  let:16 a376 = (-1 + (a374,a375)) in
                  M[a376] := 75;
                  #return-to: 1575
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a377 = a370 in
                  let:8 a378 = a363 in
                  let:16 a379 = addWithCarry(!false,a377,~a378) in
                  let:8 a380 = (a377 & 0F) in
                  let:8 a381 = (~a378 & 0F) in
                  let:16 a382 = addWithCarry(!false,a380,a381) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a379[15:8][0]) {
                    let:8 a383 = a376[15:8] in
                    let:8 a384 = a376[7:0] in
                    let:16 a385 = (-1 + (a383,a384)) in
                    M[a385] := 15;
                    let:8 a386 = a385[15:8] in
                    let:8 a387 = a385[7:0] in
                    let:16 a388 = (-1 + (a386,a387)) in
                    M[a388] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a389 = addWithCarry(true,00,00) in
                    let:8 a390 = (00 & 0F) in
                    let:8 a391 = (00 & 0F) in
                    let:16 a392 = addWithCarry(true,a390,a391) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a393 = a370 in
                    let:16 a394 = addWithCarry(false,10,a393) in
                    let:8 a395 = (10 & 0F) in
                    let:8 a396 = (a393 & 0F) in
                    let:16 a397 = addWithCarry(false,a395,a396) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a394[7:0][7]) {
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a388[15:8];
                      SPL := a388[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a398 = a388[15:8] in
                      let:8 a399 = a388[7:0] in
                      let:16 a400 = (1 + (a398,a399)) in
                      let:8 a401 = M[(a398,a399)] in
                      let:8 a402 = a400[15:8] in
                      let:8 a403 = a400[7:0] in
                      let:16 a404 = (1 + (a402,a403)) in
                      let:8 a405 = M[(a402,a403)] in
                      advance (10)
                      A := a394[7:0];
                      B := a331;
                      C := a389[7:0];
                      H := a363;
                      L := 75;
                      SPH := a404[15:8];
                      SPL := a404[7:0];
                      FlagS := a394[7:0][7];
                      FlagZ := is_zero(a394[7:0]);
                      FlagA := a397[7:0][4];
                      FlagP := parity(a394[7:0]);
                      FlagCY := a394[15:8][0];
                      jump ((a405,a401));
                    }
                  } else {
                    advance (11)
                    A := a370;
                    B := a331;
                    C := 00;
                    H := a363;
                    L := 75;
                    SPH := a376[15:8];
                    SPL := a376[7:0];
                    FlagS := a379[7:0][7];
                    FlagZ := is_zero(a379[7:0]);
                    FlagA := a382[7:0][4];
                    FlagP := parity(a379[7:0]);
                    FlagCY := !a379[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #059C
                  #instruction: LD   HL,(2076)
                  let:8 a406 = M[2076] in
                  let:8 a407 = M[2077] in
                  advance (16)
                  #059F
                  #instruction: LD   C,(HL)
                  let:8 a408 = a407 in
                  let:8 a409 = a406 in
                  let:8 a410 = M[(a408,a409)] in
                  advance (7)
                  #05A0
                  #instruction: INC  HL
                  let:8 a411 = a407 in
                  let:8 a412 = a406 in
                  let:16 a413 = (1 + (a411,a412)) in
                  advance (5)
                  #05A1
                  #instruction: NOP
                  advance (4)
                  #05A2
                  #instruction: LD   (2076),HL
                  let:8 a414 = a413[7:0] in
                  M[2076] := a414;
                  let:8 a415 = a413[15:8] in
                  M[2077] := a415;
                  advance (16)
                  #05A5
                  #instruction: CALL 062F
                  let:8 a416 = a10[15:8] in
                  let:8 a417 = a10[7:0] in
                  let:16 a418 = (-1 + (a416,a417)) in
                  M[a418] := 05;
                  let:8 a419 = a418[15:8] in
                  let:8 a420 = a418[7:0] in
                  let:16 a421 = (-1 + (a419,a420)) in
                  M[a421] := A8;
                  #return-to: 05A8
                  advance (17)
                  #062F
                  #instruction: DEC  C
                  let:8 a422 = a410 in
                  let:16 a423 = addWithCarry(!true,a422,~00) in
                  let:8 a424 = (a422 & 0F) in
                  let:8 a425 = (~00 & 0F) in
                  let:16 a426 = addWithCarry(!true,a424,a425) in
                  advance (5)
                  #0630
                  #instruction: LD   A,(2067)
                  let:8 a427 = M[2067] in
                  advance (13)
                  #0633
                  #instruction: LD   H,A
                  let:8 a428 = a427 in
                  advance (5)
                  #0634
                  #instruction: LD   L,C
                  let:8 a429 = a423[7:0] in
                  advance (5)
                  #0635
                  #instruction: LD   D,05
                  advance (7)
                  #0637
                  #instruction: LD   A,(HL)
                  let:8 a430 = a428 in
                  let:8 a431 = a429 in
                  let:8 a432 = M[(a430,a431)] in
                  advance (7)
                  #0638
                  #instruction: AND  A
                  let:8 a433 = a432 in
                  let:8 a434 = a432 in
                  let:8 a435 = (a433 & a434) in
                  let:8 a436 = (a433 | a434) in
                  advance (4)
                  #0639
                  #instruction: SCF
                  advance (4)
                  #063A
                  #instruction: RET  NZ
                  if (!is_zero(a435)) {
                    let:8 a437 = a421[15:8] in
                    let:8 a438 = a421[7:0] in
                    let:16 a439 = (1 + (a437,a438)) in
                    let:8 a440 = M[(a437,a438)] in
                    let:8 a441 = a439[15:8] in
                    let:8 a442 = a439[7:0] in
                    let:16 a443 = (1 + (a441,a442)) in
                    let:8 a444 = M[(a441,a442)] in
                    advance (11)
                    A := a435;
                    B := a331;
                    C := a423[7:0];
                    D := 05;
                    H := a428;
                    L := a429;
                    SPH := a443[15:8];
                    SPL := a443[7:0];
                    FlagS := a435[7];
                    FlagZ := is_zero(a435);
                    FlagA := a436[3];
                    FlagP := parity(a435);
                    FlagCY := true;
                    jump ((a444,a440));
                  } else {
                    advance (5)
                    #063B
                    #instruction: LD   A,L
                    let:8 a445 = a429 in
                    advance (5)
                    #063C
                    #instruction: ADD  0B
                    let:8 a446 = a445 in
                    let:16 a447 = addWithCarry(false,0B,a446) in
                    let:8 a448 = (0B & 0F) in
                    let:8 a449 = (a446 & 0F) in
                    let:16 a450 = addWithCarry(false,a448,a449) in
                    advance (7)
                    #063E
                    #instruction: LD   L,A
                    let:8 a451 = a447[7:0] in
                    advance (5)
                    #063F
                    #instruction: DEC  D
                    let:16 a452 = addWithCarry(!true,05,~00) in
                    let:8 a453 = (05 & 0F) in
                    let:8 a454 = (~00 & 0F) in
                    let:16 a455 = addWithCarry(!true,a453,a454) in
                    advance (5)
                    #0640
                    #instruction: JP   NZ,0637
                    if (!is_zero(a452[7:0])) {
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a421[15:8];
                      SPL := a421[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump (0637);
                    } else {
                      advance (10)
                      #0643
                      #instruction: RET
                      let:8 a456 = a421[15:8] in
                      let:8 a457 = a421[7:0] in
                      let:16 a458 = (1 + (a456,a457)) in
                      let:8 a459 = M[(a456,a457)] in
                      let:8 a460 = a458[15:8] in
                      let:8 a461 = a458[7:0] in
                      let:16 a462 = (1 + (a460,a461)) in
                      let:8 a463 = M[(a460,a461)] in
                      advance (10)
                      A := a447[7:0];
                      B := a331;
                      C := a423[7:0];
                      D := a452[7:0];
                      H := a428;
                      L := a451;
                      SPH := a462[15:8];
                      SPL := a462[7:0];
                      FlagS := a452[7:0][7];
                      FlagZ := is_zero(a452[7:0]);
                      FlagA := a455[7:0][4];
                      FlagP := parity(a452[7:0]);
                      FlagCY := a447[15:8][0];
                      jump ((a463,a459));
                    }
                  }
                }
              } else {
                advance (10)
                #0590
                #instruction: LD   B,A
                let:8 a464 = a350 in
                advance (5)
                #0591
                #instruction: LD   A,(20CF)
                let:8 a465 = M[20CF] in
                advance (13)
                #0594
                #instruction: CP   B
                let:8 a466 = a465 in
                let:8 a467 = a464 in
                let:16 a468 = addWithCarry(!false,a466,~a467) in
                let:8 a469 = (a466 & 0F) in
                let:8 a470 = (~a467 & 0F) in
                let:16 a471 = addWithCarry(!false,a469,a470) in
                advance (4)
                #0595
                #instruction: RET  NC
                if (!!a468[15:8][0]) {
                  let:8 a472 = a10[15:8] in
                  let:8 a473 = a10[7:0] in
                  let:16 a474 = (1 + (a472,a473)) in
                  let:8 a475 = M[(a472,a473)] in
                  let:8 a476 = a474[15:8] in
                  let:8 a477 = a474[7:0] in
                  let:16 a478 = (1 + (a476,a477)) in
                  let:8 a479 = M[(a476,a477)] in
                  advance (11)
                  A := a465;
                  B := a464;
                  H := 20;
                  L := 74;
                  SPH := a478[15:8];
                  SPL := a478[7:0];
                  FlagS := a468[7:0][7];
                  FlagZ := is_zero(a468[7:0]);
                  FlagA := a471[7:0][4];
                  FlagP := parity(a468[7:0]);
                  FlagCY := !a468[15:8][0];
                  jump ((a479,a475));
                } else {
                  advance (5)
                  #0596
                  #instruction: INC  HL
                  advance (5)
                  #0597
                  #instruction: LD   A,(HL)
                  let:8 a480 = M[2075] in
                  advance (7)
                  #0598
                  #instruction: AND  A
                  let:8 a481 = a480 in
                  let:8 a482 = a480 in
                  let:8 a483 = (a481 & a482) in
                  let:8 a484 = (a481 | a482) in
                  advance (4)
                  #0599
                  #instruction: JP   Z,061B
                  if (is_zero(a483)) {
                    advance (10)
                    #061B
                    #instruction: LD   A,(201B)
                    let:8 a485 = M[201B] in
                    advance (13)
                    #061E
                    #instruction: ADD  08
                    let:8 a486 = a485 in
                    let:16 a487 = addWithCarry(false,08,a486) in
                    let:8 a488 = (08 & 0F) in
                    let:8 a489 = (a486 & 0F) in
                    let:16 a490 = addWithCarry(false,a488,a489) in
                    advance (7)
                    #0620
                    #instruction: LD   H,A
                    let:8 a491 = a487[7:0] in
                    advance (5)
                    #0621
                    #instruction: CALL 156F
                    let:8 a492 = a10[15:8] in
                    let:8 a493 = a10[7:0] in
                    let:16 a494 = (-1 + (a492,a493)) in
                    M[a494] := 06;
                    let:8 a495 = a494[15:8] in
                    let:8 a496 = a494[7:0] in
                    let:16 a497 = (-1 + (a495,a496)) in
                    M[a497] := 24;
                    #return-to: 0624
                    advance (17)
                    #156F
                    #instruction: LD   A,(200A)
                    let:8 a498 = M[200A] in
                    advance (13)
                    #1572
                    #instruction: CALL 1554
                    let:8 a499 = a497[15:8] in
                    let:8 a500 = a497[7:0] in
                    let:16 a501 = (-1 + (a499,a500)) in
                    M[a501] := 15;
                    let:8 a502 = a501[15:8] in
                    let:8 a503 = a501[7:0] in
                    let:16 a504 = (-1 + (a502,a503)) in
                    M[a504] := 75;
                    #return-to: 1575
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:8 a505 = a498 in
                    let:8 a506 = a491 in
                    let:16 a507 = addWithCarry(!false,a505,~a506) in
                    let:8 a508 = (a505 & 0F) in
                    let:8 a509 = (~a506 & 0F) in
                    let:16 a510 = addWithCarry(!false,a508,a509) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a507[15:8][0]) {
                      let:8 a511 = a504[15:8] in
                      let:8 a512 = a504[7:0] in
                      let:16 a513 = (-1 + (a511,a512)) in
                      M[a513] := 15;
                      let:8 a514 = a513[15:8] in
                      let:8 a515 = a513[7:0] in
                      let:16 a516 = (-1 + (a514,a515)) in
                      M[a516] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a517 = addWithCarry(true,00,00) in
                      let:8 a518 = (00 & 0F) in
                      let:8 a519 = (00 & 0F) in
                      let:16 a520 = addWithCarry(true,a518,a519) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:8 a521 = a498 in
                      let:16 a522 = addWithCarry(false,10,a521) in
                      let:8 a523 = (10 & 0F) in
                      let:8 a524 = (a521 & 0F) in
                      let:16 a525 = addWithCarry(false,a523,a524) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a522[7:0][7]) {
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a516[15:8];
                        SPL := a516[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:8 a526 = a516[15:8] in
                        let:8 a527 = a516[7:0] in
                        let:16 a528 = (1 + (a526,a527)) in
                        let:8 a529 = M[(a526,a527)] in
                        let:8 a530 = a528[15:8] in
                        let:8 a531 = a528[7:0] in
                        let:16 a532 = (1 + (a530,a531)) in
                        let:8 a533 = M[(a530,a531)] in
                        advance (10)
                        A := a522[7:0];
                        B := a464;
                        C := a517[7:0];
                        H := a491;
                        L := 75;
                        SPH := a532[15:8];
                        SPL := a532[7:0];
                        FlagS := a522[7:0][7];
                        FlagZ := is_zero(a522[7:0]);
                        FlagA := a525[7:0][4];
                        FlagP := parity(a522[7:0]);
                        FlagCY := a522[15:8][0];
                        jump ((a533,a529));
                      }
                    } else {
                      advance (11)
                      A := a498;
                      B := a464;
                      C := 00;
                      H := a491;
                      L := 75;
                      SPH := a504[15:8];
                      SPL := a504[7:0];
                      FlagS := a507[7:0][7];
                      FlagZ := is_zero(a507[7:0]);
                      FlagA := a510[7:0][4];
                      FlagP := parity(a507[7:0]);
                      FlagCY := !a507[15:8][0];
                      jump (155A);
                    }
                  } else {
                    advance (10)
                    #059C
                    #instruction: LD   HL,(2076)
                    let:8 a534 = M[2076] in
                    let:8 a535 = M[2077] in
                    advance (16)
                    #059F
                    #instruction: LD   C,(HL)
                    let:8 a536 = a535 in
                    let:8 a537 = a534 in
                    let:8 a538 = M[(a536,a537)] in
                    advance (7)
                    #05A0
                    #instruction: INC  HL
                    let:8 a539 = a535 in
                    let:8 a540 = a534 in
                    let:16 a541 = (1 + (a539,a540)) in
                    advance (5)
                    #05A1
                    #instruction: NOP
                    advance (4)
                    #05A2
                    #instruction: LD   (2076),HL
                    let:8 a542 = a541[7:0] in
                    M[2076] := a542;
                    let:8 a543 = a541[15:8] in
                    M[2077] := a543;
                    advance (16)
                    #05A5
                    #instruction: CALL 062F
                    let:8 a544 = a10[15:8] in
                    let:8 a545 = a10[7:0] in
                    let:16 a546 = (-1 + (a544,a545)) in
                    M[a546] := 05;
                    let:8 a547 = a546[15:8] in
                    let:8 a548 = a546[7:0] in
                    let:16 a549 = (-1 + (a547,a548)) in
                    M[a549] := A8;
                    #return-to: 05A8
                    advance (17)
                    #062F
                    #instruction: DEC  C
                    let:8 a550 = a538 in
                    let:16 a551 = addWithCarry(!true,a550,~00) in
                    let:8 a552 = (a550 & 0F) in
                    let:8 a553 = (~00 & 0F) in
                    let:16 a554 = addWithCarry(!true,a552,a553) in
                    advance (5)
                    #0630
                    #instruction: LD   A,(2067)
                    let:8 a555 = M[2067] in
                    advance (13)
                    #0633
                    #instruction: LD   H,A
                    let:8 a556 = a555 in
                    advance (5)
                    #0634
                    #instruction: LD   L,C
                    let:8 a557 = a551[7:0] in
                    advance (5)
                    #0635
                    #instruction: LD   D,05
                    advance (7)
                    #0637
                    #instruction: LD   A,(HL)
                    let:8 a558 = a556 in
                    let:8 a559 = a557 in
                    let:8 a560 = M[(a558,a559)] in
                    advance (7)
                    #0638
                    #instruction: AND  A
                    let:8 a561 = a560 in
                    let:8 a562 = a560 in
                    let:8 a563 = (a561 & a562) in
                    let:8 a564 = (a561 | a562) in
                    advance (4)
                    #0639
                    #instruction: SCF
                    advance (4)
                    #063A
                    #instruction: RET  NZ
                    if (!is_zero(a563)) {
                      let:8 a565 = a549[15:8] in
                      let:8 a566 = a549[7:0] in
                      let:16 a567 = (1 + (a565,a566)) in
                      let:8 a568 = M[(a565,a566)] in
                      let:8 a569 = a567[15:8] in
                      let:8 a570 = a567[7:0] in
                      let:16 a571 = (1 + (a569,a570)) in
                      let:8 a572 = M[(a569,a570)] in
                      advance (11)
                      A := a563;
                      B := a464;
                      C := a551[7:0];
                      D := 05;
                      H := a556;
                      L := a557;
                      SPH := a571[15:8];
                      SPL := a571[7:0];
                      FlagS := a563[7];
                      FlagZ := is_zero(a563);
                      FlagA := a564[3];
                      FlagP := parity(a563);
                      FlagCY := true;
                      jump ((a572,a568));
                    } else {
                      advance (5)
                      #063B
                      #instruction: LD   A,L
                      let:8 a573 = a557 in
                      advance (5)
                      #063C
                      #instruction: ADD  0B
                      let:8 a574 = a573 in
                      let:16 a575 = addWithCarry(false,0B,a574) in
                      let:8 a576 = (0B & 0F) in
                      let:8 a577 = (a574 & 0F) in
                      let:16 a578 = addWithCarry(false,a576,a577) in
                      advance (7)
                      #063E
                      #instruction: LD   L,A
                      let:8 a579 = a575[7:0] in
                      advance (5)
                      #063F
                      #instruction: DEC  D
                      let:16 a580 = addWithCarry(!true,05,~00) in
                      let:8 a581 = (05 & 0F) in
                      let:8 a582 = (~00 & 0F) in
                      let:16 a583 = addWithCarry(!true,a581,a582) in
                      advance (5)
                      #0640
                      #instruction: JP   NZ,0637
                      if (!is_zero(a580[7:0])) {
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a549[15:8];
                        SPL := a549[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump (0637);
                      } else {
                        advance (10)
                        #0643
                        #instruction: RET
                        let:8 a584 = a549[15:8] in
                        let:8 a585 = a549[7:0] in
                        let:16 a586 = (1 + (a584,a585)) in
                        let:8 a587 = M[(a584,a585)] in
                        let:8 a588 = a586[15:8] in
                        let:8 a589 = a586[7:0] in
                        let:16 a590 = (1 + (a588,a589)) in
                        let:8 a591 = M[(a588,a589)] in
                        advance (10)
                        A := a575[7:0];
                        B := a464;
                        C := a551[7:0];
                        D := a580[7:0];
                        H := a556;
                        L := a579;
                        SPH := a590[15:8];
                        SPL := a590[7:0];
                        FlagS := a580[7:0][7];
                        FlagZ := is_zero(a580[7:0]);
                        FlagA := a583[7:0][4];
                        FlagP := parity(a580[7:0]);
                        FlagCY := a575[15:8][0];
                        jump ((a591,a587));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

0526:

    #0526
    #instruction: LD   A,(2076)
    let:8 a1 = M[2076] in
    advance (13)
    #0529
    #instruction: CP   15
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~15) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~15 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #052B
    #instruction: JP   CY,0534
    if (!a3[15:8][0]) {
      advance (10)
      #0534
      #instruction: LD   A,(2078)
      let:8 a7 = M[2078] in
      advance (13)
      #0537
      #instruction: AND  A
      let:8 a8 = a7 in
      let:8 a9 = a7 in
      let:8 a10 = (a8 & a9) in
      let:8 a11 = (a8 | a9) in
      advance (4)
      #0538
      #instruction: LD   HL,2055
      advance (10)
      #053B
      #instruction: JP   NZ,055B
      if (!is_zero(a10)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a12 = M[2073] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a13 = a12 in
        M[2055] := a13;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a14 = addWithCarry(!true,0B,~00) in
        let:8 a15 = (0B & 0F) in
        let:8 a16 = (~00 & 0F) in
        let:16 a17 = addWithCarry(!true,a15,a16) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a14[7:0])) {
          advance (10)
          A := a12;
          B := a14[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          FlagS := a14[7:0][7];
          FlagZ := is_zero(a14[7:0]);
          FlagA := a17[7:0][4];
          FlagP := parity(a14[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a18 = SPH in
          let:8 a19 = SPL in
          let:16 a20 = (1 + (a18,a19)) in
          let:8 a21 = M[(a18,a19)] in
          let:8 a22 = a20[15:8] in
          let:8 a23 = a20[7:0] in
          let:16 a24 = (1 + (a22,a23)) in
          let:8 a25 = M[(a22,a23)] in
          advance (10)
          A := a12;
          B := a14[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          SPH := a24[15:8];
          SPL := a24[7:0];
          FlagS := a14[7:0][7];
          FlagZ := is_zero(a14[7:0]);
          FlagA := a17[7:0][4];
          FlagP := parity(a14[7:0]);
          FlagCY := false;
          jump ((a25,a21));
        }
      } else {
        advance (10)
        #053E
        #instruction: LD   DE,1B50
        advance (10)
        #0541
        #instruction: LD   HL,2050
        advance (10)
        #0544
        #instruction: LD   B,10
        advance (7)
        #0546
        #instruction: CALL 1A32
        let:8 a26 = SPH in
        let:8 a27 = SPL in
        let:16 a28 = (-1 + (a26,a27)) in
        M[a28] := 05;
        let:8 a29 = a28[15:8] in
        let:8 a30 = a28[7:0] in
        let:16 a31 = (-1 + (a29,a30)) in
        M[a31] := 49;
        #return-to: 0549
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2050] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a32 = addWithCarry(!true,10,~00) in
        let:8 a33 = (10 & 0F) in
        let:8 a34 = (~00 & 0F) in
        let:16 a35 = addWithCarry(!true,a33,a34) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a32[7:0])) {
          advance (10)
          A := 00;
          B := a32[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a31[15:8];
          SPL := a31[7:0];
          FlagS := a32[7:0][7];
          FlagZ := is_zero(a32[7:0]);
          FlagA := a35[7:0][4];
          FlagP := parity(a32[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a36 = a31[15:8] in
          let:8 a37 = a31[7:0] in
          let:16 a38 = (1 + (a36,a37)) in
          let:8 a39 = M[(a36,a37)] in
          let:8 a40 = a38[15:8] in
          let:8 a41 = a38[7:0] in
          let:16 a42 = (1 + (a40,a41)) in
          let:8 a43 = M[(a40,a41)] in
          advance (10)
          A := 00;
          B := a32[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a42[15:8];
          SPL := a42[7:0];
          FlagS := a32[7:0][7];
          FlagZ := is_zero(a32[7:0]);
          FlagA := a35[7:0][4];
          FlagP := parity(a32[7:0]);
          FlagCY := false;
          jump ((a43,a39));
        }
      }
    } else {
      advance (10)
      #052E
      #instruction: LD   A,(1B58)
      advance (13)
      #0531
      #instruction: LD   (2076),A
      M[2076] := 06;
      advance (13)
      #0534
      #instruction: LD   A,(2078)
      let:8 a44 = M[2078] in
      advance (13)
      #0537
      #instruction: AND  A
      let:8 a45 = a44 in
      let:8 a46 = a44 in
      let:8 a47 = (a45 & a46) in
      let:8 a48 = (a45 | a46) in
      advance (4)
      #0538
      #instruction: LD   HL,2055
      advance (10)
      #053B
      #instruction: JP   NZ,055B
      if (!is_zero(a47)) {
        advance (10)
        #055B
        #instruction: LD   DE,2073
        advance (10)
        #055E
        #instruction: LD   B,0B
        advance (7)
        #0560
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a49 = M[2073] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a50 = a49 in
        M[2055] := a50;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a51 = addWithCarry(!true,0B,~00) in
        let:8 a52 = (0B & 0F) in
        let:8 a53 = (~00 & 0F) in
        let:16 a54 = addWithCarry(!true,a52,a53) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a51[7:0])) {
          advance (10)
          A := a49;
          B := a51[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          FlagS := a51[7:0][7];
          FlagZ := is_zero(a51[7:0]);
          FlagA := a54[7:0][4];
          FlagP := parity(a51[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a55 = SPH in
          let:8 a56 = SPL in
          let:16 a57 = (1 + (a55,a56)) in
          let:8 a58 = M[(a55,a56)] in
          let:8 a59 = a57[15:8] in
          let:8 a60 = a57[7:0] in
          let:16 a61 = (1 + (a59,a60)) in
          let:8 a62 = M[(a59,a60)] in
          advance (10)
          A := a49;
          B := a51[7:0];
          D := 20;
          E := 74;
          H := 20;
          L := 56;
          SPH := a61[15:8];
          SPL := a61[7:0];
          FlagS := a51[7:0][7];
          FlagZ := is_zero(a51[7:0]);
          FlagA := a54[7:0][4];
          FlagP := parity(a51[7:0]);
          FlagCY := false;
          jump ((a62,a58));
        }
      } else {
        advance (10)
        #053E
        #instruction: LD   DE,1B50
        advance (10)
        #0541
        #instruction: LD   HL,2050
        advance (10)
        #0544
        #instruction: LD   B,10
        advance (7)
        #0546
        #instruction: CALL 1A32
        let:8 a63 = SPH in
        let:8 a64 = SPL in
        let:16 a65 = (-1 + (a63,a64)) in
        M[a65] := 05;
        let:8 a66 = a65[15:8] in
        let:8 a67 = a65[7:0] in
        let:16 a68 = (-1 + (a66,a67)) in
        M[a68] := 49;
        #return-to: 0549
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2050] := 00;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a69 = addWithCarry(!true,10,~00) in
        let:8 a70 = (10 & 0F) in
        let:8 a71 = (~00 & 0F) in
        let:16 a72 = addWithCarry(!true,a70,a71) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a69[7:0])) {
          advance (10)
          A := 00;
          B := a69[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a68[15:8];
          SPL := a68[7:0];
          FlagS := a69[7:0][7];
          FlagZ := is_zero(a69[7:0]);
          FlagA := a72[7:0][4];
          FlagP := parity(a69[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a73 = a68[15:8] in
          let:8 a74 = a68[7:0] in
          let:16 a75 = (1 + (a73,a74)) in
          let:8 a76 = M[(a73,a74)] in
          let:8 a77 = a75[15:8] in
          let:8 a78 = a75[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          advance (10)
          A := 00;
          B := a69[7:0];
          D := 1B;
          E := 51;
          H := 20;
          L := 51;
          SPH := a79[15:8];
          SPL := a79[7:0];
          FlagS := a69[7:0][7];
          FlagZ := is_zero(a69[7:0]);
          FlagA := a72[7:0][4];
          FlagP := parity(a69[7:0]);
          FlagCY := false;
          jump ((a80,a76));
        }
      }
    }

0549:

    #0549
    #instruction: LD   HL,(2076)
    let:8 a1 = M[2076] in
    let:8 a2 = M[2077] in
    advance (16)
    #054C
    #instruction: LD   (2058),HL
    let:8 a3 = a1 in
    M[2058] := a3;
    let:8 a4 = a2 in
    M[2059] := a4;
    advance (16)
    #054F
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    H := a2;
    L := a1;
    SPH := a11[15:8];
    SPL := a11[7:0];
    jump ((a12,a8));

05A8:

    #05A8
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #05A9
      #instruction: CALL 017A
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 05;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := AC;
      #return-to: 05AC
      advance (17)
      #017A
      #instruction: LD   D,00
      advance (7)
      #017C
      #instruction: LD   A,L
      let:8 a15 = L in
      advance (5)
      #017D
      #instruction: LD   HL,2009
      advance (10)
      #0180
      #instruction: LD   B,(HL)
      let:8 a16 = M[2009] in
      advance (7)
      #0181
      #instruction: INC  HL
      advance (5)
      #0182
      #instruction: LD   C,(HL)
      let:8 a17 = M[200A] in
      advance (7)
      #0183
      #instruction: CP   0B
      let:8 a18 = a15 in
      let:16 a19 = addWithCarry(!false,a18,~0B) in
      let:8 a20 = (a18 & 0F) in
      let:8 a21 = (~0B & 0F) in
      let:16 a22 = addWithCarry(!false,a20,a21) in
      advance (7)
      #0185
      #instruction: JP   MI,0194
      if (a19[7:0][7]) {
        advance (10)
        #0194
        #instruction: LD   L,B
        let:8 a23 = a16 in
        advance (5)
        #0195
        #instruction: AND  A
        let:8 a24 = a15 in
        let:8 a25 = a15 in
        let:8 a26 = (a24 & a25) in
        let:8 a27 = (a24 | a25) in
        advance (4)
        #0196
        #instruction: RET  Z
        if (is_zero(a26)) {
          let:8 a28 = a14[15:8] in
          let:8 a29 = a14[7:0] in
          let:16 a30 = (1 + (a28,a29)) in
          let:8 a31 = M[(a28,a29)] in
          let:8 a32 = a30[15:8] in
          let:8 a33 = a30[7:0] in
          let:16 a34 = (1 + (a32,a33)) in
          let:8 a35 = M[(a32,a33)] in
          advance (11)
          A := a26;
          B := a16;
          C := a17;
          D := 00;
          H := 20;
          L := a23;
          SPH := a34[15:8];
          SPL := a34[7:0];
          FlagS := a26[7];
          FlagZ := is_zero(a26);
          FlagA := a27[3];
          FlagP := parity(a26);
          FlagCY := false;
          jump ((a35,a31));
        } else {
          advance (5)
          #0197
          #instruction: LD   E,A
          let:8 a36 = a26 in
          advance (5)
          #0198
          #instruction: LD   A,C
          let:8 a37 = a17 in
          advance (5)
          #0199
          #instruction: ADD  10
          let:8 a38 = a37 in
          let:16 a39 = addWithCarry(false,10,a38) in
          let:8 a40 = (10 & 0F) in
          let:8 a41 = (a38 & 0F) in
          let:16 a42 = addWithCarry(false,a40,a41) in
          advance (7)
          #019B
          #instruction: LD   C,A
          let:8 a43 = a39[7:0] in
          advance (5)
          #019C
          #instruction: LD   A,E
          let:8 a44 = a36 in
          advance (5)
          #019D
          #instruction: DEC  A
          let:8 a45 = a44 in
          let:16 a46 = addWithCarry(!true,a45,~00) in
          let:8 a47 = (a45 & 0F) in
          let:8 a48 = (~00 & 0F) in
          let:16 a49 = addWithCarry(!true,a47,a48) in
          advance (5)
          #019E
          #instruction: JP   0195
          advance (10)
          A := a46[7:0];
          B := a16;
          C := a43;
          D := 00;
          E := a36;
          H := 20;
          L := a23;
          SPH := a14[15:8];
          SPL := a14[7:0];
          FlagS := a46[7:0][7];
          FlagZ := is_zero(a46[7:0]);
          FlagA := a49[7:0][4];
          FlagP := parity(a46[7:0]);
          FlagCY := a39[15:8][0];
          jump (0195);
        }
      } else {
        advance (10)
        #0188
        #instruction: SBC  0B
        let:8 a50 = a15 in
        let:16 a51 = addWithCarry(!!a19[15:8][0],a50,~0B) in
        let:8 a52 = (a50 & 0F) in
        let:8 a53 = (~0B & 0F) in
        let:16 a54 = addWithCarry(!!a19[15:8][0],a52,a53) in
        advance (7)
        #018A
        #instruction: LD   E,A
        let:8 a55 = a51[7:0] in
        advance (5)
        #018B
        #instruction: LD   A,B
        let:8 a56 = a16 in
        advance (5)
        #018C
        #instruction: ADD  10
        let:8 a57 = a56 in
        let:16 a58 = addWithCarry(false,10,a57) in
        let:8 a59 = (10 & 0F) in
        let:8 a60 = (a57 & 0F) in
        let:16 a61 = addWithCarry(false,a59,a60) in
        advance (7)
        #018E
        #instruction: LD   B,A
        let:8 a62 = a58[7:0] in
        advance (5)
        #018F
        #instruction: LD   A,E
        let:8 a63 = a55 in
        advance (5)
        #0190
        #instruction: INC  D
        let:16 a64 = addWithCarry(true,00,00) in
        let:8 a65 = (00 & 0F) in
        let:8 a66 = (00 & 0F) in
        let:16 a67 = addWithCarry(true,a65,a66) in
        advance (5)
        #0191
        #instruction: JP   0183
        advance (10)
        A := a63;
        B := a62;
        C := a17;
        D := a64[7:0];
        E := a55;
        H := 20;
        L := 0A;
        SPH := a14[15:8];
        SPL := a14[7:0];
        FlagS := a64[7:0][7];
        FlagZ := is_zero(a64[7:0]);
        FlagA := a67[7:0][4];
        FlagP := parity(a64[7:0]);
        FlagCY := a58[15:8][0];
        jump (0183);
      }
    }

05AC:

    #05AC
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #05AD
    #instruction: ADD  07
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(false,07,a2) in
    let:8 a4 = (07 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (7)
    #05AF
    #instruction: LD   H,A
    let:8 a7 = a3[7:0] in
    advance (5)
    #05B0
    #instruction: LD   A,L
    let:8 a8 = L in
    advance (5)
    #05B1
    #instruction: SUB  0A
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(!false,a9,~0A) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~0A & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #05B3
    #instruction: LD   L,A
    let:8 a14 = a10[7:0] in
    advance (5)
    #05B4
    #instruction: LD   (207B),HL
    let:8 a15 = a14 in
    M[207B] := a15;
    let:8 a16 = a7 in
    M[207C] := a16;
    advance (16)
    #05B7
    #instruction: LD   HL,2073
    advance (10)
    #05BA
    #instruction: LD   A,(HL)
    let:8 a17 = M[2073] in
    advance (7)
    #05BB
    #instruction: OR   80
    let:8 a18 = a17 in
    let:8 a19 = (80 | a18) in
    advance (7)
    #05BD
    #instruction: LD   (HL),A
    let:8 a20 = a19 in
    M[2073] := a20;
    advance (7)
    #05BE
    #instruction: INC  HL
    advance (5)
    #05BF
    #instruction: INC  (HL)
    let:8 a21 = M[2074] in
    let:16 a22 = addWithCarry(true,a21,00) in
    let:8 a23 = (a21 & 0F) in
    let:8 a24 = (00 & 0F) in
    let:16 a25 = addWithCarry(true,a23,a24) in
    M[2074] := a22[7:0];
    advance (10)
    #05C0
    #instruction: RET
    let:8 a26 = SPH in
    let:8 a27 = SPL in
    let:16 a28 = (1 + (a26,a27)) in
    let:8 a29 = M[(a26,a27)] in
    let:8 a30 = a28[15:8] in
    let:8 a31 = a28[7:0] in
    let:16 a32 = (1 + (a30,a31)) in
    let:8 a33 = M[(a30,a31)] in
    advance (10)
    A := a19;
    H := 20;
    L := 74;
    SPH := a32[15:8];
    SPL := a32[7:0];
    FlagS := a22[7:0][7];
    FlagZ := is_zero(a22[7:0]);
    FlagA := a25[7:0][4];
    FlagP := parity(a22[7:0]);
    FlagCY := false;
    jump ((a33,a29));

05C7:

    #05C7
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #05C8
      #instruction: INC  HL
      let:8 a9 = H in
      let:8 a10 = L in
      let:16 a11 = (1 + (a9,a10)) in
      advance (5)
      #05C9
      #instruction: LD   A,(HL)
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:8 a14 = M[(a12,a13)] in
      advance (7)
      #05CA
      #instruction: AND  01
      let:8 a15 = a14 in
      let:8 a16 = (01 & a15) in
      let:8 a17 = (01 | a15) in
      advance (7)
      #05CC
      #instruction: JP   NZ,0644
      if (!is_zero(a16)) {
        advance (10)
        #0644
        #instruction: LD   HL,2078
        advance (10)
        #0647
        #instruction: DEC  (HL)
        let:8 a18 = M[2078] in
        let:16 a19 = addWithCarry(!true,a18,~00) in
        let:8 a20 = (a18 & 0F) in
        let:8 a21 = (~00 & 0F) in
        let:16 a22 = addWithCarry(!true,a20,a21) in
        M[2078] := a19[7:0];
        advance (10)
        #0648
        #instruction: LD   A,(HL)
        let:8 a23 = M[2078] in
        advance (7)
        #0649
        #instruction: CP   03
        let:8 a24 = a23 in
        let:16 a25 = addWithCarry(!false,a24,~03) in
        let:8 a26 = (a24 & 0F) in
        let:8 a27 = (~03 & 0F) in
        let:16 a28 = addWithCarry(!false,a26,a27) in
        advance (7)
        #064B
        #instruction: JP   NZ,0667
        if (!is_zero(a25[7:0])) {
          advance (10)
          #0667
          #instruction: AND  A
          let:8 a29 = a23 in
          let:8 a30 = a23 in
          let:8 a31 = (a29 & a30) in
          let:8 a32 = (a29 | a30) in
          advance (4)
          #0668
          #instruction: RET  NZ
          if (!is_zero(a31)) {
            let:8 a33 = SPH in
            let:8 a34 = SPL in
            let:16 a35 = (1 + (a33,a34)) in
            let:8 a36 = M[(a33,a34)] in
            let:8 a37 = a35[15:8] in
            let:8 a38 = a35[7:0] in
            let:16 a39 = (1 + (a37,a38)) in
            let:8 a40 = M[(a37,a38)] in
            advance (11)
            A := a31;
            H := 20;
            L := 78;
            SPH := a39[15:8];
            SPL := a39[7:0];
            FlagS := a31[7];
            FlagZ := is_zero(a31);
            FlagA := a32[3];
            FlagP := parity(a31);
            FlagCY := false;
            jump ((a40,a36));
          } else {
            advance (5)
            #0669
            #instruction: JP   0675
            advance (10)
            #0675
            #instruction: LD   HL,2079
            advance (10)
            #0678
            #instruction: CALL 1A3B
            let:8 a41 = SPH in
            let:8 a42 = SPL in
            let:16 a43 = (-1 + (a41,a42)) in
            M[a43] := 06;
            let:8 a44 = a43[15:8] in
            let:8 a45 = a43[7:0] in
            let:16 a46 = (-1 + (a44,a45)) in
            M[a46] := 7B;
            #return-to: 067B
            advance (17)
            #1A3B
            #instruction: LD   E,(HL)
            let:8 a47 = M[2079] in
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            let:8 a48 = M[207A] in
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            let:8 a49 = M[207B] in
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            let:8 a50 = M[207C] in
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            let:8 a51 = M[207D] in
            advance (7)
            #1A44
            #instruction: LD   H,C
            let:8 a52 = a50 in
            advance (5)
            #1A45
            #instruction: LD   L,A
            let:8 a53 = a49 in
            advance (5)
            #1A46
            #instruction: RET
            let:8 a54 = a46[15:8] in
            let:8 a55 = a46[7:0] in
            let:16 a56 = (1 + (a54,a55)) in
            let:8 a57 = M[(a54,a55)] in
            let:8 a58 = a56[15:8] in
            let:8 a59 = a56[7:0] in
            let:16 a60 = (1 + (a58,a59)) in
            let:8 a61 = M[(a58,a59)] in
            advance (10)
            A := a49;
            B := a51;
            C := a50;
            D := a48;
            E := a47;
            H := a52;
            L := a53;
            SPH := a60[15:8];
            SPL := a60[7:0];
            FlagS := a31[7];
            FlagZ := is_zero(a31);
            FlagA := a32[3];
            FlagP := parity(a31);
            FlagCY := false;
            jump ((a61,a57));
          }
        } else {
          advance (10)
          #064E
          #instruction: CALL 0675
          let:8 a62 = SPH in
          let:8 a63 = SPL in
          let:16 a64 = (-1 + (a62,a63)) in
          M[a64] := 06;
          let:8 a65 = a64[15:8] in
          let:8 a66 = a64[7:0] in
          let:16 a67 = (-1 + (a65,a66)) in
          M[a67] := 51;
          #return-to: 0651
          advance (17)
          #0675
          #instruction: LD   HL,2079
          advance (10)
          #0678
          #instruction: CALL 1A3B
          let:8 a68 = a67[15:8] in
          let:8 a69 = a67[7:0] in
          let:16 a70 = (-1 + (a68,a69)) in
          M[a70] := 06;
          let:8 a71 = a70[15:8] in
          let:8 a72 = a70[7:0] in
          let:16 a73 = (-1 + (a71,a72)) in
          M[a73] := 7B;
          #return-to: 067B
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a74 = M[2079] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a75 = M[207A] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a76 = M[207B] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a77 = M[207C] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a78 = M[207D] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a79 = a77 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a80 = a76 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a81 = a73[15:8] in
          let:8 a82 = a73[7:0] in
          let:16 a83 = (1 + (a81,a82)) in
          let:8 a84 = M[(a81,a82)] in
          let:8 a85 = a83[15:8] in
          let:8 a86 = a83[7:0] in
          let:16 a87 = (1 + (a85,a86)) in
          let:8 a88 = M[(a85,a86)] in
          advance (10)
          A := a76;
          B := a78;
          C := a77;
          D := a75;
          E := a74;
          H := a79;
          L := a80;
          SPH := a87[15:8];
          SPL := a87[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := !a25[15:8][0];
          jump ((a88,a84));
        }
      } else {
        advance (10)
        #05CF
        #instruction: INC  HL
        let:8 a89 = a11[15:8] in
        let:8 a90 = a11[7:0] in
        let:16 a91 = (1 + (a89,a90)) in
        advance (5)
        #05D0
        #instruction: INC  (HL)
        let:8 a92 = a91[15:8] in
        let:8 a93 = a91[7:0] in
        let:8 a94 = M[(a92,a93)] in
        let:16 a95 = addWithCarry(true,a94,00) in
        let:8 a96 = (a94 & 0F) in
        let:8 a97 = (00 & 0F) in
        let:16 a98 = addWithCarry(true,a96,a97) in
        let:8 a99 = a91[15:8] in
        let:8 a100 = a91[7:0] in
        M[(a99,a100)] := a95[7:0];
        advance (10)
        #05D1
        #instruction: CALL 0675
        let:8 a101 = SPH in
        let:8 a102 = SPL in
        let:16 a103 = (-1 + (a101,a102)) in
        M[a103] := 05;
        let:8 a104 = a103[15:8] in
        let:8 a105 = a103[7:0] in
        let:16 a106 = (-1 + (a104,a105)) in
        M[a106] := D4;
        #return-to: 05D4
        advance (17)
        #0675
        #instruction: LD   HL,2079
        advance (10)
        #0678
        #instruction: CALL 1A3B
        let:8 a107 = a106[15:8] in
        let:8 a108 = a106[7:0] in
        let:16 a109 = (-1 + (a107,a108)) in
        M[a109] := 06;
        let:8 a110 = a109[15:8] in
        let:8 a111 = a109[7:0] in
        let:16 a112 = (-1 + (a110,a111)) in
        M[a112] := 7B;
        #return-to: 067B
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a113 = M[2079] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a114 = M[207A] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a115 = M[207B] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a116 = M[207C] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a117 = M[207D] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a118 = a116 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a119 = a115 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a120 = a112[15:8] in
        let:8 a121 = a112[7:0] in
        let:16 a122 = (1 + (a120,a121)) in
        let:8 a123 = M[(a120,a121)] in
        let:8 a124 = a122[15:8] in
        let:8 a125 = a122[7:0] in
        let:16 a126 = (1 + (a124,a125)) in
        let:8 a127 = M[(a124,a125)] in
        advance (10)
        A := a115;
        B := a117;
        C := a116;
        D := a114;
        E := a113;
        H := a118;
        L := a119;
        SPH := a126[15:8];
        SPL := a126[7:0];
        FlagS := a95[7:0][7];
        FlagZ := is_zero(a95[7:0]);
        FlagA := a98[7:0][4];
        FlagP := parity(a95[7:0]);
        FlagCY := false;
        jump ((a127,a123));
      }
    }

05D4:

    #05D4
    #instruction: LD   A,(2079)
    let:8 a1 = M[2079] in
    advance (13)
    #05D7
    #instruction: ADD  03
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(false,03,a2) in
    let:8 a4 = (03 & 0F) in
    let:8 a5 = (a2 & 0F) in
    let:16 a6 = addWithCarry(false,a4,a5) in
    advance (7)
    #05D9
    #instruction: LD   HL,207F
    advance (10)
    #05DC
    #instruction: CP   (HL)
    let:8 a7 = a3[7:0] in
    let:8 a8 = M[207F] in
    let:16 a9 = addWithCarry(!false,a7,~a8) in
    let:8 a10 = (a7 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #05DD
    #instruction: JP   CY,05E2
    if (!a9[15:8][0]) {
      advance (10)
      #05E2
      #instruction: LD   (2079),A
      let:8 a13 = a3[7:0] in
      M[2079] := a13;
      advance (13)
      #05E5
      #instruction: LD   A,(207B)
      let:8 a14 = M[207B] in
      advance (13)
      #05E8
      #instruction: LD   B,A
      let:8 a15 = a14 in
      advance (5)
      #05E9
      #instruction: LD   A,(207E)
      let:8 a16 = M[207E] in
      advance (13)
      #05EC
      #instruction: ADD  B
      let:8 a17 = a15 in
      let:8 a18 = a16 in
      let:16 a19 = addWithCarry(false,a17,a18) in
      let:8 a20 = (a17 & 0F) in
      let:8 a21 = (a18 & 0F) in
      let:16 a22 = addWithCarry(false,a20,a21) in
      advance (4)
      #05ED
      #instruction: LD   (207B),A
      let:8 a23 = a19[7:0] in
      M[207B] := a23;
      advance (13)
      #05F0
      #instruction: CALL 066C
      let:8 a24 = SPH in
      let:8 a25 = SPL in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 05;
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := F3;
      #return-to: 05F3
      advance (17)
      #066C
      #instruction: LD   HL,2079
      advance (10)
      #066F
      #instruction: CALL 1A3B
      let:8 a30 = a29[15:8] in
      let:8 a31 = a29[7:0] in
      let:16 a32 = (-1 + (a30,a31)) in
      M[a32] := 06;
      let:8 a33 = a32[15:8] in
      let:8 a34 = a32[7:0] in
      let:16 a35 = (-1 + (a33,a34)) in
      M[a35] := 72;
      #return-to: 0672
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      let:8 a36 = M[2079] in
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      let:8 a37 = M[207A] in
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      let:8 a38 = M[207B] in
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      let:8 a39 = M[207C] in
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      let:8 a40 = M[207D] in
      advance (7)
      #1A44
      #instruction: LD   H,C
      let:8 a41 = a39 in
      advance (5)
      #1A45
      #instruction: LD   L,A
      let:8 a42 = a38 in
      advance (5)
      #1A46
      #instruction: RET
      let:8 a43 = a35[15:8] in
      let:8 a44 = a35[7:0] in
      let:16 a45 = (1 + (a43,a44)) in
      let:8 a46 = M[(a43,a44)] in
      let:8 a47 = a45[15:8] in
      let:8 a48 = a45[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      advance (10)
      A := a38;
      B := a40;
      C := a39;
      D := a37;
      E := a36;
      H := a41;
      L := a42;
      SPH := a49[15:8];
      SPL := a49[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      FlagCY := a19[15:8][0];
      jump ((a50,a46));
    } else {
      advance (10)
      #05E0
      #instruction: SUB  0C
      let:8 a51 = a3[7:0] in
      let:16 a52 = addWithCarry(!false,a51,~0C) in
      let:8 a53 = (a51 & 0F) in
      let:8 a54 = (~0C & 0F) in
      let:16 a55 = addWithCarry(!false,a53,a54) in
      advance (7)
      #05E2
      #instruction: LD   (2079),A
      let:8 a56 = a52[7:0] in
      M[2079] := a56;
      advance (13)
      #05E5
      #instruction: LD   A,(207B)
      let:8 a57 = M[207B] in
      advance (13)
      #05E8
      #instruction: LD   B,A
      let:8 a58 = a57 in
      advance (5)
      #05E9
      #instruction: LD   A,(207E)
      let:8 a59 = M[207E] in
      advance (13)
      #05EC
      #instruction: ADD  B
      let:8 a60 = a58 in
      let:8 a61 = a59 in
      let:16 a62 = addWithCarry(false,a60,a61) in
      let:8 a63 = (a60 & 0F) in
      let:8 a64 = (a61 & 0F) in
      let:16 a65 = addWithCarry(false,a63,a64) in
      advance (4)
      #05ED
      #instruction: LD   (207B),A
      let:8 a66 = a62[7:0] in
      M[207B] := a66;
      advance (13)
      #05F0
      #instruction: CALL 066C
      let:8 a67 = SPH in
      let:8 a68 = SPL in
      let:16 a69 = (-1 + (a67,a68)) in
      M[a69] := 05;
      let:8 a70 = a69[15:8] in
      let:8 a71 = a69[7:0] in
      let:16 a72 = (-1 + (a70,a71)) in
      M[a72] := F3;
      #return-to: 05F3
      advance (17)
      #066C
      #instruction: LD   HL,2079
      advance (10)
      #066F
      #instruction: CALL 1A3B
      let:8 a73 = a72[15:8] in
      let:8 a74 = a72[7:0] in
      let:16 a75 = (-1 + (a73,a74)) in
      M[a75] := 06;
      let:8 a76 = a75[15:8] in
      let:8 a77 = a75[7:0] in
      let:16 a78 = (-1 + (a76,a77)) in
      M[a78] := 72;
      #return-to: 0672
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      let:8 a79 = M[2079] in
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      let:8 a80 = M[207A] in
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      let:8 a81 = M[207B] in
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      let:8 a82 = M[207C] in
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      let:8 a83 = M[207D] in
      advance (7)
      #1A44
      #instruction: LD   H,C
      let:8 a84 = a82 in
      advance (5)
      #1A45
      #instruction: LD   L,A
      let:8 a85 = a81 in
      advance (5)
      #1A46
      #instruction: RET
      let:8 a86 = a78[15:8] in
      let:8 a87 = a78[7:0] in
      let:16 a88 = (1 + (a86,a87)) in
      let:8 a89 = M[(a86,a87)] in
      let:8 a90 = a88[15:8] in
      let:8 a91 = a88[7:0] in
      let:16 a92 = (1 + (a90,a91)) in
      let:8 a93 = M[(a90,a91)] in
      advance (10)
      A := a81;
      B := a83;
      C := a82;
      D := a80;
      E := a79;
      H := a84;
      L := a85;
      SPH := a92[15:8];
      SPL := a92[7:0];
      FlagS := a62[7:0][7];
      FlagZ := is_zero(a62[7:0]);
      FlagA := a65[7:0][4];
      FlagP := parity(a62[7:0]);
      FlagCY := a62[15:8][0];
      jump ((a93,a89));
    }

05F3:

    #05F3
    #instruction: LD   A,(207B)
    let:8 a1 = M[207B] in
    advance (13)
    #05F6
    #instruction: CP   15
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~15) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~15 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #05F8
    #instruction: JP   CY,0612
    if (!a3[15:8][0]) {
      advance (10)
      #0612
      #instruction: LD   A,(2073)
      let:8 a7 = M[2073] in
      advance (13)
      #0615
      #instruction: OR   01
      let:8 a8 = a7 in
      let:8 a9 = (01 | a8) in
      advance (7)
      #0617
      #instruction: LD   (2073),A
      let:8 a10 = a9 in
      M[2073] := a10;
      advance (13)
      #061A
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a9;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := false;
      FlagP := parity(a9);
      FlagCY := false;
      jump ((a18,a14));
    } else {
      advance (10)
      #05FB
      #instruction: LD   A,(2061)
      let:8 a19 = M[2061] in
      advance (13)
      #05FE
      #instruction: AND  A
      let:8 a20 = a19 in
      let:8 a21 = a19 in
      let:8 a22 = (a20 & a21) in
      let:8 a23 = (a20 | a21) in
      advance (4)
      #05FF
      #instruction: RET  Z
      if (is_zero(a22)) {
        let:8 a24 = SPH in
        let:8 a25 = SPL in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        let:8 a28 = a26[15:8] in
        let:8 a29 = a26[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        advance (11)
        A := a22;
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a22[7];
        FlagZ := is_zero(a22);
        FlagA := a23[3];
        FlagP := parity(a22);
        FlagCY := false;
        jump ((a31,a27));
      } else {
        advance (5)
        #0600
        #instruction: LD   A,(207B)
        let:8 a32 = M[207B] in
        advance (13)
        #0603
        #instruction: CP   1E
        let:8 a33 = a32 in
        let:16 a34 = addWithCarry(!false,a33,~1E) in
        let:8 a35 = (a33 & 0F) in
        let:8 a36 = (~1E & 0F) in
        let:16 a37 = addWithCarry(!false,a35,a36) in
        advance (7)
        #0605
        #instruction: JP   CY,0612
        if (!a34[15:8][0]) {
          advance (10)
          #0612
          #instruction: LD   A,(2073)
          let:8 a38 = M[2073] in
          advance (13)
          #0615
          #instruction: OR   01
          let:8 a39 = a38 in
          let:8 a40 = (01 | a39) in
          advance (7)
          #0617
          #instruction: LD   (2073),A
          let:8 a41 = a40 in
          M[2073] := a41;
          advance (13)
          #061A
          #instruction: RET
          let:8 a42 = SPH in
          let:8 a43 = SPL in
          let:16 a44 = (1 + (a42,a43)) in
          let:8 a45 = M[(a42,a43)] in
          let:8 a46 = a44[15:8] in
          let:8 a47 = a44[7:0] in
          let:16 a48 = (1 + (a46,a47)) in
          let:8 a49 = M[(a46,a47)] in
          advance (10)
          A := a40;
          SPH := a48[15:8];
          SPL := a48[7:0];
          FlagS := a40[7];
          FlagZ := is_zero(a40);
          FlagA := false;
          FlagP := parity(a40);
          FlagCY := false;
          jump ((a49,a45));
        } else {
          advance (10)
          #0608
          #instruction: CP   27
          let:8 a50 = a32 in
          let:16 a51 = addWithCarry(!false,a50,~27) in
          let:8 a52 = (a50 & 0F) in
          let:8 a53 = (~27 & 0F) in
          let:16 a54 = addWithCarry(!false,a52,a53) in
          advance (7)
          #060A
          #instruction: NOP
          advance (4)
          #060B
          #instruction: JP   NC,0612
          if (!!a51[15:8][0]) {
            advance (10)
            #0612
            #instruction: LD   A,(2073)
            let:8 a55 = M[2073] in
            advance (13)
            #0615
            #instruction: OR   01
            let:8 a56 = a55 in
            let:8 a57 = (01 | a56) in
            advance (7)
            #0617
            #instruction: LD   (2073),A
            let:8 a58 = a57 in
            M[2073] := a58;
            advance (13)
            #061A
            #instruction: RET
            let:8 a59 = SPH in
            let:8 a60 = SPL in
            let:16 a61 = (1 + (a59,a60)) in
            let:8 a62 = M[(a59,a60)] in
            let:8 a63 = a61[15:8] in
            let:8 a64 = a61[7:0] in
            let:16 a65 = (1 + (a63,a64)) in
            let:8 a66 = M[(a63,a64)] in
            advance (10)
            A := a57;
            SPH := a65[15:8];
            SPL := a65[7:0];
            FlagS := a57[7];
            FlagZ := is_zero(a57);
            FlagA := false;
            FlagP := parity(a57);
            FlagCY := false;
            jump ((a66,a62));
          } else {
            advance (10)
            #060E
            #instruction: SUB  A
            let:8 a67 = a32 in
            let:8 a68 = a32 in
            let:16 a69 = addWithCarry(!false,a68,~a67) in
            let:8 a70 = (a68 & 0F) in
            let:8 a71 = (~a67 & 0F) in
            let:16 a72 = addWithCarry(!false,a70,a71) in
            advance (4)
            #060F
            #instruction: LD   (2015),A
            let:8 a73 = a69[7:0] in
            M[2015] := a73;
            advance (13)
            #0612
            #instruction: LD   A,(2073)
            let:8 a74 = M[2073] in
            advance (13)
            #0615
            #instruction: OR   01
            let:8 a75 = a74 in
            let:8 a76 = (01 | a75) in
            advance (7)
            #0617
            #instruction: LD   (2073),A
            let:8 a77 = a76 in
            M[2073] := a77;
            advance (13)
            #061A
            #instruction: RET
            let:8 a78 = SPH in
            let:8 a79 = SPL in
            let:16 a80 = (1 + (a78,a79)) in
            let:8 a81 = M[(a78,a79)] in
            let:8 a82 = a80[15:8] in
            let:8 a83 = a80[7:0] in
            let:16 a84 = (1 + (a82,a83)) in
            let:8 a85 = M[(a82,a83)] in
            advance (10)
            A := a76;
            SPH := a84[15:8];
            SPL := a84[7:0];
            FlagS := a76[7];
            FlagZ := is_zero(a76);
            FlagA := false;
            FlagP := parity(a76);
            FlagCY := false;
            jump ((a85,a81));
          }
        }
      }
    }

0624:

    #0624
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #0625
    #instruction: CP   0C
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~0C) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~0C & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0627
    #instruction: JP   CY,05A5
    if (!a3[15:8][0]) {
      advance (10)
      #05A5
      #instruction: CALL 062F
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 05;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := A8;
      #return-to: 05A8
      advance (17)
      #062F
      #instruction: DEC  C
      let:8 a13 = C in
      let:16 a14 = addWithCarry(!true,a13,~00) in
      let:8 a15 = (a13 & 0F) in
      let:8 a16 = (~00 & 0F) in
      let:16 a17 = addWithCarry(!true,a15,a16) in
      advance (5)
      #0630
      #instruction: LD   A,(2067)
      let:8 a18 = M[2067] in
      advance (13)
      #0633
      #instruction: LD   H,A
      let:8 a19 = a18 in
      advance (5)
      #0634
      #instruction: LD   L,C
      let:8 a20 = a14[7:0] in
      advance (5)
      #0635
      #instruction: LD   D,05
      advance (7)
      #0637
      #instruction: LD   A,(HL)
      let:8 a21 = a19 in
      let:8 a22 = a20 in
      let:8 a23 = M[(a21,a22)] in
      advance (7)
      #0638
      #instruction: AND  A
      let:8 a24 = a23 in
      let:8 a25 = a23 in
      let:8 a26 = (a24 & a25) in
      let:8 a27 = (a24 | a25) in
      advance (4)
      #0639
      #instruction: SCF
      advance (4)
      #063A
      #instruction: RET  NZ
      if (!is_zero(a26)) {
        let:8 a28 = a12[15:8] in
        let:8 a29 = a12[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (11)
        A := a26;
        C := a14[7:0];
        D := 05;
        H := a19;
        L := a20;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := a27[3];
        FlagP := parity(a26);
        FlagCY := true;
        jump ((a35,a31));
      } else {
        advance (5)
        #063B
        #instruction: LD   A,L
        let:8 a36 = a20 in
        advance (5)
        #063C
        #instruction: ADD  0B
        let:8 a37 = a36 in
        let:16 a38 = addWithCarry(false,0B,a37) in
        let:8 a39 = (0B & 0F) in
        let:8 a40 = (a37 & 0F) in
        let:16 a41 = addWithCarry(false,a39,a40) in
        advance (7)
        #063E
        #instruction: LD   L,A
        let:8 a42 = a38[7:0] in
        advance (5)
        #063F
        #instruction: DEC  D
        let:16 a43 = addWithCarry(!true,05,~00) in
        let:8 a44 = (05 & 0F) in
        let:8 a45 = (~00 & 0F) in
        let:16 a46 = addWithCarry(!true,a44,a45) in
        advance (5)
        #0640
        #instruction: JP   NZ,0637
        if (!is_zero(a43[7:0])) {
          advance (10)
          A := a38[7:0];
          C := a14[7:0];
          D := a43[7:0];
          H := a19;
          L := a42;
          SPH := a12[15:8];
          SPL := a12[7:0];
          FlagS := a43[7:0][7];
          FlagZ := is_zero(a43[7:0]);
          FlagA := a46[7:0][4];
          FlagP := parity(a43[7:0]);
          FlagCY := a38[15:8][0];
          jump (0637);
        } else {
          advance (10)
          #0643
          #instruction: RET
          let:8 a47 = a12[15:8] in
          let:8 a48 = a12[7:0] in
          let:16 a49 = (1 + (a47,a48)) in
          let:8 a50 = M[(a47,a48)] in
          let:8 a51 = a49[15:8] in
          let:8 a52 = a49[7:0] in
          let:16 a53 = (1 + (a51,a52)) in
          let:8 a54 = M[(a51,a52)] in
          advance (10)
          A := a38[7:0];
          C := a14[7:0];
          D := a43[7:0];
          H := a19;
          L := a42;
          SPH := a53[15:8];
          SPL := a53[7:0];
          FlagS := a43[7:0][7];
          FlagZ := is_zero(a43[7:0]);
          FlagA := a46[7:0][4];
          FlagP := parity(a43[7:0]);
          FlagCY := a38[15:8][0];
          jump ((a54,a50));
        }
      }
    } else {
      advance (10)
      #062A
      #instruction: LD   C,0B
      advance (7)
      #062C
      #instruction: JP   05A5
      advance (10)
      #05A5
      #instruction: CALL 062F
      let:8 a55 = SPH in
      let:8 a56 = SPL in
      let:16 a57 = (-1 + (a55,a56)) in
      M[a57] := 05;
      let:8 a58 = a57[15:8] in
      let:8 a59 = a57[7:0] in
      let:16 a60 = (-1 + (a58,a59)) in
      M[a60] := A8;
      #return-to: 05A8
      advance (17)
      #062F
      #instruction: DEC  C
      let:16 a61 = addWithCarry(!true,0B,~00) in
      let:8 a62 = (0B & 0F) in
      let:8 a63 = (~00 & 0F) in
      let:16 a64 = addWithCarry(!true,a62,a63) in
      advance (5)
      #0630
      #instruction: LD   A,(2067)
      let:8 a65 = M[2067] in
      advance (13)
      #0633
      #instruction: LD   H,A
      let:8 a66 = a65 in
      advance (5)
      #0634
      #instruction: LD   L,C
      let:8 a67 = a61[7:0] in
      advance (5)
      #0635
      #instruction: LD   D,05
      advance (7)
      #0637
      #instruction: LD   A,(HL)
      let:8 a68 = a66 in
      let:8 a69 = a67 in
      let:8 a70 = M[(a68,a69)] in
      advance (7)
      #0638
      #instruction: AND  A
      let:8 a71 = a70 in
      let:8 a72 = a70 in
      let:8 a73 = (a71 & a72) in
      let:8 a74 = (a71 | a72) in
      advance (4)
      #0639
      #instruction: SCF
      advance (4)
      #063A
      #instruction: RET  NZ
      if (!is_zero(a73)) {
        let:8 a75 = a60[15:8] in
        let:8 a76 = a60[7:0] in
        let:16 a77 = (1 + (a75,a76)) in
        let:8 a78 = M[(a75,a76)] in
        let:8 a79 = a77[15:8] in
        let:8 a80 = a77[7:0] in
        let:16 a81 = (1 + (a79,a80)) in
        let:8 a82 = M[(a79,a80)] in
        advance (11)
        A := a73;
        C := a61[7:0];
        D := 05;
        H := a66;
        L := a67;
        SPH := a81[15:8];
        SPL := a81[7:0];
        FlagS := a73[7];
        FlagZ := is_zero(a73);
        FlagA := a74[3];
        FlagP := parity(a73);
        FlagCY := true;
        jump ((a82,a78));
      } else {
        advance (5)
        #063B
        #instruction: LD   A,L
        let:8 a83 = a67 in
        advance (5)
        #063C
        #instruction: ADD  0B
        let:8 a84 = a83 in
        let:16 a85 = addWithCarry(false,0B,a84) in
        let:8 a86 = (0B & 0F) in
        let:8 a87 = (a84 & 0F) in
        let:16 a88 = addWithCarry(false,a86,a87) in
        advance (7)
        #063E
        #instruction: LD   L,A
        let:8 a89 = a85[7:0] in
        advance (5)
        #063F
        #instruction: DEC  D
        let:16 a90 = addWithCarry(!true,05,~00) in
        let:8 a91 = (05 & 0F) in
        let:8 a92 = (~00 & 0F) in
        let:16 a93 = addWithCarry(!true,a91,a92) in
        advance (5)
        #0640
        #instruction: JP   NZ,0637
        if (!is_zero(a90[7:0])) {
          advance (10)
          A := a85[7:0];
          C := a61[7:0];
          D := a90[7:0];
          H := a66;
          L := a89;
          SPH := a60[15:8];
          SPL := a60[7:0];
          FlagS := a90[7:0][7];
          FlagZ := is_zero(a90[7:0]);
          FlagA := a93[7:0][4];
          FlagP := parity(a90[7:0]);
          FlagCY := a85[15:8][0];
          jump (0637);
        } else {
          advance (10)
          #0643
          #instruction: RET
          let:8 a94 = a60[15:8] in
          let:8 a95 = a60[7:0] in
          let:16 a96 = (1 + (a94,a95)) in
          let:8 a97 = M[(a94,a95)] in
          let:8 a98 = a96[15:8] in
          let:8 a99 = a96[7:0] in
          let:16 a100 = (1 + (a98,a99)) in
          let:8 a101 = M[(a98,a99)] in
          advance (10)
          A := a85[7:0];
          C := a61[7:0];
          D := a90[7:0];
          H := a66;
          L := a89;
          SPH := a100[15:8];
          SPL := a100[7:0];
          FlagS := a90[7:0][7];
          FlagZ := is_zero(a90[7:0]);
          FlagA := a93[7:0][4];
          FlagP := parity(a90[7:0]);
          FlagCY := a85[15:8][0];
          jump ((a101,a97));
        }
      }
    }

0651:

    #0651
    #instruction: LD   HL,1CDC
    advance (10)
    #0654
    #instruction: LD   (2079),HL
    M[2079] := DC;
    M[207A] := 1C;
    advance (16)
    #0657
    #instruction: LD   HL,207C
    advance (10)
    #065A
    #instruction: DEC  (HL)
    let:8 a1 = M[207C] in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    M[207C] := a2[7:0];
    advance (10)
    #065B
    #instruction: DEC  (HL)
    let:8 a6 = M[207C] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    M[207C] := a7[7:0];
    advance (10)
    #065C
    #instruction: DEC  HL
    advance (5)
    #065D
    #instruction: DEC  (HL)
    let:8 a11 = M[207B] in
    let:16 a12 = addWithCarry(!true,a11,~00) in
    let:8 a13 = (a11 & 0F) in
    let:8 a14 = (~00 & 0F) in
    let:16 a15 = addWithCarry(!true,a13,a14) in
    M[207B] := a12[7:0];
    advance (10)
    #065E
    #instruction: DEC  (HL)
    let:8 a16 = M[207B] in
    let:16 a17 = addWithCarry(!true,a16,~00) in
    let:8 a18 = (a16 & 0F) in
    let:8 a19 = (~00 & 0F) in
    let:16 a20 = addWithCarry(!true,a18,a19) in
    M[207B] := a17[7:0];
    advance (10)
    #065F
    #instruction: LD   A,06
    advance (7)
    #0661
    #instruction: LD   (207D),A
    M[207D] := 06;
    advance (13)
    #0664
    #instruction: JP   066C
    advance (10)
    #066C
    #instruction: LD   HL,2079
    advance (10)
    #066F
    #instruction: CALL 1A3B
    let:8 a21 = SPH in
    let:8 a22 = SPL in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := 06;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := 72;
    #return-to: 0672
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    let:8 a27 = M[2079] in
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    let:8 a28 = M[207A] in
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    let:8 a29 = M[207B] in
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    let:8 a30 = M[207C] in
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    let:8 a31 = M[207D] in
    advance (7)
    #1A44
    #instruction: LD   H,C
    let:8 a32 = a30 in
    advance (5)
    #1A45
    #instruction: LD   L,A
    let:8 a33 = a29 in
    advance (5)
    #1A46
    #instruction: RET
    let:8 a34 = a26[15:8] in
    let:8 a35 = a26[7:0] in
    let:16 a36 = (1 + (a34,a35)) in
    let:8 a37 = M[(a34,a35)] in
    let:8 a38 = a36[15:8] in
    let:8 a39 = a36[7:0] in
    let:16 a40 = (1 + (a38,a39)) in
    let:8 a41 = M[(a38,a39)] in
    advance (10)
    A := a29;
    B := a31;
    C := a30;
    D := a28;
    E := a27;
    H := a32;
    L := a33;
    SPH := a40[15:8];
    SPL := a40[7:0];
    FlagS := a17[7:0][7];
    FlagZ := is_zero(a17[7:0]);
    FlagA := a20[7:0][4];
    FlagP := parity(a17[7:0]);
    jump ((a41,a37));

0672:

    #0672
    #instruction: JP   1491
    advance (10)
    #1491
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 94;
    #return-to: 1494
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a7 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a8 = a7 in
    let:8 a9 = (07 & a8) in
    let:8 a10 = (07 | a8) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a11 = a9 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a12 = B in
    let:8 a13 = C in
    let:8 a14 = a6[15:8] in
    let:8 a15 = a6[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a20 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a21 = a20 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a22 = updateBit((a21 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a23 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a24 = a23 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a25 = updateBit((a24 >> 01),7,a21[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a26 = addWithCarry(!true,03,~00) in
    let:8 a27 = (03 & 0F) in
    let:8 a28 = (~00 & 0F) in
    let:16 a29 = addWithCarry(!true,a27,a28) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a26[7:0])) {
      advance (10)
      A := updateBit((a24 >> 01),7,a21[0]);
      B := a26[7:0];
      H := a22;
      L := a25;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a26[7:0][7];
      FlagZ := is_zero(a26[7:0]);
      FlagA := a29[7:0][4];
      FlagP := parity(a26[7:0]);
      FlagCY := a24[0];
      Shifter_OFF := a11;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a30 = a22 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a31 = a30 in
      let:8 a32 = (3F & a31) in
      let:8 a33 = (3F | a31) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a34 = a32 in
      let:8 a35 = (20 | a34) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a36 = a35 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a37 = a19[15:8] in
      let:8 a38 = a19[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      advance (10)
      A := a35;
      B := a44;
      C := a40;
      H := a36;
      L := a25;
      SPH := a51[15:8];
      SPL := a51[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := false;
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_OFF := a11;
      jump ((a52,a48));
    }

067B:

    #067B
    #instruction: JP   1452
    advance (10)
    #1452
    #instruction: CALL 1474
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 14;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 55;
    #return-to: 1455
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a7 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a8 = a7 in
    let:8 a9 = (07 & a8) in
    let:8 a10 = (07 | a8) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a11 = a9 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a12 = B in
    let:8 a13 = C in
    let:8 a14 = a6[15:8] in
    let:8 a15 = a6[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a20 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a21 = a20 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a22 = updateBit((a21 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a23 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a24 = a23 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a25 = updateBit((a24 >> 01),7,a21[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a26 = addWithCarry(!true,03,~00) in
    let:8 a27 = (03 & 0F) in
    let:8 a28 = (~00 & 0F) in
    let:16 a29 = addWithCarry(!true,a27,a28) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a26[7:0])) {
      advance (10)
      A := updateBit((a24 >> 01),7,a21[0]);
      B := a26[7:0];
      H := a22;
      L := a25;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a26[7:0][7];
      FlagZ := is_zero(a26[7:0]);
      FlagA := a29[7:0][4];
      FlagP := parity(a26[7:0]);
      FlagCY := a24[0];
      Shifter_OFF := a11;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a30 = a22 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a31 = a30 in
      let:8 a32 = (3F & a31) in
      let:8 a33 = (3F | a31) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a34 = a32 in
      let:8 a35 = (20 | a34) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a36 = a35 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a37 = a19[15:8] in
      let:8 a38 = a19[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      advance (10)
      A := a35;
      B := a44;
      C := a40;
      H := a36;
      L := a25;
      SPH := a51[15:8];
      SPL := a51[7:0];
      FlagS := a35[7];
      FlagZ := is_zero(a35);
      FlagA := false;
      FlagP := parity(a35);
      FlagCY := false;
      Shifter_OFF := a11;
      jump ((a52,a48));
    }

0682:

    #0682
    #instruction: POP  HL
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0683
    #instruction: LD   A,(2080)
    let:8 a9 = M[2080] in
    advance (13)
    #0686
    #instruction: CP   02
    let:8 a10 = a9 in
    let:16 a11 = addWithCarry(!false,a10,~02) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~02 & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #0688
    #instruction: RET  NZ
    if (!is_zero(a11[7:0])) {
      let:8 a15 = a7[15:8] in
      let:8 a16 = a7[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a9;
      H := a8;
      L := a4;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := !a11[15:8][0];
      jump ((a22,a18));
    } else {
      advance (5)
      #0689
      #instruction: LD   HL,2083
      advance (10)
      #068C
      #instruction: LD   A,(HL)
      let:8 a23 = M[2083] in
      advance (7)
      #068D
      #instruction: AND  A
      let:8 a24 = a23 in
      let:8 a25 = a23 in
      let:8 a26 = (a24 & a25) in
      let:8 a27 = (a24 | a25) in
      advance (4)
      #068E
      #instruction: JP   Z,050F
      if (is_zero(a26)) {
        advance (10)
        #050F
        #instruction: LD   DE,2055
        advance (10)
        #0512
        #instruction: LD   A,DB
        advance (7)
        #0514
        #instruction: CALL 0550
        let:8 a28 = a7[15:8] in
        let:8 a29 = a7[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 05;
        let:8 a31 = a30[15:8] in
        let:8 a32 = a30[7:0] in
        let:16 a33 = (-1 + (a31,a32)) in
        M[a33] := 17;
        #return-to: 0517
        advance (17)
        #0550
        #instruction: LD   (207F),A
        M[207F] := DB;
        advance (13)
        #0553
        #instruction: LD   HL,2073
        advance (10)
        #0556
        #instruction: LD   B,0B
        advance (7)
        #0558
        #instruction: JP   1A32
        advance (10)
        #1A32
        #instruction: LD   A,(DE)
        let:8 a34 = M[2055] in
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        let:8 a35 = a34 in
        M[2073] := a35;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a36 = addWithCarry(!true,0B,~00) in
        let:8 a37 = (0B & 0F) in
        let:8 a38 = (~00 & 0F) in
        let:16 a39 = addWithCarry(!true,a37,a38) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a36[7:0])) {
          advance (10)
          A := a34;
          B := a36[7:0];
          D := 20;
          E := 56;
          H := 20;
          L := 74;
          SPH := a33[15:8];
          SPL := a33[7:0];
          FlagS := a36[7:0][7];
          FlagZ := is_zero(a36[7:0]);
          FlagA := a39[7:0][4];
          FlagP := parity(a36[7:0]);
          FlagCY := false;
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a40 = a33[15:8] in
          let:8 a41 = a33[7:0] in
          let:16 a42 = (1 + (a40,a41)) in
          let:8 a43 = M[(a40,a41)] in
          let:8 a44 = a42[15:8] in
          let:8 a45 = a42[7:0] in
          let:16 a46 = (1 + (a44,a45)) in
          let:8 a47 = M[(a44,a45)] in
          advance (10)
          A := a34;
          B := a36[7:0];
          D := 20;
          E := 56;
          H := 20;
          L := 74;
          SPH := a46[15:8];
          SPL := a46[7:0];
          FlagS := a36[7:0][7];
          FlagZ := is_zero(a36[7:0]);
          FlagA := a39[7:0][4];
          FlagP := parity(a36[7:0]);
          FlagCY := false;
          jump ((a47,a43));
        }
      } else {
        advance (10)
        #0691
        #instruction: LD   A,(2056)
        let:8 a48 = M[2056] in
        advance (13)
        #0694
        #instruction: AND  A
        let:8 a49 = a48 in
        let:8 a50 = a48 in
        let:8 a51 = (a49 & a50) in
        let:8 a52 = (a49 | a50) in
        advance (4)
        #0695
        #instruction: JP   NZ,050F
        if (!is_zero(a51)) {
          advance (10)
          #050F
          #instruction: LD   DE,2055
          advance (10)
          #0512
          #instruction: LD   A,DB
          advance (7)
          #0514
          #instruction: CALL 0550
          let:8 a53 = a7[15:8] in
          let:8 a54 = a7[7:0] in
          let:16 a55 = (-1 + (a53,a54)) in
          M[a55] := 05;
          let:8 a56 = a55[15:8] in
          let:8 a57 = a55[7:0] in
          let:16 a58 = (-1 + (a56,a57)) in
          M[a58] := 17;
          #return-to: 0517
          advance (17)
          #0550
          #instruction: LD   (207F),A
          M[207F] := DB;
          advance (13)
          #0553
          #instruction: LD   HL,2073
          advance (10)
          #0556
          #instruction: LD   B,0B
          advance (7)
          #0558
          #instruction: JP   1A32
          advance (10)
          #1A32
          #instruction: LD   A,(DE)
          let:8 a59 = M[2055] in
          advance (7)
          #1A33
          #instruction: LD   (HL),A
          let:8 a60 = a59 in
          M[2073] := a60;
          advance (7)
          #1A34
          #instruction: INC  HL
          advance (5)
          #1A35
          #instruction: INC  DE
          advance (5)
          #1A36
          #instruction: DEC  B
          let:16 a61 = addWithCarry(!true,0B,~00) in
          let:8 a62 = (0B & 0F) in
          let:8 a63 = (~00 & 0F) in
          let:16 a64 = addWithCarry(!true,a62,a63) in
          advance (5)
          #1A37
          #instruction: JP   NZ,1A32
          if (!is_zero(a61[7:0])) {
            advance (10)
            A := a59;
            B := a61[7:0];
            D := 20;
            E := 56;
            H := 20;
            L := 74;
            SPH := a58[15:8];
            SPL := a58[7:0];
            FlagS := a61[7:0][7];
            FlagZ := is_zero(a61[7:0]);
            FlagA := a64[7:0][4];
            FlagP := parity(a61[7:0]);
            FlagCY := false;
            jump (1A32);
          } else {
            advance (10)
            #1A3A
            #instruction: RET
            let:8 a65 = a58[15:8] in
            let:8 a66 = a58[7:0] in
            let:16 a67 = (1 + (a65,a66)) in
            let:8 a68 = M[(a65,a66)] in
            let:8 a69 = a67[15:8] in
            let:8 a70 = a67[7:0] in
            let:16 a71 = (1 + (a69,a70)) in
            let:8 a72 = M[(a69,a70)] in
            advance (10)
            A := a59;
            B := a61[7:0];
            D := 20;
            E := 56;
            H := 20;
            L := 74;
            SPH := a71[15:8];
            SPL := a71[7:0];
            FlagS := a61[7:0][7];
            FlagZ := is_zero(a61[7:0]);
            FlagA := a64[7:0][4];
            FlagP := parity(a61[7:0]);
            FlagCY := false;
            jump ((a72,a68));
          }
        } else {
          advance (10)
          #0698
          #instruction: INC  HL
          advance (5)
          #0699
          #instruction: LD   A,(HL)
          let:8 a73 = M[2084] in
          advance (7)
          #069A
          #instruction: AND  A
          let:8 a74 = a73 in
          let:8 a75 = a73 in
          let:8 a76 = (a74 & a75) in
          let:8 a77 = (a74 | a75) in
          advance (4)
          #069B
          #instruction: JP   NZ,06AB
          if (!is_zero(a76)) {
            advance (10)
            A := a76;
            H := 20;
            L := 84;
            SPH := a7[15:8];
            SPL := a7[7:0];
            FlagS := a76[7];
            FlagZ := is_zero(a76);
            FlagA := a77[3];
            FlagP := parity(a76);
            FlagCY := false;
            jump (06AB);
          } else {
            advance (10)
            #069E
            #instruction: LD   A,(2082)
            let:8 a78 = M[2082] in
            advance (13)
            #06A1
            #instruction: CP   08
            let:8 a79 = a78 in
            let:16 a80 = addWithCarry(!false,a79,~08) in
            let:8 a81 = (a79 & 0F) in
            let:8 a82 = (~08 & 0F) in
            let:16 a83 = addWithCarry(!false,a81,a82) in
            advance (7)
            #06A3
            #instruction: JP   CY,050F
            if (!a80[15:8][0]) {
              advance (10)
              #050F
              #instruction: LD   DE,2055
              advance (10)
              #0512
              #instruction: LD   A,DB
              advance (7)
              #0514
              #instruction: CALL 0550
              let:8 a84 = a7[15:8] in
              let:8 a85 = a7[7:0] in
              let:16 a86 = (-1 + (a84,a85)) in
              M[a86] := 05;
              let:8 a87 = a86[15:8] in
              let:8 a88 = a86[7:0] in
              let:16 a89 = (-1 + (a87,a88)) in
              M[a89] := 17;
              #return-to: 0517
              advance (17)
              #0550
              #instruction: LD   (207F),A
              M[207F] := DB;
              advance (13)
              #0553
              #instruction: LD   HL,2073
              advance (10)
              #0556
              #instruction: LD   B,0B
              advance (7)
              #0558
              #instruction: JP   1A32
              advance (10)
              #1A32
              #instruction: LD   A,(DE)
              let:8 a90 = M[2055] in
              advance (7)
              #1A33
              #instruction: LD   (HL),A
              let:8 a91 = a90 in
              M[2073] := a91;
              advance (7)
              #1A34
              #instruction: INC  HL
              advance (5)
              #1A35
              #instruction: INC  DE
              advance (5)
              #1A36
              #instruction: DEC  B
              let:16 a92 = addWithCarry(!true,0B,~00) in
              let:8 a93 = (0B & 0F) in
              let:8 a94 = (~00 & 0F) in
              let:16 a95 = addWithCarry(!true,a93,a94) in
              advance (5)
              #1A37
              #instruction: JP   NZ,1A32
              if (!is_zero(a92[7:0])) {
                advance (10)
                A := a90;
                B := a92[7:0];
                D := 20;
                E := 56;
                H := 20;
                L := 74;
                SPH := a89[15:8];
                SPL := a89[7:0];
                FlagS := a92[7:0][7];
                FlagZ := is_zero(a92[7:0]);
                FlagA := a95[7:0][4];
                FlagP := parity(a92[7:0]);
                FlagCY := !a80[15:8][0];
                jump (1A32);
              } else {
                advance (10)
                #1A3A
                #instruction: RET
                let:8 a96 = a89[15:8] in
                let:8 a97 = a89[7:0] in
                let:16 a98 = (1 + (a96,a97)) in
                let:8 a99 = M[(a96,a97)] in
                let:8 a100 = a98[15:8] in
                let:8 a101 = a98[7:0] in
                let:16 a102 = (1 + (a100,a101)) in
                let:8 a103 = M[(a100,a101)] in
                advance (10)
                A := a90;
                B := a92[7:0];
                D := 20;
                E := 56;
                H := 20;
                L := 74;
                SPH := a102[15:8];
                SPL := a102[7:0];
                FlagS := a92[7:0][7];
                FlagZ := is_zero(a92[7:0]);
                FlagA := a95[7:0][4];
                FlagP := parity(a92[7:0]);
                FlagCY := !a80[15:8][0];
                jump ((a103,a99));
              }
            } else {
              advance (10)
              #06A6
              #instruction: LD   (HL),01
              M[2084] := 01;
              advance (10)
              #06A8
              #instruction: CALL 073C
              let:8 a104 = a7[15:8] in
              let:8 a105 = a7[7:0] in
              let:16 a106 = (-1 + (a104,a105)) in
              M[a106] := 06;
              let:8 a107 = a106[15:8] in
              let:8 a108 = a106[7:0] in
              let:16 a109 = (-1 + (a107,a108)) in
              M[a109] := AB;
              #return-to: 06AB
              advance (17)
              #073C
              #instruction: CALL 0742
              let:8 a110 = a109[15:8] in
              let:8 a111 = a109[7:0] in
              let:16 a112 = (-1 + (a110,a111)) in
              M[a112] := 07;
              let:8 a113 = a112[15:8] in
              let:8 a114 = a112[7:0] in
              let:16 a115 = (-1 + (a113,a114)) in
              M[a115] := 3F;
              #return-to: 073F
              advance (17)
              #0742
              #instruction: LD   HL,2087
              advance (10)
              #0745
              #instruction: CALL 1A3B
              let:8 a116 = a115[15:8] in
              let:8 a117 = a115[7:0] in
              let:16 a118 = (-1 + (a116,a117)) in
              M[a118] := 07;
              let:8 a119 = a118[15:8] in
              let:8 a120 = a118[7:0] in
              let:16 a121 = (-1 + (a119,a120)) in
              M[a121] := 48;
              #return-to: 0748
              advance (17)
              #1A3B
              #instruction: LD   E,(HL)
              let:8 a122 = M[2087] in
              advance (7)
              #1A3C
              #instruction: INC  HL
              advance (5)
              #1A3D
              #instruction: LD   D,(HL)
              let:8 a123 = M[2088] in
              advance (7)
              #1A3E
              #instruction: INC  HL
              advance (5)
              #1A3F
              #instruction: LD   A,(HL)
              let:8 a124 = M[2089] in
              advance (7)
              #1A40
              #instruction: INC  HL
              advance (5)
              #1A41
              #instruction: LD   C,(HL)
              let:8 a125 = M[208A] in
              advance (7)
              #1A42
              #instruction: INC  HL
              advance (5)
              #1A43
              #instruction: LD   B,(HL)
              let:8 a126 = M[208B] in
              advance (7)
              #1A44
              #instruction: LD   H,C
              let:8 a127 = a125 in
              advance (5)
              #1A45
              #instruction: LD   L,A
              let:8 a128 = a124 in
              advance (5)
              #1A46
              #instruction: RET
              let:8 a129 = a121[15:8] in
              let:8 a130 = a121[7:0] in
              let:16 a131 = (1 + (a129,a130)) in
              let:8 a132 = M[(a129,a130)] in
              let:8 a133 = a131[15:8] in
              let:8 a134 = a131[7:0] in
              let:16 a135 = (1 + (a133,a134)) in
              let:8 a136 = M[(a133,a134)] in
              advance (10)
              A := a124;
              B := a126;
              C := a125;
              D := a123;
              E := a122;
              H := a127;
              L := a128;
              SPH := a135[15:8];
              SPL := a135[7:0];
              FlagS := a80[7:0][7];
              FlagZ := is_zero(a80[7:0]);
              FlagA := a83[7:0][4];
              FlagP := parity(a80[7:0]);
              FlagCY := !a80[15:8][0];
              jump ((a136,a132));
            }
          }
        }
      }
    }

06AB:

    #06AB
    #instruction: LD   DE,208A
    advance (10)
    #06AE
    #instruction: CALL 1A06
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B1;
    #return-to: 06B1
    advance (17)
    #1A06
    #instruction: LD   HL,2072
    advance (10)
    #1A09
    #instruction: LD   B,(HL)
    let:8 a7 = M[2072] in
    advance (7)
    #1A0A
    #instruction: LD   A,(DE)
    let:8 a8 = M[208A] in
    advance (7)
    #1A0B
    #instruction: AND  80
    let:8 a9 = a8 in
    let:8 a10 = (80 & a9) in
    let:8 a11 = (80 | a9) in
    advance (7)
    #1A0D
    #instruction: XOR  B
    let:8 a12 = a7 in
    let:8 a13 = a10 in
    let:8 a14 = (a12 ^ a13) in
    advance (4)
    #1A0E
    #instruction: RET  NZ
    if (!is_zero(a14)) {
      let:8 a15 = a6[15:8] in
      let:8 a16 = a6[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a14;
      B := a7;
      D := 20;
      E := 8A;
      H := 20;
      L := 72;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a22,a18));
    } else {
      advance (5)
      #1A0F
      #instruction: SCF
      advance (4)
      #1A10
      #instruction: RET
      let:8 a23 = a6[15:8] in
      let:8 a24 = a6[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := a14;
      B := a7;
      D := 20;
      E := 8A;
      H := 20;
      L := 72;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := true;
      jump ((a30,a26));
    }

06B1:

    #06B1
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #06B2
      #instruction: LD   HL,2085
      advance (10)
      #06B5
      #instruction: LD   A,(HL)
      let:8 a9 = M[2085] in
      advance (7)
      #06B6
      #instruction: AND  A
      let:8 a10 = a9 in
      let:8 a11 = a9 in
      let:8 a12 = (a10 & a11) in
      let:8 a13 = (a10 | a11) in
      advance (4)
      #06B7
      #instruction: JP   NZ,06D6
      if (!is_zero(a12)) {
        advance (10)
        #06D6
        #instruction: LD   B,FE
        advance (7)
        #06D8
        #instruction: CALL 19DC
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (-1 + (a14,a15)) in
        M[a16] := 06;
        let:8 a17 = a16[15:8] in
        let:8 a18 = a16[7:0] in
        let:16 a19 = (-1 + (a17,a18)) in
        M[a19] := DB;
        #return-to: 06DB
        advance (17)
        #19DC
        #instruction: LD   A,(2094)
        let:8 a20 = M[2094] in
        advance (13)
        #19DF
        #instruction: AND  B
        let:8 a21 = a20 in
        let:8 a22 = (FE & a21) in
        let:8 a23 = (FE | a21) in
        advance (4)
        #19E0
        #instruction: LD   (2094),A
        let:8 a24 = a22 in
        M[2094] := a24;
        advance (13)
        #19E3
        #instruction: OUT  03
        let:8 a25 = a22 in
        sound_control(Ufo,a25[0]);
        sound_control(Shot,a25[1]);
        sound_control(PlayerDie,a25[2]);
        sound_control(InvaderDie,a25[3]);
        sound_control(ExtraLife,a25[4]);
        advance (10)
        #19E5
        #instruction: RET
        let:8 a26 = a19[15:8] in
        let:8 a27 = a19[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        advance (10)
        A := a22;
        B := FE;
        H := 20;
        L := 85;
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a22[7];
        FlagZ := is_zero(a22);
        FlagA := a23[3];
        FlagP := parity(a22);
        FlagCY := false;
        jump ((a33,a29));
      } else {
        advance (10)
        #06BA
        #instruction: LD   HL,208A
        advance (10)
        #06BD
        #instruction: LD   A,(HL)
        let:8 a34 = M[208A] in
        advance (7)
        #06BE
        #instruction: INC  HL
        advance (5)
        #06BF
        #instruction: INC  HL
        advance (5)
        #06C0
        #instruction: ADD  (HL)
        let:8 a35 = M[208C] in
        let:8 a36 = a34 in
        let:16 a37 = addWithCarry(false,a35,a36) in
        let:8 a38 = (a35 & 0F) in
        let:8 a39 = (a36 & 0F) in
        let:16 a40 = addWithCarry(false,a38,a39) in
        advance (7)
        #06C1
        #instruction: LD   (208A),A
        let:8 a41 = a37[7:0] in
        M[208A] := a41;
        advance (13)
        #06C4
        #instruction: CALL 073C
        let:8 a42 = SPH in
        let:8 a43 = SPL in
        let:16 a44 = (-1 + (a42,a43)) in
        M[a44] := 06;
        let:8 a45 = a44[15:8] in
        let:8 a46 = a44[7:0] in
        let:16 a47 = (-1 + (a45,a46)) in
        M[a47] := C7;
        #return-to: 06C7
        advance (17)
        #073C
        #instruction: CALL 0742
        let:8 a48 = a47[15:8] in
        let:8 a49 = a47[7:0] in
        let:16 a50 = (-1 + (a48,a49)) in
        M[a50] := 07;
        let:8 a51 = a50[15:8] in
        let:8 a52 = a50[7:0] in
        let:16 a53 = (-1 + (a51,a52)) in
        M[a53] := 3F;
        #return-to: 073F
        advance (17)
        #0742
        #instruction: LD   HL,2087
        advance (10)
        #0745
        #instruction: CALL 1A3B
        let:8 a54 = a53[15:8] in
        let:8 a55 = a53[7:0] in
        let:16 a56 = (-1 + (a54,a55)) in
        M[a56] := 07;
        let:8 a57 = a56[15:8] in
        let:8 a58 = a56[7:0] in
        let:16 a59 = (-1 + (a57,a58)) in
        M[a59] := 48;
        #return-to: 0748
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a60 = M[2087] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a61 = M[2088] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a62 = M[2089] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a63 = M[208A] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a64 = M[208B] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a65 = a63 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a66 = a62 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a67 = a59[15:8] in
        let:8 a68 = a59[7:0] in
        let:16 a69 = (1 + (a67,a68)) in
        let:8 a70 = M[(a67,a68)] in
        let:8 a71 = a69[15:8] in
        let:8 a72 = a69[7:0] in
        let:16 a73 = (1 + (a71,a72)) in
        let:8 a74 = M[(a71,a72)] in
        advance (10)
        A := a62;
        B := a64;
        C := a63;
        D := a61;
        E := a60;
        H := a65;
        L := a66;
        SPH := a73[15:8];
        SPL := a73[7:0];
        FlagS := a37[7:0][7];
        FlagZ := is_zero(a37[7:0]);
        FlagA := a40[7:0][4];
        FlagP := parity(a37[7:0]);
        FlagCY := a37[15:8][0];
        jump ((a74,a70));
      }
    }

06C7:

    #06C7
    #instruction: LD   HL,208A
    advance (10)
    #06CA
    #instruction: LD   A,(HL)
    let:8 a1 = M[208A] in
    advance (7)
    #06CB
    #instruction: CP   28
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~28) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~28 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #06CD
    #instruction: JP   CY,06F9
    if (!a3[15:8][0]) {
      advance (10)
      #06F9
      #instruction: CALL 0742
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 06;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := FC;
      #return-to: 06FC
      advance (17)
      #0742
      #instruction: LD   HL,2087
      advance (10)
      #0745
      #instruction: CALL 1A3B
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 07;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := 48;
      #return-to: 0748
      advance (17)
      #1A3B
      #instruction: LD   E,(HL)
      let:8 a19 = M[2087] in
      advance (7)
      #1A3C
      #instruction: INC  HL
      advance (5)
      #1A3D
      #instruction: LD   D,(HL)
      let:8 a20 = M[2088] in
      advance (7)
      #1A3E
      #instruction: INC  HL
      advance (5)
      #1A3F
      #instruction: LD   A,(HL)
      let:8 a21 = M[2089] in
      advance (7)
      #1A40
      #instruction: INC  HL
      advance (5)
      #1A41
      #instruction: LD   C,(HL)
      let:8 a22 = M[208A] in
      advance (7)
      #1A42
      #instruction: INC  HL
      advance (5)
      #1A43
      #instruction: LD   B,(HL)
      let:8 a23 = M[208B] in
      advance (7)
      #1A44
      #instruction: LD   H,C
      let:8 a24 = a22 in
      advance (5)
      #1A45
      #instruction: LD   L,A
      let:8 a25 = a21 in
      advance (5)
      #1A46
      #instruction: RET
      let:8 a26 = a18[15:8] in
      let:8 a27 = a18[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      let:8 a30 = a28[15:8] in
      let:8 a31 = a28[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      let:8 a33 = M[(a30,a31)] in
      advance (10)
      A := a21;
      B := a23;
      C := a22;
      D := a20;
      E := a19;
      H := a24;
      L := a25;
      SPH := a32[15:8];
      SPL := a32[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a33,a29));
    } else {
      advance (10)
      #06D0
      #instruction: CP   E1
      let:8 a34 = a1 in
      let:16 a35 = addWithCarry(!false,a34,~E1) in
      let:8 a36 = (a34 & 0F) in
      let:8 a37 = (~E1 & 0F) in
      let:16 a38 = addWithCarry(!false,a36,a37) in
      advance (7)
      #06D2
      #instruction: JP   NC,06F9
      if (!!a35[15:8][0]) {
        advance (10)
        #06F9
        #instruction: CALL 0742
        let:8 a39 = SPH in
        let:8 a40 = SPL in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := 06;
        let:8 a42 = a41[15:8] in
        let:8 a43 = a41[7:0] in
        let:16 a44 = (-1 + (a42,a43)) in
        M[a44] := FC;
        #return-to: 06FC
        advance (17)
        #0742
        #instruction: LD   HL,2087
        advance (10)
        #0745
        #instruction: CALL 1A3B
        let:8 a45 = a44[15:8] in
        let:8 a46 = a44[7:0] in
        let:16 a47 = (-1 + (a45,a46)) in
        M[a47] := 07;
        let:8 a48 = a47[15:8] in
        let:8 a49 = a47[7:0] in
        let:16 a50 = (-1 + (a48,a49)) in
        M[a50] := 48;
        #return-to: 0748
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a51 = M[2087] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a52 = M[2088] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a53 = M[2089] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a54 = M[208A] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a55 = M[208B] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a56 = a54 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a57 = a53 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a58 = a50[15:8] in
        let:8 a59 = a50[7:0] in
        let:16 a60 = (1 + (a58,a59)) in
        let:8 a61 = M[(a58,a59)] in
        let:8 a62 = a60[15:8] in
        let:8 a63 = a60[7:0] in
        let:16 a64 = (1 + (a62,a63)) in
        let:8 a65 = M[(a62,a63)] in
        advance (10)
        A := a53;
        B := a55;
        C := a54;
        D := a52;
        E := a51;
        H := a56;
        L := a57;
        SPH := a64[15:8];
        SPL := a64[7:0];
        FlagS := a35[7:0][7];
        FlagZ := is_zero(a35[7:0]);
        FlagA := a38[7:0][4];
        FlagP := parity(a35[7:0]);
        FlagCY := !a35[15:8][0];
        jump ((a65,a61));
      } else {
        advance (10)
        #06D5
        #instruction: RET
        let:8 a66 = SPH in
        let:8 a67 = SPL in
        let:16 a68 = (1 + (a66,a67)) in
        let:8 a69 = M[(a66,a67)] in
        let:8 a70 = a68[15:8] in
        let:8 a71 = a68[7:0] in
        let:16 a72 = (1 + (a70,a71)) in
        let:8 a73 = M[(a70,a71)] in
        advance (10)
        A := a1;
        H := 20;
        L := 8A;
        SPH := a72[15:8];
        SPL := a72[7:0];
        FlagS := a35[7:0][7];
        FlagZ := is_zero(a35[7:0]);
        FlagA := a38[7:0][4];
        FlagP := parity(a35[7:0]);
        FlagCY := !a35[15:8][0];
        jump ((a73,a69));
      }
    }

06DB:

    #06DB
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #06DC
    #instruction: DEC  (HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    let:8 a11 = a3[15:8] in
    let:8 a12 = a3[7:0] in
    M[(a11,a12)] := a7[7:0];
    advance (10)
    #06DD
    #instruction: LD   A,(HL)
    let:8 a13 = a3[15:8] in
    let:8 a14 = a3[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #06DE
    #instruction: CP   1F
    let:8 a16 = a15 in
    let:16 a17 = addWithCarry(!false,a16,~1F) in
    let:8 a18 = (a16 & 0F) in
    let:8 a19 = (~1F & 0F) in
    let:16 a20 = addWithCarry(!false,a18,a19) in
    advance (7)
    #06E0
    #instruction: JP   Z,074B
    if (is_zero(a17[7:0])) {
      advance (10)
      #074B
      #instruction: LD   B,10
      advance (7)
      #074D
      #instruction: LD   HL,2098
      advance (10)
      #0750
      #instruction: LD   A,(HL)
      let:8 a21 = M[2098] in
      advance (7)
      #0751
      #instruction: OR   B
      let:8 a22 = a21 in
      let:8 a23 = (10 | a22) in
      advance (4)
      #0752
      #instruction: LD   (HL),A
      let:8 a24 = a23 in
      M[2098] := a24;
      advance (7)
      #0753
      #instruction: CALL 1770
      let:8 a25 = SPH in
      let:8 a26 = SPL in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 07;
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 56;
      #return-to: 0756
      advance (17)
      #1770
      #instruction: AND  30
      let:8 a31 = a23 in
      let:8 a32 = (30 & a31) in
      let:8 a33 = (30 | a31) in
      advance (7)
      #1772
      #instruction: OUT  05
      let:8 a34 = a32 in
      sound_control(FleetMovement1,a34[0]);
      sound_control(FleetMovement2,a34[1]);
      sound_control(FleetMovement3,a34[2]);
      sound_control(FleetMovement4,a34[3]);
      sound_control(UfoHit,a34[4]);
      advance (10)
      #1774
      #instruction: RET
      let:8 a35 = a30[15:8] in
      let:8 a36 = a30[7:0] in
      let:16 a37 = (1 + (a35,a36)) in
      let:8 a38 = M[(a35,a36)] in
      let:8 a39 = a37[15:8] in
      let:8 a40 = a37[7:0] in
      let:16 a41 = (1 + (a39,a40)) in
      let:8 a42 = M[(a39,a40)] in
      advance (10)
      A := a32;
      B := 10;
      H := 20;
      L := 98;
      SPH := a41[15:8];
      SPL := a41[7:0];
      FlagS := a32[7];
      FlagZ := is_zero(a32);
      FlagA := a33[3];
      FlagP := parity(a32);
      FlagCY := false;
      jump ((a42,a38));
    } else {
      advance (10)
      #06E3
      #instruction: CP   18
      let:8 a43 = a15 in
      let:16 a44 = addWithCarry(!false,a43,~18) in
      let:8 a45 = (a43 & 0F) in
      let:8 a46 = (~18 & 0F) in
      let:16 a47 = addWithCarry(!false,a45,a46) in
      advance (7)
      #06E5
      #instruction: JP   Z,070C
      if (is_zero(a44[7:0])) {
        advance (10)
        #070C
        #instruction: LD   A,01
        advance (7)
        #070E
        #instruction: LD   (20F1),A
        M[20F1] := 01;
        advance (13)
        #0711
        #instruction: LD   HL,(208D)
        let:8 a48 = M[208D] in
        let:8 a49 = M[208E] in
        advance (16)
        #0714
        #instruction: LD   B,(HL)
        let:8 a50 = a49 in
        let:8 a51 = a48 in
        let:8 a52 = M[(a50,a51)] in
        advance (7)
        #0715
        #instruction: LD   C,04
        advance (7)
        #0717
        #instruction: LD   HL,1D50
        advance (10)
        #071A
        #instruction: LD   DE,1D4C
        advance (10)
        #071D
        #instruction: LD   A,(DE)
        advance (7)
        #071E
        #instruction: CP   B
        let:8 a53 = a52 in
        let:16 a54 = addWithCarry(!false,05,~a53) in
        let:8 a55 = (05 & 0F) in
        let:8 a56 = (~a53 & 0F) in
        let:16 a57 = addWithCarry(!false,a55,a56) in
        advance (4)
        #071F
        #instruction: JP   Z,0728
        if (is_zero(a54[7:0])) {
          advance (10)
          #0728
          #instruction: LD   A,(HL)
          advance (7)
          #0729
          #instruction: LD   (2087),A
          M[2087] := 94;
          advance (13)
          #072C
          #instruction: LD   H,00
          advance (7)
          #072E
          #instruction: LD   L,B
          let:8 a58 = a52 in
          advance (5)
          #072F
          #instruction: ADD  HL,HL
          let:8 a59 = a58 in
          let:8 a60 = a58 in
          let:17 a61 = add17((00,a59),(00,a60)) in
          advance (10)
          #0730
          #instruction: ADD  HL,HL
          let:8 a62 = a61[15:0][15:8] in
          let:8 a63 = a61[15:0][7:0] in
          let:8 a64 = a61[15:0][15:8] in
          let:8 a65 = a61[15:0][7:0] in
          let:17 a66 = add17((a62,a63),(a64,a65)) in
          advance (10)
          #0731
          #instruction: ADD  HL,HL
          let:8 a67 = a66[15:0][15:8] in
          let:8 a68 = a66[15:0][7:0] in
          let:8 a69 = a66[15:0][15:8] in
          let:8 a70 = a66[15:0][7:0] in
          let:17 a71 = add17((a67,a68),(a69,a70)) in
          advance (10)
          #0732
          #instruction: ADD  HL,HL
          let:8 a72 = a71[15:0][15:8] in
          let:8 a73 = a71[15:0][7:0] in
          let:8 a74 = a71[15:0][15:8] in
          let:8 a75 = a71[15:0][7:0] in
          let:17 a76 = add17((a72,a73),(a74,a75)) in
          advance (10)
          #0733
          #instruction: LD   (20F2),HL
          let:8 a77 = a76[15:0][7:0] in
          M[20F2] := a77;
          let:8 a78 = a76[15:0][15:8] in
          M[20F3] := a78;
          advance (16)
          #0736
          #instruction: CALL 0742
          let:8 a79 = SPH in
          let:8 a80 = SPL in
          let:16 a81 = (-1 + (a79,a80)) in
          M[a81] := 07;
          let:8 a82 = a81[15:8] in
          let:8 a83 = a81[7:0] in
          let:16 a84 = (-1 + (a82,a83)) in
          M[a84] := 39;
          #return-to: 0739
          advance (17)
          #0742
          #instruction: LD   HL,2087
          advance (10)
          #0745
          #instruction: CALL 1A3B
          let:8 a85 = a84[15:8] in
          let:8 a86 = a84[7:0] in
          let:16 a87 = (-1 + (a85,a86)) in
          M[a87] := 07;
          let:8 a88 = a87[15:8] in
          let:8 a89 = a87[7:0] in
          let:16 a90 = (-1 + (a88,a89)) in
          M[a90] := 48;
          #return-to: 0748
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a91 = M[2087] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a92 = M[2088] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a93 = M[2089] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a94 = M[208A] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a95 = M[208B] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a96 = a94 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a97 = a93 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a98 = a90[15:8] in
          let:8 a99 = a90[7:0] in
          let:16 a100 = (1 + (a98,a99)) in
          let:8 a101 = M[(a98,a99)] in
          let:8 a102 = a100[15:8] in
          let:8 a103 = a100[7:0] in
          let:16 a104 = (1 + (a102,a103)) in
          let:8 a105 = M[(a102,a103)] in
          advance (10)
          A := a93;
          B := a95;
          C := a94;
          D := a92;
          E := a91;
          H := a96;
          L := a97;
          SPH := a104[15:8];
          SPL := a104[7:0];
          FlagS := a54[7:0][7];
          FlagZ := is_zero(a54[7:0]);
          FlagA := a57[7:0][4];
          FlagP := parity(a54[7:0]);
          FlagCY := a76[16];
          jump ((a105,a101));
        } else {
          advance (10)
          #0722
          #instruction: INC  HL
          advance (5)
          #0723
          #instruction: INC  DE
          advance (5)
          #0724
          #instruction: DEC  C
          let:16 a106 = addWithCarry(!true,04,~00) in
          let:8 a107 = (04 & 0F) in
          let:8 a108 = (~00 & 0F) in
          let:16 a109 = addWithCarry(!true,a107,a108) in
          advance (5)
          #0725
          #instruction: JP   NZ,071D
          if (!is_zero(a106[7:0])) {
            advance (10)
            A := 05;
            B := a52;
            C := a106[7:0];
            D := 1D;
            E := 4D;
            H := 1D;
            L := 51;
            FlagS := a106[7:0][7];
            FlagZ := is_zero(a106[7:0]);
            FlagA := a109[7:0][4];
            FlagP := parity(a106[7:0]);
            FlagCY := !a54[15:8][0];
            jump (071D);
          } else {
            advance (10)
            #0728
            #instruction: LD   A,(HL)
            advance (7)
            #0729
            #instruction: LD   (2087),A
            M[2087] := 97;
            advance (13)
            #072C
            #instruction: LD   H,00
            advance (7)
            #072E
            #instruction: LD   L,B
            let:8 a110 = a52 in
            advance (5)
            #072F
            #instruction: ADD  HL,HL
            let:8 a111 = a110 in
            let:8 a112 = a110 in
            let:17 a113 = add17((00,a111),(00,a112)) in
            advance (10)
            #0730
            #instruction: ADD  HL,HL
            let:8 a114 = a113[15:0][15:8] in
            let:8 a115 = a113[15:0][7:0] in
            let:8 a116 = a113[15:0][15:8] in
            let:8 a117 = a113[15:0][7:0] in
            let:17 a118 = add17((a114,a115),(a116,a117)) in
            advance (10)
            #0731
            #instruction: ADD  HL,HL
            let:8 a119 = a118[15:0][15:8] in
            let:8 a120 = a118[15:0][7:0] in
            let:8 a121 = a118[15:0][15:8] in
            let:8 a122 = a118[15:0][7:0] in
            let:17 a123 = add17((a119,a120),(a121,a122)) in
            advance (10)
            #0732
            #instruction: ADD  HL,HL
            let:8 a124 = a123[15:0][15:8] in
            let:8 a125 = a123[15:0][7:0] in
            let:8 a126 = a123[15:0][15:8] in
            let:8 a127 = a123[15:0][7:0] in
            let:17 a128 = add17((a124,a125),(a126,a127)) in
            advance (10)
            #0733
            #instruction: LD   (20F2),HL
            let:8 a129 = a128[15:0][7:0] in
            M[20F2] := a129;
            let:8 a130 = a128[15:0][15:8] in
            M[20F3] := a130;
            advance (16)
            #0736
            #instruction: CALL 0742
            let:8 a131 = SPH in
            let:8 a132 = SPL in
            let:16 a133 = (-1 + (a131,a132)) in
            M[a133] := 07;
            let:8 a134 = a133[15:8] in
            let:8 a135 = a133[7:0] in
            let:16 a136 = (-1 + (a134,a135)) in
            M[a136] := 39;
            #return-to: 0739
            advance (17)
            #0742
            #instruction: LD   HL,2087
            advance (10)
            #0745
            #instruction: CALL 1A3B
            let:8 a137 = a136[15:8] in
            let:8 a138 = a136[7:0] in
            let:16 a139 = (-1 + (a137,a138)) in
            M[a139] := 07;
            let:8 a140 = a139[15:8] in
            let:8 a141 = a139[7:0] in
            let:16 a142 = (-1 + (a140,a141)) in
            M[a142] := 48;
            #return-to: 0748
            advance (17)
            #1A3B
            #instruction: LD   E,(HL)
            let:8 a143 = M[2087] in
            advance (7)
            #1A3C
            #instruction: INC  HL
            advance (5)
            #1A3D
            #instruction: LD   D,(HL)
            let:8 a144 = M[2088] in
            advance (7)
            #1A3E
            #instruction: INC  HL
            advance (5)
            #1A3F
            #instruction: LD   A,(HL)
            let:8 a145 = M[2089] in
            advance (7)
            #1A40
            #instruction: INC  HL
            advance (5)
            #1A41
            #instruction: LD   C,(HL)
            let:8 a146 = M[208A] in
            advance (7)
            #1A42
            #instruction: INC  HL
            advance (5)
            #1A43
            #instruction: LD   B,(HL)
            let:8 a147 = M[208B] in
            advance (7)
            #1A44
            #instruction: LD   H,C
            let:8 a148 = a146 in
            advance (5)
            #1A45
            #instruction: LD   L,A
            let:8 a149 = a145 in
            advance (5)
            #1A46
            #instruction: RET
            let:8 a150 = a142[15:8] in
            let:8 a151 = a142[7:0] in
            let:16 a152 = (1 + (a150,a151)) in
            let:8 a153 = M[(a150,a151)] in
            let:8 a154 = a152[15:8] in
            let:8 a155 = a152[7:0] in
            let:16 a156 = (1 + (a154,a155)) in
            let:8 a157 = M[(a154,a155)] in
            advance (10)
            A := a145;
            B := a147;
            C := a146;
            D := a144;
            E := a143;
            H := a148;
            L := a149;
            SPH := a156[15:8];
            SPL := a156[7:0];
            FlagS := a106[7:0][7];
            FlagZ := is_zero(a106[7:0]);
            FlagA := a109[7:0][4];
            FlagP := parity(a106[7:0]);
            FlagCY := a128[16];
            jump ((a157,a153));
          }
        }
      } else {
        advance (10)
        #06E8
        #instruction: AND  A
        let:8 a158 = a15 in
        let:8 a159 = a15 in
        let:8 a160 = (a158 & a159) in
        let:8 a161 = (a158 | a159) in
        advance (4)
        #06E9
        #instruction: RET  NZ
        if (!is_zero(a160)) {
          let:8 a162 = SPH in
          let:8 a163 = SPL in
          let:16 a164 = (1 + (a162,a163)) in
          let:8 a165 = M[(a162,a163)] in
          let:8 a166 = a164[15:8] in
          let:8 a167 = a164[7:0] in
          let:16 a168 = (1 + (a166,a167)) in
          let:8 a169 = M[(a166,a167)] in
          advance (11)
          A := a160;
          H := a3[15:8];
          L := a3[7:0];
          SPH := a168[15:8];
          SPL := a168[7:0];
          FlagS := a160[7];
          FlagZ := is_zero(a160);
          FlagA := a161[3];
          FlagP := parity(a160);
          FlagCY := false;
          jump ((a169,a165));
        } else {
          advance (5)
          #06EA
          #instruction: LD   B,EF
          advance (7)
          #06EC
          #instruction: LD   HL,2098
          advance (10)
          #06EF
          #instruction: LD   A,(HL)
          let:8 a170 = M[2098] in
          advance (7)
          #06F0
          #instruction: AND  B
          let:8 a171 = a170 in
          let:8 a172 = (EF & a171) in
          let:8 a173 = (EF | a171) in
          advance (4)
          #06F1
          #instruction: LD   (HL),A
          let:8 a174 = a172 in
          M[2098] := a174;
          advance (7)
          #06F2
          #instruction: AND  20
          let:8 a175 = a172 in
          let:8 a176 = (20 & a175) in
          let:8 a177 = (20 | a175) in
          advance (7)
          #06F4
          #instruction: OUT  05
          let:8 a178 = a176 in
          sound_control(FleetMovement1,a178[0]);
          sound_control(FleetMovement2,a178[1]);
          sound_control(FleetMovement3,a178[2]);
          sound_control(FleetMovement4,a178[3]);
          sound_control(UfoHit,a178[4]);
          advance (10)
          #06F6
          #instruction: NOP
          advance (4)
          #06F7
          #instruction: NOP
          advance (4)
          #06F8
          #instruction: NOP
          advance (4)
          #06F9
          #instruction: CALL 0742
          let:8 a179 = SPH in
          let:8 a180 = SPL in
          let:16 a181 = (-1 + (a179,a180)) in
          M[a181] := 06;
          let:8 a182 = a181[15:8] in
          let:8 a183 = a181[7:0] in
          let:16 a184 = (-1 + (a182,a183)) in
          M[a184] := FC;
          #return-to: 06FC
          advance (17)
          #0742
          #instruction: LD   HL,2087
          advance (10)
          #0745
          #instruction: CALL 1A3B
          let:8 a185 = a184[15:8] in
          let:8 a186 = a184[7:0] in
          let:16 a187 = (-1 + (a185,a186)) in
          M[a187] := 07;
          let:8 a188 = a187[15:8] in
          let:8 a189 = a187[7:0] in
          let:16 a190 = (-1 + (a188,a189)) in
          M[a190] := 48;
          #return-to: 0748
          advance (17)
          #1A3B
          #instruction: LD   E,(HL)
          let:8 a191 = M[2087] in
          advance (7)
          #1A3C
          #instruction: INC  HL
          advance (5)
          #1A3D
          #instruction: LD   D,(HL)
          let:8 a192 = M[2088] in
          advance (7)
          #1A3E
          #instruction: INC  HL
          advance (5)
          #1A3F
          #instruction: LD   A,(HL)
          let:8 a193 = M[2089] in
          advance (7)
          #1A40
          #instruction: INC  HL
          advance (5)
          #1A41
          #instruction: LD   C,(HL)
          let:8 a194 = M[208A] in
          advance (7)
          #1A42
          #instruction: INC  HL
          advance (5)
          #1A43
          #instruction: LD   B,(HL)
          let:8 a195 = M[208B] in
          advance (7)
          #1A44
          #instruction: LD   H,C
          let:8 a196 = a194 in
          advance (5)
          #1A45
          #instruction: LD   L,A
          let:8 a197 = a193 in
          advance (5)
          #1A46
          #instruction: RET
          let:8 a198 = a190[15:8] in
          let:8 a199 = a190[7:0] in
          let:16 a200 = (1 + (a198,a199)) in
          let:8 a201 = M[(a198,a199)] in
          let:8 a202 = a200[15:8] in
          let:8 a203 = a200[7:0] in
          let:16 a204 = (1 + (a202,a203)) in
          let:8 a205 = M[(a202,a203)] in
          advance (10)
          A := a193;
          B := a195;
          C := a194;
          D := a192;
          E := a191;
          H := a196;
          L := a197;
          SPH := a204[15:8];
          SPL := a204[7:0];
          FlagS := a176[7];
          FlagZ := is_zero(a176);
          FlagA := a177[3];
          FlagP := parity(a176);
          FlagCY := false;
          jump ((a205,a201));
        }
      }
    }

06FC:

    #06FC
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 06;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FF;
    #return-to: 06FF
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a7 = A in
    let:8 a8 = A in
    let:8 a9 = (a7 ^ a8) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:8 a10 = B in
    let:8 a11 = C in
    let:8 a12 = a6[15:8] in
    let:8 a13 = a6[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := a10;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := a11;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    let:8 a18 = a9 in
    let:8 a19 = H in
    let:8 a20 = L in
    M[(a19,a20)] := a18;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:8 a21 = H in
    let:8 a22 = L in
    let:17 a23 = add17(0020,(a21,a22)) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a24 = a17[15:8] in
    let:8 a25 = a17[7:0] in
    let:16 a26 = (1 + (a24,a25)) in
    let:8 a27 = M[(a24,a25)] in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (1 + (a28,a29)) in
    let:8 a31 = M[(a28,a29)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a32 = a31 in
    let:16 a33 = addWithCarry(!true,a32,~00) in
    let:8 a34 = (a32 & 0F) in
    let:8 a35 = (~00 & 0F) in
    let:16 a36 = addWithCarry(!true,a34,a35) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a33[7:0])) {
      advance (10)
      A := a9;
      B := a33[7:0];
      C := a27;
      H := a23[15:0][15:8];
      L := a23[15:0][7:0];
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a33[7:0][7];
      FlagZ := is_zero(a33[7:0]);
      FlagA := a36[7:0][4];
      FlagP := parity(a33[7:0]);
      FlagCY := a23[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a37 = a30[15:8] in
      let:8 a38 = a30[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      A := a9;
      B := a33[7:0];
      C := a27;
      H := a23[15:0][15:8];
      L := a23[15:0][7:0];
      SPH := a43[15:8];
      SPL := a43[7:0];
      FlagS := a33[7:0][7];
      FlagZ := is_zero(a33[7:0]);
      FlagA := a36[7:0][4];
      FlagP := parity(a33[7:0]);
      FlagCY := a23[16];
      jump ((a44,a40));
    }

06FF:

    #06FF
    #instruction: LD   HL,2083
    advance (10)
    #0702
    #instruction: LD   B,0A
    advance (7)
    #0704
    #instruction: CALL 075F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 07;
    #return-to: 0707
    advance (17)
    #075F
    #instruction: LD   DE,1B83
    advance (10)
    #0762
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2083] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,0A,~00) in
    let:8 a8 = (0A & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 84;
      H := 20;
      L := 84;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := 84;
      H := 20;
      L := 84;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0707:

    #0707
    #instruction: LD   B,FE
    advance (7)
    #0709
    #instruction: JP   19DC
    advance (10)
    #19DC
    #instruction: LD   A,(2094)
    let:8 a1 = M[2094] in
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a2 = a1 in
    let:8 a3 = (FE & a2) in
    let:8 a4 = (FE | a2) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    let:8 a5 = a3 in
    M[2094] := a5;
    advance (13)
    #19E3
    #instruction: OUT  03
    let:8 a6 = a3 in
    sound_control(Ufo,a6[0]);
    sound_control(Shot,a6[1]);
    sound_control(PlayerDie,a6[2]);
    sound_control(InvaderDie,a6[3]);
    sound_control(ExtraLife,a6[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a3;
    B := FE;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a14,a10));

0739:

    #0739
    #instruction: JP   08F1
    advance (10)
    #08F1
    #instruction: LD   C,03
    advance (7)
    #08F3
    #instruction: LD   A,(DE)
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a4 = D in
    let:8 a5 = E in
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a4;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a5;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 08;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a18 = H in
    let:8 a19 = L in
    let:8 a20 = a17[15:8] in
    let:8 a21 = a17[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := a18;
    let:8 a23 = a22[15:8] in
    let:8 a24 = a22[7:0] in
    let:16 a25 = (-1 + (a23,a24)) in
    M[a25] := a19;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a26 = a3 in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a27 = a26 in
    let:8 a28 = a26 in
    let:17 a29 = add17((00,a27),(00,a28)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a30 = a29[15:0][15:8] in
    let:8 a31 = a29[15:0][7:0] in
    let:8 a32 = a29[15:0][15:8] in
    let:8 a33 = a29[15:0][7:0] in
    let:17 a34 = add17((a30,a31),(a32,a33)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a35 = a34[15:0][15:8] in
    let:8 a36 = a34[15:0][7:0] in
    let:8 a37 = a34[15:0][15:8] in
    let:8 a38 = a34[15:0][7:0] in
    let:17 a39 = add17((a35,a36),(a37,a38)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a40 = a39[15:0][15:8] in
    let:8 a41 = a39[15:0][7:0] in
    let:17 a42 = add17(1E00,(a40,a41)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a43 = a42[15:0][15:8] in
    let:8 a44 = a42[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a45 = a25[15:8] in
    let:8 a46 = a25[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (1 + (a49,a50)) in
    let:8 a52 = M[(a49,a50)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a53 = a3 in
    unknown_output(6,a53);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a54 = a51[15:8] in
    let:8 a55 = a51[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := 08;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := 03;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a60 = a43 in
    let:8 a61 = a44 in
    let:8 a62 = M[(a60,a61)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a63 = a62 in
    let:8 a64 = a52 in
    let:8 a65 = a48 in
    M[(a64,a65)] := a63;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a66 = a43 in
    let:8 a67 = a44 in
    let:16 a68 = (1 + (a66,a67)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a69 = a52 in
    let:8 a70 = a48 in
    let:17 a71 = add17(0020,(a69,a70)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a72 = a59[15:8] in
    let:8 a73 = a59[7:0] in
    let:16 a74 = (1 + (a72,a73)) in
    let:8 a75 = M[(a72,a73)] in
    let:8 a76 = a74[15:8] in
    let:8 a77 = a74[7:0] in
    let:16 a78 = (1 + (a76,a77)) in
    let:8 a79 = M[(a76,a77)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a80 = a79 in
    let:16 a81 = addWithCarry(!true,a80,~00) in
    let:8 a82 = (a80 & 0F) in
    let:8 a83 = (~00 & 0F) in
    let:16 a84 = addWithCarry(!true,a82,a83) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a81[7:0])) {
      advance (10)
      A := a62;
      B := a81[7:0];
      C := a75;
      D := a68[15:8];
      E := a68[7:0];
      H := a71[15:0][15:8];
      L := a71[15:0][7:0];
      SPH := a78[15:8];
      SPL := a78[7:0];
      FlagS := a81[7:0][7];
      FlagZ := is_zero(a81[7:0]);
      FlagA := a84[7:0][4];
      FlagP := parity(a81[7:0]);
      FlagCY := a71[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a85 = a78[15:8] in
      let:8 a86 = a78[7:0] in
      let:16 a87 = (1 + (a85,a86)) in
      let:8 a88 = M[(a85,a86)] in
      let:8 a89 = a87[15:8] in
      let:8 a90 = a87[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      let:8 a92 = M[(a89,a90)] in
      advance (10)
      A := a62;
      B := a81[7:0];
      C := a75;
      D := a68[15:8];
      E := a68[7:0];
      H := a71[15:0][15:8];
      L := a71[15:0][7:0];
      SPH := a91[15:8];
      SPL := a91[7:0];
      FlagS := a81[7:0][7];
      FlagZ := is_zero(a81[7:0]);
      FlagA := a84[7:0][4];
      FlagP := parity(a81[7:0]);
      FlagCY := a71[16];
      jump ((a92,a88));
    }

073F:

    #073F
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a9 = D in
    let:8 a10 = E in
    let:8 a11 = M[(a9,a10)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a12 = a11 in
    let:8 a13 = H in
    let:8 a14 = L in
    M[(a13,a14)] := a12;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a15 = D in
    let:8 a16 = E in
    let:16 a17 = (1 + (a15,a16)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a18 = H in
    let:8 a19 = L in
    let:17 a20 = add17(0020,(a18,a19)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a21 = a8[15:8] in
    let:8 a22 = a8[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a29 = a28 in
    let:16 a30 = addWithCarry(!true,a29,~00) in
    let:8 a31 = (a29 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a30[7:0])) {
      advance (10)
      A := a11;
      B := a30[7:0];
      C := a24;
      D := a17[15:8];
      E := a17[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      FlagCY := a20[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a34 = a27[15:8] in
      let:8 a35 = a27[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      A := a11;
      B := a30[7:0];
      C := a24;
      D := a17[15:8];
      E := a17[7:0];
      H := a20[15:0][15:8];
      L := a20[15:0][7:0];
      SPH := a40[15:8];
      SPL := a40[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      FlagCY := a20[16];
      jump ((a41,a37));
    }

0748:

    #0748
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a9 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a10 = a9 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a11 = updateBit((a10 >> 01),7,FlagCY) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a12 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a13 = a12 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a14 = updateBit((a13 >> 01),7,a10[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a15 = addWithCarry(!true,03,~00) in
    let:8 a16 = (03 & 0F) in
    let:8 a17 = (~00 & 0F) in
    let:16 a18 = addWithCarry(!true,a16,a17) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a15[7:0])) {
      advance (10)
      A := updateBit((a13 >> 01),7,a10[0]);
      B := a15[7:0];
      H := a11;
      L := a14;
      SPH := a8[15:8];
      SPL := a8[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      FlagCY := a13[0];
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a19 = a11 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a20 = a19 in
      let:8 a21 = (3F & a20) in
      let:8 a22 = (3F | a20) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a23 = a21 in
      let:8 a24 = (20 | a23) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a25 = a24 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a26 = a8[15:8] in
      let:8 a27 = a8[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      let:8 a30 = a28[15:8] in
      let:8 a31 = a28[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      let:8 a33 = M[(a30,a31)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a34 = a32[15:8] in
      let:8 a35 = a32[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      A := a24;
      B := a33;
      C := a29;
      H := a25;
      L := a14;
      SPH := a40[15:8];
      SPL := a40[7:0];
      FlagS := a24[7];
      FlagZ := is_zero(a24);
      FlagA := false;
      FlagP := parity(a24);
      FlagCY := false;
      jump ((a41,a37));
    }

0756:

    #0756
    #instruction: LD   HL,1D7C
    advance (10)
    #0759
    #instruction: LD   (2087),HL
    M[2087] := 7C;
    M[2088] := 1D;
    advance (16)
    #075C
    #instruction: JP   073C
    advance (10)
    #073C
    #instruction: CALL 0742
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3F;
    #return-to: 073F
    advance (17)
    #0742
    #instruction: LD   HL,2087
    advance (10)
    #0745
    #instruction: CALL 1A3B
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 07;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 48;
    #return-to: 0748
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    let:8 a13 = M[2087] in
    advance (7)
    #1A3C
    #instruction: INC  HL
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    let:8 a14 = M[2088] in
    advance (7)
    #1A3E
    #instruction: INC  HL
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    let:8 a15 = M[2089] in
    advance (7)
    #1A40
    #instruction: INC  HL
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    let:8 a16 = M[208A] in
    advance (7)
    #1A42
    #instruction: INC  HL
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    let:8 a17 = M[208B] in
    advance (7)
    #1A44
    #instruction: LD   H,C
    let:8 a18 = a16 in
    advance (5)
    #1A45
    #instruction: LD   L,A
    let:8 a19 = a15 in
    advance (5)
    #1A46
    #instruction: RET
    let:8 a20 = a12[15:8] in
    let:8 a21 = a12[7:0] in
    let:16 a22 = (1 + (a20,a21)) in
    let:8 a23 = M[(a20,a21)] in
    let:8 a24 = a22[15:8] in
    let:8 a25 = a22[7:0] in
    let:16 a26 = (1 + (a24,a25)) in
    let:8 a27 = M[(a24,a25)] in
    advance (10)
    A := a15;
    B := a17;
    C := a16;
    D := a14;
    E := a13;
    H := a18;
    L := a19;
    SPH := a26[15:8];
    SPL := a26[7:0];
    jump ((a27,a23));

0771:

    #0771
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 0774
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = (1F & 03) in
    let:8 a8 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a9 = a7 in
    let:16 a10 = addWithCarry(!false,a9,~1C) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a18 = a6[15:8] in
        let:8 a19 = a6[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a25,a21));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a26 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a27 = a26[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a28 = a27 in
      let:16 a29 = addWithCarry(!false,a28,~40) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~40 & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a29[15:8][0]) {
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a33 = a6[15:8] in
        let:8 a34 = a6[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump ((a40,a36));
      }
    }

0774:

    #0774
    #instruction: LD   HL,3013
    advance (10)
    #0777
    #instruction: LD   DE,1FF3
    advance (10)
    #077A
    #instruction: LD   C,04
    advance (7)
    #077C
    #instruction: CALL 08F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7F;
    #return-to: 077F
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1F;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F3;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 08;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 30;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 13;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(000F,000F) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,0F);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 04;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

077F:

    #077F
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    #0782
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #0783
    #instruction: LD   HL,2810
    advance (10)
    #0786
    #instruction: LD   C,14
    advance (7)
    #0788
    #instruction: JP   NZ,0857
    if (!is_zero(a3[7:0])) {
      advance (10)
      #0857
      #instruction: LD   DE,1ABA
      advance (10)
      #085A
      #instruction: CALL 08F3
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 08;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := 5D;
      #return-to: 085D
      advance (17)
      #08F3
      #instruction: LD   A,(DE)
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 1A;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := BA;
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:8 a19 = a18[15:8] in
      let:8 a20 = a18[7:0] in
      let:16 a21 = (-1 + (a19,a20)) in
      M[a21] := 08;
      let:8 a22 = a21[15:8] in
      let:8 a23 = a21[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 28;
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 10;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a31 = add17(001B,001B) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a32 = a31[15:0][15:8] in
      let:8 a33 = a31[15:0][7:0] in
      let:8 a34 = a31[15:0][15:8] in
      let:8 a35 = a31[15:0][7:0] in
      let:17 a36 = add17((a32,a33),(a34,a35)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a37 = a36[15:0][15:8] in
      let:8 a38 = a36[15:0][7:0] in
      let:8 a39 = a36[15:0][15:8] in
      let:8 a40 = a36[15:0][7:0] in
      let:17 a41 = add17((a37,a38),(a39,a40)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a42 = a41[15:0][15:8] in
      let:8 a43 = a41[15:0][7:0] in
      let:17 a44 = add17(1E00,(a42,a43)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a45 = a44[15:0][15:8] in
      let:8 a46 = a44[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a47 = a30[15:8] in
      let:8 a48 = a30[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      let:8 a51 = a49[15:8] in
      let:8 a52 = a49[7:0] in
      let:16 a53 = (1 + (a51,a52)) in
      let:8 a54 = M[(a51,a52)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,1B);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a55 = a53[15:8] in
      let:8 a56 = a53[7:0] in
      let:16 a57 = (-1 + (a55,a56)) in
      M[a57] := 08;
      let:8 a58 = a57[15:8] in
      let:8 a59 = a57[7:0] in
      let:16 a60 = (-1 + (a58,a59)) in
      M[a60] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a61 = a45 in
      let:8 a62 = a46 in
      let:8 a63 = M[(a61,a62)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a64 = a63 in
      let:8 a65 = a54 in
      let:8 a66 = a50 in
      M[(a65,a66)] := a64;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a67 = a45 in
      let:8 a68 = a46 in
      let:16 a69 = (1 + (a67,a68)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a70 = a54 in
      let:8 a71 = a50 in
      let:17 a72 = add17(0020,(a70,a71)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a73 = a60[15:8] in
      let:8 a74 = a60[7:0] in
      let:16 a75 = (1 + (a73,a74)) in
      let:8 a76 = M[(a73,a74)] in
      let:8 a77 = a75[15:8] in
      let:8 a78 = a75[7:0] in
      let:16 a79 = (1 + (a77,a78)) in
      let:8 a80 = M[(a77,a78)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a81 = a80 in
      let:16 a82 = addWithCarry(!true,a81,~00) in
      let:8 a83 = (a81 & 0F) in
      let:8 a84 = (~00 & 0F) in
      let:16 a85 = addWithCarry(!true,a83,a84) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a82[7:0])) {
        advance (10)
        A := a63;
        B := a82[7:0];
        C := a76;
        D := a69[15:8];
        E := a69[7:0];
        H := a72[15:0][15:8];
        L := a72[15:0][7:0];
        SPH := a79[15:8];
        SPL := a79[7:0];
        FlagS := a82[7:0][7];
        FlagZ := is_zero(a82[7:0]);
        FlagA := a85[7:0][4];
        FlagP := parity(a82[7:0]);
        FlagCY := a72[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a86 = a79[15:8] in
        let:8 a87 = a79[7:0] in
        let:16 a88 = (1 + (a86,a87)) in
        let:8 a89 = M[(a86,a87)] in
        let:8 a90 = a88[15:8] in
        let:8 a91 = a88[7:0] in
        let:16 a92 = (1 + (a90,a91)) in
        let:8 a93 = M[(a90,a91)] in
        advance (10)
        A := a63;
        B := a82[7:0];
        C := a76;
        D := a69[15:8];
        E := a69[7:0];
        H := a72[15:0][15:8];
        L := a72[15:0][7:0];
        SPH := a92[15:8];
        SPL := a92[7:0];
        FlagS := a82[7:0][7];
        FlagZ := is_zero(a82[7:0]);
        FlagA := a85[7:0][4];
        FlagP := parity(a82[7:0]);
        FlagCY := a72[16];
        jump ((a93,a89));
      }
    } else {
      advance (10)
      #078B
      #instruction: LD   DE,1ACF
      advance (10)
      #078E
      #instruction: CALL 08F3
      let:8 a94 = SPH in
      let:8 a95 = SPL in
      let:16 a96 = (-1 + (a94,a95)) in
      M[a96] := 07;
      let:8 a97 = a96[15:8] in
      let:8 a98 = a96[7:0] in
      let:16 a99 = (-1 + (a97,a98)) in
      M[a99] := 91;
      #return-to: 0791
      advance (17)
      #08F3
      #instruction: LD   A,(DE)
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:8 a100 = a99[15:8] in
      let:8 a101 = a99[7:0] in
      let:16 a102 = (-1 + (a100,a101)) in
      M[a102] := 1A;
      let:8 a103 = a102[15:8] in
      let:8 a104 = a102[7:0] in
      let:16 a105 = (-1 + (a103,a104)) in
      M[a105] := CF;
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:8 a106 = a105[15:8] in
      let:8 a107 = a105[7:0] in
      let:16 a108 = (-1 + (a106,a107)) in
      M[a108] := 08;
      let:8 a109 = a108[15:8] in
      let:8 a110 = a108[7:0] in
      let:16 a111 = (-1 + (a109,a110)) in
      M[a111] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a112 = a111[15:8] in
      let:8 a113 = a111[7:0] in
      let:16 a114 = (-1 + (a112,a113)) in
      M[a114] := 28;
      let:8 a115 = a114[15:8] in
      let:8 a116 = a114[7:0] in
      let:16 a117 = (-1 + (a115,a116)) in
      M[a117] := 10;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a118 = add17(000E,000E) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a119 = a118[15:0][15:8] in
      let:8 a120 = a118[15:0][7:0] in
      let:8 a121 = a118[15:0][15:8] in
      let:8 a122 = a118[15:0][7:0] in
      let:17 a123 = add17((a119,a120),(a121,a122)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a124 = a123[15:0][15:8] in
      let:8 a125 = a123[15:0][7:0] in
      let:8 a126 = a123[15:0][15:8] in
      let:8 a127 = a123[15:0][7:0] in
      let:17 a128 = add17((a124,a125),(a126,a127)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a129 = a128[15:0][15:8] in
      let:8 a130 = a128[15:0][7:0] in
      let:17 a131 = add17(1E00,(a129,a130)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a132 = a131[15:0][15:8] in
      let:8 a133 = a131[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a134 = a117[15:8] in
      let:8 a135 = a117[7:0] in
      let:16 a136 = (1 + (a134,a135)) in
      let:8 a137 = M[(a134,a135)] in
      let:8 a138 = a136[15:8] in
      let:8 a139 = a136[7:0] in
      let:16 a140 = (1 + (a138,a139)) in
      let:8 a141 = M[(a138,a139)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,0E);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a142 = a140[15:8] in
      let:8 a143 = a140[7:0] in
      let:16 a144 = (-1 + (a142,a143)) in
      M[a144] := 08;
      let:8 a145 = a144[15:8] in
      let:8 a146 = a144[7:0] in
      let:16 a147 = (-1 + (a145,a146)) in
      M[a147] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a148 = a132 in
      let:8 a149 = a133 in
      let:8 a150 = M[(a148,a149)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a151 = a150 in
      let:8 a152 = a141 in
      let:8 a153 = a137 in
      M[(a152,a153)] := a151;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a154 = a132 in
      let:8 a155 = a133 in
      let:16 a156 = (1 + (a154,a155)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a157 = a141 in
      let:8 a158 = a137 in
      let:17 a159 = add17(0020,(a157,a158)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a160 = a147[15:8] in
      let:8 a161 = a147[7:0] in
      let:16 a162 = (1 + (a160,a161)) in
      let:8 a163 = M[(a160,a161)] in
      let:8 a164 = a162[15:8] in
      let:8 a165 = a162[7:0] in
      let:16 a166 = (1 + (a164,a165)) in
      let:8 a167 = M[(a164,a165)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a168 = a167 in
      let:16 a169 = addWithCarry(!true,a168,~00) in
      let:8 a170 = (a168 & 0F) in
      let:8 a171 = (~00 & 0F) in
      let:16 a172 = addWithCarry(!true,a170,a171) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a169[7:0])) {
        advance (10)
        A := a150;
        B := a169[7:0];
        C := a163;
        D := a156[15:8];
        E := a156[7:0];
        H := a159[15:0][15:8];
        L := a159[15:0][7:0];
        SPH := a166[15:8];
        SPL := a166[7:0];
        FlagS := a169[7:0][7];
        FlagZ := is_zero(a169[7:0]);
        FlagA := a172[7:0][4];
        FlagP := parity(a169[7:0]);
        FlagCY := a159[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a173 = a166[15:8] in
        let:8 a174 = a166[7:0] in
        let:16 a175 = (1 + (a173,a174)) in
        let:8 a176 = M[(a173,a174)] in
        let:8 a177 = a175[15:8] in
        let:8 a178 = a175[7:0] in
        let:16 a179 = (1 + (a177,a178)) in
        let:8 a180 = M[(a177,a178)] in
        advance (10)
        A := a150;
        B := a169[7:0];
        C := a163;
        D := a156[15:8];
        E := a156[7:0];
        H := a159[15:0][15:8];
        L := a159[15:0][7:0];
        SPH := a179[15:8];
        SPL := a179[7:0];
        FlagS := a169[7:0][7];
        FlagZ := is_zero(a169[7:0]);
        FlagA := a172[7:0][4];
        FlagP := parity(a169[7:0]);
        FlagCY := a159[16];
        jump ((a180,a176));
      }
    }

0791:

    #0791
    #instruction: IN   01
    advance (10)
    #0793
    #instruction: AND  04
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    let:8 a2 = (04 & a1) in
    let:8 a3 = (04 | a1) in
    advance (7)
    #0795
    #instruction: JP   Z,077F
    if (is_zero(a2)) {
      advance (10)
      A := a2;
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump (077F);
    } else {
      advance (10)
      #0798
      #instruction: LD   B,99
      advance (7)
      #079A
      #instruction: XOR  A
      let:8 a4 = a2 in
      let:8 a5 = a2 in
      let:8 a6 = (a4 ^ a5) in
      advance (4)
      #079B
      #instruction: LD   (20CE),A
      let:8 a7 = a6 in
      M[20CE] := a7;
      advance (13)
      #079E
      #instruction: LD   A,(20EB)
      let:8 a8 = M[20EB] in
      advance (13)
      #07A1
      #instruction: ADD  B
      let:8 a9 = a8 in
      let:16 a10 = addWithCarry(false,99,a9) in
      let:8 a11 = (99 & 0F) in
      let:8 a12 = (a9 & 0F) in
      let:16 a13 = addWithCarry(false,a11,a12) in
      advance (4)
      #07A2
      #instruction: DAA
      let:8 a14 = a10[7:0] in
      let:8 a15 = (a14 & 0F) in
      let:16 a16 = addWithCarry(false,a15,06) in
      let:16 a17 = addWithCarry(((((a15[1] || a15[2]) && a15[3]) || a13[7:0][4]) ? a16[7:0] : a15)[4],(a14 >> 04),00) in
      let:16 a18 = addWithCarry(false,a17[7:0],06) in
      let:8 a19 = (((((a15[1] || a15[2]) && a15[3]) || a13[7:0][4]) ? a16[7:0] : a15) & 0F) in
      let:8 a20 = ((((((a17[7:0][1] || a17[7:0][2]) && a17[7:0][3]) || a10[15:8][0]) ? a18[7:0] : a17[7:0]) << 04) | a19) in
      advance (4)
      #07A3
      #instruction: LD   (20EB),A
      let:8 a21 = a20 in
      M[20EB] := a21;
      advance (13)
      #07A6
      #instruction: CALL 1947
      let:8 a22 = SPH in
      let:8 a23 = SPL in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 07;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := A9;
      #return-to: 07A9
      advance (17)
      #1947
      #instruction: LD   A,(20EB)
      let:8 a28 = M[20EB] in
      advance (13)
      #194A
      #instruction: LD   HL,3C01
      advance (10)
      #194D
      #instruction: JP   09B2
      advance (10)
      #09B2
      #instruction: PUSH DE
      let:8 a29 = D in
      let:8 a30 = E in
      let:8 a31 = a27[15:8] in
      let:8 a32 = a27[7:0] in
      let:16 a33 = (-1 + (a31,a32)) in
      M[a33] := a29;
      let:8 a34 = a33[15:8] in
      let:8 a35 = a33[7:0] in
      let:16 a36 = (-1 + (a34,a35)) in
      M[a36] := a30;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:8 a37 = a28 in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (-1 + (a38,a39)) in
      M[a40] := a37;
      let:8 a41 = a40[15:8] in
      let:8 a42 = a40[7:0] in
      let:16 a43 = (-1 + (a41,a42)) in
      M[a43] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a20[7]),6,is_zero(a20)),4,((((a15[1] || a15[2]) && a15[3]) || a13[7:0][4]) ? a16[7:0] : a15)[4]),2,parity(a20)),0,(((((a17[7:0][1] || a17[7:0][2]) && a17[7:0][3]) || a10[15:8][0]) ? a18[7:0] : a17[7:0])[4] || a10[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA
      let:8 a44 = a28 in
      advance (4)
      #09B5
      #instruction: RRCA
      let:8 a45 = updateBit((a44 >> 01),7,a44[0]) in
      advance (4)
      #09B6
      #instruction: RRCA
      let:8 a46 = updateBit((a45 >> 01),7,a45[0]) in
      advance (4)
      #09B7
      #instruction: RRCA
      let:8 a47 = updateBit((a46 >> 01),7,a46[0]) in
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a48 = updateBit((a47 >> 01),7,a47[0]) in
      let:8 a49 = (0F & a48) in
      let:8 a50 = (0F | a48) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:8 a51 = a43[15:8] in
      let:8 a52 = a43[7:0] in
      let:16 a53 = (-1 + (a51,a52)) in
      M[a53] := 09;
      let:8 a54 = a53[15:8] in
      let:8 a55 = a53[7:0] in
      let:16 a56 = (-1 + (a54,a55)) in
      M[a56] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:8 a57 = a49 in
      let:16 a58 = addWithCarry(false,1A,a57) in
      let:8 a59 = (1A & 0F) in
      let:8 a60 = (a57 & 0F) in
      let:16 a61 = addWithCarry(false,a59,a60) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a62 = a56[15:8] in
      let:8 a63 = a56[7:0] in
      let:16 a64 = (-1 + (a62,a63)) in
      M[a64] := 3C;
      let:8 a65 = a64[15:8] in
      let:8 a66 = a64[7:0] in
      let:16 a67 = (-1 + (a65,a66)) in
      M[a67] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a68 = a58[7:0] in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a69 = a68 in
      let:8 a70 = a68 in
      let:17 a71 = add17((00,a69),(00,a70)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a72 = a71[15:0][15:8] in
      let:8 a73 = a71[15:0][7:0] in
      let:8 a74 = a71[15:0][15:8] in
      let:8 a75 = a71[15:0][7:0] in
      let:17 a76 = add17((a72,a73),(a74,a75)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a77 = a76[15:0][15:8] in
      let:8 a78 = a76[15:0][7:0] in
      let:8 a79 = a76[15:0][15:8] in
      let:8 a80 = a76[15:0][7:0] in
      let:17 a81 = add17((a77,a78),(a79,a80)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a82 = a81[15:0][15:8] in
      let:8 a83 = a81[15:0][7:0] in
      let:17 a84 = add17(1E00,(a82,a83)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a85 = a84[15:0][15:8] in
      let:8 a86 = a84[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a87 = a67[15:8] in
      let:8 a88 = a67[7:0] in
      let:16 a89 = (1 + (a87,a88)) in
      let:8 a90 = M[(a87,a88)] in
      let:8 a91 = a89[15:8] in
      let:8 a92 = a89[7:0] in
      let:16 a93 = (1 + (a91,a92)) in
      let:8 a94 = M[(a91,a92)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a95 = a58[7:0] in
      unknown_output(6,a95);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a96 = C in
      let:8 a97 = a93[15:8] in
      let:8 a98 = a93[7:0] in
      let:16 a99 = (-1 + (a97,a98)) in
      M[a99] := 08;
      let:8 a100 = a99[15:8] in
      let:8 a101 = a99[7:0] in
      let:16 a102 = (-1 + (a100,a101)) in
      M[a102] := a96;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a103 = a85 in
      let:8 a104 = a86 in
      let:8 a105 = M[(a103,a104)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a106 = a105 in
      let:8 a107 = a94 in
      let:8 a108 = a90 in
      M[(a107,a108)] := a106;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a109 = a85 in
      let:8 a110 = a86 in
      let:16 a111 = (1 + (a109,a110)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a112 = a94 in
      let:8 a113 = a90 in
      let:17 a114 = add17(0020,(a112,a113)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a115 = a102[15:8] in
      let:8 a116 = a102[7:0] in
      let:16 a117 = (1 + (a115,a116)) in
      let:8 a118 = M[(a115,a116)] in
      let:8 a119 = a117[15:8] in
      let:8 a120 = a117[7:0] in
      let:16 a121 = (1 + (a119,a120)) in
      let:8 a122 = M[(a119,a120)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a123 = a122 in
      let:16 a124 = addWithCarry(!true,a123,~00) in
      let:8 a125 = (a123 & 0F) in
      let:8 a126 = (~00 & 0F) in
      let:16 a127 = addWithCarry(!true,a125,a126) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a124[7:0])) {
        advance (10)
        A := a105;
        B := a124[7:0];
        C := a118;
        D := a111[15:8];
        E := a111[7:0];
        H := a114[15:0][15:8];
        L := a114[15:0][7:0];
        SPH := a121[15:8];
        SPL := a121[7:0];
        FlagS := a124[7:0][7];
        FlagZ := is_zero(a124[7:0]);
        FlagA := a127[7:0][4];
        FlagP := parity(a124[7:0]);
        FlagCY := a114[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a128 = a121[15:8] in
        let:8 a129 = a121[7:0] in
        let:16 a130 = (1 + (a128,a129)) in
        let:8 a131 = M[(a128,a129)] in
        let:8 a132 = a130[15:8] in
        let:8 a133 = a130[7:0] in
        let:16 a134 = (1 + (a132,a133)) in
        let:8 a135 = M[(a132,a133)] in
        advance (10)
        A := a105;
        B := a124[7:0];
        C := a118;
        D := a111[15:8];
        E := a111[7:0];
        H := a114[15:0][15:8];
        L := a114[15:0][7:0];
        SPH := a134[15:8];
        SPL := a134[7:0];
        FlagS := a124[7:0][7];
        FlagZ := is_zero(a124[7:0]);
        FlagA := a127[7:0][4];
        FlagP := parity(a124[7:0]);
        FlagCY := a114[16];
        jump ((a135,a131));
      }
    }

07A9:

    #07A9
    #instruction: LD   HL,0000
    advance (10)
    #07AC
    #instruction: LD   (20F8),HL
    M[20F8] := 00;
    M[20F9] := 00;
    advance (16)
    #07AF
    #instruction: LD   (20FC),HL
    M[20FC] := 00;
    M[20FD] := 00;
    advance (16)
    #07B2
    #instruction: CALL 1925
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B5;
    #return-to: 07B5
    advance (17)
    #1925
    #instruction: LD   HL,20F8
    advance (10)
    #1928
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = M[20F8] in
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a8 = M[20F9] in
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a9 = M[20FA] in
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a10 = M[20FB] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a11 = a9 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a12 = a8 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a19 = a8 in
    let:8 a20 = a7 in
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a19;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a27 = a12 in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a27;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a34 = a12 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a35 = updateBit((a34 >> 01),7,a34[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a36 = updateBit((a35 >> 01),7,a35[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a37 = updateBit((a36 >> 01),7,a36[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a38 = updateBit((a37 >> 01),7,a37[0]) in
    let:8 a39 = (0F & a38) in
    let:8 a40 = (0F | a38) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a41 = a33[15:8] in
    let:8 a42 = a33[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 09;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a47 = a39 in
    let:16 a48 = addWithCarry(false,1A,a47) in
    let:8 a49 = (1A & 0F) in
    let:8 a50 = (a47 & 0F) in
    let:16 a51 = addWithCarry(false,a49,a50) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a52 = a10 in
    let:8 a53 = a11 in
    let:8 a54 = a46[15:8] in
    let:8 a55 = a46[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := a52;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := a53;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a60 = a48[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a61 = a60 in
    let:8 a62 = a60 in
    let:17 a63 = add17((00,a61),(00,a62)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    let:8 a66 = a63[15:0][15:8] in
    let:8 a67 = a63[15:0][7:0] in
    let:17 a68 = add17((a64,a65),(a66,a67)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a69 = a68[15:0][15:8] in
    let:8 a70 = a68[15:0][7:0] in
    let:8 a71 = a68[15:0][15:8] in
    let:8 a72 = a68[15:0][7:0] in
    let:17 a73 = add17((a69,a70),(a71,a72)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a74 = a73[15:0][15:8] in
    let:8 a75 = a73[15:0][7:0] in
    let:17 a76 = add17(1E00,(a74,a75)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a77 = a76[15:0][15:8] in
    let:8 a78 = a76[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a79 = a59[15:8] in
    let:8 a80 = a59[7:0] in
    let:16 a81 = (1 + (a79,a80)) in
    let:8 a82 = M[(a79,a80)] in
    let:8 a83 = a81[15:8] in
    let:8 a84 = a81[7:0] in
    let:16 a85 = (1 + (a83,a84)) in
    let:8 a86 = M[(a83,a84)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a87 = a48[7:0] in
    unknown_output(6,a87);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a88 = C in
    let:8 a89 = a85[15:8] in
    let:8 a90 = a85[7:0] in
    let:16 a91 = (-1 + (a89,a90)) in
    M[a91] := 08;
    let:8 a92 = a91[15:8] in
    let:8 a93 = a91[7:0] in
    let:16 a94 = (-1 + (a92,a93)) in
    M[a94] := a88;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a95 = a77 in
    let:8 a96 = a78 in
    let:8 a97 = M[(a95,a96)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a98 = a97 in
    let:8 a99 = a86 in
    let:8 a100 = a82 in
    M[(a99,a100)] := a98;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a101 = a77 in
    let:8 a102 = a78 in
    let:16 a103 = (1 + (a101,a102)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a104 = a86 in
    let:8 a105 = a82 in
    let:17 a106 = add17(0020,(a104,a105)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a107 = a94[15:8] in
    let:8 a108 = a94[7:0] in
    let:16 a109 = (1 + (a107,a108)) in
    let:8 a110 = M[(a107,a108)] in
    let:8 a111 = a109[15:8] in
    let:8 a112 = a109[7:0] in
    let:16 a113 = (1 + (a111,a112)) in
    let:8 a114 = M[(a111,a112)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a115 = a114 in
    let:16 a116 = addWithCarry(!true,a115,~00) in
    let:8 a117 = (a115 & 0F) in
    let:8 a118 = (~00 & 0F) in
    let:16 a119 = addWithCarry(!true,a117,a118) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a116[7:0])) {
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a120 = a113[15:8] in
      let:8 a121 = a113[7:0] in
      let:16 a122 = (1 + (a120,a121)) in
      let:8 a123 = M[(a120,a121)] in
      let:8 a124 = a122[15:8] in
      let:8 a125 = a122[7:0] in
      let:16 a126 = (1 + (a124,a125)) in
      let:8 a127 = M[(a124,a125)] in
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a126[15:8];
      SPL := a126[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump ((a127,a123));
    }

07B5:

    #07B5
    #instruction: CALL 192B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B8;
    #return-to: 07B8
    advance (17)
    #192B
    #instruction: LD   HL,20FC
    advance (10)
    #192E
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = M[20FC] in
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a8 = M[20FD] in
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a9 = M[20FE] in
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a10 = M[20FF] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a11 = a9 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a12 = a8 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a19 = a8 in
    let:8 a20 = a7 in
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a19;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a27 = a12 in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a27;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a34 = a12 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a35 = updateBit((a34 >> 01),7,a34[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a36 = updateBit((a35 >> 01),7,a35[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a37 = updateBit((a36 >> 01),7,a36[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a38 = updateBit((a37 >> 01),7,a37[0]) in
    let:8 a39 = (0F & a38) in
    let:8 a40 = (0F | a38) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a41 = a33[15:8] in
    let:8 a42 = a33[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 09;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a47 = a39 in
    let:16 a48 = addWithCarry(false,1A,a47) in
    let:8 a49 = (1A & 0F) in
    let:8 a50 = (a47 & 0F) in
    let:16 a51 = addWithCarry(false,a49,a50) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a52 = a10 in
    let:8 a53 = a11 in
    let:8 a54 = a46[15:8] in
    let:8 a55 = a46[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := a52;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := a53;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a60 = a48[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a61 = a60 in
    let:8 a62 = a60 in
    let:17 a63 = add17((00,a61),(00,a62)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    let:8 a66 = a63[15:0][15:8] in
    let:8 a67 = a63[15:0][7:0] in
    let:17 a68 = add17((a64,a65),(a66,a67)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a69 = a68[15:0][15:8] in
    let:8 a70 = a68[15:0][7:0] in
    let:8 a71 = a68[15:0][15:8] in
    let:8 a72 = a68[15:0][7:0] in
    let:17 a73 = add17((a69,a70),(a71,a72)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a74 = a73[15:0][15:8] in
    let:8 a75 = a73[15:0][7:0] in
    let:17 a76 = add17(1E00,(a74,a75)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a77 = a76[15:0][15:8] in
    let:8 a78 = a76[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a79 = a59[15:8] in
    let:8 a80 = a59[7:0] in
    let:16 a81 = (1 + (a79,a80)) in
    let:8 a82 = M[(a79,a80)] in
    let:8 a83 = a81[15:8] in
    let:8 a84 = a81[7:0] in
    let:16 a85 = (1 + (a83,a84)) in
    let:8 a86 = M[(a83,a84)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a87 = a48[7:0] in
    unknown_output(6,a87);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a88 = C in
    let:8 a89 = a85[15:8] in
    let:8 a90 = a85[7:0] in
    let:16 a91 = (-1 + (a89,a90)) in
    M[a91] := 08;
    let:8 a92 = a91[15:8] in
    let:8 a93 = a91[7:0] in
    let:16 a94 = (-1 + (a92,a93)) in
    M[a94] := a88;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a95 = a77 in
    let:8 a96 = a78 in
    let:8 a97 = M[(a95,a96)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a98 = a97 in
    let:8 a99 = a86 in
    let:8 a100 = a82 in
    M[(a99,a100)] := a98;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a101 = a77 in
    let:8 a102 = a78 in
    let:16 a103 = (1 + (a101,a102)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a104 = a86 in
    let:8 a105 = a82 in
    let:17 a106 = add17(0020,(a104,a105)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a107 = a94[15:8] in
    let:8 a108 = a94[7:0] in
    let:16 a109 = (1 + (a107,a108)) in
    let:8 a110 = M[(a107,a108)] in
    let:8 a111 = a109[15:8] in
    let:8 a112 = a109[7:0] in
    let:16 a113 = (1 + (a111,a112)) in
    let:8 a114 = M[(a111,a112)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a115 = a114 in
    let:16 a116 = addWithCarry(!true,a115,~00) in
    let:8 a117 = (a115 & 0F) in
    let:8 a118 = (~00 & 0F) in
    let:16 a119 = addWithCarry(!true,a117,a118) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a116[7:0])) {
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a120 = a113[15:8] in
      let:8 a121 = a113[7:0] in
      let:16 a122 = (1 + (a120,a121)) in
      let:8 a123 = M[(a120,a121)] in
      let:8 a124 = a122[15:8] in
      let:8 a125 = a122[7:0] in
      let:16 a126 = (1 + (a124,a125)) in
      let:8 a127 = M[(a124,a125)] in
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a126[15:8];
      SPL := a126[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump ((a127,a123));
    }

07B8:

    #07B8
    #instruction: CALL 19D7
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := BB;
    #return-to: 07BB
    advance (17)
    #19D7
    #instruction: XOR  A
    let:8 a7 = A in
    let:8 a8 = A in
    let:8 a9 = (a7 ^ a8) in
    advance (4)
    #19D8
    #instruction: JP   19D3
    advance (10)
    #19D3
    #instruction: LD   (20E9),A
    let:8 a10 = a9 in
    M[20E9] := a10;
    advance (13)
    #19D6
    #instruction: RET
    let:8 a11 = a6[15:8] in
    let:8 a12 = a6[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    advance (10)
    A := a9;
    SPH := a17[15:8];
    SPL := a17[7:0];
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := false;
    FlagP := parity(a9);
    FlagCY := false;
    jump ((a18,a14));

07BB:

    #07BB
    #instruction: LD   HL,0101
    advance (10)
    #07BE
    #instruction: LD   A,H
    advance (5)
    #07BF
    #instruction: LD   (20EF),A
    M[20EF] := 01;
    advance (13)
    #07C2
    #instruction: LD   (20E7),HL
    M[20E7] := 01;
    M[20E8] := 01;
    advance (16)
    #07C5
    #instruction: LD   (20E5),HL
    M[20E5] := 01;
    M[20E6] := 01;
    advance (16)
    #07C8
    #instruction: CALL 1956
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := CB;
    #return-to: 07CB
    advance (17)
    #1956
    #instruction: CALL 1A5C
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 19;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 59;
    #return-to: 1959
    advance (17)
    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    #1A5F
    #instruction: LD   (HL),00
    M[2400] := 00;
    advance (10)
    #1A61
    #instruction: INC  HL
    advance (5)
    #1A62
    #instruction: LD   A,H
    advance (5)
    #1A63
    #instruction: CP   40
    let:16 a13 = addWithCarry(!false,24,~40) in
    let:8 a14 = (24 & 0F) in
    let:8 a15 = (~40 & 0F) in
    let:16 a16 = addWithCarry(!false,a14,a15) in
    advance (7)
    #1A65
    #instruction: JP   NZ,1A5F
    if (!is_zero(a13[7:0])) {
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := !a13[15:8][0];
      jump (1A5F);
    } else {
      advance (10)
      #1A68
      #instruction: RET
      let:8 a17 = a12[15:8] in
      let:8 a18 = a12[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := !a13[15:8][0];
      jump ((a24,a20));
    }

07CB:

    #07CB
    #instruction: CALL 01EF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := CE;
    #return-to: 07CE
    advance (17)
    #01EF
    #instruction: LD   HL,2142
    advance (10)
    #01F2
    #instruction: JP   01F8
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1D;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 02;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2142] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,2C,~00) in
    let:8 a20 = (2C & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a23 = a18[15:8] in
      let:8 a24 = a18[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump ((a30,a26));
    }

07CE:

    #07CE
    #instruction: CALL 01F5
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D1;
    #return-to: 07D1
    advance (17)
    #01F5
    #instruction: LD   HL,2242
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1D;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 02;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2242] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,2C,~00) in
    let:8 a20 = (2C & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 22;
      L := 43;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a23 = a18[15:8] in
      let:8 a24 = a18[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 22;
      L := 43;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump ((a30,a26));
    }

07D1:

    #07D1
    #instruction: CALL 08D1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D4;
    #return-to: 07D4
    advance (17)
    #08D1
    #instruction: IN   02
    advance (10)
    #08D3
    #instruction: AND  03
    let:8 a7 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    let:8 a8 = (03 & a7) in
    let:8 a9 = (03 | a7) in
    advance (7)
    #08D5
    #instruction: ADD  03
    let:8 a10 = a8 in
    let:16 a11 = addWithCarry(false,03,a10) in
    let:8 a12 = (03 & 0F) in
    let:8 a13 = (a10 & 0F) in
    let:16 a14 = addWithCarry(false,a12,a13) in
    advance (7)
    #08D7
    #instruction: RET
    let:8 a15 = a6[15:8] in
    let:8 a16 = a6[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a11[7:0];
    SPH := a21[15:8];
    SPL := a21[7:0];
    FlagS := a11[7:0][7];
    FlagZ := is_zero(a11[7:0]);
    FlagA := a14[7:0][4];
    FlagP := parity(a11[7:0]);
    FlagCY := a11[15:8][0];
    jump ((a22,a18));

07D4:

    #07D4
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    #07D7
    #instruction: LD   (22FF),A
    let:8 a2 = A in
    M[22FF] := a2;
    advance (13)
    #07DA
    #instruction: CALL 00D7
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 07;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := DD;
    #return-to: 07DD
    advance (17)
    #00D7
    #instruction: LD   A,02
    advance (7)
    #00D9
    #instruction: LD   (21FB),A
    M[21FB] := 02;
    advance (13)
    #00DC
    #instruction: LD   (22FB),A
    M[22FB] := 02;
    advance (13)
    #00DF
    #instruction: JP   08E4
    advance (10)
    #08E4
    #instruction: LD   A,(20CE)
    let:8 a9 = M[20CE] in
    advance (13)
    #08E7
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #08E8
    #instruction: RET  NZ
    if (!is_zero(a12)) {
      let:8 a14 = a8[15:8] in
      let:8 a15 = a8[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #08E9
      #instruction: LD   HL,391C
      advance (10)
      #08EC
      #instruction: LD   B,20
      advance (7)
      #08EE
      #instruction: JP   14CB
      advance (10)
      #14CB
      #instruction: XOR  A
      let:8 a22 = a12 in
      let:8 a23 = a12 in
      let:8 a24 = (a22 ^ a23) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:8 a25 = C in
      let:8 a26 = a8[15:8] in
      let:8 a27 = a8[7:0] in
      let:16 a28 = (-1 + (a26,a27)) in
      M[a28] := 20;
      let:8 a29 = a28[15:8] in
      let:8 a30 = a28[7:0] in
      let:16 a31 = (-1 + (a29,a30)) in
      M[a31] := a25;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      let:8 a32 = a24 in
      M[391C] := a32;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:17 a33 = add17(0020,391C) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:8 a34 = a31[15:8] in
      let:8 a35 = a31[7:0] in
      let:16 a36 = (1 + (a34,a35)) in
      let:8 a37 = M[(a34,a35)] in
      let:8 a38 = a36[15:8] in
      let:8 a39 = a36[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:8 a42 = a41 in
      let:16 a43 = addWithCarry(!true,a42,~00) in
      let:8 a44 = (a42 & 0F) in
      let:8 a45 = (~00 & 0F) in
      let:16 a46 = addWithCarry(!true,a44,a45) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a43[7:0])) {
        advance (10)
        A := a24;
        B := a43[7:0];
        C := a37;
        H := a33[15:0][15:8];
        L := a33[15:0][7:0];
        SPH := a40[15:8];
        SPL := a40[7:0];
        FlagS := a43[7:0][7];
        FlagZ := is_zero(a43[7:0]);
        FlagA := a46[7:0][4];
        FlagP := parity(a43[7:0]);
        FlagCY := a33[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:8 a47 = a40[15:8] in
        let:8 a48 = a40[7:0] in
        let:16 a49 = (1 + (a47,a48)) in
        let:8 a50 = M[(a47,a48)] in
        let:8 a51 = a49[15:8] in
        let:8 a52 = a49[7:0] in
        let:16 a53 = (1 + (a51,a52)) in
        let:8 a54 = M[(a51,a52)] in
        advance (10)
        A := a24;
        B := a43[7:0];
        C := a37;
        H := a33[15:0][15:8];
        L := a33[15:0][7:0];
        SPH := a53[15:8];
        SPL := a53[7:0];
        FlagS := a43[7:0][7];
        FlagZ := is_zero(a43[7:0]);
        FlagA := a46[7:0][4];
        FlagP := parity(a43[7:0]);
        FlagCY := a33[16];
        jump ((a54,a50));
      }
    }

07DD:

    #07DD
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #07DE
    #instruction: LD   (21FE),A
    let:8 a4 = a3 in
    M[21FE] := a4;
    advance (13)
    #07E1
    #instruction: LD   (22FE),A
    let:8 a5 = a3 in
    M[22FE] := a5;
    advance (13)
    #07E4
    #instruction: CALL 01C0
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 07;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := E7;
    #return-to: 07E7
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a12 = addWithCarry(!true,37,~00) in
    let:8 a13 = (37 & 0F) in
    let:8 a14 = (~00 & 0F) in
    let:16 a15 = addWithCarry(!true,a13,a14) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a12[7:0])) {
      advance (10)
      A := a3;
      B := a12[7:0];
      H := 21;
      L := 01;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a12[7:0][7];
      FlagZ := is_zero(a12[7:0]);
      FlagA := a15[7:0][4];
      FlagP := parity(a12[7:0]);
      FlagCY := false;
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a16 = a11[15:8] in
      let:8 a17 = a11[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a3;
      B := a12[7:0];
      H := 21;
      L := 01;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a12[7:0][7];
      FlagZ := is_zero(a12[7:0]);
      FlagA := a15[7:0][4];
      FlagP := parity(a12[7:0]);
      FlagCY := false;
      jump ((a23,a19));
    }

07E7:

    #07E7
    #instruction: CALL 1904
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := EA;
    #return-to: 07EA
    advance (17)
    #1904
    #instruction: LD   HL,2200
    advance (10)
    #1907
    #instruction: JP   01C3
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2200] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,37,~00) in
    let:8 a8 = (37 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a7[7:0])) {
      advance (10)
      B := a7[7:0];
      H := 22;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      B := a7[7:0];
      H := 22;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

07EA:

    #07EA
    #instruction: LD   HL,3878
    advance (10)
    #07ED
    #instruction: LD   (21FC),HL
    M[21FC] := 78;
    M[21FD] := 38;
    advance (16)
    #07F0
    #instruction: LD   (22FC),HL
    M[22FC] := 78;
    M[22FD] := 38;
    advance (16)
    #07F3
    #instruction: CALL 01E4
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 07F6
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,C0,~00) in
    let:8 a8 = (C0 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 01;
      B := a7[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 01;
      B := a7[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

07F6:

    #07F6
    #instruction: CALL 1A7F
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F9;
    #return-to: 07F9
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1A;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a19 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a20 = a19 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (1 + (a21,a22)) in
    let:8 a24 = M[(a21,a22)] in
    let:8 a25 = a23[15:8] in
    let:8 a26 = a23[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    advance (10)
    A := a19;
    H := a20;
    L := 00;
    SPH := a27[15:8];
    SPL := a27[7:0];
    jump ((a28,a24));

07F9:

    #07F9
    #instruction: CALL 088D
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FC;
    #return-to: 07FC
    advance (17)
    #088D
    #instruction: LD   HL,2B11
    advance (10)
    #0890
    #instruction: LD   DE,1B70
    advance (10)
    #0893
    #instruction: LD   C,0E
    advance (7)
    #0895
    #instruction: CALL 08F3
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 08;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 98;
    #return-to: 0898
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 1B;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 70;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 08;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := 2B;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := 11;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a31 = add17(000F,000F) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a32 = a31[15:0][15:8] in
    let:8 a33 = a31[15:0][7:0] in
    let:8 a34 = a31[15:0][15:8] in
    let:8 a35 = a31[15:0][7:0] in
    let:17 a36 = add17((a32,a33),(a34,a35)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a37 = a36[15:0][15:8] in
    let:8 a38 = a36[15:0][7:0] in
    let:8 a39 = a36[15:0][15:8] in
    let:8 a40 = a36[15:0][7:0] in
    let:17 a41 = add17((a37,a38),(a39,a40)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a42 = a41[15:0][15:8] in
    let:8 a43 = a41[15:0][7:0] in
    let:17 a44 = add17(1E00,(a42,a43)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a45 = a44[15:0][15:8] in
    let:8 a46 = a44[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a47 = a30[15:8] in
    let:8 a48 = a30[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    let:8 a51 = a49[15:8] in
    let:8 a52 = a49[7:0] in
    let:16 a53 = (1 + (a51,a52)) in
    let:8 a54 = M[(a51,a52)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,0F);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a55 = a53[15:8] in
    let:8 a56 = a53[7:0] in
    let:16 a57 = (-1 + (a55,a56)) in
    M[a57] := 08;
    let:8 a58 = a57[15:8] in
    let:8 a59 = a57[7:0] in
    let:16 a60 = (-1 + (a58,a59)) in
    M[a60] := 0E;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a61 = a45 in
    let:8 a62 = a46 in
    let:8 a63 = M[(a61,a62)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a64 = a63 in
    let:8 a65 = a54 in
    let:8 a66 = a50 in
    M[(a65,a66)] := a64;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a67 = a45 in
    let:8 a68 = a46 in
    let:16 a69 = (1 + (a67,a68)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a70 = a54 in
    let:8 a71 = a50 in
    let:17 a72 = add17(0020,(a70,a71)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a73 = a60[15:8] in
    let:8 a74 = a60[7:0] in
    let:16 a75 = (1 + (a73,a74)) in
    let:8 a76 = M[(a73,a74)] in
    let:8 a77 = a75[15:8] in
    let:8 a78 = a75[7:0] in
    let:16 a79 = (1 + (a77,a78)) in
    let:8 a80 = M[(a77,a78)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a81 = a80 in
    let:16 a82 = addWithCarry(!true,a81,~00) in
    let:8 a83 = (a81 & 0F) in
    let:8 a84 = (~00 & 0F) in
    let:16 a85 = addWithCarry(!true,a83,a84) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a82[7:0])) {
      advance (10)
      A := a63;
      B := a82[7:0];
      C := a76;
      D := a69[15:8];
      E := a69[7:0];
      H := a72[15:0][15:8];
      L := a72[15:0][7:0];
      SPH := a79[15:8];
      SPL := a79[7:0];
      FlagS := a82[7:0][7];
      FlagZ := is_zero(a82[7:0]);
      FlagA := a85[7:0][4];
      FlagP := parity(a82[7:0]);
      FlagCY := a72[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a86 = a79[15:8] in
      let:8 a87 = a79[7:0] in
      let:16 a88 = (1 + (a86,a87)) in
      let:8 a89 = M[(a86,a87)] in
      let:8 a90 = a88[15:8] in
      let:8 a91 = a88[7:0] in
      let:16 a92 = (1 + (a90,a91)) in
      let:8 a93 = M[(a90,a91)] in
      advance (10)
      A := a63;
      B := a82[7:0];
      C := a76;
      D := a69[15:8];
      E := a69[7:0];
      H := a72[15:0][15:8];
      L := a72[15:0][7:0];
      SPH := a92[15:8];
      SPL := a92[7:0];
      FlagS := a82[7:0][7];
      FlagZ := is_zero(a82[7:0]);
      FlagA := a85[7:0][4];
      FlagP := parity(a82[7:0]);
      FlagCY := a72[16];
      jump ((a93,a89));
    }

07FC:

    #07FC
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 07;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FF;
    #return-to: 07FF
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = (1F & 03) in
    let:8 a8 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a9 = a7 in
    let:16 a10 = addWithCarry(!false,a9,~1C) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a18 = a6[15:8] in
        let:8 a19 = a6[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a25,a21));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a26 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a27 = a26[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a28 = a27 in
      let:16 a29 = addWithCarry(!false,a28,~40) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~40 & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a29[15:8][0]) {
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a33 = a6[15:8] in
        let:8 a34 = a6[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump ((a40,a36));
      }
    }

07FF:

    #07FF
    #instruction: NOP
    advance (4)
    #0800
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0801
    #instruction: LD   (20C1),A
    let:8 a4 = a3 in
    M[20C1] := a4;
    advance (13)
    #0804
    #instruction: CALL 01CF
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 08;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:8 a11 = C in
    let:8 a12 = a10[15:8] in
    let:8 a13 = a10[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := E0;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := a11;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    let:8 a23 = a21[15:8] in
    let:8 a24 = a21[7:0] in
    let:16 a25 = (1 + (a23,a24)) in
    let:8 a26 = M[(a23,a24)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a27 = a26 in
    let:16 a28 = addWithCarry(!true,a27,~00) in
    let:8 a29 = (a27 & 0F) in
    let:8 a30 = (~00 & 0F) in
    let:16 a31 = addWithCarry(!true,a29,a30) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a28[7:0])) {
      advance (10)
      A := 01;
      B := a28[7:0];
      C := a22;
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a28[7:0][7];
      FlagZ := is_zero(a28[7:0]);
      FlagA := a31[7:0][4];
      FlagP := parity(a28[7:0]);
      FlagCY := a18[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a32 = a25[15:8] in
      let:8 a33 = a25[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      A := 01;
      B := a28[7:0];
      C := a22;
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a38[15:8];
      SPL := a38[7:0];
      FlagS := a28[7:0][7];
      FlagZ := is_zero(a28[7:0]);
      FlagA := a31[7:0][4];
      FlagP := parity(a28[7:0]);
      FlagCY := a18[16];
      jump ((a39,a35));
    }

0807:

    #0807
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #080A
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #080B
    #instruction: JP   CY,0872
    if (a2[0]) {
      advance (10)
      #0872
      #instruction: CALL 021A
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (-1 + (a3,a4)) in
      M[a5] := 08;
      let:8 a6 = a5[15:8] in
      let:8 a7 = a5[7:0] in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 75;
      #return-to: 0875
      advance (17)
      #021A
      #instruction: XOR  A
      let:8 a9 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a10 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a11 = (a9 ^ a10) in
      advance (4)
      #021B
      #instruction: LD   DE,2142
      advance (10)
      #021E
      #instruction: LD   (2081),A
      let:8 a12 = a11 in
      M[2081] := a12;
      advance (13)
      #0221
      #instruction: LD   BC,1602
      advance (10)
      #0224
      #instruction: LD   HL,2806
      advance (10)
      #0227
      #instruction: LD   A,04
      advance (7)
      #0229
      #instruction: PUSH PSW
      let:8 a13 = a8[15:8] in
      let:8 a14 = a8[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 04;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a11[7]),6,is_zero(a11)),4,false),2,parity(a11)),0,false);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:8 a19 = a18[15:8] in
      let:8 a20 = a18[7:0] in
      let:16 a21 = (-1 + (a19,a20)) in
      M[a21] := 16;
      let:8 a22 = a21[15:8] in
      let:8 a23 = a21[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 02;
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      let:8 a25 = M[2081] in
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a26 = a25 in
      let:8 a27 = a25 in
      let:8 a28 = (a26 & a27) in
      let:8 a29 = (a26 | a27) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a28)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:8 a30 = a24[15:8] in
        let:8 a31 = a24[7:0] in
        let:16 a32 = (-1 + (a30,a31)) in
        M[a32] := 02;
        let:8 a33 = a32[15:8] in
        let:8 a34 = a32[7:0] in
        let:16 a35 = (-1 + (a33,a34)) in
        M[a35] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:8 a36 = a35[15:8] in
        let:8 a37 = a35[7:0] in
        let:16 a38 = (-1 + (a36,a37)) in
        M[a38] := 16;
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := 02;
        advance (11)
        #147D
        #instruction: PUSH HL
        let:8 a42 = a41[15:8] in
        let:8 a43 = a41[7:0] in
        let:16 a44 = (-1 + (a42,a43)) in
        M[a44] := 28;
        let:8 a45 = a44[15:8] in
        let:8 a46 = a44[7:0] in
        let:16 a47 = (-1 + (a45,a46)) in
        M[a47] := 06;
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        let:8 a48 = M[2806] in
        advance (7)
        #147F
        #instruction: LD   (DE),A
        let:8 a49 = a48 in
        M[2142] := a49;
        advance (7)
        #1480
        #instruction: INC  DE
        advance (5)
        #1481
        #instruction: INC  HL
        advance (5)
        #1482
        #instruction: DEC  C
        let:16 a50 = addWithCarry(!true,02,~00) in
        let:8 a51 = (02 & 0F) in
        let:8 a52 = (~00 & 0F) in
        let:16 a53 = addWithCarry(!true,a51,a52) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a50[7:0])) {
          advance (10)
          A := a48;
          B := 16;
          C := a50[7:0];
          D := 21;
          E := 43;
          H := 28;
          L := 07;
          SPH := a47[15:8];
          SPL := a47[7:0];
          FlagS := a50[7:0][7];
          FlagZ := is_zero(a50[7:0]);
          FlagA := a53[7:0][4];
          FlagP := parity(a50[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:8 a54 = a47[15:8] in
          let:8 a55 = a47[7:0] in
          let:16 a56 = (1 + (a54,a55)) in
          let:8 a57 = M[(a54,a55)] in
          let:8 a58 = a56[15:8] in
          let:8 a59 = a56[7:0] in
          let:16 a60 = (1 + (a58,a59)) in
          let:8 a61 = M[(a58,a59)] in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:8 a62 = a61 in
          let:8 a63 = a57 in
          let:17 a64 = add17(0020,(a62,a63)) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:8 a65 = a60[15:8] in
          let:8 a66 = a60[7:0] in
          let:16 a67 = (1 + (a65,a66)) in
          let:8 a68 = M[(a65,a66)] in
          let:8 a69 = a67[15:8] in
          let:8 a70 = a67[7:0] in
          let:16 a71 = (1 + (a69,a70)) in
          let:8 a72 = M[(a69,a70)] in
          advance (10)
          #148C
          #instruction: DEC  B
          let:8 a73 = a72 in
          let:16 a74 = addWithCarry(!true,a73,~00) in
          let:8 a75 = (a73 & 0F) in
          let:8 a76 = (~00 & 0F) in
          let:16 a77 = addWithCarry(!true,a75,a76) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a74[7:0])) {
            advance (10)
            A := a48;
            B := a74[7:0];
            C := a68;
            D := 21;
            E := 43;
            H := a64[15:0][15:8];
            L := a64[15:0][7:0];
            SPH := a71[15:8];
            SPL := a71[7:0];
            FlagS := a74[7:0][7];
            FlagZ := is_zero(a74[7:0]);
            FlagA := a77[7:0][4];
            FlagP := parity(a74[7:0]);
            FlagCY := a64[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:8 a78 = a71[15:8] in
            let:8 a79 = a71[7:0] in
            let:16 a80 = (1 + (a78,a79)) in
            let:8 a81 = M[(a78,a79)] in
            let:8 a82 = a80[15:8] in
            let:8 a83 = a80[7:0] in
            let:16 a84 = (1 + (a82,a83)) in
            let:8 a85 = M[(a82,a83)] in
            advance (10)
            A := a48;
            B := a74[7:0];
            C := a68;
            D := 21;
            E := 43;
            H := a64[15:0][15:8];
            L := a64[15:0][7:0];
            SPH := a84[15:8];
            SPL := a84[7:0];
            FlagS := a74[7:0][7];
            FlagZ := is_zero(a74[7:0]);
            FlagA := a77[7:0][4];
            FlagP := parity(a74[7:0]);
            FlagCY := a64[16];
            jump ((a85,a81));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:8 a86 = a24[15:8] in
        let:8 a87 = a24[7:0] in
        let:16 a88 = (-1 + (a86,a87)) in
        M[a88] := 02;
        let:8 a89 = a88[15:8] in
        let:8 a90 = a88[7:0] in
        let:16 a91 = (-1 + (a89,a90)) in
        M[a91] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:8 a92 = a91[15:8] in
        let:8 a93 = a91[7:0] in
        let:16 a94 = (-1 + (a92,a93)) in
        M[a94] := 16;
        let:8 a95 = a94[15:8] in
        let:8 a96 = a94[7:0] in
        let:16 a97 = (-1 + (a95,a96)) in
        M[a97] := 02;
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:8 a98 = a97[15:8] in
        let:8 a99 = a97[7:0] in
        let:16 a100 = (-1 + (a98,a99)) in
        M[a100] := 28;
        let:8 a101 = a100[15:8] in
        let:8 a102 = a100[7:0] in
        let:16 a103 = (-1 + (a101,a102)) in
        M[a103] := 06;
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        let:8 a104 = M[2142] in
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a105 = M[2806] in
        let:8 a106 = a104 in
        let:8 a107 = (a105 | a106) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        let:8 a108 = a107 in
        M[2806] := a108;
        advance (7)
        #1A6E
        #instruction: INC  DE
        advance (5)
        #1A6F
        #instruction: INC  HL
        advance (5)
        #1A70
        #instruction: DEC  C
        let:16 a109 = addWithCarry(!true,02,~00) in
        let:8 a110 = (02 & 0F) in
        let:8 a111 = (~00 & 0F) in
        let:16 a112 = addWithCarry(!true,a110,a111) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a109[7:0])) {
          advance (10)
          A := a107;
          B := 16;
          C := a109[7:0];
          D := 21;
          E := 43;
          H := 28;
          L := 07;
          SPH := a103[15:8];
          SPL := a103[7:0];
          FlagS := a109[7:0][7];
          FlagZ := is_zero(a109[7:0]);
          FlagA := a112[7:0][4];
          FlagP := parity(a109[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:8 a113 = a103[15:8] in
          let:8 a114 = a103[7:0] in
          let:16 a115 = (1 + (a113,a114)) in
          let:8 a116 = M[(a113,a114)] in
          let:8 a117 = a115[15:8] in
          let:8 a118 = a115[7:0] in
          let:16 a119 = (1 + (a117,a118)) in
          let:8 a120 = M[(a117,a118)] in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:8 a121 = a120 in
          let:8 a122 = a116 in
          let:17 a123 = add17(0020,(a121,a122)) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:8 a124 = a119[15:8] in
          let:8 a125 = a119[7:0] in
          let:16 a126 = (1 + (a124,a125)) in
          let:8 a127 = M[(a124,a125)] in
          let:8 a128 = a126[15:8] in
          let:8 a129 = a126[7:0] in
          let:16 a130 = (1 + (a128,a129)) in
          let:8 a131 = M[(a128,a129)] in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:8 a132 = a131 in
          let:16 a133 = addWithCarry(!true,a132,~00) in
          let:8 a134 = (a132 & 0F) in
          let:8 a135 = (~00 & 0F) in
          let:16 a136 = addWithCarry(!true,a134,a135) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a133[7:0])) {
            advance (10)
            A := a107;
            B := a133[7:0];
            C := a127;
            D := 21;
            E := 43;
            H := a123[15:0][15:8];
            L := a123[15:0][7:0];
            SPH := a130[15:8];
            SPL := a130[7:0];
            FlagS := a133[7:0][7];
            FlagZ := is_zero(a133[7:0]);
            FlagA := a136[7:0][4];
            FlagP := parity(a133[7:0]);
            FlagCY := a123[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:8 a137 = a130[15:8] in
            let:8 a138 = a130[7:0] in
            let:16 a139 = (1 + (a137,a138)) in
            let:8 a140 = M[(a137,a138)] in
            let:8 a141 = a139[15:8] in
            let:8 a142 = a139[7:0] in
            let:16 a143 = (1 + (a141,a142)) in
            let:8 a144 = M[(a141,a142)] in
            advance (10)
            A := a107;
            B := a133[7:0];
            C := a127;
            D := 21;
            E := 43;
            H := a123[15:0][15:8];
            L := a123[15:0][7:0];
            SPH := a143[15:8];
            SPL := a143[7:0];
            FlagS := a133[7:0][7];
            FlagZ := is_zero(a133[7:0]);
            FlagA := a136[7:0][4];
            FlagP := parity(a133[7:0]);
            FlagCY := a123[16];
            jump ((a144,a140));
          }
        }
      }
    } else {
      advance (10)
      #080E
      #instruction: CALL 0213
      let:8 a145 = SPH in
      let:8 a146 = SPL in
      let:16 a147 = (-1 + (a145,a146)) in
      M[a147] := 08;
      let:8 a148 = a147[15:8] in
      let:8 a149 = a147[7:0] in
      let:16 a150 = (-1 + (a148,a149)) in
      M[a150] := 11;
      #return-to: 0811
      advance (17)
      #0213
      #instruction: XOR  A
      let:8 a151 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a152 = updateBit((a2 >> 01),7,a2[0]) in
      let:8 a153 = (a151 ^ a152) in
      advance (4)
      #0214
      #instruction: LD   DE,2242
      advance (10)
      #0217
      #instruction: JP   021E
      advance (10)
      #021E
      #instruction: LD   (2081),A
      let:8 a154 = a153 in
      M[2081] := a154;
      advance (13)
      #0221
      #instruction: LD   BC,1602
      advance (10)
      #0224
      #instruction: LD   HL,2806
      advance (10)
      #0227
      #instruction: LD   A,04
      advance (7)
      #0229
      #instruction: PUSH PSW
      let:8 a155 = a150[15:8] in
      let:8 a156 = a150[7:0] in
      let:16 a157 = (-1 + (a155,a156)) in
      M[a157] := 04;
      let:8 a158 = a157[15:8] in
      let:8 a159 = a157[7:0] in
      let:16 a160 = (-1 + (a158,a159)) in
      M[a160] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a153[7]),6,is_zero(a153)),4,false),2,parity(a153)),0,false);
      advance (11)
      #022A
      #instruction: PUSH BC
      let:8 a161 = a160[15:8] in
      let:8 a162 = a160[7:0] in
      let:16 a163 = (-1 + (a161,a162)) in
      M[a163] := 16;
      let:8 a164 = a163[15:8] in
      let:8 a165 = a163[7:0] in
      let:16 a166 = (-1 + (a164,a165)) in
      M[a166] := 02;
      advance (11)
      #022B
      #instruction: LD   A,(2081)
      let:8 a167 = M[2081] in
      advance (13)
      #022E
      #instruction: AND  A
      let:8 a168 = a167 in
      let:8 a169 = a167 in
      let:8 a170 = (a168 & a169) in
      let:8 a171 = (a168 | a169) in
      advance (4)
      #022F
      #instruction: JP   NZ,0242
      if (!is_zero(a170)) {
        advance (10)
        #0242
        #instruction: CALL 147C
        let:8 a172 = a166[15:8] in
        let:8 a173 = a166[7:0] in
        let:16 a174 = (-1 + (a172,a173)) in
        M[a174] := 02;
        let:8 a175 = a174[15:8] in
        let:8 a176 = a174[7:0] in
        let:16 a177 = (-1 + (a175,a176)) in
        M[a177] := 45;
        #return-to: 0245
        advance (17)
        #147C
        #instruction: PUSH BC
        let:8 a178 = a177[15:8] in
        let:8 a179 = a177[7:0] in
        let:16 a180 = (-1 + (a178,a179)) in
        M[a180] := 16;
        let:8 a181 = a180[15:8] in
        let:8 a182 = a180[7:0] in
        let:16 a183 = (-1 + (a181,a182)) in
        M[a183] := 02;
        advance (11)
        #147D
        #instruction: PUSH HL
        let:8 a184 = a183[15:8] in
        let:8 a185 = a183[7:0] in
        let:16 a186 = (-1 + (a184,a185)) in
        M[a186] := 28;
        let:8 a187 = a186[15:8] in
        let:8 a188 = a186[7:0] in
        let:16 a189 = (-1 + (a187,a188)) in
        M[a189] := 06;
        advance (11)
        #147E
        #instruction: LD   A,(HL)
        let:8 a190 = M[2806] in
        advance (7)
        #147F
        #instruction: LD   (DE),A
        let:8 a191 = a190 in
        M[2242] := a191;
        advance (7)
        #1480
        #instruction: INC  DE
        advance (5)
        #1481
        #instruction: INC  HL
        advance (5)
        #1482
        #instruction: DEC  C
        let:16 a192 = addWithCarry(!true,02,~00) in
        let:8 a193 = (02 & 0F) in
        let:8 a194 = (~00 & 0F) in
        let:16 a195 = addWithCarry(!true,a193,a194) in
        advance (5)
        #1483
        #instruction: JP   NZ,147E
        if (!is_zero(a192[7:0])) {
          advance (10)
          A := a190;
          B := 16;
          C := a192[7:0];
          D := 22;
          E := 43;
          H := 28;
          L := 07;
          SPH := a189[15:8];
          SPL := a189[7:0];
          FlagS := a192[7:0][7];
          FlagZ := is_zero(a192[7:0]);
          FlagA := a195[7:0][4];
          FlagP := parity(a192[7:0]);
          FlagCY := false;
          jump (147E);
        } else {
          advance (10)
          #1486
          #instruction: POP  HL
          let:8 a196 = a189[15:8] in
          let:8 a197 = a189[7:0] in
          let:16 a198 = (1 + (a196,a197)) in
          let:8 a199 = M[(a196,a197)] in
          let:8 a200 = a198[15:8] in
          let:8 a201 = a198[7:0] in
          let:16 a202 = (1 + (a200,a201)) in
          let:8 a203 = M[(a200,a201)] in
          advance (10)
          #1487
          #instruction: LD   BC,0020
          advance (10)
          #148A
          #instruction: ADD  HL,BC
          let:8 a204 = a203 in
          let:8 a205 = a199 in
          let:17 a206 = add17(0020,(a204,a205)) in
          advance (10)
          #148B
          #instruction: POP  BC
          let:8 a207 = a202[15:8] in
          let:8 a208 = a202[7:0] in
          let:16 a209 = (1 + (a207,a208)) in
          let:8 a210 = M[(a207,a208)] in
          let:8 a211 = a209[15:8] in
          let:8 a212 = a209[7:0] in
          let:16 a213 = (1 + (a211,a212)) in
          let:8 a214 = M[(a211,a212)] in
          advance (10)
          #148C
          #instruction: DEC  B
          let:8 a215 = a214 in
          let:16 a216 = addWithCarry(!true,a215,~00) in
          let:8 a217 = (a215 & 0F) in
          let:8 a218 = (~00 & 0F) in
          let:16 a219 = addWithCarry(!true,a217,a218) in
          advance (5)
          #148D
          #instruction: JP   NZ,147C
          if (!is_zero(a216[7:0])) {
            advance (10)
            A := a190;
            B := a216[7:0];
            C := a210;
            D := 22;
            E := 43;
            H := a206[15:0][15:8];
            L := a206[15:0][7:0];
            SPH := a213[15:8];
            SPL := a213[7:0];
            FlagS := a216[7:0][7];
            FlagZ := is_zero(a216[7:0]);
            FlagA := a219[7:0][4];
            FlagP := parity(a216[7:0]);
            FlagCY := a206[16];
            jump (147C);
          } else {
            advance (10)
            #1490
            #instruction: RET
            let:8 a220 = a213[15:8] in
            let:8 a221 = a213[7:0] in
            let:16 a222 = (1 + (a220,a221)) in
            let:8 a223 = M[(a220,a221)] in
            let:8 a224 = a222[15:8] in
            let:8 a225 = a222[7:0] in
            let:16 a226 = (1 + (a224,a225)) in
            let:8 a227 = M[(a224,a225)] in
            advance (10)
            A := a190;
            B := a216[7:0];
            C := a210;
            D := 22;
            E := 43;
            H := a206[15:0][15:8];
            L := a206[15:0][7:0];
            SPH := a226[15:8];
            SPL := a226[7:0];
            FlagS := a216[7:0][7];
            FlagZ := is_zero(a216[7:0]);
            FlagA := a219[7:0][4];
            FlagP := parity(a216[7:0]);
            FlagCY := a206[16];
            jump ((a227,a223));
          }
        }
      } else {
        advance (10)
        #0232
        #instruction: CALL 1A69
        let:8 a228 = a166[15:8] in
        let:8 a229 = a166[7:0] in
        let:16 a230 = (-1 + (a228,a229)) in
        M[a230] := 02;
        let:8 a231 = a230[15:8] in
        let:8 a232 = a230[7:0] in
        let:16 a233 = (-1 + (a231,a232)) in
        M[a233] := 35;
        #return-to: 0235
        advance (17)
        #1A69
        #instruction: PUSH BC
        let:8 a234 = a233[15:8] in
        let:8 a235 = a233[7:0] in
        let:16 a236 = (-1 + (a234,a235)) in
        M[a236] := 16;
        let:8 a237 = a236[15:8] in
        let:8 a238 = a236[7:0] in
        let:16 a239 = (-1 + (a237,a238)) in
        M[a239] := 02;
        advance (11)
        #1A6A
        #instruction: PUSH HL
        let:8 a240 = a239[15:8] in
        let:8 a241 = a239[7:0] in
        let:16 a242 = (-1 + (a240,a241)) in
        M[a242] := 28;
        let:8 a243 = a242[15:8] in
        let:8 a244 = a242[7:0] in
        let:16 a245 = (-1 + (a243,a244)) in
        M[a245] := 06;
        advance (11)
        #1A6B
        #instruction: LD   A,(DE)
        let:8 a246 = M[2242] in
        advance (7)
        #1A6C
        #instruction: OR   (HL)
        let:8 a247 = M[2806] in
        let:8 a248 = a246 in
        let:8 a249 = (a247 | a248) in
        advance (7)
        #1A6D
        #instruction: LD   (HL),A
        let:8 a250 = a249 in
        M[2806] := a250;
        advance (7)
        #1A6E
        #instruction: INC  DE
        advance (5)
        #1A6F
        #instruction: INC  HL
        advance (5)
        #1A70
        #instruction: DEC  C
        let:16 a251 = addWithCarry(!true,02,~00) in
        let:8 a252 = (02 & 0F) in
        let:8 a253 = (~00 & 0F) in
        let:16 a254 = addWithCarry(!true,a252,a253) in
        advance (5)
        #1A71
        #instruction: JP   NZ,1A6B
        if (!is_zero(a251[7:0])) {
          advance (10)
          A := a249;
          B := 16;
          C := a251[7:0];
          D := 22;
          E := 43;
          H := 28;
          L := 07;
          SPH := a245[15:8];
          SPL := a245[7:0];
          FlagS := a251[7:0][7];
          FlagZ := is_zero(a251[7:0]);
          FlagA := a254[7:0][4];
          FlagP := parity(a251[7:0]);
          FlagCY := false;
          jump (1A6B);
        } else {
          advance (10)
          #1A74
          #instruction: POP  HL
          let:8 a255 = a245[15:8] in
          let:8 a256 = a245[7:0] in
          let:16 a257 = (1 + (a255,a256)) in
          let:8 a258 = M[(a255,a256)] in
          let:8 a259 = a257[15:8] in
          let:8 a260 = a257[7:0] in
          let:16 a261 = (1 + (a259,a260)) in
          let:8 a262 = M[(a259,a260)] in
          advance (10)
          #1A75
          #instruction: LD   BC,0020
          advance (10)
          #1A78
          #instruction: ADD  HL,BC
          let:8 a263 = a262 in
          let:8 a264 = a258 in
          let:17 a265 = add17(0020,(a263,a264)) in
          advance (10)
          #1A79
          #instruction: POP  BC
          let:8 a266 = a261[15:8] in
          let:8 a267 = a261[7:0] in
          let:16 a268 = (1 + (a266,a267)) in
          let:8 a269 = M[(a266,a267)] in
          let:8 a270 = a268[15:8] in
          let:8 a271 = a268[7:0] in
          let:16 a272 = (1 + (a270,a271)) in
          let:8 a273 = M[(a270,a271)] in
          advance (10)
          #1A7A
          #instruction: DEC  B
          let:8 a274 = a273 in
          let:16 a275 = addWithCarry(!true,a274,~00) in
          let:8 a276 = (a274 & 0F) in
          let:8 a277 = (~00 & 0F) in
          let:16 a278 = addWithCarry(!true,a276,a277) in
          advance (5)
          #1A7B
          #instruction: JP   NZ,1A69
          if (!is_zero(a275[7:0])) {
            advance (10)
            A := a249;
            B := a275[7:0];
            C := a269;
            D := 22;
            E := 43;
            H := a265[15:0][15:8];
            L := a265[15:0][7:0];
            SPH := a272[15:8];
            SPL := a272[7:0];
            FlagS := a275[7:0][7];
            FlagZ := is_zero(a275[7:0]);
            FlagA := a278[7:0][4];
            FlagP := parity(a275[7:0]);
            FlagCY := a265[16];
            jump (1A69);
          } else {
            advance (10)
            #1A7E
            #instruction: RET
            let:8 a279 = a272[15:8] in
            let:8 a280 = a272[7:0] in
            let:16 a281 = (1 + (a279,a280)) in
            let:8 a282 = M[(a279,a280)] in
            let:8 a283 = a281[15:8] in
            let:8 a284 = a281[7:0] in
            let:16 a285 = (1 + (a283,a284)) in
            let:8 a286 = M[(a283,a284)] in
            advance (10)
            A := a249;
            B := a275[7:0];
            C := a269;
            D := 22;
            E := 43;
            H := a265[15:0][15:8];
            L := a265[15:0][7:0];
            SPH := a285[15:8];
            SPL := a285[7:0];
            FlagS := a275[7:0][7];
            FlagZ := is_zero(a275[7:0]);
            FlagA := a278[7:0][4];
            FlagP := parity(a275[7:0]);
            FlagCY := a265[16];
            jump ((a286,a282));
          }
        }
      }
    }

0811:

    #0811
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 14;
    #return-to: 0814
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:8 a7 = C in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := E0;
    let:8 a11 = a10[15:8] in
    let:8 a12 = a10[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a7;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a14 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a23 = a22 in
    let:16 a24 = addWithCarry(!true,a23,~00) in
    let:8 a25 = (a23 & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a24[7:0])) {
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a28 = a21[15:8] in
      let:8 a29 = a21[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump ((a35,a31));
    }

0814:

    #0814
    #instruction: CALL 00B1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    #return-to: 0817
    advance (17)
    #00B1
    #instruction: CALL 0886
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 00;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := B4;
    #return-to: 00B4
    advance (17)
    #0886
    #instruction: LD   A,(2067)
    let:8 a13 = M[2067] in
    advance (13)
    #0889
    #instruction: LD   H,A
    let:8 a14 = a13 in
    advance (5)
    #088A
    #instruction: LD   L,FC
    advance (7)
    #088C
    #instruction: RET
    let:8 a15 = a12[15:8] in
    let:8 a16 = a12[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a13;
    H := a14;
    L := FC;
    SPH := a21[15:8];
    SPL := a21[7:0];
    jump ((a22,a18));

0817:

    #0817
    #instruction: CALL 19D1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 1A;
    #return-to: 081A
    advance (17)
    #19D1
    #instruction: LD   A,01
    advance (7)
    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := 01;
    advance (13)
    #19D6
    #instruction: RET
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := 01;
    SPH := a13[15:8];
    SPL := a13[7:0];
    jump ((a14,a10));

081A:

    #081A
    #instruction: LD   B,20
    advance (7)
    #081C
    #instruction: CALL 18FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 1F;
    #return-to: 081F
    advance (17)
    #18FA
    #instruction: LD   A,(2094)
    let:8 a7 = M[2094] in
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a8 = a7 in
    let:8 a9 = (20 | a8) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    let:8 a10 = a9 in
    M[2094] := a10;
    advance (13)
    #1901
    #instruction: OUT  03
    let:8 a11 = a9 in
    sound_control(Ufo,a11[0]);
    sound_control(Shot,a11[1]);
    sound_control(PlayerDie,a11[2]);
    sound_control(InvaderDie,a11[3]);
    sound_control(ExtraLife,a11[4]);
    advance (10)
    #1903
    #instruction: RET
    let:8 a12 = a6[15:8] in
    let:8 a13 = a6[7:0] in
    let:16 a14 = (1 + (a12,a13)) in
    let:8 a15 = M[(a12,a13)] in
    let:8 a16 = a14[15:8] in
    let:8 a17 = a14[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    let:8 a19 = M[(a16,a17)] in
    advance (10)
    A := a9;
    B := 20;
    SPH := a18[15:8];
    SPL := a18[7:0];
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := false;
    FlagP := parity(a9);
    FlagCY := false;
    jump ((a19,a15));

081F:

    #081F
    #instruction: CALL 1618
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 22;
    #return-to: 0822
    advance (17)
    #1618
    #instruction: LD   A,(2015)
    let:8 a7 = M[2015] in
    advance (13)
    #161B
    #instruction: CP   FF
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~FF) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~FF & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #161D
    #instruction: RET  NZ
    if (!is_zero(a9[7:0])) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #161E
      #instruction: LD   HL,2010
      advance (10)
      #1621
      #instruction: LD   A,(HL)
      let:8 a21 = M[2010] in
      advance (7)
      #1622
      #instruction: INC  HL
      advance (5)
      #1623
      #instruction: LD   B,(HL)
      let:8 a22 = M[2011] in
      advance (7)
      #1624
      #instruction: OR   B
      let:8 a23 = a22 in
      let:8 a24 = a21 in
      let:8 a25 = (a23 | a24) in
      advance (4)
      #1625
      #instruction: RET  NZ
      if (!is_zero(a25)) {
        let:8 a26 = a6[15:8] in
        let:8 a27 = a6[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        advance (11)
        A := a25;
        B := a22;
        H := 20;
        L := 11;
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a25[7];
        FlagZ := is_zero(a25);
        FlagA := false;
        FlagP := parity(a25);
        FlagCY := false;
        jump ((a33,a29));
      } else {
        advance (5)
        #1626
        #instruction: LD   A,(2025)
        let:8 a34 = M[2025] in
        advance (13)
        #1629
        #instruction: AND  A
        let:8 a35 = a34 in
        let:8 a36 = a34 in
        let:8 a37 = (a35 & a36) in
        let:8 a38 = (a35 | a36) in
        advance (4)
        #162A
        #instruction: RET  NZ
        if (!is_zero(a37)) {
          let:8 a39 = a6[15:8] in
          let:8 a40 = a6[7:0] in
          let:16 a41 = (1 + (a39,a40)) in
          let:8 a42 = M[(a39,a40)] in
          let:8 a43 = a41[15:8] in
          let:8 a44 = a41[7:0] in
          let:16 a45 = (1 + (a43,a44)) in
          let:8 a46 = M[(a43,a44)] in
          advance (11)
          A := a37;
          B := a22;
          H := 20;
          L := 11;
          SPH := a45[15:8];
          SPL := a45[7:0];
          FlagS := a37[7];
          FlagZ := is_zero(a37);
          FlagA := a38[3];
          FlagP := parity(a37);
          FlagCY := false;
          jump ((a46,a42));
        } else {
          advance (5)
          #162B
          #instruction: LD   A,(20EF)
          let:8 a47 = M[20EF] in
          advance (13)
          #162E
          #instruction: AND  A
          let:8 a48 = a47 in
          let:8 a49 = a47 in
          let:8 a50 = (a48 & a49) in
          let:8 a51 = (a48 | a49) in
          advance (4)
          #162F
          #instruction: JP   Z,1652
          if (is_zero(a50)) {
            advance (10)
            #1652
            #instruction: LD   HL,2025
            advance (10)
            #1655
            #instruction: LD   (HL),01
            M[2025] := 01;
            advance (10)
            #1657
            #instruction: LD   HL,(20ED)
            let:8 a52 = M[20ED] in
            let:8 a53 = M[20EE] in
            advance (16)
            #165A
            #instruction: INC  HL
            let:8 a54 = a53 in
            let:8 a55 = a52 in
            let:16 a56 = (1 + (a54,a55)) in
            advance (5)
            #165B
            #instruction: LD   A,L
            let:8 a57 = a56[7:0] in
            advance (5)
            #165C
            #instruction: CP   7E
            let:8 a58 = a57 in
            let:16 a59 = addWithCarry(!false,a58,~7E) in
            let:8 a60 = (a58 & 0F) in
            let:8 a61 = (~7E & 0F) in
            let:16 a62 = addWithCarry(!false,a60,a61) in
            advance (7)
            #165E
            #instruction: JP   CY,1663
            if (!a59[15:8][0]) {
              advance (10)
              #1663
              #instruction: LD   (20ED),HL
              let:8 a63 = a56[7:0] in
              M[20ED] := a63;
              let:8 a64 = a56[15:8] in
              M[20EE] := a64;
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              let:8 a65 = a56[15:8] in
              let:8 a66 = a56[7:0] in
              let:8 a67 = M[(a65,a66)] in
              advance (7)
              #1667
              #instruction: LD   (201D),A
              let:8 a68 = a67 in
              M[201D] := a68;
              advance (13)
              #166A
              #instruction: RET
              let:8 a69 = a6[15:8] in
              let:8 a70 = a6[7:0] in
              let:16 a71 = (1 + (a69,a70)) in
              let:8 a72 = M[(a69,a70)] in
              let:8 a73 = a71[15:8] in
              let:8 a74 = a71[7:0] in
              let:16 a75 = (1 + (a73,a74)) in
              let:8 a76 = M[(a73,a74)] in
              advance (10)
              A := a67;
              B := a22;
              H := a56[15:8];
              L := a56[7:0];
              SPH := a75[15:8];
              SPL := a75[7:0];
              FlagS := a59[7:0][7];
              FlagZ := is_zero(a59[7:0]);
              FlagA := a62[7:0][4];
              FlagP := parity(a59[7:0]);
              FlagCY := !a59[15:8][0];
              jump ((a76,a72));
            } else {
              advance (10)
              #1661
              #instruction: LD   L,74
              advance (7)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := 74;
              let:8 a77 = a56[15:8] in
              M[20EE] := a77;
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              let:8 a78 = a56[15:8] in
              let:8 a79 = M[(a78,74)] in
              advance (7)
              #1667
              #instruction: LD   (201D),A
              let:8 a80 = a79 in
              M[201D] := a80;
              advance (13)
              #166A
              #instruction: RET
              let:8 a81 = a6[15:8] in
              let:8 a82 = a6[7:0] in
              let:16 a83 = (1 + (a81,a82)) in
              let:8 a84 = M[(a81,a82)] in
              let:8 a85 = a83[15:8] in
              let:8 a86 = a83[7:0] in
              let:16 a87 = (1 + (a85,a86)) in
              let:8 a88 = M[(a85,a86)] in
              advance (10)
              A := a79;
              B := a22;
              H := a56[15:8];
              L := 74;
              SPH := a87[15:8];
              SPL := a87[7:0];
              FlagS := a59[7:0][7];
              FlagZ := is_zero(a59[7:0]);
              FlagA := a62[7:0][4];
              FlagP := parity(a59[7:0]);
              FlagCY := !a59[15:8][0];
              jump ((a88,a84));
            }
          } else {
            advance (10)
            #1632
            #instruction: LD   A,(202D)
            let:8 a89 = M[202D] in
            advance (13)
            #1635
            #instruction: AND  A
            let:8 a90 = a89 in
            let:8 a91 = a89 in
            let:8 a92 = (a90 & a91) in
            let:8 a93 = (a90 | a91) in
            advance (4)
            #1636
            #instruction: JP   NZ,1648
            if (!is_zero(a92)) {
              advance (10)
              #1648
              #instruction: CALL 17C0
              let:8 a94 = a6[15:8] in
              let:8 a95 = a6[7:0] in
              let:16 a96 = (-1 + (a94,a95)) in
              M[a96] := 16;
              let:8 a97 = a96[15:8] in
              let:8 a98 = a96[7:0] in
              let:16 a99 = (-1 + (a97,a98)) in
              M[a99] := 4B;
              #return-to: 164B
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              let:8 a100 = M[2067] in
              advance (13)
              #17C3
              #instruction: RRCA
              let:8 a101 = a100 in
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!a101[0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:8 a102 = a99[15:8] in
                let:8 a103 = a99[7:0] in
                let:16 a104 = (1 + (a102,a103)) in
                let:8 a105 = M[(a102,a103)] in
                let:8 a106 = a104[15:8] in
                let:8 a107 = a104[7:0] in
                let:16 a108 = (1 + (a106,a107)) in
                let:8 a109 = M[(a106,a107)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := a22;
                H := 20;
                L := 11;
                SPH := a108[15:8];
                SPL := a108[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a101[0];
                jump ((a109,a105));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:8 a110 = a99[15:8] in
                let:8 a111 = a99[7:0] in
                let:16 a112 = (1 + (a110,a111)) in
                let:8 a113 = M[(a110,a111)] in
                let:8 a114 = a112[15:8] in
                let:8 a115 = a112[7:0] in
                let:16 a116 = (1 + (a114,a115)) in
                let:8 a117 = M[(a114,a115)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := a22;
                H := 20;
                L := 11;
                SPH := a116[15:8];
                SPL := a116[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a101[0];
                jump ((a117,a113));
              }
            } else {
              advance (10)
              #1639
              #instruction: CALL 17C0
              let:8 a118 = a6[15:8] in
              let:8 a119 = a6[7:0] in
              let:16 a120 = (-1 + (a118,a119)) in
              M[a120] := 16;
              let:8 a121 = a120[15:8] in
              let:8 a122 = a120[7:0] in
              let:16 a123 = (-1 + (a121,a122)) in
              M[a123] := 3C;
              #return-to: 163C
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              let:8 a124 = M[2067] in
              advance (13)
              #17C3
              #instruction: RRCA
              let:8 a125 = a124 in
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!a125[0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:8 a126 = a123[15:8] in
                let:8 a127 = a123[7:0] in
                let:16 a128 = (1 + (a126,a127)) in
                let:8 a129 = M[(a126,a127)] in
                let:8 a130 = a128[15:8] in
                let:8 a131 = a128[7:0] in
                let:16 a132 = (1 + (a130,a131)) in
                let:8 a133 = M[(a130,a131)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := a22;
                H := 20;
                L := 11;
                SPH := a132[15:8];
                SPL := a132[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a125[0];
                jump ((a133,a129));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:8 a134 = a123[15:8] in
                let:8 a135 = a123[7:0] in
                let:16 a136 = (1 + (a134,a135)) in
                let:8 a137 = M[(a134,a135)] in
                let:8 a138 = a136[15:8] in
                let:8 a139 = a136[7:0] in
                let:16 a140 = (1 + (a138,a139)) in
                let:8 a141 = M[(a138,a139)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := a22;
                H := 20;
                L := 11;
                SPH := a140[15:8];
                SPL := a140[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a125[0];
                jump ((a141,a137));
              }
            }
          }
        }
      }
    }

0822:

    #0822
    #instruction: CALL 190A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 25;
    #return-to: 0825
    advance (17)
    #190A
    #instruction: CALL 14D8
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 19;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 0D;
    #return-to: 190D
    advance (17)
    #14D8
    #instruction: LD   A,(2025)
    let:8 a13 = M[2025] in
    advance (13)
    #14DB
    #instruction: CP   05
    let:8 a14 = a13 in
    let:16 a15 = addWithCarry(!false,a14,~05) in
    let:8 a16 = (a14 & 0F) in
    let:8 a17 = (~05 & 0F) in
    let:16 a18 = addWithCarry(!false,a16,a17) in
    advance (7)
    #14DD
    #instruction: RET  Z
    if (is_zero(a15[7:0])) {
      let:8 a19 = a12[15:8] in
      let:8 a20 = a12[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      let:8 a23 = a21[15:8] in
      let:8 a24 = a21[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      advance (11)
      A := a13;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      FlagCY := !a15[15:8][0];
      jump ((a26,a22));
    } else {
      advance (5)
      #14DE
      #instruction: CP   02
      let:8 a27 = a13 in
      let:16 a28 = addWithCarry(!false,a27,~02) in
      let:8 a29 = (a27 & 0F) in
      let:8 a30 = (~02 & 0F) in
      let:16 a31 = addWithCarry(!false,a29,a30) in
      advance (7)
      #14E0
      #instruction: RET  NZ
      if (!is_zero(a28[7:0])) {
        let:8 a32 = a12[15:8] in
        let:8 a33 = a12[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        let:8 a36 = a34[15:8] in
        let:8 a37 = a34[7:0] in
        let:16 a38 = (1 + (a36,a37)) in
        let:8 a39 = M[(a36,a37)] in
        advance (11)
        A := a13;
        SPH := a38[15:8];
        SPL := a38[7:0];
        FlagS := a28[7:0][7];
        FlagZ := is_zero(a28[7:0]);
        FlagA := a31[7:0][4];
        FlagP := parity(a28[7:0]);
        FlagCY := !a28[15:8][0];
        jump ((a39,a35));
      } else {
        advance (5)
        #14E1
        #instruction: LD   A,(2029)
        let:8 a40 = M[2029] in
        advance (13)
        #14E4
        #instruction: CP   D8
        let:8 a41 = a40 in
        let:16 a42 = addWithCarry(!false,a41,~D8) in
        let:8 a43 = (a41 & 0F) in
        let:8 a44 = (~D8 & 0F) in
        let:16 a45 = addWithCarry(!false,a43,a44) in
        advance (7)
        #14E6
        #instruction: LD   B,A
        let:8 a46 = a40 in
        advance (5)
        #14E7
        #instruction: JP   NC,1530
        if (!!a42[15:8][0]) {
          advance (10)
          #1530
          #instruction: LD   A,03
          advance (7)
          #1532
          #instruction: LD   (2025),A
          M[2025] := 03;
          advance (13)
          #1535
          #instruction: JP   154A
          advance (10)
          #154A
          #instruction: XOR  A
          let:8 a47 = (03 ^ 03) in
          advance (4)
          #154B
          #instruction: LD   (2002),A
          let:8 a48 = a47 in
          M[2002] := a48;
          advance (13)
          #154E
          #instruction: LD   B,F7
          advance (7)
          #1550
          #instruction: JP   19DC
          advance (10)
          #19DC
          #instruction: LD   A,(2094)
          let:8 a49 = M[2094] in
          advance (13)
          #19DF
          #instruction: AND  B
          let:8 a50 = a49 in
          let:8 a51 = (F7 & a50) in
          let:8 a52 = (F7 | a50) in
          advance (4)
          #19E0
          #instruction: LD   (2094),A
          let:8 a53 = a51 in
          M[2094] := a53;
          advance (13)
          #19E3
          #instruction: OUT  03
          let:8 a54 = a51 in
          sound_control(Ufo,a54[0]);
          sound_control(Shot,a54[1]);
          sound_control(PlayerDie,a54[2]);
          sound_control(InvaderDie,a54[3]);
          sound_control(ExtraLife,a54[4]);
          advance (10)
          #19E5
          #instruction: RET
          let:8 a55 = a12[15:8] in
          let:8 a56 = a12[7:0] in
          let:16 a57 = (1 + (a55,a56)) in
          let:8 a58 = M[(a55,a56)] in
          let:8 a59 = a57[15:8] in
          let:8 a60 = a57[7:0] in
          let:16 a61 = (1 + (a59,a60)) in
          let:8 a62 = M[(a59,a60)] in
          advance (10)
          A := a51;
          B := F7;
          SPH := a61[15:8];
          SPL := a61[7:0];
          FlagS := a51[7];
          FlagZ := is_zero(a51);
          FlagA := a52[3];
          FlagP := parity(a51);
          FlagCY := false;
          jump ((a62,a58));
        } else {
          advance (10)
          #14EA
          #instruction: LD   A,(2002)
          let:8 a63 = M[2002] in
          advance (13)
          #14ED
          #instruction: AND  A
          let:8 a64 = a63 in
          let:8 a65 = a63 in
          let:8 a66 = (a64 & a65) in
          let:8 a67 = (a64 | a65) in
          advance (4)
          #14EE
          #instruction: RET  Z
          if (is_zero(a66)) {
            let:8 a68 = a12[15:8] in
            let:8 a69 = a12[7:0] in
            let:16 a70 = (1 + (a68,a69)) in
            let:8 a71 = M[(a68,a69)] in
            let:8 a72 = a70[15:8] in
            let:8 a73 = a70[7:0] in
            let:16 a74 = (1 + (a72,a73)) in
            let:8 a75 = M[(a72,a73)] in
            advance (11)
            A := a66;
            B := a46;
            SPH := a74[15:8];
            SPL := a74[7:0];
            FlagS := a66[7];
            FlagZ := is_zero(a66);
            FlagA := a67[3];
            FlagP := parity(a66);
            FlagCY := false;
            jump ((a75,a71));
          } else {
            advance (5)
            #14EF
            #instruction: LD   A,B
            let:8 a76 = a46 in
            advance (5)
            #14F0
            #instruction: CP   CE
            let:8 a77 = a76 in
            let:16 a78 = addWithCarry(!false,a77,~CE) in
            let:8 a79 = (a77 & 0F) in
            let:8 a80 = (~CE & 0F) in
            let:16 a81 = addWithCarry(!false,a79,a80) in
            advance (7)
            #14F2
            #instruction: JP   NC,1579
            if (!!a78[15:8][0]) {
              advance (10)
              #1579
              #instruction: LD   A,01
              advance (7)
              #157B
              #instruction: LD   (2085),A
              M[2085] := 01;
              advance (13)
              #157E
              #instruction: JP   1545
              advance (10)
              A := 01;
              B := a46;
              SPH := a12[15:8];
              SPL := a12[7:0];
              FlagS := a78[7:0][7];
              FlagZ := is_zero(a78[7:0]);
              FlagA := a81[7:0][4];
              FlagP := parity(a78[7:0]);
              FlagCY := !a78[15:8][0];
              jump (1545);
            } else {
              advance (10)
              #14F5
              #instruction: ADD  06
              let:8 a82 = a76 in
              let:16 a83 = addWithCarry(false,06,a82) in
              let:8 a84 = (06 & 0F) in
              let:8 a85 = (a82 & 0F) in
              let:16 a86 = addWithCarry(false,a84,a85) in
              advance (7)
              #14F7
              #instruction: LD   B,A
              let:8 a87 = a83[7:0] in
              advance (5)
              #14F8
              #instruction: LD   A,(2009)
              let:8 a88 = M[2009] in
              advance (13)
              #14FB
              #instruction: CP   90
              let:8 a89 = a88 in
              let:16 a90 = addWithCarry(!false,a89,~90) in
              let:8 a91 = (a89 & 0F) in
              let:8 a92 = (~90 & 0F) in
              let:16 a93 = addWithCarry(!false,a91,a92) in
              advance (7)
              #14FD
              #instruction: JP   NC,1504
              if (!!a90[15:8][0]) {
                advance (10)
                #1504
                #instruction: LD   L,B
                let:8 a94 = a87 in
                advance (5)
                #1505
                #instruction: CALL 1562
                let:8 a95 = a12[15:8] in
                let:8 a96 = a12[7:0] in
                let:16 a97 = (-1 + (a95,a96)) in
                M[a97] := 15;
                let:8 a98 = a97[15:8] in
                let:8 a99 = a97[7:0] in
                let:16 a100 = (-1 + (a98,a99)) in
                M[a100] := 08;
                #return-to: 1508
                advance (17)
                #1562
                #instruction: LD   A,(2009)
                let:8 a101 = M[2009] in
                advance (13)
                #1565
                #instruction: LD   H,L
                let:8 a102 = a94 in
                advance (5)
                #1566
                #instruction: CALL 1554
                let:8 a103 = a100[15:8] in
                let:8 a104 = a100[7:0] in
                let:16 a105 = (-1 + (a103,a104)) in
                M[a105] := 15;
                let:8 a106 = a105[15:8] in
                let:8 a107 = a105[7:0] in
                let:16 a108 = (-1 + (a106,a107)) in
                M[a108] := 69;
                #return-to: 1569
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:8 a109 = a101 in
                let:8 a110 = a102 in
                let:16 a111 = addWithCarry(!false,a109,~a110) in
                let:8 a112 = (a109 & 0F) in
                let:8 a113 = (~a110 & 0F) in
                let:16 a114 = addWithCarry(!false,a112,a113) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a111[15:8][0]) {
                  let:8 a115 = a108[15:8] in
                  let:8 a116 = a108[7:0] in
                  let:16 a117 = (-1 + (a115,a116)) in
                  M[a117] := 15;
                  let:8 a118 = a117[15:8] in
                  let:8 a119 = a117[7:0] in
                  let:16 a120 = (-1 + (a118,a119)) in
                  M[a120] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a121 = addWithCarry(true,00,00) in
                  let:8 a122 = (00 & 0F) in
                  let:8 a123 = (00 & 0F) in
                  let:16 a124 = addWithCarry(true,a122,a123) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:8 a125 = a101 in
                  let:16 a126 = addWithCarry(false,10,a125) in
                  let:8 a127 = (10 & 0F) in
                  let:8 a128 = (a125 & 0F) in
                  let:16 a129 = addWithCarry(false,a127,a128) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a126[7:0][7]) {
                    advance (10)
                    A := a126[7:0];
                    B := a87;
                    C := a121[7:0];
                    H := a102;
                    L := a94;
                    SPH := a120[15:8];
                    SPL := a120[7:0];
                    FlagS := a126[7:0][7];
                    FlagZ := is_zero(a126[7:0]);
                    FlagA := a129[7:0][4];
                    FlagP := parity(a126[7:0]);
                    FlagCY := a126[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:8 a130 = a120[15:8] in
                    let:8 a131 = a120[7:0] in
                    let:16 a132 = (1 + (a130,a131)) in
                    let:8 a133 = M[(a130,a131)] in
                    let:8 a134 = a132[15:8] in
                    let:8 a135 = a132[7:0] in
                    let:16 a136 = (1 + (a134,a135)) in
                    let:8 a137 = M[(a134,a135)] in
                    advance (10)
                    A := a126[7:0];
                    B := a87;
                    C := a121[7:0];
                    H := a102;
                    L := a94;
                    SPH := a136[15:8];
                    SPL := a136[7:0];
                    FlagS := a126[7:0][7];
                    FlagZ := is_zero(a126[7:0]);
                    FlagA := a129[7:0][4];
                    FlagP := parity(a126[7:0]);
                    FlagCY := a126[15:8][0];
                    jump ((a137,a133));
                  }
                } else {
                  advance (11)
                  A := a101;
                  B := a87;
                  C := 00;
                  H := a102;
                  L := a94;
                  SPH := a108[15:8];
                  SPL := a108[7:0];
                  FlagS := a111[7:0][7];
                  FlagZ := is_zero(a111[7:0]);
                  FlagA := a114[7:0][4];
                  FlagP := parity(a111[7:0]);
                  FlagCY := !a111[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #1500
                #instruction: CP   B
                let:8 a138 = a88 in
                let:8 a139 = a87 in
                let:16 a140 = addWithCarry(!false,a138,~a139) in
                let:8 a141 = (a138 & 0F) in
                let:8 a142 = (~a139 & 0F) in
                let:16 a143 = addWithCarry(!false,a141,a142) in
                advance (4)
                #1501
                #instruction: JP   NC,1530
                if (!!a140[15:8][0]) {
                  advance (10)
                  #1530
                  #instruction: LD   A,03
                  advance (7)
                  #1532
                  #instruction: LD   (2025),A
                  M[2025] := 03;
                  advance (13)
                  #1535
                  #instruction: JP   154A
                  advance (10)
                  #154A
                  #instruction: XOR  A
                  let:8 a144 = (03 ^ 03) in
                  advance (4)
                  #154B
                  #instruction: LD   (2002),A
                  let:8 a145 = a144 in
                  M[2002] := a145;
                  advance (13)
                  #154E
                  #instruction: LD   B,F7
                  advance (7)
                  #1550
                  #instruction: JP   19DC
                  advance (10)
                  #19DC
                  #instruction: LD   A,(2094)
                  let:8 a146 = M[2094] in
                  advance (13)
                  #19DF
                  #instruction: AND  B
                  let:8 a147 = a146 in
                  let:8 a148 = (F7 & a147) in
                  let:8 a149 = (F7 | a147) in
                  advance (4)
                  #19E0
                  #instruction: LD   (2094),A
                  let:8 a150 = a148 in
                  M[2094] := a150;
                  advance (13)
                  #19E3
                  #instruction: OUT  03
                  let:8 a151 = a148 in
                  sound_control(Ufo,a151[0]);
                  sound_control(Shot,a151[1]);
                  sound_control(PlayerDie,a151[2]);
                  sound_control(InvaderDie,a151[3]);
                  sound_control(ExtraLife,a151[4]);
                  advance (10)
                  #19E5
                  #instruction: RET
                  let:8 a152 = a12[15:8] in
                  let:8 a153 = a12[7:0] in
                  let:16 a154 = (1 + (a152,a153)) in
                  let:8 a155 = M[(a152,a153)] in
                  let:8 a156 = a154[15:8] in
                  let:8 a157 = a154[7:0] in
                  let:16 a158 = (1 + (a156,a157)) in
                  let:8 a159 = M[(a156,a157)] in
                  advance (10)
                  A := a148;
                  B := F7;
                  SPH := a158[15:8];
                  SPL := a158[7:0];
                  FlagS := a148[7];
                  FlagZ := is_zero(a148);
                  FlagA := a149[3];
                  FlagP := parity(a148);
                  FlagCY := false;
                  jump ((a159,a155));
                } else {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  let:8 a160 = a87 in
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:8 a161 = a12[15:8] in
                  let:8 a162 = a12[7:0] in
                  let:16 a163 = (-1 + (a161,a162)) in
                  M[a163] := 15;
                  let:8 a164 = a163[15:8] in
                  let:8 a165 = a163[7:0] in
                  let:16 a166 = (-1 + (a164,a165)) in
                  M[a166] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  let:8 a167 = M[2009] in
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  let:8 a168 = a160 in
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:8 a169 = a166[15:8] in
                  let:8 a170 = a166[7:0] in
                  let:16 a171 = (-1 + (a169,a170)) in
                  M[a171] := 15;
                  let:8 a172 = a171[15:8] in
                  let:8 a173 = a171[7:0] in
                  let:16 a174 = (-1 + (a172,a173)) in
                  M[a174] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a175 = a167 in
                  let:8 a176 = a168 in
                  let:16 a177 = addWithCarry(!false,a175,~a176) in
                  let:8 a178 = (a175 & 0F) in
                  let:8 a179 = (~a176 & 0F) in
                  let:16 a180 = addWithCarry(!false,a178,a179) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a177[15:8][0]) {
                    let:8 a181 = a174[15:8] in
                    let:8 a182 = a174[7:0] in
                    let:16 a183 = (-1 + (a181,a182)) in
                    M[a183] := 15;
                    let:8 a184 = a183[15:8] in
                    let:8 a185 = a183[7:0] in
                    let:16 a186 = (-1 + (a184,a185)) in
                    M[a186] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a187 = addWithCarry(true,00,00) in
                    let:8 a188 = (00 & 0F) in
                    let:8 a189 = (00 & 0F) in
                    let:16 a190 = addWithCarry(true,a188,a189) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a191 = a167 in
                    let:16 a192 = addWithCarry(false,10,a191) in
                    let:8 a193 = (10 & 0F) in
                    let:8 a194 = (a191 & 0F) in
                    let:16 a195 = addWithCarry(false,a193,a194) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a192[7:0][7]) {
                      advance (10)
                      A := a192[7:0];
                      B := a87;
                      C := a187[7:0];
                      H := a168;
                      L := a160;
                      SPH := a186[15:8];
                      SPL := a186[7:0];
                      FlagS := a192[7:0][7];
                      FlagZ := is_zero(a192[7:0]);
                      FlagA := a195[7:0][4];
                      FlagP := parity(a192[7:0]);
                      FlagCY := a192[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a196 = a186[15:8] in
                      let:8 a197 = a186[7:0] in
                      let:16 a198 = (1 + (a196,a197)) in
                      let:8 a199 = M[(a196,a197)] in
                      let:8 a200 = a198[15:8] in
                      let:8 a201 = a198[7:0] in
                      let:16 a202 = (1 + (a200,a201)) in
                      let:8 a203 = M[(a200,a201)] in
                      advance (10)
                      A := a192[7:0];
                      B := a87;
                      C := a187[7:0];
                      H := a168;
                      L := a160;
                      SPH := a202[15:8];
                      SPL := a202[7:0];
                      FlagS := a192[7:0][7];
                      FlagZ := is_zero(a192[7:0]);
                      FlagA := a195[7:0][4];
                      FlagP := parity(a192[7:0]);
                      FlagCY := a192[15:8][0];
                      jump ((a203,a199));
                    }
                  } else {
                    advance (11)
                    A := a167;
                    B := a87;
                    C := 00;
                    H := a168;
                    L := a160;
                    SPH := a174[15:8];
                    SPL := a174[7:0];
                    FlagS := a177[7:0][7];
                    FlagZ := is_zero(a177[7:0]);
                    FlagA := a180[7:0][4];
                    FlagP := parity(a177[7:0]);
                    FlagCY := !a177[15:8][0];
                    jump (155A);
                  }
                }
              }
            }
          }
        }
      }
    }

0825:

    #0825
    #instruction: CALL 15F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 28;
    #return-to: 0828
    advance (17)
    #15F3
    #instruction: CALL 1611
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 15;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F6;
    #return-to: 15F6
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a13 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a14 = a13 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a15 = a12[15:8] in
    let:8 a16 = a12[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    A := a13;
    H := a14;
    L := 00;
    SPH := a21[15:8];
    SPL := a21[7:0];
    jump ((a22,a18));

0828:

    #0828
    #instruction: CALL 0988
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2B;
    #return-to: 082B
    advance (17)
    #0988
    #instruction: CALL 09CA
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 8B;
    #return-to: 098B
    advance (17)
    #09CA
    #instruction: LD   A,(2067)
    let:8 a13 = M[2067] in
    advance (13)
    #09CD
    #instruction: RRCA
    let:8 a14 = a13 in
    advance (4)
    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    #09D1
    #instruction: RET  CY
    if (a14[0]) {
      let:8 a15 = a12[15:8] in
      let:8 a16 = a12[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := updateBit((a14 >> 01),7,a14[0]);
      H := 20;
      L := F8;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagCY := a14[0];
      jump ((a22,a18));
    } else {
      advance (5)
      #09D2
      #instruction: LD   HL,20FC
      advance (10)
      #09D5
      #instruction: RET
      let:8 a23 = a12[15:8] in
      let:8 a24 = a12[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := updateBit((a14 >> 01),7,a14[0]);
      H := 20;
      L := FC;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagCY := a14[0];
      jump ((a30,a26));
    }

082B:

    #082B
    #instruction: LD   A,(2082)
    let:8 a1 = M[2082] in
    advance (13)
    #082E
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #082F
    #instruction: JP   Z,09EF
    if (is_zero(a4)) {
      advance (10)
      #09EF
      #instruction: CALL 0A3C
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 09;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := F2;
      #return-to: 09F2
      advance (17)
      #0A3C
      #instruction: CALL 0A59
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 0A;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 3F;
      #return-to: 0A3F
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a18 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a19 = a18 in
      let:16 a20 = addWithCarry(!false,a19,~FF) in
      let:8 a21 = (a19 & 0F) in
      let:8 a22 = (~FF & 0F) in
      let:16 a23 = addWithCarry(!false,a21,a22) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a24 = a17[15:8] in
      let:8 a25 = a17[7:0] in
      let:16 a26 = (1 + (a24,a25)) in
      let:8 a27 = M[(a24,a25)] in
      let:8 a28 = a26[15:8] in
      let:8 a29 = a26[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      advance (10)
      A := a18;
      SPH := a30[15:8];
      SPL := a30[7:0];
      FlagS := a20[7:0][7];
      FlagZ := is_zero(a20[7:0]);
      FlagA := a23[7:0][4];
      FlagP := parity(a20[7:0]);
      FlagCY := !a20[15:8][0];
      jump ((a31,a27));
    } else {
      advance (10)
      #0832
      #instruction: CALL 170E
      let:8 a32 = SPH in
      let:8 a33 = SPL in
      let:16 a34 = (-1 + (a32,a33)) in
      M[a34] := 08;
      let:8 a35 = a34[15:8] in
      let:8 a36 = a34[7:0] in
      let:16 a37 = (-1 + (a35,a36)) in
      M[a37] := 35;
      #return-to: 0835
      advance (17)
      #170E
      #instruction: CALL 09CA
      let:8 a38 = a37[15:8] in
      let:8 a39 = a37[7:0] in
      let:16 a40 = (-1 + (a38,a39)) in
      M[a40] := 17;
      let:8 a41 = a40[15:8] in
      let:8 a42 = a40[7:0] in
      let:16 a43 = (-1 + (a41,a42)) in
      M[a43] := 11;
      #return-to: 1711
      advance (17)
      #09CA
      #instruction: LD   A,(2067)
      let:8 a44 = M[2067] in
      advance (13)
      #09CD
      #instruction: RRCA
      let:8 a45 = a44 in
      advance (4)
      #09CE
      #instruction: LD   HL,20F8
      advance (10)
      #09D1
      #instruction: RET  CY
      if (a45[0]) {
        let:8 a46 = a43[15:8] in
        let:8 a47 = a43[7:0] in
        let:16 a48 = (1 + (a46,a47)) in
        let:8 a49 = M[(a46,a47)] in
        let:8 a50 = a48[15:8] in
        let:8 a51 = a48[7:0] in
        let:16 a52 = (1 + (a50,a51)) in
        let:8 a53 = M[(a50,a51)] in
        advance (11)
        A := updateBit((a45 >> 01),7,a45[0]);
        H := 20;
        L := F8;
        SPH := a52[15:8];
        SPL := a52[7:0];
        FlagS := a4[7];
        FlagZ := is_zero(a4);
        FlagA := a5[3];
        FlagP := parity(a4);
        FlagCY := a45[0];
        jump ((a53,a49));
      } else {
        advance (5)
        #09D2
        #instruction: LD   HL,20FC
        advance (10)
        #09D5
        #instruction: RET
        let:8 a54 = a43[15:8] in
        let:8 a55 = a43[7:0] in
        let:16 a56 = (1 + (a54,a55)) in
        let:8 a57 = M[(a54,a55)] in
        let:8 a58 = a56[15:8] in
        let:8 a59 = a56[7:0] in
        let:16 a60 = (1 + (a58,a59)) in
        let:8 a61 = M[(a58,a59)] in
        advance (10)
        A := updateBit((a45 >> 01),7,a45[0]);
        H := 20;
        L := FC;
        SPH := a60[15:8];
        SPL := a60[7:0];
        FlagS := a4[7];
        FlagZ := is_zero(a4);
        FlagA := a5[3];
        FlagP := parity(a4);
        FlagCY := a45[0];
        jump ((a61,a57));
      }
    }

0835:

    #0835
    #instruction: CALL 0935
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 38;
    #return-to: 0838
    advance (17)
    #0935
    #instruction: CALL 1910
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 38;
    #return-to: 0938
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    let:8 a13 = M[2067] in
    advance (13)
    #1916
    #instruction: RRCA
    let:8 a14 = a13 in
    advance (4)
    #1917
    #instruction: RET  CY
    if (a14[0]) {
      let:8 a15 = a12[15:8] in
      let:8 a16 = a12[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := updateBit((a14 >> 01),7,a14[0]);
      H := 20;
      L := E7;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagCY := a14[0];
      jump ((a22,a18));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:8 a23 = a12[15:8] in
      let:8 a24 = a12[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := updateBit((a14 >> 01),7,a14[0]);
      H := 20;
      L := E8;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagCY := a14[0];
      jump ((a30,a26));
    }

0838:

    #0838
    #instruction: CALL 08D8
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3B;
    #return-to: 083B
    advance (17)
    #08D8
    #instruction: LD   A,(2082)
    let:8 a7 = M[2082] in
    advance (13)
    #08DB
    #instruction: CP   09
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~09) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~09 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #08DD
    #instruction: RET  NC
    if (!!a9[15:8][0]) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #08DE
      #instruction: LD   A,FB
      advance (7)
      #08E0
      #instruction: LD   (207E),A
      M[207E] := FB;
      advance (13)
      #08E3
      #instruction: RET
      let:8 a21 = a6[15:8] in
      let:8 a22 = a6[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := FB;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a28,a24));
    }

083B:

    #083B
    #instruction: CALL 172C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3E;
    #return-to: 083E
    advance (17)
    #172C
    #instruction: LD   A,(2025)
    let:8 a7 = M[2025] in
    advance (13)
    #172F
    #instruction: CP   00
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~00) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~00 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #1731
    #instruction: JP   NZ,1739
    if (!is_zero(a9[7:0])) {
      advance (10)
      #1739
      #instruction: LD   B,02
      advance (7)
      #173B
      #instruction: JP   18FA
      advance (10)
      #18FA
      #instruction: LD   A,(2094)
      let:8 a13 = M[2094] in
      advance (13)
      #18FD
      #instruction: OR   B
      let:8 a14 = a13 in
      let:8 a15 = (02 | a14) in
      advance (4)
      #18FE
      #instruction: LD   (2094),A
      let:8 a16 = a15 in
      M[2094] := a16;
      advance (13)
      #1901
      #instruction: OUT  03
      let:8 a17 = a15 in
      sound_control(Ufo,a17[0]);
      sound_control(Shot,a17[1]);
      sound_control(PlayerDie,a17[2]);
      sound_control(InvaderDie,a17[3]);
      sound_control(ExtraLife,a17[4]);
      advance (10)
      #1903
      #instruction: RET
      let:8 a18 = a6[15:8] in
      let:8 a19 = a6[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      let:8 a22 = a20[15:8] in
      let:8 a23 = a20[7:0] in
      let:16 a24 = (1 + (a22,a23)) in
      let:8 a25 = M[(a22,a23)] in
      advance (10)
      A := a15;
      B := 02;
      SPH := a24[15:8];
      SPL := a24[7:0];
      FlagS := a15[7];
      FlagZ := is_zero(a15);
      FlagA := false;
      FlagP := parity(a15);
      FlagCY := false;
      jump ((a25,a21));
    } else {
      advance (10)
      #1734
      #instruction: LD   B,FD
      advance (7)
      #1736
      #instruction: JP   19DC
      advance (10)
      #19DC
      #instruction: LD   A,(2094)
      let:8 a26 = M[2094] in
      advance (13)
      #19DF
      #instruction: AND  B
      let:8 a27 = a26 in
      let:8 a28 = (FD & a27) in
      let:8 a29 = (FD | a27) in
      advance (4)
      #19E0
      #instruction: LD   (2094),A
      let:8 a30 = a28 in
      M[2094] := a30;
      advance (13)
      #19E3
      #instruction: OUT  03
      let:8 a31 = a28 in
      sound_control(Ufo,a31[0]);
      sound_control(Shot,a31[1]);
      sound_control(PlayerDie,a31[2]);
      sound_control(InvaderDie,a31[3]);
      sound_control(ExtraLife,a31[4]);
      advance (10)
      #19E5
      #instruction: RET
      let:8 a32 = a6[15:8] in
      let:8 a33 = a6[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      A := a28;
      B := FD;
      SPH := a38[15:8];
      SPL := a38[7:0];
      FlagS := a28[7];
      FlagZ := is_zero(a28);
      FlagA := a29[3];
      FlagP := parity(a28);
      FlagCY := false;
      jump ((a39,a35));
    }

083E:

    #083E
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 41;
    #return-to: 0841
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    let:8 a7 = M[2015] in
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~FF) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~FF & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #0A5E
    #instruction: RET
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a7;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a9[7:0][7];
    FlagZ := is_zero(a9[7:0]);
    FlagA := a12[7:0][4];
    FlagP := parity(a9[7:0]);
    FlagCY := !a9[15:8][0];
    jump ((a20,a16));

0841:

    #0841
    #instruction: JP   Z,0849
    if (FlagZ) {
      advance (10)
      jump (0849);
    } else {
      advance (10)
      #0844
      #instruction: LD   B,04
      advance (7)
      #0846
      #instruction: CALL 18FA
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 08;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 49;
      #return-to: 0849
      advance (17)
      #18FA
      #instruction: LD   A,(2094)
      let:8 a7 = M[2094] in
      advance (13)
      #18FD
      #instruction: OR   B
      let:8 a8 = a7 in
      let:8 a9 = (04 | a8) in
      advance (4)
      #18FE
      #instruction: LD   (2094),A
      let:8 a10 = a9 in
      M[2094] := a10;
      advance (13)
      #1901
      #instruction: OUT  03
      let:8 a11 = a9 in
      sound_control(Ufo,a11[0]);
      sound_control(Shot,a11[1]);
      sound_control(PlayerDie,a11[2]);
      sound_control(InvaderDie,a11[3]);
      sound_control(ExtraLife,a11[4]);
      advance (10)
      #1903
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a9;
      B := 04;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a9[7];
      FlagZ := is_zero(a9);
      FlagA := false;
      FlagP := parity(a9);
      FlagCY := false;
      jump ((a19,a15));
    }

0849:

    #0849
    #instruction: CALL 1775
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4C;
    #return-to: 084C
    advance (17)
    #1775
    #instruction: LD   A,(2095)
    let:8 a7 = M[2095] in
    advance (13)
    #1778
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #1779
    #instruction: JP   Z,17AA
    if (is_zero(a10)) {
      advance (10)
      #17AA
      #instruction: LD   HL,2099
      advance (10)
      #17AD
      #instruction: DEC  (HL)
      let:8 a12 = M[2099] in
      let:16 a13 = addWithCarry(!true,a12,~00) in
      let:8 a14 = (a12 & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      M[2099] := a13[7:0];
      advance (10)
      #17AE
      #instruction: RET  NZ
      if (!is_zero(a13[7:0])) {
        let:8 a17 = a6[15:8] in
        let:8 a18 = a6[7:0] in
        let:16 a19 = (1 + (a17,a18)) in
        let:8 a20 = M[(a17,a18)] in
        let:8 a21 = a19[15:8] in
        let:8 a22 = a19[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        advance (11)
        A := a10;
        H := 20;
        L := 99;
        SPH := a23[15:8];
        SPL := a23[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := false;
        jump ((a24,a20));
      } else {
        advance (5)
        #17AF
        #instruction: LD   B,EF
        advance (7)
        #17B1
        #instruction: JP   19DC
        advance (10)
        #19DC
        #instruction: LD   A,(2094)
        let:8 a25 = M[2094] in
        advance (13)
        #19DF
        #instruction: AND  B
        let:8 a26 = a25 in
        let:8 a27 = (EF & a26) in
        let:8 a28 = (EF | a26) in
        advance (4)
        #19E0
        #instruction: LD   (2094),A
        let:8 a29 = a27 in
        M[2094] := a29;
        advance (13)
        #19E3
        #instruction: OUT  03
        let:8 a30 = a27 in
        sound_control(Ufo,a30[0]);
        sound_control(Shot,a30[1]);
        sound_control(PlayerDie,a30[2]);
        sound_control(InvaderDie,a30[3]);
        sound_control(ExtraLife,a30[4]);
        advance (10)
        #19E5
        #instruction: RET
        let:8 a31 = a6[15:8] in
        let:8 a32 = a6[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        let:8 a35 = a33[15:8] in
        let:8 a36 = a33[7:0] in
        let:16 a37 = (1 + (a35,a36)) in
        let:8 a38 = M[(a35,a36)] in
        advance (10)
        A := a27;
        B := EF;
        H := 20;
        L := 99;
        SPH := a37[15:8];
        SPL := a37[7:0];
        FlagS := a27[7];
        FlagZ := is_zero(a27);
        FlagA := a28[3];
        FlagP := parity(a27);
        FlagCY := false;
        jump ((a38,a34));
      }
    } else {
      advance (10)
      #177C
      #instruction: LD   HL,1A11
      advance (10)
      #177F
      #instruction: LD   DE,1A21
      advance (10)
      #1782
      #instruction: LD   A,(2082)
      let:8 a39 = M[2082] in
      advance (13)
      #1785
      #instruction: CP   (HL)
      let:8 a40 = a39 in
      let:16 a41 = addWithCarry(!false,a40,~32) in
      let:8 a42 = (a40 & 0F) in
      let:8 a43 = (~32 & 0F) in
      let:16 a44 = addWithCarry(!false,a42,a43) in
      advance (7)
      #1786
      #instruction: JP   NC,178E
      if (!!a41[15:8][0]) {
        advance (10)
        #178E
        #instruction: LD   A,(DE)
        advance (7)
        #178F
        #instruction: LD   (2097),A
        M[2097] := 34;
        advance (13)
        #1792
        #instruction: LD   HL,2098
        advance (10)
        #1795
        #instruction: LD   A,(HL)
        let:8 a45 = M[2098] in
        advance (7)
        #1796
        #instruction: AND  30
        let:8 a46 = a45 in
        let:8 a47 = (30 & a46) in
        let:8 a48 = (30 | a46) in
        advance (7)
        #1798
        #instruction: LD   B,A
        let:8 a49 = a47 in
        advance (5)
        #1799
        #instruction: LD   A,(HL)
        let:8 a50 = M[2098] in
        advance (7)
        #179A
        #instruction: AND  0F
        let:8 a51 = a50 in
        let:8 a52 = (0F & a51) in
        let:8 a53 = (0F | a51) in
        advance (7)
        #179C
        #instruction: RLCA
        let:8 a54 = a52 in
        advance (4)
        #179D
        #instruction: CP   10
        let:8 a55 = updateBit((a54 << 01),0,a54[7]) in
        let:16 a56 = addWithCarry(!false,a55,~10) in
        let:8 a57 = (a55 & 0F) in
        let:8 a58 = (~10 & 0F) in
        let:16 a59 = addWithCarry(!false,a57,a58) in
        advance (7)
        #179F
        #instruction: JP   NZ,17A4
        if (!is_zero(a56[7:0])) {
          advance (10)
          #17A4
          #instruction: OR   B
          let:8 a60 = a49 in
          let:8 a61 = updateBit((a54 << 01),0,a54[7]) in
          let:8 a62 = (a60 | a61) in
          advance (4)
          #17A5
          #instruction: LD   (HL),A
          let:8 a63 = a62 in
          M[2098] := a63;
          advance (7)
          #17A6
          #instruction: XOR  A
          let:8 a64 = a62 in
          let:8 a65 = a62 in
          let:8 a66 = (a64 ^ a65) in
          advance (4)
          #17A7
          #instruction: LD   (2095),A
          let:8 a67 = a66 in
          M[2095] := a67;
          advance (13)
          #17AA
          #instruction: LD   HL,2099
          advance (10)
          #17AD
          #instruction: DEC  (HL)
          let:8 a68 = M[2099] in
          let:16 a69 = addWithCarry(!true,a68,~00) in
          let:8 a70 = (a68 & 0F) in
          let:8 a71 = (~00 & 0F) in
          let:16 a72 = addWithCarry(!true,a70,a71) in
          M[2099] := a69[7:0];
          advance (10)
          #17AE
          #instruction: RET  NZ
          if (!is_zero(a69[7:0])) {
            let:8 a73 = a6[15:8] in
            let:8 a74 = a6[7:0] in
            let:16 a75 = (1 + (a73,a74)) in
            let:8 a76 = M[(a73,a74)] in
            let:8 a77 = a75[15:8] in
            let:8 a78 = a75[7:0] in
            let:16 a79 = (1 + (a77,a78)) in
            let:8 a80 = M[(a77,a78)] in
            advance (11)
            A := a66;
            B := a49;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a79[15:8];
            SPL := a79[7:0];
            FlagS := a69[7:0][7];
            FlagZ := is_zero(a69[7:0]);
            FlagA := a72[7:0][4];
            FlagP := parity(a69[7:0]);
            FlagCY := false;
            jump ((a80,a76));
          } else {
            advance (5)
            #17AF
            #instruction: LD   B,EF
            advance (7)
            #17B1
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            let:8 a81 = M[2094] in
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a82 = a81 in
            let:8 a83 = (EF & a82) in
            let:8 a84 = (EF | a82) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            let:8 a85 = a83 in
            M[2094] := a85;
            advance (13)
            #19E3
            #instruction: OUT  03
            let:8 a86 = a83 in
            sound_control(Ufo,a86[0]);
            sound_control(Shot,a86[1]);
            sound_control(PlayerDie,a86[2]);
            sound_control(InvaderDie,a86[3]);
            sound_control(ExtraLife,a86[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:8 a87 = a6[15:8] in
            let:8 a88 = a6[7:0] in
            let:16 a89 = (1 + (a87,a88)) in
            let:8 a90 = M[(a87,a88)] in
            let:8 a91 = a89[15:8] in
            let:8 a92 = a89[7:0] in
            let:16 a93 = (1 + (a91,a92)) in
            let:8 a94 = M[(a91,a92)] in
            advance (10)
            A := a83;
            B := EF;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a93[15:8];
            SPL := a93[7:0];
            FlagS := a83[7];
            FlagZ := is_zero(a83);
            FlagA := a84[3];
            FlagP := parity(a83);
            FlagCY := false;
            jump ((a94,a90));
          }
        } else {
          advance (10)
          #17A2
          #instruction: LD   A,01
          advance (7)
          #17A4
          #instruction: OR   B
          let:8 a95 = a49 in
          let:8 a96 = (a95 | 01) in
          advance (4)
          #17A5
          #instruction: LD   (HL),A
          let:8 a97 = a96 in
          M[2098] := a97;
          advance (7)
          #17A6
          #instruction: XOR  A
          let:8 a98 = a96 in
          let:8 a99 = a96 in
          let:8 a100 = (a98 ^ a99) in
          advance (4)
          #17A7
          #instruction: LD   (2095),A
          let:8 a101 = a100 in
          M[2095] := a101;
          advance (13)
          #17AA
          #instruction: LD   HL,2099
          advance (10)
          #17AD
          #instruction: DEC  (HL)
          let:8 a102 = M[2099] in
          let:16 a103 = addWithCarry(!true,a102,~00) in
          let:8 a104 = (a102 & 0F) in
          let:8 a105 = (~00 & 0F) in
          let:16 a106 = addWithCarry(!true,a104,a105) in
          M[2099] := a103[7:0];
          advance (10)
          #17AE
          #instruction: RET  NZ
          if (!is_zero(a103[7:0])) {
            let:8 a107 = a6[15:8] in
            let:8 a108 = a6[7:0] in
            let:16 a109 = (1 + (a107,a108)) in
            let:8 a110 = M[(a107,a108)] in
            let:8 a111 = a109[15:8] in
            let:8 a112 = a109[7:0] in
            let:16 a113 = (1 + (a111,a112)) in
            let:8 a114 = M[(a111,a112)] in
            advance (11)
            A := a100;
            B := a49;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a113[15:8];
            SPL := a113[7:0];
            FlagS := a103[7:0][7];
            FlagZ := is_zero(a103[7:0]);
            FlagA := a106[7:0][4];
            FlagP := parity(a103[7:0]);
            FlagCY := false;
            jump ((a114,a110));
          } else {
            advance (5)
            #17AF
            #instruction: LD   B,EF
            advance (7)
            #17B1
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            let:8 a115 = M[2094] in
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a116 = a115 in
            let:8 a117 = (EF & a116) in
            let:8 a118 = (EF | a116) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            let:8 a119 = a117 in
            M[2094] := a119;
            advance (13)
            #19E3
            #instruction: OUT  03
            let:8 a120 = a117 in
            sound_control(Ufo,a120[0]);
            sound_control(Shot,a120[1]);
            sound_control(PlayerDie,a120[2]);
            sound_control(InvaderDie,a120[3]);
            sound_control(ExtraLife,a120[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:8 a121 = a6[15:8] in
            let:8 a122 = a6[7:0] in
            let:16 a123 = (1 + (a121,a122)) in
            let:8 a124 = M[(a121,a122)] in
            let:8 a125 = a123[15:8] in
            let:8 a126 = a123[7:0] in
            let:16 a127 = (1 + (a125,a126)) in
            let:8 a128 = M[(a125,a126)] in
            advance (10)
            A := a117;
            B := EF;
            D := 1A;
            E := 21;
            H := 20;
            L := 99;
            SPH := a127[15:8];
            SPL := a127[7:0];
            FlagS := a117[7];
            FlagZ := is_zero(a117);
            FlagA := a118[3];
            FlagP := parity(a117);
            FlagCY := false;
            jump ((a128,a124));
          }
        }
      } else {
        advance (10)
        #1789
        #instruction: INC  HL
        advance (5)
        #178A
        #instruction: INC  DE
        advance (5)
        #178B
        #instruction: JP   1785
        advance (10)
        A := a39;
        D := 1A;
        E := 22;
        H := 1A;
        L := 12;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a41[7:0][7];
        FlagZ := is_zero(a41[7:0]);
        FlagA := a44[7:0][4];
        FlagP := parity(a41[7:0]);
        FlagCY := !a41[15:8][0];
        jump (1785);
      }
    }

084C:

    #084C
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    #084E
    #instruction: CALL 1804
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 08;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 51;
    #return-to: 0851
    advance (17)
    #1804
    #instruction: LD   HL,2084
    advance (10)
    #1807
    #instruction: LD   A,(HL)
    let:8 a8 = M[2084] in
    advance (7)
    #1808
    #instruction: AND  A
    let:8 a9 = a8 in
    let:8 a10 = a8 in
    let:8 a11 = (a9 & a10) in
    let:8 a12 = (a9 | a10) in
    advance (4)
    #1809
    #instruction: JP   Z,0707
    if (is_zero(a11)) {
      advance (10)
      A := a11;
      H := 20;
      L := 84;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a11[7];
      FlagZ := is_zero(a11);
      FlagA := a12[3];
      FlagP := parity(a11);
      FlagCY := false;
      jump (0707);
    } else {
      advance (10)
      #180C
      #instruction: INC  HL
      advance (5)
      #180D
      #instruction: LD   A,(HL)
      let:8 a13 = M[2085] in
      advance (7)
      #180E
      #instruction: AND  A
      let:8 a14 = a13 in
      let:8 a15 = a13 in
      let:8 a16 = (a14 & a15) in
      let:8 a17 = (a14 | a15) in
      advance (4)
      #180F
      #instruction: RET  NZ
      if (!is_zero(a16)) {
        let:8 a18 = a7[15:8] in
        let:8 a19 = a7[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (11)
        A := a16;
        H := 20;
        L := 85;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a16[7];
        FlagZ := is_zero(a16);
        FlagA := a17[3];
        FlagP := parity(a16);
        FlagCY := false;
        jump ((a25,a21));
      } else {
        advance (5)
        #1810
        #instruction: LD   B,01
        advance (7)
        #1812
        #instruction: JP   18FA
        advance (10)
        #18FA
        #instruction: LD   A,(2094)
        let:8 a26 = M[2094] in
        advance (13)
        #18FD
        #instruction: OR   B
        let:8 a27 = a26 in
        let:8 a28 = (01 | a27) in
        advance (4)
        #18FE
        #instruction: LD   (2094),A
        let:8 a29 = a28 in
        M[2094] := a29;
        advance (13)
        #1901
        #instruction: OUT  03
        let:8 a30 = a28 in
        sound_control(Ufo,a30[0]);
        sound_control(Shot,a30[1]);
        sound_control(PlayerDie,a30[2]);
        sound_control(InvaderDie,a30[3]);
        sound_control(ExtraLife,a30[4]);
        advance (10)
        #1903
        #instruction: RET
        let:8 a31 = a7[15:8] in
        let:8 a32 = a7[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        let:8 a35 = a33[15:8] in
        let:8 a36 = a33[7:0] in
        let:16 a37 = (1 + (a35,a36)) in
        let:8 a38 = M[(a35,a36)] in
        advance (10)
        A := a28;
        B := 01;
        H := 20;
        L := 85;
        SPH := a37[15:8];
        SPL := a37[7:0];
        FlagS := a28[7];
        FlagZ := is_zero(a28);
        FlagA := false;
        FlagP := parity(a28);
        FlagCY := false;
        jump ((a38,a34));
      }
    }

0851:

    #0851
    #instruction: JP   081F
    advance (10)
    jump (081F);

085D:

    #085D
    #instruction: LD   B,98
    advance (7)
    #085F
    #instruction: IN   01
    advance (10)
    #0861
    #instruction: RRCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
    advance (4)
    #0862
    #instruction: RRCA
    let:8 a2 = updateBit((a1 >> 01),7,a1[0]) in
    advance (4)
    #0863
    #instruction: JP   CY,086D
    if (a2[0]) {
      advance (10)
      #086D
      #instruction: LD   A,01
      advance (7)
      #086F
      #instruction: JP   079B
      advance (10)
      #079B
      #instruction: LD   (20CE),A
      M[20CE] := 01;
      advance (13)
      #079E
      #instruction: LD   A,(20EB)
      let:8 a3 = M[20EB] in
      advance (13)
      #07A1
      #instruction: ADD  B
      let:8 a4 = a3 in
      let:16 a5 = addWithCarry(false,98,a4) in
      let:8 a6 = (98 & 0F) in
      let:8 a7 = (a4 & 0F) in
      let:16 a8 = addWithCarry(false,a6,a7) in
      advance (4)
      #07A2
      #instruction: DAA
      let:8 a9 = a5[7:0] in
      let:8 a10 = (a9 & 0F) in
      let:16 a11 = addWithCarry(false,a10,06) in
      let:16 a12 = addWithCarry(((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10)[4],(a9 >> 04),00) in
      let:16 a13 = addWithCarry(false,a12[7:0],06) in
      let:8 a14 = (((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10) & 0F) in
      let:8 a15 = ((((((a12[7:0][1] || a12[7:0][2]) && a12[7:0][3]) || a5[15:8][0]) ? a13[7:0] : a12[7:0]) << 04) | a14) in
      advance (4)
      #07A3
      #instruction: LD   (20EB),A
      let:8 a16 = a15 in
      M[20EB] := a16;
      advance (13)
      #07A6
      #instruction: CALL 1947
      let:8 a17 = SPH in
      let:8 a18 = SPL in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := 07;
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := A9;
      #return-to: 07A9
      advance (17)
      #1947
      #instruction: LD   A,(20EB)
      let:8 a23 = M[20EB] in
      advance (13)
      #194A
      #instruction: LD   HL,3C01
      advance (10)
      #194D
      #instruction: JP   09B2
      advance (10)
      #09B2
      #instruction: PUSH DE
      let:8 a24 = D in
      let:8 a25 = E in
      let:8 a26 = a22[15:8] in
      let:8 a27 = a22[7:0] in
      let:16 a28 = (-1 + (a26,a27)) in
      M[a28] := a24;
      let:8 a29 = a28[15:8] in
      let:8 a30 = a28[7:0] in
      let:16 a31 = (-1 + (a29,a30)) in
      M[a31] := a25;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:8 a32 = a23 in
      let:8 a33 = a31[15:8] in
      let:8 a34 = a31[7:0] in
      let:16 a35 = (-1 + (a33,a34)) in
      M[a35] := a32;
      let:8 a36 = a35[15:8] in
      let:8 a37 = a35[7:0] in
      let:16 a38 = (-1 + (a36,a37)) in
      M[a38] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a15[7]),6,is_zero(a15)),4,((((a10[1] || a10[2]) && a10[3]) || a8[7:0][4]) ? a11[7:0] : a10)[4]),2,parity(a15)),0,(((((a12[7:0][1] || a12[7:0][2]) && a12[7:0][3]) || a5[15:8][0]) ? a13[7:0] : a12[7:0])[4] || a5[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA
      let:8 a39 = a23 in
      advance (4)
      #09B5
      #instruction: RRCA
      let:8 a40 = updateBit((a39 >> 01),7,a39[0]) in
      advance (4)
      #09B6
      #instruction: RRCA
      let:8 a41 = updateBit((a40 >> 01),7,a40[0]) in
      advance (4)
      #09B7
      #instruction: RRCA
      let:8 a42 = updateBit((a41 >> 01),7,a41[0]) in
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a43 = updateBit((a42 >> 01),7,a42[0]) in
      let:8 a44 = (0F & a43) in
      let:8 a45 = (0F | a43) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:8 a46 = a38[15:8] in
      let:8 a47 = a38[7:0] in
      let:16 a48 = (-1 + (a46,a47)) in
      M[a48] := 09;
      let:8 a49 = a48[15:8] in
      let:8 a50 = a48[7:0] in
      let:16 a51 = (-1 + (a49,a50)) in
      M[a51] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:8 a52 = a44 in
      let:16 a53 = addWithCarry(false,1A,a52) in
      let:8 a54 = (1A & 0F) in
      let:8 a55 = (a52 & 0F) in
      let:16 a56 = addWithCarry(false,a54,a55) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a57 = a51[15:8] in
      let:8 a58 = a51[7:0] in
      let:16 a59 = (-1 + (a57,a58)) in
      M[a59] := 3C;
      let:8 a60 = a59[15:8] in
      let:8 a61 = a59[7:0] in
      let:16 a62 = (-1 + (a60,a61)) in
      M[a62] := 01;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a63 = a53[7:0] in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a64 = a63 in
      let:8 a65 = a63 in
      let:17 a66 = add17((00,a64),(00,a65)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a67 = a66[15:0][15:8] in
      let:8 a68 = a66[15:0][7:0] in
      let:8 a69 = a66[15:0][15:8] in
      let:8 a70 = a66[15:0][7:0] in
      let:17 a71 = add17((a67,a68),(a69,a70)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a72 = a71[15:0][15:8] in
      let:8 a73 = a71[15:0][7:0] in
      let:8 a74 = a71[15:0][15:8] in
      let:8 a75 = a71[15:0][7:0] in
      let:17 a76 = add17((a72,a73),(a74,a75)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a77 = a76[15:0][15:8] in
      let:8 a78 = a76[15:0][7:0] in
      let:17 a79 = add17(1E00,(a77,a78)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a80 = a79[15:0][15:8] in
      let:8 a81 = a79[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a82 = a62[15:8] in
      let:8 a83 = a62[7:0] in
      let:16 a84 = (1 + (a82,a83)) in
      let:8 a85 = M[(a82,a83)] in
      let:8 a86 = a84[15:8] in
      let:8 a87 = a84[7:0] in
      let:16 a88 = (1 + (a86,a87)) in
      let:8 a89 = M[(a86,a87)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a90 = a53[7:0] in
      unknown_output(6,a90);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a91 = C in
      let:8 a92 = a88[15:8] in
      let:8 a93 = a88[7:0] in
      let:16 a94 = (-1 + (a92,a93)) in
      M[a94] := 08;
      let:8 a95 = a94[15:8] in
      let:8 a96 = a94[7:0] in
      let:16 a97 = (-1 + (a95,a96)) in
      M[a97] := a91;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a98 = a80 in
      let:8 a99 = a81 in
      let:8 a100 = M[(a98,a99)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a101 = a100 in
      let:8 a102 = a89 in
      let:8 a103 = a85 in
      M[(a102,a103)] := a101;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a104 = a80 in
      let:8 a105 = a81 in
      let:16 a106 = (1 + (a104,a105)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a107 = a89 in
      let:8 a108 = a85 in
      let:17 a109 = add17(0020,(a107,a108)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a110 = a97[15:8] in
      let:8 a111 = a97[7:0] in
      let:16 a112 = (1 + (a110,a111)) in
      let:8 a113 = M[(a110,a111)] in
      let:8 a114 = a112[15:8] in
      let:8 a115 = a112[7:0] in
      let:16 a116 = (1 + (a114,a115)) in
      let:8 a117 = M[(a114,a115)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a118 = a117 in
      let:16 a119 = addWithCarry(!true,a118,~00) in
      let:8 a120 = (a118 & 0F) in
      let:8 a121 = (~00 & 0F) in
      let:16 a122 = addWithCarry(!true,a120,a121) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a119[7:0])) {
        advance (10)
        A := a100;
        B := a119[7:0];
        C := a113;
        D := a106[15:8];
        E := a106[7:0];
        H := a109[15:0][15:8];
        L := a109[15:0][7:0];
        SPH := a116[15:8];
        SPL := a116[7:0];
        FlagS := a119[7:0][7];
        FlagZ := is_zero(a119[7:0]);
        FlagA := a122[7:0][4];
        FlagP := parity(a119[7:0]);
        FlagCY := a109[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a123 = a116[15:8] in
        let:8 a124 = a116[7:0] in
        let:16 a125 = (1 + (a123,a124)) in
        let:8 a126 = M[(a123,a124)] in
        let:8 a127 = a125[15:8] in
        let:8 a128 = a125[7:0] in
        let:16 a129 = (1 + (a127,a128)) in
        let:8 a130 = M[(a127,a128)] in
        advance (10)
        A := a100;
        B := a119[7:0];
        C := a113;
        D := a106[15:8];
        E := a106[7:0];
        H := a109[15:0][15:8];
        L := a109[15:0][7:0];
        SPH := a129[15:8];
        SPL := a129[7:0];
        FlagS := a119[7:0][7];
        FlagZ := is_zero(a119[7:0]);
        FlagA := a122[7:0][4];
        FlagP := parity(a119[7:0]);
        FlagCY := a109[16];
        jump ((a130,a126));
      }
    } else {
      advance (10)
      #0866
      #instruction: RRCA
      let:8 a131 = updateBit((a2 >> 01),7,a2[0]) in
      advance (4)
      #0867
      #instruction: JP   CY,0798
      if (a131[0]) {
        advance (10)
        #0798
        #instruction: LD   B,99
        advance (7)
        #079A
        #instruction: XOR  A
        let:8 a132 = updateBit((a131 >> 01),7,a131[0]) in
        let:8 a133 = updateBit((a131 >> 01),7,a131[0]) in
        let:8 a134 = (a132 ^ a133) in
        advance (4)
        #079B
        #instruction: LD   (20CE),A
        let:8 a135 = a134 in
        M[20CE] := a135;
        advance (13)
        #079E
        #instruction: LD   A,(20EB)
        let:8 a136 = M[20EB] in
        advance (13)
        #07A1
        #instruction: ADD  B
        let:8 a137 = a136 in
        let:16 a138 = addWithCarry(false,99,a137) in
        let:8 a139 = (99 & 0F) in
        let:8 a140 = (a137 & 0F) in
        let:16 a141 = addWithCarry(false,a139,a140) in
        advance (4)
        #07A2
        #instruction: DAA
        let:8 a142 = a138[7:0] in
        let:8 a143 = (a142 & 0F) in
        let:16 a144 = addWithCarry(false,a143,06) in
        let:16 a145 = addWithCarry(((((a143[1] || a143[2]) && a143[3]) || a141[7:0][4]) ? a144[7:0] : a143)[4],(a142 >> 04),00) in
        let:16 a146 = addWithCarry(false,a145[7:0],06) in
        let:8 a147 = (((((a143[1] || a143[2]) && a143[3]) || a141[7:0][4]) ? a144[7:0] : a143) & 0F) in
        let:8 a148 = ((((((a145[7:0][1] || a145[7:0][2]) && a145[7:0][3]) || a138[15:8][0]) ? a146[7:0] : a145[7:0]) << 04) | a147) in
        advance (4)
        #07A3
        #instruction: LD   (20EB),A
        let:8 a149 = a148 in
        M[20EB] := a149;
        advance (13)
        #07A6
        #instruction: CALL 1947
        let:8 a150 = SPH in
        let:8 a151 = SPL in
        let:16 a152 = (-1 + (a150,a151)) in
        M[a152] := 07;
        let:8 a153 = a152[15:8] in
        let:8 a154 = a152[7:0] in
        let:16 a155 = (-1 + (a153,a154)) in
        M[a155] := A9;
        #return-to: 07A9
        advance (17)
        #1947
        #instruction: LD   A,(20EB)
        let:8 a156 = M[20EB] in
        advance (13)
        #194A
        #instruction: LD   HL,3C01
        advance (10)
        #194D
        #instruction: JP   09B2
        advance (10)
        #09B2
        #instruction: PUSH DE
        let:8 a157 = D in
        let:8 a158 = E in
        let:8 a159 = a155[15:8] in
        let:8 a160 = a155[7:0] in
        let:16 a161 = (-1 + (a159,a160)) in
        M[a161] := a157;
        let:8 a162 = a161[15:8] in
        let:8 a163 = a161[7:0] in
        let:16 a164 = (-1 + (a162,a163)) in
        M[a164] := a158;
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:8 a165 = a156 in
        let:8 a166 = a164[15:8] in
        let:8 a167 = a164[7:0] in
        let:16 a168 = (-1 + (a166,a167)) in
        M[a168] := a165;
        let:8 a169 = a168[15:8] in
        let:8 a170 = a168[7:0] in
        let:16 a171 = (-1 + (a169,a170)) in
        M[a171] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a148[7]),6,is_zero(a148)),4,((((a143[1] || a143[2]) && a143[3]) || a141[7:0][4]) ? a144[7:0] : a143)[4]),2,parity(a148)),0,(((((a145[7:0][1] || a145[7:0][2]) && a145[7:0][3]) || a138[15:8][0]) ? a146[7:0] : a145[7:0])[4] || a138[15:8][0]));
        advance (11)
        #09B4
        #instruction: RRCA
        let:8 a172 = a156 in
        advance (4)
        #09B5
        #instruction: RRCA
        let:8 a173 = updateBit((a172 >> 01),7,a172[0]) in
        advance (4)
        #09B6
        #instruction: RRCA
        let:8 a174 = updateBit((a173 >> 01),7,a173[0]) in
        advance (4)
        #09B7
        #instruction: RRCA
        let:8 a175 = updateBit((a174 >> 01),7,a174[0]) in
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a176 = updateBit((a175 >> 01),7,a175[0]) in
        let:8 a177 = (0F & a176) in
        let:8 a178 = (0F | a176) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:8 a179 = a171[15:8] in
        let:8 a180 = a171[7:0] in
        let:16 a181 = (-1 + (a179,a180)) in
        M[a181] := 09;
        let:8 a182 = a181[15:8] in
        let:8 a183 = a181[7:0] in
        let:16 a184 = (-1 + (a182,a183)) in
        M[a184] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:8 a185 = a177 in
        let:16 a186 = addWithCarry(false,1A,a185) in
        let:8 a187 = (1A & 0F) in
        let:8 a188 = (a185 & 0F) in
        let:16 a189 = addWithCarry(false,a187,a188) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a190 = a184[15:8] in
        let:8 a191 = a184[7:0] in
        let:16 a192 = (-1 + (a190,a191)) in
        M[a192] := 3C;
        let:8 a193 = a192[15:8] in
        let:8 a194 = a192[7:0] in
        let:16 a195 = (-1 + (a193,a194)) in
        M[a195] := 01;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        let:8 a196 = a186[7:0] in
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:8 a197 = a196 in
        let:8 a198 = a196 in
        let:17 a199 = add17((00,a197),(00,a198)) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a200 = a199[15:0][15:8] in
        let:8 a201 = a199[15:0][7:0] in
        let:8 a202 = a199[15:0][15:8] in
        let:8 a203 = a199[15:0][7:0] in
        let:17 a204 = add17((a200,a201),(a202,a203)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a205 = a204[15:0][15:8] in
        let:8 a206 = a204[15:0][7:0] in
        let:8 a207 = a204[15:0][15:8] in
        let:8 a208 = a204[15:0][7:0] in
        let:17 a209 = add17((a205,a206),(a207,a208)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a210 = a209[15:0][15:8] in
        let:8 a211 = a209[15:0][7:0] in
        let:17 a212 = add17(1E00,(a210,a211)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a213 = a212[15:0][15:8] in
        let:8 a214 = a212[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a215 = a195[15:8] in
        let:8 a216 = a195[7:0] in
        let:16 a217 = (1 + (a215,a216)) in
        let:8 a218 = M[(a215,a216)] in
        let:8 a219 = a217[15:8] in
        let:8 a220 = a217[7:0] in
        let:16 a221 = (1 + (a219,a220)) in
        let:8 a222 = M[(a219,a220)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        let:8 a223 = a186[7:0] in
        unknown_output(6,a223);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a224 = C in
        let:8 a225 = a221[15:8] in
        let:8 a226 = a221[7:0] in
        let:16 a227 = (-1 + (a225,a226)) in
        M[a227] := 08;
        let:8 a228 = a227[15:8] in
        let:8 a229 = a227[7:0] in
        let:16 a230 = (-1 + (a228,a229)) in
        M[a230] := a224;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a231 = a213 in
        let:8 a232 = a214 in
        let:8 a233 = M[(a231,a232)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a234 = a233 in
        let:8 a235 = a222 in
        let:8 a236 = a218 in
        M[(a235,a236)] := a234;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a237 = a213 in
        let:8 a238 = a214 in
        let:16 a239 = (1 + (a237,a238)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a240 = a222 in
        let:8 a241 = a218 in
        let:17 a242 = add17(0020,(a240,a241)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a243 = a230[15:8] in
        let:8 a244 = a230[7:0] in
        let:16 a245 = (1 + (a243,a244)) in
        let:8 a246 = M[(a243,a244)] in
        let:8 a247 = a245[15:8] in
        let:8 a248 = a245[7:0] in
        let:16 a249 = (1 + (a247,a248)) in
        let:8 a250 = M[(a247,a248)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a251 = a250 in
        let:16 a252 = addWithCarry(!true,a251,~00) in
        let:8 a253 = (a251 & 0F) in
        let:8 a254 = (~00 & 0F) in
        let:16 a255 = addWithCarry(!true,a253,a254) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a252[7:0])) {
          advance (10)
          A := a233;
          B := a252[7:0];
          C := a246;
          D := a239[15:8];
          E := a239[7:0];
          H := a242[15:0][15:8];
          L := a242[15:0][7:0];
          SPH := a249[15:8];
          SPL := a249[7:0];
          FlagS := a252[7:0][7];
          FlagZ := is_zero(a252[7:0]);
          FlagA := a255[7:0][4];
          FlagP := parity(a252[7:0]);
          FlagCY := a242[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a256 = a249[15:8] in
          let:8 a257 = a249[7:0] in
          let:16 a258 = (1 + (a256,a257)) in
          let:8 a259 = M[(a256,a257)] in
          let:8 a260 = a258[15:8] in
          let:8 a261 = a258[7:0] in
          let:16 a262 = (1 + (a260,a261)) in
          let:8 a263 = M[(a260,a261)] in
          advance (10)
          A := a233;
          B := a252[7:0];
          C := a246;
          D := a239[15:8];
          E := a239[7:0];
          H := a242[15:0][15:8];
          L := a242[15:0][7:0];
          SPH := a262[15:8];
          SPL := a262[7:0];
          FlagS := a252[7:0][7];
          FlagZ := is_zero(a252[7:0]);
          FlagA := a255[7:0][4];
          FlagP := parity(a252[7:0]);
          FlagCY := a242[16];
          jump ((a263,a259));
        }
      } else {
        advance (10)
        #086A
        #instruction: JP   077F
        advance (10)
        A := updateBit((a131 >> 01),7,a131[0]);
        B := 98;
        FlagCY := a131[0];
        jump (077F);
      }
    }

0875:

    #0875
    #instruction: JP   0814
    advance (10)
    jump (0814);

0898:

    #0898
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #089B
    #instruction: RRCA
    let:8 a2 = a1 in
    advance (4)
    #089C
    #instruction: LD   A,1C
    advance (7)
    #089E
    #instruction: LD   HL,3711
    advance (10)
    #08A1
    #instruction: CALL NC,08FF
    if (!a2[0]) {
      let:8 a3 = SPH in
      let:8 a4 = SPL in
      let:16 a5 = (-1 + (a3,a4)) in
      M[a5] := 08;
      let:8 a6 = a5[15:8] in
      let:8 a7 = a5[7:0] in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := A4;
      #return-to: 08A4
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 37;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 11;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a15 = add17(001C,001C) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a16 = a15[15:0][15:8] in
      let:8 a17 = a15[15:0][7:0] in
      let:8 a18 = a15[15:0][15:8] in
      let:8 a19 = a15[15:0][7:0] in
      let:17 a20 = add17((a16,a17),(a18,a19)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a21 = a20[15:0][15:8] in
      let:8 a22 = a20[15:0][7:0] in
      let:8 a23 = a20[15:0][15:8] in
      let:8 a24 = a20[15:0][7:0] in
      let:17 a25 = add17((a21,a22),(a23,a24)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a26 = a25[15:0][15:8] in
      let:8 a27 = a25[15:0][7:0] in
      let:17 a28 = add17(1E00,(a26,a27)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a29 = a28[15:0][15:8] in
      let:8 a30 = a28[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a31 = a14[15:8] in
      let:8 a32 = a14[7:0] in
      let:16 a33 = (1 + (a31,a32)) in
      let:8 a34 = M[(a31,a32)] in
      let:8 a35 = a33[15:8] in
      let:8 a36 = a33[7:0] in
      let:16 a37 = (1 + (a35,a36)) in
      let:8 a38 = M[(a35,a36)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,1C);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a39 = C in
      let:8 a40 = a37[15:8] in
      let:8 a41 = a37[7:0] in
      let:16 a42 = (-1 + (a40,a41)) in
      M[a42] := 08;
      let:8 a43 = a42[15:8] in
      let:8 a44 = a42[7:0] in
      let:16 a45 = (-1 + (a43,a44)) in
      M[a45] := a39;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a46 = a29 in
      let:8 a47 = a30 in
      let:8 a48 = M[(a46,a47)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a49 = a48 in
      let:8 a50 = a38 in
      let:8 a51 = a34 in
      M[(a50,a51)] := a49;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a52 = a29 in
      let:8 a53 = a30 in
      let:16 a54 = (1 + (a52,a53)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a55 = a38 in
      let:8 a56 = a34 in
      let:17 a57 = add17(0020,(a55,a56)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a58 = a45[15:8] in
      let:8 a59 = a45[7:0] in
      let:16 a60 = (1 + (a58,a59)) in
      let:8 a61 = M[(a58,a59)] in
      let:8 a62 = a60[15:8] in
      let:8 a63 = a60[7:0] in
      let:16 a64 = (1 + (a62,a63)) in
      let:8 a65 = M[(a62,a63)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a66 = a65 in
      let:16 a67 = addWithCarry(!true,a66,~00) in
      let:8 a68 = (a66 & 0F) in
      let:8 a69 = (~00 & 0F) in
      let:16 a70 = addWithCarry(!true,a68,a69) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a67[7:0])) {
        advance (10)
        A := a48;
        B := a67[7:0];
        C := a61;
        D := a54[15:8];
        E := a54[7:0];
        H := a57[15:0][15:8];
        L := a57[15:0][7:0];
        SPH := a64[15:8];
        SPL := a64[7:0];
        FlagS := a67[7:0][7];
        FlagZ := is_zero(a67[7:0]);
        FlagA := a70[7:0][4];
        FlagP := parity(a67[7:0]);
        FlagCY := a57[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a71 = a64[15:8] in
        let:8 a72 = a64[7:0] in
        let:16 a73 = (1 + (a71,a72)) in
        let:8 a74 = M[(a71,a72)] in
        let:8 a75 = a73[15:8] in
        let:8 a76 = a73[7:0] in
        let:16 a77 = (1 + (a75,a76)) in
        let:8 a78 = M[(a75,a76)] in
        advance (10)
        A := a48;
        B := a67[7:0];
        C := a61;
        D := a54[15:8];
        E := a54[7:0];
        H := a57[15:0][15:8];
        L := a57[15:0][7:0];
        SPH := a77[15:8];
        SPL := a77[7:0];
        FlagS := a67[7:0][7];
        FlagZ := is_zero(a67[7:0]);
        FlagA := a70[7:0][4];
        FlagP := parity(a67[7:0]);
        FlagCY := a57[16];
        jump ((a78,a74));
      }
    } else {
      advance (11)
      A := 1C;
      H := 37;
      L := 11;
      FlagCY := a2[0];
      jump (08A4);
    }

08A4:

    #08A4
    #instruction: LD   A,B0
    advance (7)
    #08A6
    #instruction: LD   (20C0),A
    M[20C0] := B0;
    advance (13)
    #08A9
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a14 = a4 in
      let:8 a15 = (04 & a14) in
      let:8 a16 = (04 | a14) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a15)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        let:8 a17 = M[2067] in
        advance (13)
        #08C4
        #instruction: RRCA
        let:8 a18 = a17 in
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (a18[0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a19 = SPH in
          let:8 a20 = SPL in
          let:16 a21 = (-1 + (a19,a20)) in
          M[a21] := 08;
          let:8 a22 = a21[15:8] in
          let:8 a23 = a21[7:0] in
          let:16 a24 = (-1 + (a22,a23)) in
          M[a24] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a25 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a26 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a27 = (a25 ^ a26) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a28 = C in
          let:8 a29 = a24[15:8] in
          let:8 a30 = a24[7:0] in
          let:16 a31 = (-1 + (a29,a30)) in
          M[a31] := 20;
          let:8 a32 = a31[15:8] in
          let:8 a33 = a31[7:0] in
          let:16 a34 = (-1 + (a32,a33)) in
          M[a34] := a28;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a35 = a27 in
          M[271C] := a35;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a36 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a37 = a34[15:8] in
          let:8 a38 = a34[7:0] in
          let:16 a39 = (1 + (a37,a38)) in
          let:8 a40 = M[(a37,a38)] in
          let:8 a41 = a39[15:8] in
          let:8 a42 = a39[7:0] in
          let:16 a43 = (1 + (a41,a42)) in
          let:8 a44 = M[(a41,a42)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a45 = a44 in
          let:16 a46 = addWithCarry(!true,a45,~00) in
          let:8 a47 = (a45 & 0F) in
          let:8 a48 = (~00 & 0F) in
          let:16 a49 = addWithCarry(!true,a47,a48) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a46[7:0])) {
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a43[15:8];
            SPL := a43[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a50 = a43[15:8] in
            let:8 a51 = a43[7:0] in
            let:16 a52 = (1 + (a50,a51)) in
            let:8 a53 = M[(a50,a51)] in
            let:8 a54 = a52[15:8] in
            let:8 a55 = a52[7:0] in
            let:16 a56 = (1 + (a54,a55)) in
            let:8 a57 = M[(a54,a55)] in
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a56[15:8];
            SPL := a56[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump ((a57,a53));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a58 = SPH in
          let:8 a59 = SPL in
          let:16 a60 = (-1 + (a58,a59)) in
          M[a60] := 08;
          let:8 a61 = a60[15:8] in
          let:8 a62 = a60[7:0] in
          let:16 a63 = (-1 + (a61,a62)) in
          M[a63] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a64 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a65 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a66 = (a64 ^ a65) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a67 = C in
          let:8 a68 = a63[15:8] in
          let:8 a69 = a63[7:0] in
          let:16 a70 = (-1 + (a68,a69)) in
          M[a70] := 20;
          let:8 a71 = a70[15:8] in
          let:8 a72 = a70[7:0] in
          let:16 a73 = (-1 + (a71,a72)) in
          M[a73] := a67;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a74 = a66 in
          M[391C] := a74;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a75 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a76 = a73[15:8] in
          let:8 a77 = a73[7:0] in
          let:16 a78 = (1 + (a76,a77)) in
          let:8 a79 = M[(a76,a77)] in
          let:8 a80 = a78[15:8] in
          let:8 a81 = a78[7:0] in
          let:16 a82 = (1 + (a80,a81)) in
          let:8 a83 = M[(a80,a81)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a84 = a83 in
          let:16 a85 = addWithCarry(!true,a84,~00) in
          let:8 a86 = (a84 & 0F) in
          let:8 a87 = (~00 & 0F) in
          let:16 a88 = addWithCarry(!true,a86,a87) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a85[7:0])) {
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a82[15:8];
            SPL := a82[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a89 = a82[15:8] in
            let:8 a90 = a82[7:0] in
            let:16 a91 = (1 + (a89,a90)) in
            let:8 a92 = M[(a89,a90)] in
            let:8 a93 = a91[15:8] in
            let:8 a94 = a91[7:0] in
            let:16 a95 = (1 + (a93,a94)) in
            let:8 a96 = M[(a93,a94)] in
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a95[15:8];
            SPL := a95[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump ((a96,a92));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:8 a97 = SPH in
        let:8 a98 = SPL in
        let:16 a99 = (-1 + (a97,a98)) in
        M[a99] := 08;
        let:8 a100 = a99[15:8] in
        let:8 a101 = a99[7:0] in
        let:16 a102 = (-1 + (a100,a101)) in
        M[a102] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        let:8 a103 = M[2067] in
        advance (13)
        #09CD
        #instruction: RRCA
        let:8 a104 = a103 in
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (a104[0]) {
          let:8 a105 = a102[15:8] in
          let:8 a106 = a102[7:0] in
          let:16 a107 = (1 + (a105,a106)) in
          let:8 a108 = M[(a105,a106)] in
          let:8 a109 = a107[15:8] in
          let:8 a110 = a107[7:0] in
          let:16 a111 = (1 + (a109,a110)) in
          let:8 a112 = M[(a109,a110)] in
          advance (11)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := F8;
          SPH := a111[15:8];
          SPL := a111[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a112,a108));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:8 a113 = a102[15:8] in
          let:8 a114 = a102[7:0] in
          let:16 a115 = (1 + (a113,a114)) in
          let:8 a116 = M[(a113,a114)] in
          let:8 a117 = a115[15:8] in
          let:8 a118 = a115[7:0] in
          let:16 a119 = (1 + (a117,a118)) in
          let:8 a120 = M[(a117,a118)] in
          advance (10)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := FC;
          SPH := a119[15:8];
          SPL := a119[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a120,a116));
        }
      }
    }

08B6:

    #08B6
    #instruction: CALL 1931
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B9;
    #return-to: 08B9
    advance (17)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = H in
    let:8 a8 = L in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1932
    #instruction: INC  HL
    let:8 a10 = H in
    let:8 a11 = L in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #1934
    #instruction: INC  HL
    let:8 a16 = a12[15:8] in
    let:8 a17 = a12[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:8 a21 = M[(a19,a20)] in
    advance (7)
    #1936
    #instruction: INC  HL
    let:8 a22 = a18[15:8] in
    let:8 a23 = a18[7:0] in
    let:16 a24 = (1 + (a22,a23)) in
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:8 a27 = M[(a25,a26)] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a28 = a21 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a29 = a15 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a30 = a6[15:8] in
    let:8 a31 = a6[7:0] in
    let:16 a32 = (-1 + (a30,a31)) in
    M[a32] := 09;
    let:8 a33 = a32[15:8] in
    let:8 a34 = a32[7:0] in
    let:16 a35 = (-1 + (a33,a34)) in
    M[a35] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a36 = a15 in
    let:8 a37 = a9 in
    let:8 a38 = a35[15:8] in
    let:8 a39 = a35[7:0] in
    let:16 a40 = (-1 + (a38,a39)) in
    M[a40] := a36;
    let:8 a41 = a40[15:8] in
    let:8 a42 = a40[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := a37;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a44 = a29 in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (-1 + (a45,a46)) in
    M[a47] := a44;
    let:8 a48 = a47[15:8] in
    let:8 a49 = a47[7:0] in
    let:16 a50 = (-1 + (a48,a49)) in
    M[a50] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a51 = a29 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a52 = updateBit((a51 >> 01),7,a51[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a53 = updateBit((a52 >> 01),7,a52[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a54 = updateBit((a53 >> 01),7,a53[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a55 = updateBit((a54 >> 01),7,a54[0]) in
    let:8 a56 = (0F & a55) in
    let:8 a57 = (0F | a55) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a58 = a50[15:8] in
    let:8 a59 = a50[7:0] in
    let:16 a60 = (-1 + (a58,a59)) in
    M[a60] := 09;
    let:8 a61 = a60[15:8] in
    let:8 a62 = a60[7:0] in
    let:16 a63 = (-1 + (a61,a62)) in
    M[a63] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a64 = a56 in
    let:16 a65 = addWithCarry(false,1A,a64) in
    let:8 a66 = (1A & 0F) in
    let:8 a67 = (a64 & 0F) in
    let:16 a68 = addWithCarry(false,a66,a67) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a69 = a27 in
    let:8 a70 = a28 in
    let:8 a71 = a63[15:8] in
    let:8 a72 = a63[7:0] in
    let:16 a73 = (-1 + (a71,a72)) in
    M[a73] := a69;
    let:8 a74 = a73[15:8] in
    let:8 a75 = a73[7:0] in
    let:16 a76 = (-1 + (a74,a75)) in
    M[a76] := a70;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a77 = a65[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a78 = a77 in
    let:8 a79 = a77 in
    let:17 a80 = add17((00,a78),(00,a79)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a81 = a80[15:0][15:8] in
    let:8 a82 = a80[15:0][7:0] in
    let:8 a83 = a80[15:0][15:8] in
    let:8 a84 = a80[15:0][7:0] in
    let:17 a85 = add17((a81,a82),(a83,a84)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a86 = a85[15:0][15:8] in
    let:8 a87 = a85[15:0][7:0] in
    let:8 a88 = a85[15:0][15:8] in
    let:8 a89 = a85[15:0][7:0] in
    let:17 a90 = add17((a86,a87),(a88,a89)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a91 = a90[15:0][15:8] in
    let:8 a92 = a90[15:0][7:0] in
    let:17 a93 = add17(1E00,(a91,a92)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a94 = a93[15:0][15:8] in
    let:8 a95 = a93[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a96 = a76[15:8] in
    let:8 a97 = a76[7:0] in
    let:16 a98 = (1 + (a96,a97)) in
    let:8 a99 = M[(a96,a97)] in
    let:8 a100 = a98[15:8] in
    let:8 a101 = a98[7:0] in
    let:16 a102 = (1 + (a100,a101)) in
    let:8 a103 = M[(a100,a101)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a104 = a65[7:0] in
    unknown_output(6,a104);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a105 = C in
    let:8 a106 = a102[15:8] in
    let:8 a107 = a102[7:0] in
    let:16 a108 = (-1 + (a106,a107)) in
    M[a108] := 08;
    let:8 a109 = a108[15:8] in
    let:8 a110 = a108[7:0] in
    let:16 a111 = (-1 + (a109,a110)) in
    M[a111] := a105;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a112 = a94 in
    let:8 a113 = a95 in
    let:8 a114 = M[(a112,a113)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a115 = a114 in
    let:8 a116 = a103 in
    let:8 a117 = a99 in
    M[(a116,a117)] := a115;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a118 = a94 in
    let:8 a119 = a95 in
    let:16 a120 = (1 + (a118,a119)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a121 = a103 in
    let:8 a122 = a99 in
    let:17 a123 = add17(0020,(a121,a122)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a124 = a111[15:8] in
    let:8 a125 = a111[7:0] in
    let:16 a126 = (1 + (a124,a125)) in
    let:8 a127 = M[(a124,a125)] in
    let:8 a128 = a126[15:8] in
    let:8 a129 = a126[7:0] in
    let:16 a130 = (1 + (a128,a129)) in
    let:8 a131 = M[(a128,a129)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a132 = a131 in
    let:16 a133 = addWithCarry(!true,a132,~00) in
    let:8 a134 = (a132 & 0F) in
    let:8 a135 = (~00 & 0F) in
    let:16 a136 = addWithCarry(!true,a134,a135) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a133[7:0])) {
      advance (10)
      A := a114;
      B := a133[7:0];
      C := a127;
      D := a120[15:8];
      E := a120[7:0];
      H := a123[15:0][15:8];
      L := a123[15:0][7:0];
      SPH := a130[15:8];
      SPL := a130[7:0];
      FlagS := a133[7:0][7];
      FlagZ := is_zero(a133[7:0]);
      FlagA := a136[7:0][4];
      FlagP := parity(a133[7:0]);
      FlagCY := a123[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a137 = a130[15:8] in
      let:8 a138 = a130[7:0] in
      let:16 a139 = (1 + (a137,a138)) in
      let:8 a140 = M[(a137,a138)] in
      let:8 a141 = a139[15:8] in
      let:8 a142 = a139[7:0] in
      let:16 a143 = (1 + (a141,a142)) in
      let:8 a144 = M[(a141,a142)] in
      advance (10)
      A := a114;
      B := a133[7:0];
      C := a127;
      D := a120[15:8];
      E := a120[7:0];
      H := a123[15:0][15:8];
      L := a123[15:0][7:0];
      SPH := a143[15:8];
      SPL := a143[7:0];
      FlagS := a133[7:0][7];
      FlagZ := is_zero(a133[7:0]);
      FlagA := a136[7:0][4];
      FlagP := parity(a133[7:0]);
      FlagCY := a123[16];
      jump ((a144,a140));
    }

08B9:

    #08B9
    #instruction: JP   08A9
    advance (10)
    #08A9
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a14 = a4 in
      let:8 a15 = (04 & a14) in
      let:8 a16 = (04 | a14) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a15)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        let:8 a17 = M[2067] in
        advance (13)
        #08C4
        #instruction: RRCA
        let:8 a18 = a17 in
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (a18[0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a19 = SPH in
          let:8 a20 = SPL in
          let:16 a21 = (-1 + (a19,a20)) in
          M[a21] := 08;
          let:8 a22 = a21[15:8] in
          let:8 a23 = a21[7:0] in
          let:16 a24 = (-1 + (a22,a23)) in
          M[a24] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a25 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a26 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a27 = (a25 ^ a26) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a28 = C in
          let:8 a29 = a24[15:8] in
          let:8 a30 = a24[7:0] in
          let:16 a31 = (-1 + (a29,a30)) in
          M[a31] := 20;
          let:8 a32 = a31[15:8] in
          let:8 a33 = a31[7:0] in
          let:16 a34 = (-1 + (a32,a33)) in
          M[a34] := a28;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a35 = a27 in
          M[271C] := a35;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a36 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a37 = a34[15:8] in
          let:8 a38 = a34[7:0] in
          let:16 a39 = (1 + (a37,a38)) in
          let:8 a40 = M[(a37,a38)] in
          let:8 a41 = a39[15:8] in
          let:8 a42 = a39[7:0] in
          let:16 a43 = (1 + (a41,a42)) in
          let:8 a44 = M[(a41,a42)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a45 = a44 in
          let:16 a46 = addWithCarry(!true,a45,~00) in
          let:8 a47 = (a45 & 0F) in
          let:8 a48 = (~00 & 0F) in
          let:16 a49 = addWithCarry(!true,a47,a48) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a46[7:0])) {
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a43[15:8];
            SPL := a43[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a50 = a43[15:8] in
            let:8 a51 = a43[7:0] in
            let:16 a52 = (1 + (a50,a51)) in
            let:8 a53 = M[(a50,a51)] in
            let:8 a54 = a52[15:8] in
            let:8 a55 = a52[7:0] in
            let:16 a56 = (1 + (a54,a55)) in
            let:8 a57 = M[(a54,a55)] in
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a56[15:8];
            SPL := a56[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump ((a57,a53));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a58 = SPH in
          let:8 a59 = SPL in
          let:16 a60 = (-1 + (a58,a59)) in
          M[a60] := 08;
          let:8 a61 = a60[15:8] in
          let:8 a62 = a60[7:0] in
          let:16 a63 = (-1 + (a61,a62)) in
          M[a63] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a64 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a65 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a66 = (a64 ^ a65) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a67 = C in
          let:8 a68 = a63[15:8] in
          let:8 a69 = a63[7:0] in
          let:16 a70 = (-1 + (a68,a69)) in
          M[a70] := 20;
          let:8 a71 = a70[15:8] in
          let:8 a72 = a70[7:0] in
          let:16 a73 = (-1 + (a71,a72)) in
          M[a73] := a67;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a74 = a66 in
          M[391C] := a74;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a75 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a76 = a73[15:8] in
          let:8 a77 = a73[7:0] in
          let:16 a78 = (1 + (a76,a77)) in
          let:8 a79 = M[(a76,a77)] in
          let:8 a80 = a78[15:8] in
          let:8 a81 = a78[7:0] in
          let:16 a82 = (1 + (a80,a81)) in
          let:8 a83 = M[(a80,a81)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a84 = a83 in
          let:16 a85 = addWithCarry(!true,a84,~00) in
          let:8 a86 = (a84 & 0F) in
          let:8 a87 = (~00 & 0F) in
          let:16 a88 = addWithCarry(!true,a86,a87) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a85[7:0])) {
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a82[15:8];
            SPL := a82[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a89 = a82[15:8] in
            let:8 a90 = a82[7:0] in
            let:16 a91 = (1 + (a89,a90)) in
            let:8 a92 = M[(a89,a90)] in
            let:8 a93 = a91[15:8] in
            let:8 a94 = a91[7:0] in
            let:16 a95 = (1 + (a93,a94)) in
            let:8 a96 = M[(a93,a94)] in
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a95[15:8];
            SPL := a95[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump ((a96,a92));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:8 a97 = SPH in
        let:8 a98 = SPL in
        let:16 a99 = (-1 + (a97,a98)) in
        M[a99] := 08;
        let:8 a100 = a99[15:8] in
        let:8 a101 = a99[7:0] in
        let:16 a102 = (-1 + (a100,a101)) in
        M[a102] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        let:8 a103 = M[2067] in
        advance (13)
        #09CD
        #instruction: RRCA
        let:8 a104 = a103 in
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (a104[0]) {
          let:8 a105 = a102[15:8] in
          let:8 a106 = a102[7:0] in
          let:16 a107 = (1 + (a105,a106)) in
          let:8 a108 = M[(a105,a106)] in
          let:8 a109 = a107[15:8] in
          let:8 a110 = a107[7:0] in
          let:16 a111 = (1 + (a109,a110)) in
          let:8 a112 = M[(a109,a110)] in
          advance (11)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := F8;
          SPH := a111[15:8];
          SPL := a111[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a112,a108));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:8 a113 = a102[15:8] in
          let:8 a114 = a102[7:0] in
          let:16 a115 = (1 + (a113,a114)) in
          let:8 a116 = M[(a113,a114)] in
          let:8 a117 = a115[15:8] in
          let:8 a118 = a115[7:0] in
          let:16 a119 = (1 + (a117,a118)) in
          let:8 a120 = M[(a117,a118)] in
          advance (10)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := FC;
          SPH := a119[15:8];
          SPL := a119[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a120,a116));
        }
      }
    }

08CE:

    #08CE
    #instruction: JP   08A9
    advance (10)
    #08A9
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #08AC
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #08AD
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #08AE
      #instruction: AND  04
      let:8 a14 = a4 in
      let:8 a15 = (04 & a14) in
      let:8 a16 = (04 | a14) in
      advance (7)
      #08B0
      #instruction: JP   NZ,08BC
      if (!is_zero(a15)) {
        advance (10)
        #08BC
        #instruction: LD   B,20
        advance (7)
        #08BE
        #instruction: LD   HL,271C
        advance (10)
        #08C1
        #instruction: LD   A,(2067)
        let:8 a17 = M[2067] in
        advance (13)
        #08C4
        #instruction: RRCA
        let:8 a18 = a17 in
        advance (4)
        #08C5
        #instruction: JP   CY,08CB
        if (a18[0]) {
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a19 = SPH in
          let:8 a20 = SPL in
          let:16 a21 = (-1 + (a19,a20)) in
          M[a21] := 08;
          let:8 a22 = a21[15:8] in
          let:8 a23 = a21[7:0] in
          let:16 a24 = (-1 + (a22,a23)) in
          M[a24] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a25 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a26 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a27 = (a25 ^ a26) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a28 = C in
          let:8 a29 = a24[15:8] in
          let:8 a30 = a24[7:0] in
          let:16 a31 = (-1 + (a29,a30)) in
          M[a31] := 20;
          let:8 a32 = a31[15:8] in
          let:8 a33 = a31[7:0] in
          let:16 a34 = (-1 + (a32,a33)) in
          M[a34] := a28;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a35 = a27 in
          M[271C] := a35;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a36 = add17(0020,271C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a37 = a34[15:8] in
          let:8 a38 = a34[7:0] in
          let:16 a39 = (1 + (a37,a38)) in
          let:8 a40 = M[(a37,a38)] in
          let:8 a41 = a39[15:8] in
          let:8 a42 = a39[7:0] in
          let:16 a43 = (1 + (a41,a42)) in
          let:8 a44 = M[(a41,a42)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a45 = a44 in
          let:16 a46 = addWithCarry(!true,a45,~00) in
          let:8 a47 = (a45 & 0F) in
          let:8 a48 = (~00 & 0F) in
          let:16 a49 = addWithCarry(!true,a47,a48) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a46[7:0])) {
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a43[15:8];
            SPL := a43[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a50 = a43[15:8] in
            let:8 a51 = a43[7:0] in
            let:16 a52 = (1 + (a50,a51)) in
            let:8 a53 = M[(a50,a51)] in
            let:8 a54 = a52[15:8] in
            let:8 a55 = a52[7:0] in
            let:16 a56 = (1 + (a54,a55)) in
            let:8 a57 = M[(a54,a55)] in
            advance (10)
            A := a27;
            B := a46[7:0];
            C := a40;
            H := a36[15:0][15:8];
            L := a36[15:0][7:0];
            SPH := a56[15:8];
            SPL := a56[7:0];
            FlagS := a46[7:0][7];
            FlagZ := is_zero(a46[7:0]);
            FlagA := a49[7:0][4];
            FlagP := parity(a46[7:0]);
            FlagCY := a36[16];
            jump ((a57,a53));
          }
        } else {
          advance (10)
          #08C8
          #instruction: LD   HL,391C
          advance (10)
          #08CB
          #instruction: CALL 14CB
          let:8 a58 = SPH in
          let:8 a59 = SPL in
          let:16 a60 = (-1 + (a58,a59)) in
          M[a60] := 08;
          let:8 a61 = a60[15:8] in
          let:8 a62 = a60[7:0] in
          let:16 a63 = (-1 + (a61,a62)) in
          M[a63] := CE;
          #return-to: 08CE
          advance (17)
          #14CB
          #instruction: XOR  A
          let:8 a64 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a65 = updateBit((a18 >> 01),7,a18[0]) in
          let:8 a66 = (a64 ^ a65) in
          advance (4)
          #14CC
          #instruction: PUSH BC
          let:8 a67 = C in
          let:8 a68 = a63[15:8] in
          let:8 a69 = a63[7:0] in
          let:16 a70 = (-1 + (a68,a69)) in
          M[a70] := 20;
          let:8 a71 = a70[15:8] in
          let:8 a72 = a70[7:0] in
          let:16 a73 = (-1 + (a71,a72)) in
          M[a73] := a67;
          advance (11)
          #14CD
          #instruction: LD   (HL),A
          let:8 a74 = a66 in
          M[391C] := a74;
          advance (7)
          #14CE
          #instruction: LD   BC,0020
          advance (10)
          #14D1
          #instruction: ADD  HL,BC
          let:17 a75 = add17(0020,391C) in
          advance (10)
          #14D2
          #instruction: POP  BC
          let:8 a76 = a73[15:8] in
          let:8 a77 = a73[7:0] in
          let:16 a78 = (1 + (a76,a77)) in
          let:8 a79 = M[(a76,a77)] in
          let:8 a80 = a78[15:8] in
          let:8 a81 = a78[7:0] in
          let:16 a82 = (1 + (a80,a81)) in
          let:8 a83 = M[(a80,a81)] in
          advance (10)
          #14D3
          #instruction: DEC  B
          let:8 a84 = a83 in
          let:16 a85 = addWithCarry(!true,a84,~00) in
          let:8 a86 = (a84 & 0F) in
          let:8 a87 = (~00 & 0F) in
          let:16 a88 = addWithCarry(!true,a86,a87) in
          advance (5)
          #14D4
          #instruction: JP   NZ,14CC
          if (!is_zero(a85[7:0])) {
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a82[15:8];
            SPL := a82[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump (14CC);
          } else {
            advance (10)
            #14D7
            #instruction: RET
            let:8 a89 = a82[15:8] in
            let:8 a90 = a82[7:0] in
            let:16 a91 = (1 + (a89,a90)) in
            let:8 a92 = M[(a89,a90)] in
            let:8 a93 = a91[15:8] in
            let:8 a94 = a91[7:0] in
            let:16 a95 = (1 + (a93,a94)) in
            let:8 a96 = M[(a93,a94)] in
            advance (10)
            A := a66;
            B := a85[7:0];
            C := a79;
            H := a75[15:0][15:8];
            L := a75[15:0][7:0];
            SPH := a95[15:8];
            SPL := a95[7:0];
            FlagS := a85[7:0][7];
            FlagZ := is_zero(a85[7:0]);
            FlagA := a88[7:0][4];
            FlagP := parity(a85[7:0]);
            FlagCY := a75[16];
            jump ((a96,a92));
          }
        }
      } else {
        advance (10)
        #08B3
        #instruction: CALL 09CA
        let:8 a97 = SPH in
        let:8 a98 = SPL in
        let:16 a99 = (-1 + (a97,a98)) in
        M[a99] := 08;
        let:8 a100 = a99[15:8] in
        let:8 a101 = a99[7:0] in
        let:16 a102 = (-1 + (a100,a101)) in
        M[a102] := B6;
        #return-to: 08B6
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        let:8 a103 = M[2067] in
        advance (13)
        #09CD
        #instruction: RRCA
        let:8 a104 = a103 in
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (a104[0]) {
          let:8 a105 = a102[15:8] in
          let:8 a106 = a102[7:0] in
          let:16 a107 = (1 + (a105,a106)) in
          let:8 a108 = M[(a105,a106)] in
          let:8 a109 = a107[15:8] in
          let:8 a110 = a107[7:0] in
          let:16 a111 = (1 + (a109,a110)) in
          let:8 a112 = M[(a109,a110)] in
          advance (11)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := F8;
          SPH := a111[15:8];
          SPL := a111[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a112,a108));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:8 a113 = a102[15:8] in
          let:8 a114 = a102[7:0] in
          let:16 a115 = (1 + (a113,a114)) in
          let:8 a116 = M[(a113,a114)] in
          let:8 a117 = a115[15:8] in
          let:8 a118 = a115[7:0] in
          let:16 a119 = (1 + (a117,a118)) in
          let:8 a120 = M[(a117,a118)] in
          advance (10)
          A := updateBit((a104 >> 01),7,a104[0]);
          H := 20;
          L := FC;
          SPH := a119[15:8];
          SPL := a119[7:0];
          FlagS := a15[7];
          FlagZ := is_zero(a15);
          FlagA := a16[3];
          FlagP := parity(a15);
          FlagCY := a104[0];
          jump ((a120,a116));
        }
      }
    }

08F8:

    #08F8
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #08F9
    #instruction: INC  DE
    let:8 a9 = a8 in
    let:8 a10 = a4 in
    let:16 a11 = (1 + (a9,a10)) in
    advance (5)
    #08FA
    #instruction: DEC  C
    let:8 a12 = C in
    let:16 a13 = addWithCarry(!true,a12,~00) in
    let:8 a14 = (a12 & 0F) in
    let:8 a15 = (~00 & 0F) in
    let:16 a16 = addWithCarry(!true,a14,a15) in
    advance (5)
    #08FB
    #instruction: JP   NZ,08F3
    if (!is_zero(a13[7:0])) {
      advance (10)
      #08F3
      #instruction: LD   A,(DE)
      let:8 a17 = a11[15:8] in
      let:8 a18 = a11[7:0] in
      let:8 a19 = M[(a17,a18)] in
      advance (7)
      #08F4
      #instruction: PUSH DE
      let:8 a20 = a11[15:8] in
      let:8 a21 = a11[7:0] in
      let:8 a22 = a7[15:8] in
      let:8 a23 = a7[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := a20;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := a21;
      advance (11)
      #08F5
      #instruction: CALL 08FF
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 08;
      let:8 a31 = a30[15:8] in
      let:8 a32 = a30[7:0] in
      let:16 a33 = (-1 + (a31,a32)) in
      M[a33] := F8;
      #return-to: 08F8
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a34 = H in
      let:8 a35 = L in
      let:8 a36 = a33[15:8] in
      let:8 a37 = a33[7:0] in
      let:16 a38 = (-1 + (a36,a37)) in
      M[a38] := a34;
      let:8 a39 = a38[15:8] in
      let:8 a40 = a38[7:0] in
      let:16 a41 = (-1 + (a39,a40)) in
      M[a41] := a35;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a42 = a19 in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a43 = a42 in
      let:8 a44 = a42 in
      let:17 a45 = add17((00,a43),(00,a44)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a46 = a45[15:0][15:8] in
      let:8 a47 = a45[15:0][7:0] in
      let:8 a48 = a45[15:0][15:8] in
      let:8 a49 = a45[15:0][7:0] in
      let:17 a50 = add17((a46,a47),(a48,a49)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a51 = a50[15:0][15:8] in
      let:8 a52 = a50[15:0][7:0] in
      let:8 a53 = a50[15:0][15:8] in
      let:8 a54 = a50[15:0][7:0] in
      let:17 a55 = add17((a51,a52),(a53,a54)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a56 = a55[15:0][15:8] in
      let:8 a57 = a55[15:0][7:0] in
      let:17 a58 = add17(1E00,(a56,a57)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a59 = a58[15:0][15:8] in
      let:8 a60 = a58[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a61 = a41[15:8] in
      let:8 a62 = a41[7:0] in
      let:16 a63 = (1 + (a61,a62)) in
      let:8 a64 = M[(a61,a62)] in
      let:8 a65 = a63[15:8] in
      let:8 a66 = a63[7:0] in
      let:16 a67 = (1 + (a65,a66)) in
      let:8 a68 = M[(a65,a66)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a69 = a19 in
      unknown_output(6,a69);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a70 = a13[7:0] in
      let:8 a71 = a67[15:8] in
      let:8 a72 = a67[7:0] in
      let:16 a73 = (-1 + (a71,a72)) in
      M[a73] := 08;
      let:8 a74 = a73[15:8] in
      let:8 a75 = a73[7:0] in
      let:16 a76 = (-1 + (a74,a75)) in
      M[a76] := a70;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a77 = a59 in
      let:8 a78 = a60 in
      let:8 a79 = M[(a77,a78)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a80 = a79 in
      let:8 a81 = a68 in
      let:8 a82 = a64 in
      M[(a81,a82)] := a80;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a83 = a59 in
      let:8 a84 = a60 in
      let:16 a85 = (1 + (a83,a84)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a86 = a68 in
      let:8 a87 = a64 in
      let:17 a88 = add17(0020,(a86,a87)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a89 = a76[15:8] in
      let:8 a90 = a76[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      let:8 a92 = M[(a89,a90)] in
      let:8 a93 = a91[15:8] in
      let:8 a94 = a91[7:0] in
      let:16 a95 = (1 + (a93,a94)) in
      let:8 a96 = M[(a93,a94)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a97 = a96 in
      let:16 a98 = addWithCarry(!true,a97,~00) in
      let:8 a99 = (a97 & 0F) in
      let:8 a100 = (~00 & 0F) in
      let:16 a101 = addWithCarry(!true,a99,a100) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a98[7:0])) {
        advance (10)
        A := a79;
        B := a98[7:0];
        C := a92;
        D := a85[15:8];
        E := a85[7:0];
        H := a88[15:0][15:8];
        L := a88[15:0][7:0];
        SPH := a95[15:8];
        SPL := a95[7:0];
        FlagS := a98[7:0][7];
        FlagZ := is_zero(a98[7:0]);
        FlagA := a101[7:0][4];
        FlagP := parity(a98[7:0]);
        FlagCY := a88[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a102 = a95[15:8] in
        let:8 a103 = a95[7:0] in
        let:16 a104 = (1 + (a102,a103)) in
        let:8 a105 = M[(a102,a103)] in
        let:8 a106 = a104[15:8] in
        let:8 a107 = a104[7:0] in
        let:16 a108 = (1 + (a106,a107)) in
        let:8 a109 = M[(a106,a107)] in
        advance (10)
        A := a79;
        B := a98[7:0];
        C := a92;
        D := a85[15:8];
        E := a85[7:0];
        H := a88[15:0][15:8];
        L := a88[15:0][7:0];
        SPH := a108[15:8];
        SPL := a108[7:0];
        FlagS := a98[7:0][7];
        FlagZ := is_zero(a98[7:0]);
        FlagA := a101[7:0][4];
        FlagP := parity(a98[7:0]);
        FlagCY := a88[16];
        jump ((a109,a105));
      }
    } else {
      advance (10)
      #08FE
      #instruction: RET
      let:8 a110 = a7[15:8] in
      let:8 a111 = a7[7:0] in
      let:16 a112 = (1 + (a110,a111)) in
      let:8 a113 = M[(a110,a111)] in
      let:8 a114 = a112[15:8] in
      let:8 a115 = a112[7:0] in
      let:16 a116 = (1 + (a114,a115)) in
      let:8 a117 = M[(a114,a115)] in
      advance (10)
      C := a13[7:0];
      D := a11[15:8];
      E := a11[7:0];
      SPH := a116[15:8];
      SPL := a116[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      jump ((a117,a113));
    }

0931:

    #0931
    #instruction: LD   L,FF
    advance (7)
    #0933
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = M[(a1,FF)] in
    advance (7)
    #0934
    #instruction: RET
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (1 + (a3,a4)) in
    let:8 a6 = M[(a3,a4)] in
    let:8 a7 = a5[15:8] in
    let:8 a8 = a5[7:0] in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    advance (10)
    A := a2;
    L := FF;
    SPH := a9[15:8];
    SPL := a9[7:0];
    jump ((a10,a6));

0938:

    #0938
    #instruction: DEC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    #0939
    #instruction: DEC  HL
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    advance (5)
    #093A
    #instruction: LD   A,(HL)
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #093B
    #instruction: AND  A
    let:8 a10 = a9 in
    let:8 a11 = a9 in
    let:8 a12 = (a10 & a11) in
    let:8 a13 = (a10 | a11) in
    advance (4)
    #093C
    #instruction: RET  Z
    if (is_zero(a12)) {
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a12;
      H := a6[15:8];
      L := a6[7:0];
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a21,a17));
    } else {
      advance (5)
      #093D
      #instruction: LD   B,15
      advance (7)
      #093F
      #instruction: IN   02
      advance (10)
      #0941
      #instruction: AND  08
      let:8 a22 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
      let:8 a23 = (08 & a22) in
      let:8 a24 = (08 | a22) in
      advance (7)
      #0943
      #instruction: JP   Z,0948
      if (is_zero(a23)) {
        advance (10)
        #0948
        #instruction: CALL 09CA
        let:8 a25 = SPH in
        let:8 a26 = SPL in
        let:16 a27 = (-1 + (a25,a26)) in
        M[a27] := 09;
        let:8 a28 = a27[15:8] in
        let:8 a29 = a27[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 4B;
        #return-to: 094B
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        let:8 a31 = M[2067] in
        advance (13)
        #09CD
        #instruction: RRCA
        let:8 a32 = a31 in
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (a32[0]) {
          let:8 a33 = a30[15:8] in
          let:8 a34 = a30[7:0] in
          let:16 a35 = (1 + (a33,a34)) in
          let:8 a36 = M[(a33,a34)] in
          let:8 a37 = a35[15:8] in
          let:8 a38 = a35[7:0] in
          let:16 a39 = (1 + (a37,a38)) in
          let:8 a40 = M[(a37,a38)] in
          advance (11)
          A := updateBit((a32 >> 01),7,a32[0]);
          B := 15;
          H := 20;
          L := F8;
          SPH := a39[15:8];
          SPL := a39[7:0];
          FlagS := a23[7];
          FlagZ := is_zero(a23);
          FlagA := a24[3];
          FlagP := parity(a23);
          FlagCY := a32[0];
          jump ((a40,a36));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:8 a41 = a30[15:8] in
          let:8 a42 = a30[7:0] in
          let:16 a43 = (1 + (a41,a42)) in
          let:8 a44 = M[(a41,a42)] in
          let:8 a45 = a43[15:8] in
          let:8 a46 = a43[7:0] in
          let:16 a47 = (1 + (a45,a46)) in
          let:8 a48 = M[(a45,a46)] in
          advance (10)
          A := updateBit((a32 >> 01),7,a32[0]);
          B := 15;
          H := 20;
          L := FC;
          SPH := a47[15:8];
          SPL := a47[7:0];
          FlagS := a23[7];
          FlagZ := is_zero(a23);
          FlagA := a24[3];
          FlagP := parity(a23);
          FlagCY := a32[0];
          jump ((a48,a44));
        }
      } else {
        advance (10)
        #0946
        #instruction: LD   B,10
        advance (7)
        #0948
        #instruction: CALL 09CA
        let:8 a49 = SPH in
        let:8 a50 = SPL in
        let:16 a51 = (-1 + (a49,a50)) in
        M[a51] := 09;
        let:8 a52 = a51[15:8] in
        let:8 a53 = a51[7:0] in
        let:16 a54 = (-1 + (a52,a53)) in
        M[a54] := 4B;
        #return-to: 094B
        advance (17)
        #09CA
        #instruction: LD   A,(2067)
        let:8 a55 = M[2067] in
        advance (13)
        #09CD
        #instruction: RRCA
        let:8 a56 = a55 in
        advance (4)
        #09CE
        #instruction: LD   HL,20F8
        advance (10)
        #09D1
        #instruction: RET  CY
        if (a56[0]) {
          let:8 a57 = a54[15:8] in
          let:8 a58 = a54[7:0] in
          let:16 a59 = (1 + (a57,a58)) in
          let:8 a60 = M[(a57,a58)] in
          let:8 a61 = a59[15:8] in
          let:8 a62 = a59[7:0] in
          let:16 a63 = (1 + (a61,a62)) in
          let:8 a64 = M[(a61,a62)] in
          advance (11)
          A := updateBit((a56 >> 01),7,a56[0]);
          B := 10;
          H := 20;
          L := F8;
          SPH := a63[15:8];
          SPL := a63[7:0];
          FlagS := a23[7];
          FlagZ := is_zero(a23);
          FlagA := a24[3];
          FlagP := parity(a23);
          FlagCY := a56[0];
          jump ((a64,a60));
        } else {
          advance (5)
          #09D2
          #instruction: LD   HL,20FC
          advance (10)
          #09D5
          #instruction: RET
          let:8 a65 = a54[15:8] in
          let:8 a66 = a54[7:0] in
          let:16 a67 = (1 + (a65,a66)) in
          let:8 a68 = M[(a65,a66)] in
          let:8 a69 = a67[15:8] in
          let:8 a70 = a67[7:0] in
          let:16 a71 = (1 + (a69,a70)) in
          let:8 a72 = M[(a69,a70)] in
          advance (10)
          A := updateBit((a56 >> 01),7,a56[0]);
          B := 10;
          H := 20;
          L := FC;
          SPH := a71[15:8];
          SPL := a71[7:0];
          FlagS := a23[7];
          FlagZ := is_zero(a23);
          FlagA := a24[3];
          FlagP := parity(a23);
          FlagCY := a56[0];
          jump ((a72,a68));
        }
      }
    }

094B:

    #094B
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #094C
    #instruction: LD   A,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #094D
    #instruction: CP   B
    let:8 a7 = a6 in
    let:8 a8 = B in
    let:16 a9 = addWithCarry(!false,a7,~a8) in
    let:8 a10 = (a7 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (4)
    #094E
    #instruction: RET  CY
    if (!a9[15:8][0]) {
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a6;
      H := a3[15:8];
      L := a3[7:0];
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #094F
      #instruction: CALL 092E
      let:8 a21 = SPH in
      let:8 a22 = SPL in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 09;
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 52;
      #return-to: 0952
      advance (17)
      #092E
      #instruction: CALL 1611
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := 09;
      let:8 a30 = a29[15:8] in
      let:8 a31 = a29[7:0] in
      let:16 a32 = (-1 + (a30,a31)) in
      M[a32] := 31;
      #return-to: 0931
      advance (17)
      #1611
      #instruction: LD   L,00
      advance (7)
      #1613
      #instruction: LD   A,(2067)
      let:8 a33 = M[2067] in
      advance (13)
      #1616
      #instruction: LD   H,A
      let:8 a34 = a33 in
      advance (5)
      #1617
      #instruction: RET
      let:8 a35 = a32[15:8] in
      let:8 a36 = a32[7:0] in
      let:16 a37 = (1 + (a35,a36)) in
      let:8 a38 = M[(a35,a36)] in
      let:8 a39 = a37[15:8] in
      let:8 a40 = a37[7:0] in
      let:16 a41 = (1 + (a39,a40)) in
      let:8 a42 = M[(a39,a40)] in
      advance (10)
      A := a33;
      H := a34;
      L := 00;
      SPH := a41[15:8];
      SPL := a41[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a42,a38));
    }

0952:

    #0952
    #instruction: INC  (HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    let:16 a4 = addWithCarry(true,a3,00) in
    let:8 a5 = (a3 & 0F) in
    let:8 a6 = (00 & 0F) in
    let:16 a7 = addWithCarry(true,a5,a6) in
    let:8 a8 = H in
    let:8 a9 = L in
    M[(a8,a9)] := a4[7:0];
    advance (10)
    #0953
    #instruction: LD   A,(HL)
    let:8 a10 = H in
    let:8 a11 = L in
    let:8 a12 = M[(a10,a11)] in
    advance (7)
    #0954
    #instruction: PUSH PSW
    let:8 a13 = a12 in
    let:8 a14 = SPH in
    let:8 a15 = SPL in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a13;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a4[7:0][7]),6,is_zero(a4[7:0])),4,a7[7:0][4]),2,parity(a4[7:0])),0,FlagCY);
    advance (11)
    #0955
    #instruction: LD   HL,2501
    advance (10)
    #0958
    #instruction: INC  H
    let:16 a20 = addWithCarry(true,25,00) in
    let:8 a21 = (25 & 0F) in
    let:8 a22 = (00 & 0F) in
    let:16 a23 = addWithCarry(true,a21,a22) in
    advance (5)
    #0959
    #instruction: INC  H
    let:8 a24 = a20[7:0] in
    let:16 a25 = addWithCarry(true,a24,00) in
    let:8 a26 = (a24 & 0F) in
    let:8 a27 = (00 & 0F) in
    let:16 a28 = addWithCarry(true,a26,a27) in
    advance (5)
    #095A
    #instruction: DEC  A
    let:8 a29 = a12 in
    let:16 a30 = addWithCarry(!true,a29,~00) in
    let:8 a31 = (a29 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    advance (5)
    #095B
    #instruction: JP   NZ,0958
    if (!is_zero(a30[7:0])) {
      advance (10)
      A := a30[7:0];
      H := a25[7:0];
      L := 01;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      jump (0958);
    } else {
      advance (10)
      #095E
      #instruction: LD   B,10
      advance (7)
      #0960
      #instruction: LD   DE,1C60
      advance (10)
      #0963
      #instruction: CALL 1439
      let:8 a34 = a19[15:8] in
      let:8 a35 = a19[7:0] in
      let:16 a36 = (-1 + (a34,a35)) in
      M[a36] := 09;
      let:8 a37 = a36[15:8] in
      let:8 a38 = a36[7:0] in
      let:16 a39 = (-1 + (a37,a38)) in
      M[a39] := 66;
      #return-to: 0966
      advance (17)
      #1439
      #instruction: PUSH BC
      let:8 a40 = C in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (-1 + (a41,a42)) in
      M[a43] := 10;
      let:8 a44 = a43[15:8] in
      let:8 a45 = a43[7:0] in
      let:16 a46 = (-1 + (a44,a45)) in
      M[a46] := a40;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a47 = a25[7:0] in
      M[(a47,01)] := 00;
      advance (7)
      #143C
      #instruction: INC  DE
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a48 = a25[7:0] in
      let:17 a49 = add17(0020,(a48,01)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a50 = a46[15:8] in
      let:8 a51 = a46[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      let:8 a54 = a52[15:8] in
      let:8 a55 = a52[7:0] in
      let:16 a56 = (1 + (a54,a55)) in
      let:8 a57 = M[(a54,a55)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a58 = a57 in
      let:16 a59 = addWithCarry(!true,a58,~00) in
      let:8 a60 = (a58 & 0F) in
      let:8 a61 = (~00 & 0F) in
      let:16 a62 = addWithCarry(!true,a60,a61) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a59[7:0])) {
        advance (10)
        A := 00;
        B := a59[7:0];
        C := a53;
        D := 1C;
        E := 61;
        H := a49[15:0][15:8];
        L := a49[15:0][7:0];
        SPH := a56[15:8];
        SPL := a56[7:0];
        FlagS := a59[7:0][7];
        FlagZ := is_zero(a59[7:0]);
        FlagA := a62[7:0][4];
        FlagP := parity(a59[7:0]);
        FlagCY := a49[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a63 = a56[15:8] in
        let:8 a64 = a56[7:0] in
        let:16 a65 = (1 + (a63,a64)) in
        let:8 a66 = M[(a63,a64)] in
        let:8 a67 = a65[15:8] in
        let:8 a68 = a65[7:0] in
        let:16 a69 = (1 + (a67,a68)) in
        let:8 a70 = M[(a67,a68)] in
        advance (10)
        A := 00;
        B := a59[7:0];
        C := a53;
        D := 1C;
        E := 61;
        H := a49[15:0][15:8];
        L := a49[15:0][7:0];
        SPH := a69[15:8];
        SPL := a69[7:0];
        FlagS := a59[7:0][7];
        FlagZ := is_zero(a59[7:0]);
        FlagA := a62[7:0][4];
        FlagP := parity(a59[7:0]);
        FlagCY := a49[16];
        jump ((a70,a66));
      }
    }

0966:

    #0966
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0967
    #instruction: INC  A
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(true,a9,00) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (00 & 0F) in
    let:16 a13 = addWithCarry(true,a11,a12) in
    advance (5)
    #0968
    #instruction: CALL 1A8B
    let:8 a14 = a7[15:8] in
    let:8 a15 = a7[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := 09;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 6B;
    #return-to: 096B
    advance (17)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a20 = a10[7:0] in
    let:8 a21 = (0F & a20) in
    let:8 a22 = (0F | a20) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:8 a23 = a21 in
    let:16 a24 = addWithCarry(false,1A,a23) in
    let:8 a25 = (1A & 0F) in
    let:8 a26 = (a23 & 0F) in
    let:16 a27 = addWithCarry(false,a25,a26) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a28 = a19[15:8] in
    let:8 a29 = a19[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := 25;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a34 = a24[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a35 = a34 in
    let:8 a36 = a34 in
    let:17 a37 = add17((00,a35),(00,a36)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a38 = a37[15:0][15:8] in
    let:8 a39 = a37[15:0][7:0] in
    let:8 a40 = a37[15:0][15:8] in
    let:8 a41 = a37[15:0][7:0] in
    let:17 a42 = add17((a38,a39),(a40,a41)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a43 = a42[15:0][15:8] in
    let:8 a44 = a42[15:0][7:0] in
    let:8 a45 = a42[15:0][15:8] in
    let:8 a46 = a42[15:0][7:0] in
    let:17 a47 = add17((a43,a44),(a45,a46)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a48 = a47[15:0][15:8] in
    let:8 a49 = a47[15:0][7:0] in
    let:17 a50 = add17(1E00,(a48,a49)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a51 = a50[15:0][15:8] in
    let:8 a52 = a50[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a53 = a33[15:8] in
    let:8 a54 = a33[7:0] in
    let:16 a55 = (1 + (a53,a54)) in
    let:8 a56 = M[(a53,a54)] in
    let:8 a57 = a55[15:8] in
    let:8 a58 = a55[7:0] in
    let:16 a59 = (1 + (a57,a58)) in
    let:8 a60 = M[(a57,a58)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a61 = a24[7:0] in
    unknown_output(6,a61);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a62 = C in
    let:8 a63 = a59[15:8] in
    let:8 a64 = a59[7:0] in
    let:16 a65 = (-1 + (a63,a64)) in
    M[a65] := 08;
    let:8 a66 = a65[15:8] in
    let:8 a67 = a65[7:0] in
    let:16 a68 = (-1 + (a66,a67)) in
    M[a68] := a62;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a69 = a51 in
    let:8 a70 = a52 in
    let:8 a71 = M[(a69,a70)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a72 = a71 in
    let:8 a73 = a60 in
    let:8 a74 = a56 in
    M[(a73,a74)] := a72;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a75 = a51 in
    let:8 a76 = a52 in
    let:16 a77 = (1 + (a75,a76)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a78 = a60 in
    let:8 a79 = a56 in
    let:17 a80 = add17(0020,(a78,a79)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a81 = a68[15:8] in
    let:8 a82 = a68[7:0] in
    let:16 a83 = (1 + (a81,a82)) in
    let:8 a84 = M[(a81,a82)] in
    let:8 a85 = a83[15:8] in
    let:8 a86 = a83[7:0] in
    let:16 a87 = (1 + (a85,a86)) in
    let:8 a88 = M[(a85,a86)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a89 = a88 in
    let:16 a90 = addWithCarry(!true,a89,~00) in
    let:8 a91 = (a89 & 0F) in
    let:8 a92 = (~00 & 0F) in
    let:16 a93 = addWithCarry(!true,a91,a92) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a90[7:0])) {
      advance (10)
      A := a71;
      B := a90[7:0];
      C := a84;
      D := a77[15:8];
      E := a77[7:0];
      H := a80[15:0][15:8];
      L := a80[15:0][7:0];
      SPH := a87[15:8];
      SPL := a87[7:0];
      FlagS := a90[7:0][7];
      FlagZ := is_zero(a90[7:0]);
      FlagA := a93[7:0][4];
      FlagP := parity(a90[7:0]);
      FlagCY := a80[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a94 = a87[15:8] in
      let:8 a95 = a87[7:0] in
      let:16 a96 = (1 + (a94,a95)) in
      let:8 a97 = M[(a94,a95)] in
      let:8 a98 = a96[15:8] in
      let:8 a99 = a96[7:0] in
      let:16 a100 = (1 + (a98,a99)) in
      let:8 a101 = M[(a98,a99)] in
      advance (10)
      A := a71;
      B := a90[7:0];
      C := a84;
      D := a77[15:8];
      E := a77[7:0];
      H := a80[15:0][15:8];
      L := a80[15:0][7:0];
      SPH := a100[15:8];
      SPL := a100[7:0];
      FlagS := a90[7:0][7];
      FlagZ := is_zero(a90[7:0]);
      FlagA := a93[7:0][4];
      FlagP := parity(a90[7:0]);
      FlagCY := a80[16];
      jump ((a101,a97));
    }

096B:

    #096B
    #instruction: CALL 1910
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 09;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 6E;
    #return-to: 096E
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    let:8 a7 = M[2067] in
    advance (13)
    #1916
    #instruction: RRCA
    let:8 a8 = a7 in
    advance (4)
    #1917
    #instruction: RET  CY
    if (a8[0]) {
      let:8 a9 = a6[15:8] in
      let:8 a10 = a6[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E7;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagCY := a8[0];
      jump ((a16,a12));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:8 a17 = a6[15:8] in
      let:8 a18 = a6[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E8;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagCY := a8[0];
      jump ((a24,a20));
    }

096E:

    #096E
    #instruction: DEC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (-1 + (a1,a2)) in
    advance (5)
    #096F
    #instruction: DEC  HL
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    advance (5)
    #0970
    #instruction: LD   (HL),00
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    M[(a7,a8)] := 00;
    advance (10)
    #0972
    #instruction: LD   A,FF
    advance (7)
    #0974
    #instruction: LD   (2099),A
    M[2099] := FF;
    advance (13)
    #0977
    #instruction: LD   B,10
    advance (7)
    #0979
    #instruction: JP   18FA
    advance (10)
    #18FA
    #instruction: LD   A,(2094)
    let:8 a9 = M[2094] in
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a10 = a9 in
    let:8 a11 = (10 | a10) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    let:8 a12 = a11 in
    M[2094] := a12;
    advance (13)
    #1901
    #instruction: OUT  03
    let:8 a13 = a11 in
    sound_control(Ufo,a13[0]);
    sound_control(Shot,a13[1]);
    sound_control(PlayerDie,a13[2]);
    sound_control(InvaderDie,a13[3]);
    sound_control(ExtraLife,a13[4]);
    advance (10)
    #1903
    #instruction: RET
    let:8 a14 = SPH in
    let:8 a15 = SPL in
    let:16 a16 = (1 + (a14,a15)) in
    let:8 a17 = M[(a14,a15)] in
    let:8 a18 = a16[15:8] in
    let:8 a19 = a16[7:0] in
    let:16 a20 = (1 + (a18,a19)) in
    let:8 a21 = M[(a18,a19)] in
    advance (10)
    A := a11;
    B := 10;
    H := a6[15:8];
    L := a6[7:0];
    SPH := a20[15:8];
    SPL := a20[7:0];
    FlagS := a11[7];
    FlagZ := is_zero(a11);
    FlagA := false;
    FlagP := parity(a11);
    FlagCY := false;
    jump ((a21,a17));

098B:

    #098B
    #instruction: LD   A,(20F1)
    let:8 a1 = M[20F1] in
    advance (13)
    #098E
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #098F
    #instruction: RET  Z
    if (is_zero(a4)) {
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (11)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    } else {
      advance (5)
      #0990
      #instruction: XOR  A
      let:8 a14 = a4 in
      let:8 a15 = a4 in
      let:8 a16 = (a14 ^ a15) in
      advance (4)
      #0991
      #instruction: LD   (20F1),A
      let:8 a17 = a16 in
      M[20F1] := a17;
      advance (13)
      #0994
      #instruction: PUSH HL
      let:8 a18 = H in
      let:8 a19 = L in
      let:8 a20 = SPH in
      let:8 a21 = SPL in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := a18;
      let:8 a23 = a22[15:8] in
      let:8 a24 = a22[7:0] in
      let:16 a25 = (-1 + (a23,a24)) in
      M[a25] := a19;
      advance (11)
      #0995
      #instruction: LD   HL,(20F2)
      let:8 a26 = M[20F2] in
      let:8 a27 = M[20F3] in
      advance (16)
      #0998
      #instruction: EX   DE,HL
      let:8 a28 = D in
      let:8 a29 = E in
      let:8 a30 = a27 in
      let:8 a31 = a26 in
      advance (4)
      #0999
      #instruction: POP  HL
      let:8 a32 = a25[15:8] in
      let:8 a33 = a25[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      #099A
      #instruction: LD   A,(HL)
      let:8 a40 = a39 in
      let:8 a41 = a35 in
      let:8 a42 = M[(a40,a41)] in
      advance (7)
      #099B
      #instruction: ADD  E
      let:8 a43 = a31 in
      let:8 a44 = a42 in
      let:16 a45 = addWithCarry(false,a43,a44) in
      let:8 a46 = (a43 & 0F) in
      let:8 a47 = (a44 & 0F) in
      let:16 a48 = addWithCarry(false,a46,a47) in
      advance (4)
      #099C
      #instruction: DAA
      let:8 a49 = a45[7:0] in
      let:8 a50 = (a49 & 0F) in
      let:16 a51 = addWithCarry(false,a50,06) in
      let:16 a52 = addWithCarry(((((a50[1] || a50[2]) && a50[3]) || a48[7:0][4]) ? a51[7:0] : a50)[4],(a49 >> 04),00) in
      let:16 a53 = addWithCarry(false,a52[7:0],06) in
      let:8 a54 = (((((a50[1] || a50[2]) && a50[3]) || a48[7:0][4]) ? a51[7:0] : a50) & 0F) in
      let:8 a55 = ((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0]) << 04) | a54) in
      advance (4)
      #099D
      #instruction: LD   (HL),A
      let:8 a56 = a55 in
      let:8 a57 = a39 in
      let:8 a58 = a35 in
      M[(a57,a58)] := a56;
      advance (7)
      #099E
      #instruction: LD   E,A
      let:8 a59 = a55 in
      advance (5)
      #099F
      #instruction: INC  HL
      let:8 a60 = a39 in
      let:8 a61 = a35 in
      let:16 a62 = (1 + (a60,a61)) in
      advance (5)
      #09A0
      #instruction: LD   A,(HL)
      let:8 a63 = a62[15:8] in
      let:8 a64 = a62[7:0] in
      let:8 a65 = M[(a63,a64)] in
      advance (7)
      #09A1
      #instruction: ADC  D
      let:8 a66 = a30 in
      let:8 a67 = a65 in
      let:16 a68 = addWithCarry((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0])[4] || a45[15:8][0]),a66,a67) in
      let:8 a69 = (a66 & 0F) in
      let:8 a70 = (a67 & 0F) in
      let:16 a71 = addWithCarry((((((a52[7:0][1] || a52[7:0][2]) && a52[7:0][3]) || a45[15:8][0]) ? a53[7:0] : a52[7:0])[4] || a45[15:8][0]),a69,a70) in
      advance (4)
      #09A2
      #instruction: DAA
      let:8 a72 = a68[7:0] in
      let:8 a73 = (a72 & 0F) in
      let:16 a74 = addWithCarry(false,a73,06) in
      let:16 a75 = addWithCarry(((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73)[4],(a72 >> 04),00) in
      let:16 a76 = addWithCarry(false,a75[7:0],06) in
      let:8 a77 = (((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73) & 0F) in
      let:8 a78 = ((((((a75[7:0][1] || a75[7:0][2]) && a75[7:0][3]) || a68[15:8][0]) ? a76[7:0] : a75[7:0]) << 04) | a77) in
      advance (4)
      #09A3
      #instruction: LD   (HL),A
      let:8 a79 = a78 in
      let:8 a80 = a62[15:8] in
      let:8 a81 = a62[7:0] in
      M[(a80,a81)] := a79;
      advance (7)
      #09A4
      #instruction: LD   D,A
      let:8 a82 = a78 in
      advance (5)
      #09A5
      #instruction: INC  HL
      let:8 a83 = a62[15:8] in
      let:8 a84 = a62[7:0] in
      let:16 a85 = (1 + (a83,a84)) in
      advance (5)
      #09A6
      #instruction: LD   A,(HL)
      let:8 a86 = a85[15:8] in
      let:8 a87 = a85[7:0] in
      let:8 a88 = M[(a86,a87)] in
      advance (7)
      #09A7
      #instruction: INC  HL
      let:8 a89 = a85[15:8] in
      let:8 a90 = a85[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      advance (5)
      #09A8
      #instruction: LD   H,(HL)
      let:8 a92 = a91[15:8] in
      let:8 a93 = a91[7:0] in
      let:8 a94 = M[(a92,a93)] in
      advance (7)
      #09A9
      #instruction: LD   L,A
      let:8 a95 = a88 in
      advance (5)
      #09AA
      #instruction: JP   09AD
      advance (10)
      #09AD
      #instruction: LD   A,D
      let:8 a96 = a82 in
      advance (5)
      #09AE
      #instruction: CALL 09B2
      let:8 a97 = a38[15:8] in
      let:8 a98 = a38[7:0] in
      let:16 a99 = (-1 + (a97,a98)) in
      M[a99] := 09;
      let:8 a100 = a99[15:8] in
      let:8 a101 = a99[7:0] in
      let:16 a102 = (-1 + (a100,a101)) in
      M[a102] := B1;
      #return-to: 09B1
      advance (17)
      #09B2
      #instruction: PUSH DE
      let:8 a103 = a82 in
      let:8 a104 = a59 in
      let:8 a105 = a102[15:8] in
      let:8 a106 = a102[7:0] in
      let:16 a107 = (-1 + (a105,a106)) in
      M[a107] := a103;
      let:8 a108 = a107[15:8] in
      let:8 a109 = a107[7:0] in
      let:16 a110 = (-1 + (a108,a109)) in
      M[a110] := a104;
      advance (11)
      #09B3
      #instruction: PUSH PSW
      let:8 a111 = a96 in
      let:8 a112 = a110[15:8] in
      let:8 a113 = a110[7:0] in
      let:16 a114 = (-1 + (a112,a113)) in
      M[a114] := a111;
      let:8 a115 = a114[15:8] in
      let:8 a116 = a114[7:0] in
      let:16 a117 = (-1 + (a115,a116)) in
      M[a117] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a78[7]),6,is_zero(a78)),4,((((a73[1] || a73[2]) && a73[3]) || a71[7:0][4]) ? a74[7:0] : a73)[4]),2,parity(a78)),0,(((((a75[7:0][1] || a75[7:0][2]) && a75[7:0][3]) || a68[15:8][0]) ? a76[7:0] : a75[7:0])[4] || a68[15:8][0]));
      advance (11)
      #09B4
      #instruction: RRCA
      let:8 a118 = a96 in
      advance (4)
      #09B5
      #instruction: RRCA
      let:8 a119 = updateBit((a118 >> 01),7,a118[0]) in
      advance (4)
      #09B6
      #instruction: RRCA
      let:8 a120 = updateBit((a119 >> 01),7,a119[0]) in
      advance (4)
      #09B7
      #instruction: RRCA
      let:8 a121 = updateBit((a120 >> 01),7,a120[0]) in
      advance (4)
      #09B8
      #instruction: AND  0F
      let:8 a122 = updateBit((a121 >> 01),7,a121[0]) in
      let:8 a123 = (0F & a122) in
      let:8 a124 = (0F | a122) in
      advance (7)
      #09BA
      #instruction: CALL 09C5
      let:8 a125 = a117[15:8] in
      let:8 a126 = a117[7:0] in
      let:16 a127 = (-1 + (a125,a126)) in
      M[a127] := 09;
      let:8 a128 = a127[15:8] in
      let:8 a129 = a127[7:0] in
      let:16 a130 = (-1 + (a128,a129)) in
      M[a130] := BD;
      #return-to: 09BD
      advance (17)
      #09C5
      #instruction: ADD  1A
      let:8 a131 = a123 in
      let:16 a132 = addWithCarry(false,1A,a131) in
      let:8 a133 = (1A & 0F) in
      let:8 a134 = (a131 & 0F) in
      let:16 a135 = addWithCarry(false,a133,a134) in
      advance (7)
      #09C7
      #instruction: JP   08FF
      advance (10)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a136 = a94 in
      let:8 a137 = a95 in
      let:8 a138 = a130[15:8] in
      let:8 a139 = a130[7:0] in
      let:16 a140 = (-1 + (a138,a139)) in
      M[a140] := a136;
      let:8 a141 = a140[15:8] in
      let:8 a142 = a140[7:0] in
      let:16 a143 = (-1 + (a141,a142)) in
      M[a143] := a137;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a144 = a132[7:0] in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a145 = a144 in
      let:8 a146 = a144 in
      let:17 a147 = add17((00,a145),(00,a146)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a148 = a147[15:0][15:8] in
      let:8 a149 = a147[15:0][7:0] in
      let:8 a150 = a147[15:0][15:8] in
      let:8 a151 = a147[15:0][7:0] in
      let:17 a152 = add17((a148,a149),(a150,a151)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a153 = a152[15:0][15:8] in
      let:8 a154 = a152[15:0][7:0] in
      let:8 a155 = a152[15:0][15:8] in
      let:8 a156 = a152[15:0][7:0] in
      let:17 a157 = add17((a153,a154),(a155,a156)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a158 = a157[15:0][15:8] in
      let:8 a159 = a157[15:0][7:0] in
      let:17 a160 = add17(1E00,(a158,a159)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a161 = a160[15:0][15:8] in
      let:8 a162 = a160[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a163 = a143[15:8] in
      let:8 a164 = a143[7:0] in
      let:16 a165 = (1 + (a163,a164)) in
      let:8 a166 = M[(a163,a164)] in
      let:8 a167 = a165[15:8] in
      let:8 a168 = a165[7:0] in
      let:16 a169 = (1 + (a167,a168)) in
      let:8 a170 = M[(a167,a168)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a171 = a132[7:0] in
      unknown_output(6,a171);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a172 = C in
      let:8 a173 = a169[15:8] in
      let:8 a174 = a169[7:0] in
      let:16 a175 = (-1 + (a173,a174)) in
      M[a175] := 08;
      let:8 a176 = a175[15:8] in
      let:8 a177 = a175[7:0] in
      let:16 a178 = (-1 + (a176,a177)) in
      M[a178] := a172;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a179 = a161 in
      let:8 a180 = a162 in
      let:8 a181 = M[(a179,a180)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a182 = a181 in
      let:8 a183 = a170 in
      let:8 a184 = a166 in
      M[(a183,a184)] := a182;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a185 = a161 in
      let:8 a186 = a162 in
      let:16 a187 = (1 + (a185,a186)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a188 = a170 in
      let:8 a189 = a166 in
      let:17 a190 = add17(0020,(a188,a189)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a191 = a178[15:8] in
      let:8 a192 = a178[7:0] in
      let:16 a193 = (1 + (a191,a192)) in
      let:8 a194 = M[(a191,a192)] in
      let:8 a195 = a193[15:8] in
      let:8 a196 = a193[7:0] in
      let:16 a197 = (1 + (a195,a196)) in
      let:8 a198 = M[(a195,a196)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a199 = a198 in
      let:16 a200 = addWithCarry(!true,a199,~00) in
      let:8 a201 = (a199 & 0F) in
      let:8 a202 = (~00 & 0F) in
      let:16 a203 = addWithCarry(!true,a201,a202) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a200[7:0])) {
        advance (10)
        A := a181;
        B := a200[7:0];
        C := a194;
        D := a187[15:8];
        E := a187[7:0];
        H := a190[15:0][15:8];
        L := a190[15:0][7:0];
        SPH := a197[15:8];
        SPL := a197[7:0];
        FlagS := a200[7:0][7];
        FlagZ := is_zero(a200[7:0]);
        FlagA := a203[7:0][4];
        FlagP := parity(a200[7:0]);
        FlagCY := a190[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a204 = a197[15:8] in
        let:8 a205 = a197[7:0] in
        let:16 a206 = (1 + (a204,a205)) in
        let:8 a207 = M[(a204,a205)] in
        let:8 a208 = a206[15:8] in
        let:8 a209 = a206[7:0] in
        let:16 a210 = (1 + (a208,a209)) in
        let:8 a211 = M[(a208,a209)] in
        advance (10)
        A := a181;
        B := a200[7:0];
        C := a194;
        D := a187[15:8];
        E := a187[7:0];
        H := a190[15:0][15:8];
        L := a190[15:0][7:0];
        SPH := a210[15:8];
        SPL := a210[7:0];
        FlagS := a200[7:0][7];
        FlagZ := is_zero(a200[7:0]);
        FlagA := a203[7:0][4];
        FlagP := parity(a200[7:0]);
        FlagCY := a190[16];
        jump ((a211,a207));
      }
    }

09B1:

    #09B1
    #instruction: LD   A,E
    let:8 a1 = E in
    advance (5)
    #09B2
    #instruction: PUSH DE
    let:8 a2 = D in
    let:8 a3 = E in
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := a2;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := a3;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a10 = a1 in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a10;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a17 = a1 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a18 = updateBit((a17 >> 01),7,a17[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a19 = updateBit((a18 >> 01),7,a18[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a20 = updateBit((a19 >> 01),7,a19[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a21 = updateBit((a20 >> 01),7,a20[0]) in
    let:8 a22 = (0F & a21) in
    let:8 a23 = (0F | a21) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a24 = a16[15:8] in
    let:8 a25 = a16[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := 09;
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:16 a29 = (-1 + (a27,a28)) in
    M[a29] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a30 = a22 in
    let:16 a31 = addWithCarry(false,1A,a30) in
    let:8 a32 = (1A & 0F) in
    let:8 a33 = (a30 & 0F) in
    let:16 a34 = addWithCarry(false,a32,a33) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a35 = H in
    let:8 a36 = L in
    let:8 a37 = a29[15:8] in
    let:8 a38 = a29[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := a35;
    let:8 a40 = a39[15:8] in
    let:8 a41 = a39[7:0] in
    let:16 a42 = (-1 + (a40,a41)) in
    M[a42] := a36;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a43 = a31[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a44 = a43 in
    let:8 a45 = a43 in
    let:17 a46 = add17((00,a44),(00,a45)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a47 = a46[15:0][15:8] in
    let:8 a48 = a46[15:0][7:0] in
    let:8 a49 = a46[15:0][15:8] in
    let:8 a50 = a46[15:0][7:0] in
    let:17 a51 = add17((a47,a48),(a49,a50)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a52 = a51[15:0][15:8] in
    let:8 a53 = a51[15:0][7:0] in
    let:8 a54 = a51[15:0][15:8] in
    let:8 a55 = a51[15:0][7:0] in
    let:17 a56 = add17((a52,a53),(a54,a55)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a57 = a56[15:0][15:8] in
    let:8 a58 = a56[15:0][7:0] in
    let:17 a59 = add17(1E00,(a57,a58)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a60 = a59[15:0][15:8] in
    let:8 a61 = a59[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a62 = a42[15:8] in
    let:8 a63 = a42[7:0] in
    let:16 a64 = (1 + (a62,a63)) in
    let:8 a65 = M[(a62,a63)] in
    let:8 a66 = a64[15:8] in
    let:8 a67 = a64[7:0] in
    let:16 a68 = (1 + (a66,a67)) in
    let:8 a69 = M[(a66,a67)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a70 = a31[7:0] in
    unknown_output(6,a70);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a71 = C in
    let:8 a72 = a68[15:8] in
    let:8 a73 = a68[7:0] in
    let:16 a74 = (-1 + (a72,a73)) in
    M[a74] := 08;
    let:8 a75 = a74[15:8] in
    let:8 a76 = a74[7:0] in
    let:16 a77 = (-1 + (a75,a76)) in
    M[a77] := a71;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a78 = a60 in
    let:8 a79 = a61 in
    let:8 a80 = M[(a78,a79)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a81 = a80 in
    let:8 a82 = a69 in
    let:8 a83 = a65 in
    M[(a82,a83)] := a81;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a84 = a60 in
    let:8 a85 = a61 in
    let:16 a86 = (1 + (a84,a85)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a87 = a69 in
    let:8 a88 = a65 in
    let:17 a89 = add17(0020,(a87,a88)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a90 = a77[15:8] in
    let:8 a91 = a77[7:0] in
    let:16 a92 = (1 + (a90,a91)) in
    let:8 a93 = M[(a90,a91)] in
    let:8 a94 = a92[15:8] in
    let:8 a95 = a92[7:0] in
    let:16 a96 = (1 + (a94,a95)) in
    let:8 a97 = M[(a94,a95)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a98 = a97 in
    let:16 a99 = addWithCarry(!true,a98,~00) in
    let:8 a100 = (a98 & 0F) in
    let:8 a101 = (~00 & 0F) in
    let:16 a102 = addWithCarry(!true,a100,a101) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a99[7:0])) {
      advance (10)
      A := a80;
      B := a99[7:0];
      C := a93;
      D := a86[15:8];
      E := a86[7:0];
      H := a89[15:0][15:8];
      L := a89[15:0][7:0];
      SPH := a96[15:8];
      SPL := a96[7:0];
      FlagS := a99[7:0][7];
      FlagZ := is_zero(a99[7:0]);
      FlagA := a102[7:0][4];
      FlagP := parity(a99[7:0]);
      FlagCY := a89[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a103 = a96[15:8] in
      let:8 a104 = a96[7:0] in
      let:16 a105 = (1 + (a103,a104)) in
      let:8 a106 = M[(a103,a104)] in
      let:8 a107 = a105[15:8] in
      let:8 a108 = a105[7:0] in
      let:16 a109 = (1 + (a107,a108)) in
      let:8 a110 = M[(a107,a108)] in
      advance (10)
      A := a80;
      B := a99[7:0];
      C := a93;
      D := a86[15:8];
      E := a86[7:0];
      H := a89[15:0][15:8];
      L := a89[15:0][7:0];
      SPH := a109[15:8];
      SPL := a109[7:0];
      FlagS := a99[7:0][7];
      FlagZ := is_zero(a99[7:0]);
      FlagA := a102[7:0][4];
      FlagP := parity(a99[7:0]);
      FlagCY := a89[16];
      jump ((a110,a106));
    }

09BD:

    #09BD
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #09BE
    #instruction: AND  0F
    let:8 a9 = a8 in
    let:8 a10 = (0F & a9) in
    let:8 a11 = (0F | a9) in
    advance (7)
    #09C0
    #instruction: CALL 09C5
    let:8 a12 = a7[15:8] in
    let:8 a13 = a7[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 09;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := C3;
    #return-to: 09C3
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a18 = a10 in
    let:16 a19 = addWithCarry(false,1A,a18) in
    let:8 a20 = (1A & 0F) in
    let:8 a21 = (a18 & 0F) in
    let:16 a22 = addWithCarry(false,a20,a21) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a23 = H in
    let:8 a24 = L in
    let:8 a25 = a17[15:8] in
    let:8 a26 = a17[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := a23;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a24;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a31 = a19[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a32 = a31 in
    let:8 a33 = a31 in
    let:17 a34 = add17((00,a32),(00,a33)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a35 = a34[15:0][15:8] in
    let:8 a36 = a34[15:0][7:0] in
    let:8 a37 = a34[15:0][15:8] in
    let:8 a38 = a34[15:0][7:0] in
    let:17 a39 = add17((a35,a36),(a37,a38)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a40 = a39[15:0][15:8] in
    let:8 a41 = a39[15:0][7:0] in
    let:8 a42 = a39[15:0][15:8] in
    let:8 a43 = a39[15:0][7:0] in
    let:17 a44 = add17((a40,a41),(a42,a43)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a45 = a44[15:0][15:8] in
    let:8 a46 = a44[15:0][7:0] in
    let:17 a47 = add17(1E00,(a45,a46)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a48 = a47[15:0][15:8] in
    let:8 a49 = a47[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a50 = a30[15:8] in
    let:8 a51 = a30[7:0] in
    let:16 a52 = (1 + (a50,a51)) in
    let:8 a53 = M[(a50,a51)] in
    let:8 a54 = a52[15:8] in
    let:8 a55 = a52[7:0] in
    let:16 a56 = (1 + (a54,a55)) in
    let:8 a57 = M[(a54,a55)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a58 = a19[7:0] in
    unknown_output(6,a58);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a59 = C in
    let:8 a60 = a56[15:8] in
    let:8 a61 = a56[7:0] in
    let:16 a62 = (-1 + (a60,a61)) in
    M[a62] := 08;
    let:8 a63 = a62[15:8] in
    let:8 a64 = a62[7:0] in
    let:16 a65 = (-1 + (a63,a64)) in
    M[a65] := a59;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a66 = a48 in
    let:8 a67 = a49 in
    let:8 a68 = M[(a66,a67)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a69 = a68 in
    let:8 a70 = a57 in
    let:8 a71 = a53 in
    M[(a70,a71)] := a69;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a72 = a48 in
    let:8 a73 = a49 in
    let:16 a74 = (1 + (a72,a73)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a75 = a57 in
    let:8 a76 = a53 in
    let:17 a77 = add17(0020,(a75,a76)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a78 = a65[15:8] in
    let:8 a79 = a65[7:0] in
    let:16 a80 = (1 + (a78,a79)) in
    let:8 a81 = M[(a78,a79)] in
    let:8 a82 = a80[15:8] in
    let:8 a83 = a80[7:0] in
    let:16 a84 = (1 + (a82,a83)) in
    let:8 a85 = M[(a82,a83)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a86 = a85 in
    let:16 a87 = addWithCarry(!true,a86,~00) in
    let:8 a88 = (a86 & 0F) in
    let:8 a89 = (~00 & 0F) in
    let:16 a90 = addWithCarry(!true,a88,a89) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a87[7:0])) {
      advance (10)
      A := a68;
      B := a87[7:0];
      C := a81;
      D := a74[15:8];
      E := a74[7:0];
      H := a77[15:0][15:8];
      L := a77[15:0][7:0];
      SPH := a84[15:8];
      SPL := a84[7:0];
      FlagS := a87[7:0][7];
      FlagZ := is_zero(a87[7:0]);
      FlagA := a90[7:0][4];
      FlagP := parity(a87[7:0]);
      FlagCY := a77[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a91 = a84[15:8] in
      let:8 a92 = a84[7:0] in
      let:16 a93 = (1 + (a91,a92)) in
      let:8 a94 = M[(a91,a92)] in
      let:8 a95 = a93[15:8] in
      let:8 a96 = a93[7:0] in
      let:16 a97 = (1 + (a95,a96)) in
      let:8 a98 = M[(a95,a96)] in
      advance (10)
      A := a68;
      B := a87[7:0];
      C := a81;
      D := a74[15:8];
      E := a74[7:0];
      H := a77[15:0][15:8];
      L := a77[15:0][7:0];
      SPH := a97[15:8];
      SPL := a97[7:0];
      FlagS := a87[7:0][7];
      FlagZ := is_zero(a87[7:0]);
      FlagA := a90[7:0][4];
      FlagP := parity(a87[7:0]);
      FlagCY := a77[16];
      jump ((a98,a94));
    }

09C3:

    #09C3
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #09C4
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    D := a8;
    E := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

09F2:

    #09F2
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #09F3
    #instruction: LD   (20E9),A
    let:8 a4 = a3 in
    M[20E9] := a4;
    advance (13)
    #09F6
    #instruction: CALL 09D6
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 09;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := F9;
    #return-to: 09F9
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a11 = (1F & 03) in
    let:8 a12 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a13 = a11 in
    let:16 a14 = addWithCarry(!false,a13,~1C) in
    let:8 a15 = (a13 & 0F) in
    let:8 a16 = (~1C & 0F) in
    let:16 a17 = addWithCarry(!false,a15,a16) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a14[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a18 = addWithCarry(!false,24,~40) in
      let:8 a19 = (24 & 0F) in
      let:8 a20 = (~40 & 0F) in
      let:16 a21 = addWithCarry(!false,a19,a20) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a18[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a18[7:0][7];
        FlagZ := is_zero(a18[7:0]);
        FlagA := a21[7:0][4];
        FlagP := parity(a18[7:0]);
        FlagCY := !a18[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a22 = a10[15:8] in
        let:8 a23 = a10[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        let:8 a26 = a24[15:8] in
        let:8 a27 = a24[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a28[15:8];
        SPL := a28[7:0];
        FlagS := a18[7:0][7];
        FlagZ := is_zero(a18[7:0]);
        FlagA := a21[7:0][4];
        FlagP := parity(a18[7:0]);
        FlagCY := !a18[15:8][0];
        jump ((a29,a25));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a30 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a31 = a30[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a32 = a31 in
      let:16 a33 = addWithCarry(!false,a32,~40) in
      let:8 a34 = (a32 & 0F) in
      let:8 a35 = (~40 & 0F) in
      let:16 a36 = addWithCarry(!false,a34,a35) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a33[15:8][0]) {
        advance (10)
        A := a31;
        D := 00;
        E := 06;
        H := a30[15:0][15:8];
        L := a30[15:0][7:0];
        SPH := a10[15:8];
        SPL := a10[7:0];
        FlagS := a33[7:0][7];
        FlagZ := is_zero(a33[7:0]);
        FlagA := a36[7:0][4];
        FlagP := parity(a33[7:0]);
        FlagCY := !a33[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a37 = a10[15:8] in
        let:8 a38 = a10[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a31;
        D := 00;
        E := 06;
        H := a30[15:0][15:8];
        L := a30[15:0][7:0];
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a33[7:0][7];
        FlagZ := is_zero(a33[7:0]);
        FlagA := a36[7:0][4];
        FlagP := parity(a33[7:0]);
        FlagCY := !a33[15:8][0];
        jump ((a44,a40));
      }
    }

09F9:

    #09F9
    #instruction: LD   A,(2067)
    let:8 a1 = M[2067] in
    advance (13)
    #09FC
    #instruction: PUSH PSW
    let:8 a2 = a1 in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a2;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09FD
    #instruction: CALL 01E4
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := 0A;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 00;
    #return-to: 0A00
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a15 = addWithCarry(!true,C0,~00) in
    let:8 a16 = (C0 & 0F) in
    let:8 a17 = (~00 & 0F) in
    let:16 a18 = addWithCarry(!true,a16,a17) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a15[7:0])) {
      advance (10)
      A := 01;
      B := a15[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a14[15:8];
      SPL := a14[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a19 = a14[15:8] in
      let:8 a20 = a14[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      let:8 a23 = a21[15:8] in
      let:8 a24 = a21[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      advance (10)
      A := 01;
      B := a15[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a15[7:0][7];
      FlagZ := is_zero(a15[7:0]);
      FlagA := a18[7:0][4];
      FlagP := parity(a15[7:0]);
      jump ((a26,a22));
    }

0A00:

    #0A00
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0A01
    #instruction: LD   (2067),A
    let:8 a9 = a8 in
    M[2067] := a9;
    advance (13)
    #0A04
    #instruction: LD   A,(2067)
    let:8 a10 = M[2067] in
    advance (13)
    #0A07
    #instruction: LD   H,A
    let:8 a11 = a10 in
    advance (5)
    #0A08
    #instruction: PUSH HL
    let:8 a12 = a11 in
    let:8 a13 = L in
    let:8 a14 = a7[15:8] in
    let:8 a15 = a7[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a12;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a13;
    advance (11)
    #0A09
    #instruction: LD   L,FE
    advance (7)
    #0A0B
    #instruction: LD   A,(HL)
    let:8 a20 = a11 in
    let:8 a21 = M[(a20,FE)] in
    advance (7)
    #0A0C
    #instruction: AND  07
    let:8 a22 = a21 in
    let:8 a23 = (07 & a22) in
    let:8 a24 = (07 | a22) in
    advance (7)
    #0A0E
    #instruction: INC  A
    let:8 a25 = a23 in
    let:16 a26 = addWithCarry(true,a25,00) in
    let:8 a27 = (a25 & 0F) in
    let:8 a28 = (00 & 0F) in
    let:16 a29 = addWithCarry(true,a27,a28) in
    advance (5)
    #0A0F
    #instruction: LD   (HL),A
    let:8 a30 = a26[7:0] in
    let:8 a31 = a11 in
    M[(a31,FE)] := a30;
    advance (7)
    #0A10
    #instruction: LD   HL,1DA2
    advance (10)
    #0A13
    #instruction: INC  HL
    advance (5)
    #0A14
    #instruction: DEC  A
    let:8 a32 = a26[7:0] in
    let:16 a33 = addWithCarry(!true,a32,~00) in
    let:8 a34 = (a32 & 0F) in
    let:8 a35 = (~00 & 0F) in
    let:16 a36 = addWithCarry(!true,a34,a35) in
    advance (5)
    #0A15
    #instruction: JP   NZ,0A13
    if (!is_zero(a33[7:0])) {
      advance (10)
      A := a33[7:0];
      H := 1D;
      L := A3;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a33[7:0][7];
      FlagZ := is_zero(a33[7:0]);
      FlagA := a36[7:0][4];
      FlagP := parity(a33[7:0]);
      FlagCY := false;
      jump (0A13);
    } else {
      advance (10)
      #0A18
      #instruction: LD   A,(HL)
      advance (7)
      #0A19
      #instruction: POP  HL
      let:8 a37 = a19[15:8] in
      let:8 a38 = a19[7:0] in
      let:16 a39 = (1 + (a37,a38)) in
      let:8 a40 = M[(a37,a38)] in
      let:8 a41 = a39[15:8] in
      let:8 a42 = a39[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      advance (10)
      #0A1A
      #instruction: LD   L,FC
      advance (7)
      #0A1C
      #instruction: LD   (HL),A
      let:8 a45 = a44 in
      M[(a45,FC)] := 60;
      advance (7)
      #0A1D
      #instruction: INC  HL
      let:8 a46 = a44 in
      let:16 a47 = (1 + (a46,FC)) in
      advance (5)
      #0A1E
      #instruction: LD   (HL),38
      let:8 a48 = a47[15:8] in
      let:8 a49 = a47[7:0] in
      M[(a48,a49)] := 38;
      advance (10)
      #0A20
      #instruction: LD   A,H
      let:8 a50 = a47[15:8] in
      advance (5)
      #0A21
      #instruction: RRCA
      let:8 a51 = a50 in
      advance (4)
      #0A22
      #instruction: JP   CY,0A33
      if (a51[0]) {
        advance (10)
        #0A33
        #instruction: CALL 01EF
        let:8 a52 = a43[15:8] in
        let:8 a53 = a43[7:0] in
        let:16 a54 = (-1 + (a52,a53)) in
        M[a54] := 0A;
        let:8 a55 = a54[15:8] in
        let:8 a56 = a54[7:0] in
        let:16 a57 = (-1 + (a55,a56)) in
        M[a57] := 36;
        #return-to: 0A36
        advance (17)
        #01EF
        #instruction: LD   HL,2142
        advance (10)
        #01F2
        #instruction: JP   01F8
        advance (10)
        #01F8
        #instruction: LD   C,04
        advance (7)
        #01FA
        #instruction: LD   DE,1D20
        advance (10)
        #01FD
        #instruction: PUSH DE
        let:8 a58 = a57[15:8] in
        let:8 a59 = a57[7:0] in
        let:16 a60 = (-1 + (a58,a59)) in
        M[a60] := 1D;
        let:8 a61 = a60[15:8] in
        let:8 a62 = a60[7:0] in
        let:16 a63 = (-1 + (a61,a62)) in
        M[a63] := 20;
        advance (11)
        #01FE
        #instruction: LD   B,2C
        advance (7)
        #0200
        #instruction: CALL 1A32
        let:8 a64 = a63[15:8] in
        let:8 a65 = a63[7:0] in
        let:16 a66 = (-1 + (a64,a65)) in
        M[a66] := 02;
        let:8 a67 = a66[15:8] in
        let:8 a68 = a66[7:0] in
        let:16 a69 = (-1 + (a67,a68)) in
        M[a69] := 03;
        #return-to: 0203
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2142] := FF;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a70 = addWithCarry(!true,2C,~00) in
        let:8 a71 = (2C & 0F) in
        let:8 a72 = (~00 & 0F) in
        let:16 a73 = addWithCarry(!true,a71,a72) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a70[7:0])) {
          advance (10)
          A := FF;
          B := a70[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 21;
          L := 43;
          SPH := a69[15:8];
          SPL := a69[7:0];
          FlagS := a70[7:0][7];
          FlagZ := is_zero(a70[7:0]);
          FlagA := a73[7:0][4];
          FlagP := parity(a70[7:0]);
          FlagCY := a51[0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a74 = a69[15:8] in
          let:8 a75 = a69[7:0] in
          let:16 a76 = (1 + (a74,a75)) in
          let:8 a77 = M[(a74,a75)] in
          let:8 a78 = a76[15:8] in
          let:8 a79 = a76[7:0] in
          let:16 a80 = (1 + (a78,a79)) in
          let:8 a81 = M[(a78,a79)] in
          advance (10)
          A := FF;
          B := a70[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 21;
          L := 43;
          SPH := a80[15:8];
          SPL := a80[7:0];
          FlagS := a70[7:0][7];
          FlagZ := is_zero(a70[7:0]);
          FlagA := a73[7:0][4];
          FlagP := parity(a70[7:0]);
          FlagCY := a51[0];
          jump ((a81,a77));
        }
      } else {
        advance (10)
        #0A25
        #instruction: LD   A,21
        advance (7)
        #0A27
        #instruction: LD   (2098),A
        M[2098] := 21;
        advance (13)
        #0A2A
        #instruction: CALL 01F5
        let:8 a82 = a43[15:8] in
        let:8 a83 = a43[7:0] in
        let:16 a84 = (-1 + (a82,a83)) in
        M[a84] := 0A;
        let:8 a85 = a84[15:8] in
        let:8 a86 = a84[7:0] in
        let:16 a87 = (-1 + (a85,a86)) in
        M[a87] := 2D;
        #return-to: 0A2D
        advance (17)
        #01F5
        #instruction: LD   HL,2242
        advance (10)
        #01F8
        #instruction: LD   C,04
        advance (7)
        #01FA
        #instruction: LD   DE,1D20
        advance (10)
        #01FD
        #instruction: PUSH DE
        let:8 a88 = a87[15:8] in
        let:8 a89 = a87[7:0] in
        let:16 a90 = (-1 + (a88,a89)) in
        M[a90] := 1D;
        let:8 a91 = a90[15:8] in
        let:8 a92 = a90[7:0] in
        let:16 a93 = (-1 + (a91,a92)) in
        M[a93] := 20;
        advance (11)
        #01FE
        #instruction: LD   B,2C
        advance (7)
        #0200
        #instruction: CALL 1A32
        let:8 a94 = a93[15:8] in
        let:8 a95 = a93[7:0] in
        let:16 a96 = (-1 + (a94,a95)) in
        M[a96] := 02;
        let:8 a97 = a96[15:8] in
        let:8 a98 = a96[7:0] in
        let:16 a99 = (-1 + (a97,a98)) in
        M[a99] := 03;
        #return-to: 0203
        advance (17)
        #1A32
        #instruction: LD   A,(DE)
        advance (7)
        #1A33
        #instruction: LD   (HL),A
        M[2242] := FF;
        advance (7)
        #1A34
        #instruction: INC  HL
        advance (5)
        #1A35
        #instruction: INC  DE
        advance (5)
        #1A36
        #instruction: DEC  B
        let:16 a100 = addWithCarry(!true,2C,~00) in
        let:8 a101 = (2C & 0F) in
        let:8 a102 = (~00 & 0F) in
        let:16 a103 = addWithCarry(!true,a101,a102) in
        advance (5)
        #1A37
        #instruction: JP   NZ,1A32
        if (!is_zero(a100[7:0])) {
          advance (10)
          A := FF;
          B := a100[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 22;
          L := 43;
          SPH := a99[15:8];
          SPL := a99[7:0];
          FlagS := a100[7:0][7];
          FlagZ := is_zero(a100[7:0]);
          FlagA := a103[7:0][4];
          FlagP := parity(a100[7:0]);
          FlagCY := a51[0];
          jump (1A32);
        } else {
          advance (10)
          #1A3A
          #instruction: RET
          let:8 a104 = a99[15:8] in
          let:8 a105 = a99[7:0] in
          let:16 a106 = (1 + (a104,a105)) in
          let:8 a107 = M[(a104,a105)] in
          let:8 a108 = a106[15:8] in
          let:8 a109 = a106[7:0] in
          let:16 a110 = (1 + (a108,a109)) in
          let:8 a111 = M[(a108,a109)] in
          advance (10)
          A := FF;
          B := a100[7:0];
          C := 04;
          D := 1D;
          E := 21;
          H := 22;
          L := 43;
          SPH := a110[15:8];
          SPL := a110[7:0];
          FlagS := a100[7:0][7];
          FlagZ := is_zero(a100[7:0]);
          FlagA := a103[7:0][4];
          FlagP := parity(a100[7:0]);
          FlagCY := a51[0];
          jump ((a111,a107));
        }
      }
    }

0A2D:

    #0A2D
    #instruction: CALL 1904
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 30;
    #return-to: 0A30
    advance (17)
    #1904
    #instruction: LD   HL,2200
    advance (10)
    #1907
    #instruction: JP   01C3
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2200] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,37,~00) in
    let:8 a8 = (37 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a7[7:0])) {
      advance (10)
      B := a7[7:0];
      H := 22;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      B := a7[7:0];
      H := 22;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0A30:

    #0A30
    #instruction: JP   0804
    advance (10)
    #0804
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:8 a7 = C in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := E0;
    let:8 a11 = a10[15:8] in
    let:8 a12 = a10[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a7;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a14 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a23 = a22 in
    let:16 a24 = addWithCarry(!true,a23,~00) in
    let:8 a25 = (a23 & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a24[7:0])) {
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a28 = a21[15:8] in
      let:8 a29 = a21[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump ((a35,a31));
    }

0A36:

    #0A36
    #instruction: CALL 01C0
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 39;
    #return-to: 0A39
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,37,~00) in
    let:8 a8 = (37 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a7[7:0])) {
      advance (10)
      B := a7[7:0];
      H := 21;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      B := a7[7:0];
      H := 21;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0A39:

    #0A39
    #instruction: JP   0804
    advance (10)
    #0804
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 08;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 07;
    #return-to: 0807
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:8 a7 = C in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := E0;
    let:8 a11 = a10[15:8] in
    let:8 a12 = a10[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a7;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a14 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a23 = a22 in
    let:16 a24 = addWithCarry(!true,a23,~00) in
    let:8 a25 = (a23 & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a24[7:0])) {
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a28 = a21[15:8] in
      let:8 a29 = a21[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump ((a35,a31));
    }

0A3F:

    #0A3F
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 0A;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a7 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a8 = a7 in
      let:16 a9 = addWithCarry(!false,a8,~FF) in
      let:8 a10 = (a8 & 0F) in
      let:8 a11 = (~FF & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (10)
      #0A42
      #instruction: LD   A,30
      advance (7)
      #0A44
      #instruction: LD   (20C0),A
      M[20C0] := 30;
      advance (13)
      #0A47
      #instruction: LD   A,(20C0)
      let:8 a21 = M[20C0] in
      advance (13)
      #0A4A
      #instruction: AND  A
      let:8 a22 = a21 in
      let:8 a23 = a21 in
      let:8 a24 = (a22 & a23) in
      let:8 a25 = (a22 | a23) in
      advance (4)
      #0A4B
      #instruction: RET  Z
      if (is_zero(a24)) {
        let:8 a26 = SPH in
        let:8 a27 = SPL in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        advance (11)
        A := a24;
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a24[7];
        FlagZ := is_zero(a24);
        FlagA := a25[3];
        FlagP := parity(a24);
        FlagCY := false;
        jump ((a33,a29));
      } else {
        advance (5)
        #0A4C
        #instruction: CALL 0A59
        let:8 a34 = SPH in
        let:8 a35 = SPL in
        let:16 a36 = (-1 + (a34,a35)) in
        M[a36] := 0A;
        let:8 a37 = a36[15:8] in
        let:8 a38 = a36[7:0] in
        let:16 a39 = (-1 + (a37,a38)) in
        M[a39] := 4F;
        #return-to: 0A4F
        advance (17)
        #0A59
        #instruction: LD   A,(2015)
        let:8 a40 = M[2015] in
        advance (13)
        #0A5C
        #instruction: CP   FF
        let:8 a41 = a40 in
        let:16 a42 = addWithCarry(!false,a41,~FF) in
        let:8 a43 = (a41 & 0F) in
        let:8 a44 = (~FF & 0F) in
        let:16 a45 = addWithCarry(!false,a43,a44) in
        advance (7)
        #0A5E
        #instruction: RET
        let:8 a46 = a39[15:8] in
        let:8 a47 = a39[7:0] in
        let:16 a48 = (1 + (a46,a47)) in
        let:8 a49 = M[(a46,a47)] in
        let:8 a50 = a48[15:8] in
        let:8 a51 = a48[7:0] in
        let:16 a52 = (1 + (a50,a51)) in
        let:8 a53 = M[(a50,a51)] in
        advance (10)
        A := a40;
        SPH := a52[15:8];
        SPL := a52[7:0];
        FlagS := a42[7:0][7];
        FlagZ := is_zero(a42[7:0]);
        FlagA := a45[7:0][4];
        FlagP := parity(a42[7:0]);
        FlagCY := !a42[15:8][0];
        jump ((a53,a49));
      }
    }

0A4F:

    #0A4F
    #instruction: JP   Z,0A47
    if (FlagZ) {
      advance (10)
      #0A47
      #instruction: LD   A,(20C0)
      let:8 a1 = M[20C0] in
      advance (13)
      #0A4A
      #instruction: AND  A
      let:8 a2 = a1 in
      let:8 a3 = a1 in
      let:8 a4 = (a2 & a3) in
      let:8 a5 = (a2 | a3) in
      advance (4)
      #0A4B
      #instruction: RET  Z
      if (is_zero(a4)) {
        let:8 a6 = SPH in
        let:8 a7 = SPL in
        let:16 a8 = (1 + (a6,a7)) in
        let:8 a9 = M[(a6,a7)] in
        let:8 a10 = a8[15:8] in
        let:8 a11 = a8[7:0] in
        let:16 a12 = (1 + (a10,a11)) in
        let:8 a13 = M[(a10,a11)] in
        advance (11)
        A := a4;
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a4[7];
        FlagZ := is_zero(a4);
        FlagA := a5[3];
        FlagP := parity(a4);
        FlagCY := false;
        jump ((a13,a9));
      } else {
        advance (5)
        #0A4C
        #instruction: CALL 0A59
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (-1 + (a14,a15)) in
        M[a16] := 0A;
        let:8 a17 = a16[15:8] in
        let:8 a18 = a16[7:0] in
        let:16 a19 = (-1 + (a17,a18)) in
        M[a19] := 4F;
        #return-to: 0A4F
        advance (17)
        #0A59
        #instruction: LD   A,(2015)
        let:8 a20 = M[2015] in
        advance (13)
        #0A5C
        #instruction: CP   FF
        let:8 a21 = a20 in
        let:16 a22 = addWithCarry(!false,a21,~FF) in
        let:8 a23 = (a21 & 0F) in
        let:8 a24 = (~FF & 0F) in
        let:16 a25 = addWithCarry(!false,a23,a24) in
        advance (7)
        #0A5E
        #instruction: RET
        let:8 a26 = a19[15:8] in
        let:8 a27 = a19[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        advance (10)
        A := a20;
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a22[7:0][7];
        FlagZ := is_zero(a22[7:0]);
        FlagA := a25[7:0][4];
        FlagP := parity(a22[7:0]);
        FlagCY := !a22[15:8][0];
        jump ((a33,a29));
      }
    } else {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:8 a34 = SPH in
      let:8 a35 = SPL in
      let:16 a36 = (-1 + (a34,a35)) in
      M[a36] := 0A;
      let:8 a37 = a36[15:8] in
      let:8 a38 = a36[7:0] in
      let:16 a39 = (-1 + (a37,a38)) in
      M[a39] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a40 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a41 = a40 in
      let:16 a42 = addWithCarry(!false,a41,~FF) in
      let:8 a43 = (a41 & 0F) in
      let:8 a44 = (~FF & 0F) in
      let:16 a45 = addWithCarry(!false,a43,a44) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a46 = a39[15:8] in
      let:8 a47 = a39[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (10)
      A := a40;
      SPH := a52[15:8];
      SPL := a52[7:0];
      FlagS := a42[7:0][7];
      FlagZ := is_zero(a42[7:0]);
      FlagA := a45[7:0][4];
      FlagP := parity(a42[7:0]);
      FlagCY := !a42[15:8][0];
      jump ((a53,a49));
    }

0A55:

    #0A55
    #instruction: JP   NZ,0A52
    if (!FlagZ) {
      advance (10)
      #0A52
      #instruction: CALL 0A59
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 0A;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 55;
      #return-to: 0A55
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a7 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a8 = a7 in
      let:16 a9 = addWithCarry(!false,a8,~FF) in
      let:8 a10 = (a8 & 0F) in
      let:8 a11 = (~FF & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (10)
      #0A58
      #instruction: RET
      let:8 a21 = SPH in
      let:8 a22 = SPL in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      SPH := a27[15:8];
      SPL := a27[7:0];
      jump ((a28,a24));
    }

0A6C:

    #0A6C
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    #0A6D
    #instruction: LD   A,B
    let:8 a2 = a1 in
    advance (5)
    #0A6E
    #instruction: CALL 097C
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 0A;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 71;
    #return-to: 0A71
    advance (17)
    #097C
    #instruction: LD   HL,1DA0
    advance (10)
    #097F
    #instruction: CP   02
    let:8 a9 = a2 in
    let:16 a10 = addWithCarry(!false,a9,~02) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~02 & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #0981
    #instruction: RET  CY
    if (!a10[15:8][0]) {
      let:8 a14 = a8[15:8] in
      let:8 a15 = a8[7:0] in
      let:16 a16 = (1 + (a14,a15)) in
      let:8 a17 = M[(a14,a15)] in
      let:8 a18 = a16[15:8] in
      let:8 a19 = a16[7:0] in
      let:16 a20 = (1 + (a18,a19)) in
      let:8 a21 = M[(a18,a19)] in
      advance (11)
      A := a2;
      B := a1;
      H := 1D;
      L := A0;
      SPH := a20[15:8];
      SPL := a20[7:0];
      FlagS := a10[7:0][7];
      FlagZ := is_zero(a10[7:0]);
      FlagA := a13[7:0][4];
      FlagP := parity(a10[7:0]);
      FlagCY := !a10[15:8][0];
      jump ((a21,a17));
    } else {
      advance (5)
      #0982
      #instruction: INC  HL
      advance (5)
      #0983
      #instruction: CP   04
      let:8 a22 = a2 in
      let:16 a23 = addWithCarry(!false,a22,~04) in
      let:8 a24 = (a22 & 0F) in
      let:8 a25 = (~04 & 0F) in
      let:16 a26 = addWithCarry(!false,a24,a25) in
      advance (7)
      #0985
      #instruction: RET  CY
      if (!a23[15:8][0]) {
        let:8 a27 = a8[15:8] in
        let:8 a28 = a8[7:0] in
        let:16 a29 = (1 + (a27,a28)) in
        let:8 a30 = M[(a27,a28)] in
        let:8 a31 = a29[15:8] in
        let:8 a32 = a29[7:0] in
        let:16 a33 = (1 + (a31,a32)) in
        let:8 a34 = M[(a31,a32)] in
        advance (11)
        A := a2;
        B := a1;
        H := 1D;
        L := A1;
        SPH := a33[15:8];
        SPL := a33[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := !a23[15:8][0];
        jump ((a34,a30));
      } else {
        advance (5)
        #0986
        #instruction: INC  HL
        advance (5)
        #0987
        #instruction: RET
        let:8 a35 = a8[15:8] in
        let:8 a36 = a8[7:0] in
        let:16 a37 = (1 + (a35,a36)) in
        let:8 a38 = M[(a35,a36)] in
        let:8 a39 = a37[15:8] in
        let:8 a40 = a37[7:0] in
        let:16 a41 = (1 + (a39,a40)) in
        let:8 a42 = M[(a39,a40)] in
        advance (10)
        A := a2;
        B := a1;
        H := 1D;
        L := A2;
        SPH := a41[15:8];
        SPL := a41[7:0];
        FlagS := a23[7:0][7];
        FlagZ := is_zero(a23[7:0]);
        FlagA := a26[7:0][4];
        FlagP := parity(a23[7:0]);
        FlagCY := !a23[15:8][0];
        jump ((a42,a38));
      }
    }

0A71:

    #0A71
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #0A72
    #instruction: LD   HL,20F3
    advance (10)
    #0A75
    #instruction: LD   (HL),00
    M[20F3] := 00;
    advance (10)
    #0A77
    #instruction: DEC  HL
    advance (5)
    #0A78
    #instruction: LD   (HL),A
    let:8 a4 = a3 in
    M[20F2] := a4;
    advance (7)
    #0A79
    #instruction: DEC  HL
    advance (5)
    #0A7A
    #instruction: LD   (HL),01
    M[20F1] := 01;
    advance (10)
    #0A7C
    #instruction: LD   HL,2062
    advance (10)
    #0A7F
    #instruction: RET
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    advance (10)
    A := a3;
    H := 20;
    L := 62;
    SPH := a11[15:8];
    SPL := a11[7:0];
    jump ((a12,a8));

0A98:

    #0A98
    #instruction: POP  DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #0A99
    #instruction: LD   A,07
    advance (7)
    #0A9B
    #instruction: LD   (20C0),A
    M[20C0] := 07;
    advance (13)
    #0A9E
    #instruction: LD   A,(20C0)
    let:8 a9 = M[20C0] in
    advance (13)
    #0AA1
    #instruction: DEC  A
    let:8 a10 = a9 in
    let:16 a11 = addWithCarry(!true,a10,~00) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~00 & 0F) in
    let:16 a14 = addWithCarry(!true,a12,a13) in
    advance (5)
    #0AA2
    #instruction: JP   NZ,0A9E
    if (!is_zero(a11[7:0])) {
      advance (10)
      A := a11[7:0];
      D := a8;
      E := a4;
      SPH := a7[15:8];
      SPL := a7[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      jump (0A9E);
    } else {
      advance (10)
      #0AA5
      #instruction: INC  DE
      let:8 a15 = a8 in
      let:8 a16 = a4 in
      let:16 a17 = (1 + (a15,a16)) in
      advance (5)
      #0AA6
      #instruction: DEC  C
      let:8 a18 = C in
      let:16 a19 = addWithCarry(!true,a18,~00) in
      let:8 a20 = (a18 & 0F) in
      let:8 a21 = (~00 & 0F) in
      let:16 a22 = addWithCarry(!true,a20,a21) in
      advance (5)
      #0AA7
      #instruction: JP   NZ,0A93
      if (!is_zero(a19[7:0])) {
        advance (10)
        #0A93
        #instruction: PUSH DE
        let:8 a23 = a17[15:8] in
        let:8 a24 = a17[7:0] in
        let:8 a25 = a7[15:8] in
        let:8 a26 = a7[7:0] in
        let:16 a27 = (-1 + (a25,a26)) in
        M[a27] := a23;
        let:8 a28 = a27[15:8] in
        let:8 a29 = a27[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := a24;
        advance (11)
        #0A94
        #instruction: LD   A,(DE)
        let:8 a31 = a17[15:8] in
        let:8 a32 = a17[7:0] in
        let:8 a33 = M[(a31,a32)] in
        advance (7)
        #0A95
        #instruction: CALL 08FF
        let:8 a34 = a30[15:8] in
        let:8 a35 = a30[7:0] in
        let:16 a36 = (-1 + (a34,a35)) in
        M[a36] := 0A;
        let:8 a37 = a36[15:8] in
        let:8 a38 = a36[7:0] in
        let:16 a39 = (-1 + (a37,a38)) in
        M[a39] := 98;
        #return-to: 0A98
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a40 = H in
        let:8 a41 = L in
        let:8 a42 = a39[15:8] in
        let:8 a43 = a39[7:0] in
        let:16 a44 = (-1 + (a42,a43)) in
        M[a44] := a40;
        let:8 a45 = a44[15:8] in
        let:8 a46 = a44[7:0] in
        let:16 a47 = (-1 + (a45,a46)) in
        M[a47] := a41;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        let:8 a48 = a33 in
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:8 a49 = a48 in
        let:8 a50 = a48 in
        let:17 a51 = add17((00,a49),(00,a50)) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a52 = a51[15:0][15:8] in
        let:8 a53 = a51[15:0][7:0] in
        let:8 a54 = a51[15:0][15:8] in
        let:8 a55 = a51[15:0][7:0] in
        let:17 a56 = add17((a52,a53),(a54,a55)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a57 = a56[15:0][15:8] in
        let:8 a58 = a56[15:0][7:0] in
        let:8 a59 = a56[15:0][15:8] in
        let:8 a60 = a56[15:0][7:0] in
        let:17 a61 = add17((a57,a58),(a59,a60)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a62 = a61[15:0][15:8] in
        let:8 a63 = a61[15:0][7:0] in
        let:17 a64 = add17(1E00,(a62,a63)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a65 = a64[15:0][15:8] in
        let:8 a66 = a64[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a67 = a47[15:8] in
        let:8 a68 = a47[7:0] in
        let:16 a69 = (1 + (a67,a68)) in
        let:8 a70 = M[(a67,a68)] in
        let:8 a71 = a69[15:8] in
        let:8 a72 = a69[7:0] in
        let:16 a73 = (1 + (a71,a72)) in
        let:8 a74 = M[(a71,a72)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        let:8 a75 = a33 in
        unknown_output(6,a75);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a76 = a19[7:0] in
        let:8 a77 = a73[15:8] in
        let:8 a78 = a73[7:0] in
        let:16 a79 = (-1 + (a77,a78)) in
        M[a79] := 08;
        let:8 a80 = a79[15:8] in
        let:8 a81 = a79[7:0] in
        let:16 a82 = (-1 + (a80,a81)) in
        M[a82] := a76;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a83 = a65 in
        let:8 a84 = a66 in
        let:8 a85 = M[(a83,a84)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a86 = a85 in
        let:8 a87 = a74 in
        let:8 a88 = a70 in
        M[(a87,a88)] := a86;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a89 = a65 in
        let:8 a90 = a66 in
        let:16 a91 = (1 + (a89,a90)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a92 = a74 in
        let:8 a93 = a70 in
        let:17 a94 = add17(0020,(a92,a93)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a95 = a82[15:8] in
        let:8 a96 = a82[7:0] in
        let:16 a97 = (1 + (a95,a96)) in
        let:8 a98 = M[(a95,a96)] in
        let:8 a99 = a97[15:8] in
        let:8 a100 = a97[7:0] in
        let:16 a101 = (1 + (a99,a100)) in
        let:8 a102 = M[(a99,a100)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a103 = a102 in
        let:16 a104 = addWithCarry(!true,a103,~00) in
        let:8 a105 = (a103 & 0F) in
        let:8 a106 = (~00 & 0F) in
        let:16 a107 = addWithCarry(!true,a105,a106) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a104[7:0])) {
          advance (10)
          A := a85;
          B := a104[7:0];
          C := a98;
          D := a91[15:8];
          E := a91[7:0];
          H := a94[15:0][15:8];
          L := a94[15:0][7:0];
          SPH := a101[15:8];
          SPL := a101[7:0];
          FlagS := a104[7:0][7];
          FlagZ := is_zero(a104[7:0]);
          FlagA := a107[7:0][4];
          FlagP := parity(a104[7:0]);
          FlagCY := a94[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a108 = a101[15:8] in
          let:8 a109 = a101[7:0] in
          let:16 a110 = (1 + (a108,a109)) in
          let:8 a111 = M[(a108,a109)] in
          let:8 a112 = a110[15:8] in
          let:8 a113 = a110[7:0] in
          let:16 a114 = (1 + (a112,a113)) in
          let:8 a115 = M[(a112,a113)] in
          advance (10)
          A := a85;
          B := a104[7:0];
          C := a98;
          D := a91[15:8];
          E := a91[7:0];
          H := a94[15:0][15:8];
          L := a94[15:0][7:0];
          SPH := a114[15:8];
          SPL := a114[7:0];
          FlagS := a104[7:0][7];
          FlagZ := is_zero(a104[7:0]);
          FlagA := a107[7:0][4];
          FlagP := parity(a104[7:0]);
          FlagCY := a94[16];
          jump ((a115,a111));
        }
      } else {
        advance (10)
        #0AAA
        #instruction: RET
        let:8 a116 = a7[15:8] in
        let:8 a117 = a7[7:0] in
        let:16 a118 = (1 + (a116,a117)) in
        let:8 a119 = M[(a116,a117)] in
        let:8 a120 = a118[15:8] in
        let:8 a121 = a118[7:0] in
        let:16 a122 = (1 + (a120,a121)) in
        let:8 a123 = M[(a120,a121)] in
        advance (10)
        A := a11[7:0];
        C := a19[7:0];
        D := a17[15:8];
        E := a17[7:0];
        SPH := a122[15:8];
        SPL := a122[7:0];
        FlagS := a19[7:0][7];
        FlagZ := is_zero(a19[7:0]);
        FlagA := a22[7:0][4];
        FlagP := parity(a19[7:0]);
        jump ((a123,a119));
      }
    }

0AF2:

    #0AF2
    #instruction: EI
    enable_interrupts()
    advance (4)
    #0AF3
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0A;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 0AF6
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0AF6:

    #0AF6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0AF9
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0AFA
    #instruction: LD   HL,3017
    advance (10)
    #0AFD
    #instruction: LD   C,04
    advance (7)
    #0AFF
    #instruction: JP   NZ,0BE8
    if (!is_zero(a4)) {
      advance (10)
      #0BE8
      #instruction: LD   DE,1DAB
      advance (10)
      #0BEB
      #instruction: CALL 0A93
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := EE;
      #return-to: 0BEE
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 1D;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := AB;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 0A;
      let:8 a21 = a20[15:8] in
      let:8 a22 = a20[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 30;
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := 17;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a30 = add17(000F,000F) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a31 = a30[15:0][15:8] in
      let:8 a32 = a30[15:0][7:0] in
      let:8 a33 = a30[15:0][15:8] in
      let:8 a34 = a30[15:0][7:0] in
      let:17 a35 = add17((a31,a32),(a33,a34)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a36 = a35[15:0][15:8] in
      let:8 a37 = a35[15:0][7:0] in
      let:8 a38 = a35[15:0][15:8] in
      let:8 a39 = a35[15:0][7:0] in
      let:17 a40 = add17((a36,a37),(a38,a39)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a41 = a40[15:0][15:8] in
      let:8 a42 = a40[15:0][7:0] in
      let:17 a43 = add17(1E00,(a41,a42)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a44 = a43[15:0][15:8] in
      let:8 a45 = a43[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a46 = a29[15:8] in
      let:8 a47 = a29[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,0F);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a54 = a52[15:8] in
      let:8 a55 = a52[7:0] in
      let:16 a56 = (-1 + (a54,a55)) in
      M[a56] := 08;
      let:8 a57 = a56[15:8] in
      let:8 a58 = a56[7:0] in
      let:16 a59 = (-1 + (a57,a58)) in
      M[a59] := 04;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a60 = a44 in
      let:8 a61 = a45 in
      let:8 a62 = M[(a60,a61)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a63 = a62 in
      let:8 a64 = a53 in
      let:8 a65 = a49 in
      M[(a64,a65)] := a63;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a66 = a44 in
      let:8 a67 = a45 in
      let:16 a68 = (1 + (a66,a67)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a69 = a53 in
      let:8 a70 = a49 in
      let:17 a71 = add17(0020,(a69,a70)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a72 = a59[15:8] in
      let:8 a73 = a59[7:0] in
      let:16 a74 = (1 + (a72,a73)) in
      let:8 a75 = M[(a72,a73)] in
      let:8 a76 = a74[15:8] in
      let:8 a77 = a74[7:0] in
      let:16 a78 = (1 + (a76,a77)) in
      let:8 a79 = M[(a76,a77)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a80 = a79 in
      let:16 a81 = addWithCarry(!true,a80,~00) in
      let:8 a82 = (a80 & 0F) in
      let:8 a83 = (~00 & 0F) in
      let:16 a84 = addWithCarry(!true,a82,a83) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a81[7:0])) {
        advance (10)
        A := a62;
        B := a81[7:0];
        C := a75;
        D := a68[15:8];
        E := a68[7:0];
        H := a71[15:0][15:8];
        L := a71[15:0][7:0];
        SPH := a78[15:8];
        SPL := a78[7:0];
        FlagS := a81[7:0][7];
        FlagZ := is_zero(a81[7:0]);
        FlagA := a84[7:0][4];
        FlagP := parity(a81[7:0]);
        FlagCY := a71[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a85 = a78[15:8] in
        let:8 a86 = a78[7:0] in
        let:16 a87 = (1 + (a85,a86)) in
        let:8 a88 = M[(a85,a86)] in
        let:8 a89 = a87[15:8] in
        let:8 a90 = a87[7:0] in
        let:16 a91 = (1 + (a89,a90)) in
        let:8 a92 = M[(a89,a90)] in
        advance (10)
        A := a62;
        B := a81[7:0];
        C := a75;
        D := a68[15:8];
        E := a68[7:0];
        H := a71[15:0][15:8];
        L := a71[15:0][7:0];
        SPH := a91[15:8];
        SPL := a91[7:0];
        FlagS := a81[7:0][7];
        FlagZ := is_zero(a81[7:0]);
        FlagA := a84[7:0][4];
        FlagP := parity(a81[7:0]);
        FlagCY := a71[16];
        jump ((a92,a88));
      }
    } else {
      advance (10)
      #0B02
      #instruction: LD   DE,1CFA
      advance (10)
      #0B05
      #instruction: CALL 0A93
      let:8 a93 = SPH in
      let:8 a94 = SPL in
      let:16 a95 = (-1 + (a93,a94)) in
      M[a95] := 0B;
      let:8 a96 = a95[15:8] in
      let:8 a97 = a95[7:0] in
      let:16 a98 = (-1 + (a96,a97)) in
      M[a98] := 08;
      #return-to: 0B08
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a99 = a98[15:8] in
      let:8 a100 = a98[7:0] in
      let:16 a101 = (-1 + (a99,a100)) in
      M[a101] := 1C;
      let:8 a102 = a101[15:8] in
      let:8 a103 = a101[7:0] in
      let:16 a104 = (-1 + (a102,a103)) in
      M[a104] := FA;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a105 = a104[15:8] in
      let:8 a106 = a104[7:0] in
      let:16 a107 = (-1 + (a105,a106)) in
      M[a107] := 0A;
      let:8 a108 = a107[15:8] in
      let:8 a109 = a107[7:0] in
      let:16 a110 = (-1 + (a108,a109)) in
      M[a110] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a111 = a110[15:8] in
      let:8 a112 = a110[7:0] in
      let:16 a113 = (-1 + (a111,a112)) in
      M[a113] := 30;
      let:8 a114 = a113[15:8] in
      let:8 a115 = a113[7:0] in
      let:16 a116 = (-1 + (a114,a115)) in
      M[a116] := 17;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a117 = add17(000F,000F) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a118 = a117[15:0][15:8] in
      let:8 a119 = a117[15:0][7:0] in
      let:8 a120 = a117[15:0][15:8] in
      let:8 a121 = a117[15:0][7:0] in
      let:17 a122 = add17((a118,a119),(a120,a121)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a123 = a122[15:0][15:8] in
      let:8 a124 = a122[15:0][7:0] in
      let:8 a125 = a122[15:0][15:8] in
      let:8 a126 = a122[15:0][7:0] in
      let:17 a127 = add17((a123,a124),(a125,a126)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a128 = a127[15:0][15:8] in
      let:8 a129 = a127[15:0][7:0] in
      let:17 a130 = add17(1E00,(a128,a129)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a131 = a130[15:0][15:8] in
      let:8 a132 = a130[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a133 = a116[15:8] in
      let:8 a134 = a116[7:0] in
      let:16 a135 = (1 + (a133,a134)) in
      let:8 a136 = M[(a133,a134)] in
      let:8 a137 = a135[15:8] in
      let:8 a138 = a135[7:0] in
      let:16 a139 = (1 + (a137,a138)) in
      let:8 a140 = M[(a137,a138)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,0F);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a141 = a139[15:8] in
      let:8 a142 = a139[7:0] in
      let:16 a143 = (-1 + (a141,a142)) in
      M[a143] := 08;
      let:8 a144 = a143[15:8] in
      let:8 a145 = a143[7:0] in
      let:16 a146 = (-1 + (a144,a145)) in
      M[a146] := 04;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a147 = a131 in
      let:8 a148 = a132 in
      let:8 a149 = M[(a147,a148)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a150 = a149 in
      let:8 a151 = a140 in
      let:8 a152 = a136 in
      M[(a151,a152)] := a150;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a153 = a131 in
      let:8 a154 = a132 in
      let:16 a155 = (1 + (a153,a154)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a156 = a140 in
      let:8 a157 = a136 in
      let:17 a158 = add17(0020,(a156,a157)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a159 = a146[15:8] in
      let:8 a160 = a146[7:0] in
      let:16 a161 = (1 + (a159,a160)) in
      let:8 a162 = M[(a159,a160)] in
      let:8 a163 = a161[15:8] in
      let:8 a164 = a161[7:0] in
      let:16 a165 = (1 + (a163,a164)) in
      let:8 a166 = M[(a163,a164)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a167 = a166 in
      let:16 a168 = addWithCarry(!true,a167,~00) in
      let:8 a169 = (a167 & 0F) in
      let:8 a170 = (~00 & 0F) in
      let:16 a171 = addWithCarry(!true,a169,a170) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a168[7:0])) {
        advance (10)
        A := a149;
        B := a168[7:0];
        C := a162;
        D := a155[15:8];
        E := a155[7:0];
        H := a158[15:0][15:8];
        L := a158[15:0][7:0];
        SPH := a165[15:8];
        SPL := a165[7:0];
        FlagS := a168[7:0][7];
        FlagZ := is_zero(a168[7:0]);
        FlagA := a171[7:0][4];
        FlagP := parity(a168[7:0]);
        FlagCY := a158[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a172 = a165[15:8] in
        let:8 a173 = a165[7:0] in
        let:16 a174 = (1 + (a172,a173)) in
        let:8 a175 = M[(a172,a173)] in
        let:8 a176 = a174[15:8] in
        let:8 a177 = a174[7:0] in
        let:16 a178 = (1 + (a176,a177)) in
        let:8 a179 = M[(a176,a177)] in
        advance (10)
        A := a149;
        B := a168[7:0];
        C := a162;
        D := a155[15:8];
        E := a155[7:0];
        H := a158[15:0][15:8];
        L := a158[15:0][7:0];
        SPH := a178[15:8];
        SPL := a178[7:0];
        FlagS := a168[7:0][7];
        FlagZ := is_zero(a168[7:0]);
        FlagA := a171[7:0][4];
        FlagP := parity(a168[7:0]);
        FlagCY := a158[16];
        jump ((a179,a175));
      }
    }

0B08:

    #0B08
    #instruction: LD   DE,1DAF
    advance (10)
    #0B0B
    #instruction: CALL 0ACF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0E;
    #return-to: 0B0E
    advance (17)
    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    #0AD2
    #instruction: LD   C,0F
    advance (7)
    #0AD4
    #instruction: JP   0A93
    advance (10)
    #0A93
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1D;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := AF;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 0A;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 2B;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 14;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(0012,0012) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,12);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 0F;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

0B0E:

    #0B0E
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 11;
    #return-to: 0B11
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0B11:

    #0B11
    #instruction: CALL 1815
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 14;
    #return-to: 0B14
    advance (17)
    #1815
    #instruction: LD   HL,2810
    advance (10)
    #1818
    #instruction: LD   DE,1CA3
    advance (10)
    #181B
    #instruction: LD   C,15
    advance (7)
    #181D
    #instruction: CALL 08F3
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 18;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 20;
    #return-to: 1820
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 1C;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := A3;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 08;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := 28;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := 10;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a31 = add17(0028,0028) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a32 = a31[15:0][15:8] in
    let:8 a33 = a31[15:0][7:0] in
    let:8 a34 = a31[15:0][15:8] in
    let:8 a35 = a31[15:0][7:0] in
    let:17 a36 = add17((a32,a33),(a34,a35)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a37 = a36[15:0][15:8] in
    let:8 a38 = a36[15:0][7:0] in
    let:8 a39 = a36[15:0][15:8] in
    let:8 a40 = a36[15:0][7:0] in
    let:17 a41 = add17((a37,a38),(a39,a40)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a42 = a41[15:0][15:8] in
    let:8 a43 = a41[15:0][7:0] in
    let:17 a44 = add17(1E00,(a42,a43)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a45 = a44[15:0][15:8] in
    let:8 a46 = a44[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a47 = a30[15:8] in
    let:8 a48 = a30[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    let:8 a51 = a49[15:8] in
    let:8 a52 = a49[7:0] in
    let:16 a53 = (1 + (a51,a52)) in
    let:8 a54 = M[(a51,a52)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,28);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a55 = a53[15:8] in
    let:8 a56 = a53[7:0] in
    let:16 a57 = (-1 + (a55,a56)) in
    M[a57] := 08;
    let:8 a58 = a57[15:8] in
    let:8 a59 = a57[7:0] in
    let:16 a60 = (-1 + (a58,a59)) in
    M[a60] := 15;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a61 = a45 in
    let:8 a62 = a46 in
    let:8 a63 = M[(a61,a62)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a64 = a63 in
    let:8 a65 = a54 in
    let:8 a66 = a50 in
    M[(a65,a66)] := a64;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a67 = a45 in
    let:8 a68 = a46 in
    let:16 a69 = (1 + (a67,a68)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a70 = a54 in
    let:8 a71 = a50 in
    let:17 a72 = add17(0020,(a70,a71)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a73 = a60[15:8] in
    let:8 a74 = a60[7:0] in
    let:16 a75 = (1 + (a73,a74)) in
    let:8 a76 = M[(a73,a74)] in
    let:8 a77 = a75[15:8] in
    let:8 a78 = a75[7:0] in
    let:16 a79 = (1 + (a77,a78)) in
    let:8 a80 = M[(a77,a78)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a81 = a80 in
    let:16 a82 = addWithCarry(!true,a81,~00) in
    let:8 a83 = (a81 & 0F) in
    let:8 a84 = (~00 & 0F) in
    let:16 a85 = addWithCarry(!true,a83,a84) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a82[7:0])) {
      advance (10)
      A := a63;
      B := a82[7:0];
      C := a76;
      D := a69[15:8];
      E := a69[7:0];
      H := a72[15:0][15:8];
      L := a72[15:0][7:0];
      SPH := a79[15:8];
      SPL := a79[7:0];
      FlagS := a82[7:0][7];
      FlagZ := is_zero(a82[7:0]);
      FlagA := a85[7:0][4];
      FlagP := parity(a82[7:0]);
      FlagCY := a72[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a86 = a79[15:8] in
      let:8 a87 = a79[7:0] in
      let:16 a88 = (1 + (a86,a87)) in
      let:8 a89 = M[(a86,a87)] in
      let:8 a90 = a88[15:8] in
      let:8 a91 = a88[7:0] in
      let:16 a92 = (1 + (a90,a91)) in
      let:8 a93 = M[(a90,a91)] in
      advance (10)
      A := a63;
      B := a82[7:0];
      C := a76;
      D := a69[15:8];
      E := a69[7:0];
      H := a72[15:0][15:8];
      L := a72[15:0][7:0];
      SPH := a92[15:8];
      SPL := a92[7:0];
      FlagS := a82[7:0][7];
      FlagZ := is_zero(a82[7:0]);
      FlagA := a85[7:0][4];
      FlagP := parity(a82[7:0]);
      FlagCY := a72[16];
      jump ((a93,a89));
    }

0B14:

    #0B14
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    #return-to: 0B17
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0B17:

    #0B17
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0B1A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0B1B
    #instruction: JP   NZ,0B4A
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0B4A);
    } else {
      advance (10)
      #0B1E
      #instruction: LD   DE,1A95
      advance (10)
      #0B21
      #instruction: CALL 0AE2
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 24;
      #return-to: 0B24
      advance (17)
      #0AE2
      #instruction: LD   HL,20C2
      advance (10)
      #0AE5
      #instruction: LD   B,0C
      advance (7)
      #0AE7
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[20C2] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a12 = addWithCarry(!true,0C,~00) in
      let:8 a13 = (0C & 0F) in
      let:8 a14 = (~00 & 0F) in
      let:16 a15 = addWithCarry(!true,a13,a14) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a12[7:0])) {
        advance (10)
        A := 00;
        B := a12[7:0];
        D := 1A;
        E := 96;
        H := 20;
        L := C3;
        SPH := a11[15:8];
        SPL := a11[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := false;
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a16 = a11[15:8] in
        let:8 a17 = a11[7:0] in
        let:16 a18 = (1 + (a16,a17)) in
        let:8 a19 = M[(a16,a17)] in
        let:8 a20 = a18[15:8] in
        let:8 a21 = a18[7:0] in
        let:16 a22 = (1 + (a20,a21)) in
        let:8 a23 = M[(a20,a21)] in
        advance (10)
        A := 00;
        B := a12[7:0];
        D := 1A;
        E := 96;
        H := 20;
        L := C3;
        SPH := a22[15:8];
        SPL := a22[7:0];
        FlagS := a12[7:0][7];
        FlagZ := is_zero(a12[7:0]);
        FlagA := a15[7:0][4];
        FlagP := parity(a12[7:0]);
        FlagCY := false;
        jump ((a23,a19));
      }
    }

0B24:

    #0B24
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 27;
    #return-to: 0B27
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    let:8 a7 = M[20CB] in
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a12 = a10 in
      let:8 a13 = a10 in
      let:8 a14 = (a12 ^ a13) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      let:8 a15 = a14 in
      M[20C1] := a15;
      advance (13)
      #0A92
      #instruction: RET
      let:8 a16 = a6[15:8] in
      let:8 a17 = a6[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a14;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a23,a19));
    }

0B27:

    #0B27
    #instruction: LD   DE,1BB0
    advance (10)
    #0B2A
    #instruction: CALL 0AE2
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2D;
    #return-to: 0B2D
    advance (17)
    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    #0AE5
    #instruction: LD   B,0C
    advance (7)
    #0AE7
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[20C2] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,0C,~00) in
    let:8 a8 = (0C & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := B1;
      H := 20;
      L := C3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1B;
      E := B1;
      H := 20;
      L := C3;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0B2D:

    #0B2D
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 30;
    #return-to: 0B30
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    let:8 a7 = M[20CB] in
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a12 = a10 in
      let:8 a13 = a10 in
      let:8 a14 = (a12 ^ a13) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      let:8 a15 = a14 in
      M[20C1] := a15;
      advance (13)
      #0A92
      #instruction: RET
      let:8 a16 = a6[15:8] in
      let:8 a17 = a6[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a14;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a23,a19));
    }

0B30:

    #0B30
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 33;
    #return-to: 0B33
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0B33:

    #0B33
    #instruction: LD   DE,1FC9
    advance (10)
    #0B36
    #instruction: CALL 0AE2
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 39;
    #return-to: 0B39
    advance (17)
    #0AE2
    #instruction: LD   HL,20C2
    advance (10)
    #0AE5
    #instruction: LD   B,0C
    advance (7)
    #0AE7
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[20C2] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,0C,~00) in
    let:8 a8 = (0C & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1F;
      E := CA;
      H := 20;
      L := C3;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 00;
      B := a7[7:0];
      D := 1F;
      E := CA;
      H := 20;
      L := C3;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0B39:

    #0B39
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3C;
    #return-to: 0B3C
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    let:8 a7 = M[20CB] in
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a12 = a10 in
      let:8 a13 = a10 in
      let:8 a14 = (a12 ^ a13) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      let:8 a15 = a14 in
      M[20C1] := a15;
      advance (13)
      #0A92
      #instruction: RET
      let:8 a16 = a6[15:8] in
      let:8 a17 = a6[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a14;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a23,a19));
    }

0B3C:

    #0B3C
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3F;
    #return-to: 0B3F
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0B3F:

    #0B3F
    #instruction: LD   HL,33B7
    advance (10)
    #0B42
    #instruction: LD   B,0A
    advance (7)
    #0B44
    #instruction: CALL 14CB
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 47;
    #return-to: 0B47
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a7 = A in
    let:8 a8 = A in
    let:8 a9 = (a7 ^ a8) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:8 a10 = C in
    let:8 a11 = a6[15:8] in
    let:8 a12 = a6[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 0A;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    let:8 a17 = a9 in
    M[33B7] := a17;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a18 = add17(0020,33B7) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a19 = a16[15:8] in
    let:8 a20 = a16[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    let:8 a23 = a21[15:8] in
    let:8 a24 = a21[7:0] in
    let:16 a25 = (1 + (a23,a24)) in
    let:8 a26 = M[(a23,a24)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a27 = a26 in
    let:16 a28 = addWithCarry(!true,a27,~00) in
    let:8 a29 = (a27 & 0F) in
    let:8 a30 = (~00 & 0F) in
    let:16 a31 = addWithCarry(!true,a29,a30) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a28[7:0])) {
      advance (10)
      A := a9;
      B := a28[7:0];
      C := a22;
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a28[7:0][7];
      FlagZ := is_zero(a28[7:0]);
      FlagA := a31[7:0][4];
      FlagP := parity(a28[7:0]);
      FlagCY := a18[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a32 = a25[15:8] in
      let:8 a33 = a25[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      let:8 a36 = a34[15:8] in
      let:8 a37 = a34[7:0] in
      let:16 a38 = (1 + (a36,a37)) in
      let:8 a39 = M[(a36,a37)] in
      advance (10)
      A := a9;
      B := a28[7:0];
      C := a22;
      H := a18[15:0][15:8];
      L := a18[15:0][7:0];
      SPH := a38[15:8];
      SPL := a38[7:0];
      FlagS := a28[7:0][7];
      FlagZ := is_zero(a28[7:0]);
      FlagA := a31[7:0][4];
      FlagP := parity(a28[7:0]);
      FlagCY := a18[16];
      jump ((a39,a35));
    }

0B47:

    #0B47
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4A;
    #return-to: 0B4A
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0B4A:

    #0B4A
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 4D;
    #return-to: 0B4D
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = (1F & 03) in
    let:8 a8 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a9 = a7 in
    let:16 a10 = addWithCarry(!false,a9,~1C) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a18 = a6[15:8] in
        let:8 a19 = a6[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a25,a21));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a26 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a27 = a26[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a28 = a27 in
      let:16 a29 = addWithCarry(!false,a28,~40) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~40 & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a29[15:8][0]) {
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a33 = a6[15:8] in
        let:8 a34 = a6[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump ((a40,a36));
      }
    }

0B4D:

    #0B4D
    #instruction: LD   A,(21FF)
    let:8 a1 = M[21FF] in
    advance (13)
    #0B50
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0B51
    #instruction: JP   NZ,0B5D
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0B5D);
    } else {
      advance (10)
      #0B54
      #instruction: CALL 08D1
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 0B;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 57;
      #return-to: 0B57
      advance (17)
      #08D1
      #instruction: IN   02
      advance (10)
      #08D3
      #instruction: AND  03
      let:8 a12 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
      let:8 a13 = (03 & a12) in
      let:8 a14 = (03 | a12) in
      advance (7)
      #08D5
      #instruction: ADD  03
      let:8 a15 = a13 in
      let:16 a16 = addWithCarry(false,03,a15) in
      let:8 a17 = (03 & 0F) in
      let:8 a18 = (a15 & 0F) in
      let:16 a19 = addWithCarry(false,a17,a18) in
      advance (7)
      #08D7
      #instruction: RET
      let:8 a20 = a11[15:8] in
      let:8 a21 = a11[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      let:8 a24 = a22[15:8] in
      let:8 a25 = a22[7:0] in
      let:16 a26 = (1 + (a24,a25)) in
      let:8 a27 = M[(a24,a25)] in
      advance (10)
      A := a16[7:0];
      SPH := a26[15:8];
      SPL := a26[7:0];
      FlagS := a16[7:0][7];
      FlagZ := is_zero(a16[7:0]);
      FlagA := a19[7:0][4];
      FlagP := parity(a16[7:0]);
      FlagCY := a16[15:8][0];
      jump ((a27,a23));
    }

0B57:

    #0B57
    #instruction: LD   (21FF),A
    let:8 a1 = A in
    M[21FF] := a1;
    advance (13)
    #0B5A
    #instruction: CALL 1A7F
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 0B;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 5D;
    #return-to: 0B5D
    advance (17)
    #1A7F
    #instruction: CALL 092E
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 1A;
    let:8 a11 = a10[15:8] in
    let:8 a12 = a10[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 82;
    #return-to: 1A82
    advance (17)
    #092E
    #instruction: CALL 1611
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := 09;
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 31;
    #return-to: 0931
    advance (17)
    #1611
    #instruction: LD   L,00
    advance (7)
    #1613
    #instruction: LD   A,(2067)
    let:8 a20 = M[2067] in
    advance (13)
    #1616
    #instruction: LD   H,A
    let:8 a21 = a20 in
    advance (5)
    #1617
    #instruction: RET
    let:8 a22 = a19[15:8] in
    let:8 a23 = a19[7:0] in
    let:16 a24 = (1 + (a22,a23)) in
    let:8 a25 = M[(a22,a23)] in
    let:8 a26 = a24[15:8] in
    let:8 a27 = a24[7:0] in
    let:16 a28 = (1 + (a26,a27)) in
    let:8 a29 = M[(a26,a27)] in
    advance (10)
    A := a20;
    H := a21;
    L := 00;
    SPH := a28[15:8];
    SPL := a28[7:0];
    jump ((a29,a25));

0B5D:

    #0B5D
    #instruction: CALL 01E4
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 60;
    #return-to: 0B60
    advance (17)
    #01E4
    #instruction: LD   B,C0
    advance (7)
    #01E6
    #instruction: LD   DE,1B00
    advance (10)
    #01E9
    #instruction: LD   HL,2000
    advance (10)
    #01EC
    #instruction: JP   1A32
    advance (10)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2000] := 01;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,C0,~00) in
    let:8 a8 = (C0 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a7[7:0])) {
      advance (10)
      A := 01;
      B := a7[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := 01;
      B := a7[7:0];
      D := 1B;
      E := 01;
      H := 20;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0B60:

    #0B60
    #instruction: CALL 01C0
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 63;
    #return-to: 0B63
    advance (17)
    #01C0
    #instruction: LD   HL,2100
    advance (10)
    #01C3
    #instruction: LD   B,37
    advance (7)
    #01C5
    #instruction: LD   (HL),01
    M[2100] := 01;
    advance (10)
    #01C7
    #instruction: INC  HL
    advance (5)
    #01C8
    #instruction: DEC  B
    let:16 a7 = addWithCarry(!true,37,~00) in
    let:8 a8 = (37 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #01C9
    #instruction: JP   NZ,01C5
    if (!is_zero(a7[7:0])) {
      advance (10)
      B := a7[7:0];
      H := 21;
      L := 01;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump (01C5);
    } else {
      advance (10)
      #01CC
      #instruction: RET
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      B := a7[7:0];
      H := 21;
      L := 01;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      jump ((a18,a14));
    }

0B63:

    #0B63
    #instruction: CALL 01EF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 66;
    #return-to: 0B66
    advance (17)
    #01EF
    #instruction: LD   HL,2142
    advance (10)
    #01F2
    #instruction: JP   01F8
    advance (10)
    #01F8
    #instruction: LD   C,04
    advance (7)
    #01FA
    #instruction: LD   DE,1D20
    advance (10)
    #01FD
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1D;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 20;
    advance (11)
    #01FE
    #instruction: LD   B,2C
    advance (7)
    #0200
    #instruction: CALL 1A32
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 02;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 03;
    #return-to: 0203
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2142] := FF;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a19 = addWithCarry(!true,2C,~00) in
    let:8 a20 = (2C & 0F) in
    let:8 a21 = (~00 & 0F) in
    let:16 a22 = addWithCarry(!true,a20,a21) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a19[7:0])) {
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a23 = a18[15:8] in
      let:8 a24 = a18[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      let:8 a27 = a25[15:8] in
      let:8 a28 = a25[7:0] in
      let:16 a29 = (1 + (a27,a28)) in
      let:8 a30 = M[(a27,a28)] in
      advance (10)
      A := FF;
      B := a19[7:0];
      C := 04;
      D := 1D;
      E := 21;
      H := 21;
      L := 43;
      SPH := a29[15:8];
      SPL := a29[7:0];
      FlagS := a19[7:0][7];
      FlagZ := is_zero(a19[7:0]);
      FlagA := a22[7:0][4];
      FlagP := parity(a19[7:0]);
      jump ((a30,a26));
    }

0B66:

    #0B66
    #instruction: CALL 021A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 69;
    #return-to: 0B69
    advance (17)
    #021A
    #instruction: XOR  A
    let:8 a7 = A in
    let:8 a8 = A in
    let:8 a9 = (a7 ^ a8) in
    advance (4)
    #021B
    #instruction: LD   DE,2142
    advance (10)
    #021E
    #instruction: LD   (2081),A
    let:8 a10 = a9 in
    M[2081] := a10;
    advance (13)
    #0221
    #instruction: LD   BC,1602
    advance (10)
    #0224
    #instruction: LD   HL,2806
    advance (10)
    #0227
    #instruction: LD   A,04
    advance (7)
    #0229
    #instruction: PUSH PSW
    let:8 a11 = a6[15:8] in
    let:8 a12 = a6[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 04;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a9[7]),6,is_zero(a9)),4,false),2,parity(a9)),0,false);
    advance (11)
    #022A
    #instruction: PUSH BC
    let:8 a17 = a16[15:8] in
    let:8 a18 = a16[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 16;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := 02;
    advance (11)
    #022B
    #instruction: LD   A,(2081)
    let:8 a23 = M[2081] in
    advance (13)
    #022E
    #instruction: AND  A
    let:8 a24 = a23 in
    let:8 a25 = a23 in
    let:8 a26 = (a24 & a25) in
    let:8 a27 = (a24 | a25) in
    advance (4)
    #022F
    #instruction: JP   NZ,0242
    if (!is_zero(a26)) {
      advance (10)
      #0242
      #instruction: CALL 147C
      let:8 a28 = a22[15:8] in
      let:8 a29 = a22[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 02;
      let:8 a31 = a30[15:8] in
      let:8 a32 = a30[7:0] in
      let:16 a33 = (-1 + (a31,a32)) in
      M[a33] := 45;
      #return-to: 0245
      advance (17)
      #147C
      #instruction: PUSH BC
      let:8 a34 = a33[15:8] in
      let:8 a35 = a33[7:0] in
      let:16 a36 = (-1 + (a34,a35)) in
      M[a36] := 16;
      let:8 a37 = a36[15:8] in
      let:8 a38 = a36[7:0] in
      let:16 a39 = (-1 + (a37,a38)) in
      M[a39] := 02;
      advance (11)
      #147D
      #instruction: PUSH HL
      let:8 a40 = a39[15:8] in
      let:8 a41 = a39[7:0] in
      let:16 a42 = (-1 + (a40,a41)) in
      M[a42] := 28;
      let:8 a43 = a42[15:8] in
      let:8 a44 = a42[7:0] in
      let:16 a45 = (-1 + (a43,a44)) in
      M[a45] := 06;
      advance (11)
      #147E
      #instruction: LD   A,(HL)
      let:8 a46 = M[2806] in
      advance (7)
      #147F
      #instruction: LD   (DE),A
      let:8 a47 = a46 in
      M[2142] := a47;
      advance (7)
      #1480
      #instruction: INC  DE
      advance (5)
      #1481
      #instruction: INC  HL
      advance (5)
      #1482
      #instruction: DEC  C
      let:16 a48 = addWithCarry(!true,02,~00) in
      let:8 a49 = (02 & 0F) in
      let:8 a50 = (~00 & 0F) in
      let:16 a51 = addWithCarry(!true,a49,a50) in
      advance (5)
      #1483
      #instruction: JP   NZ,147E
      if (!is_zero(a48[7:0])) {
        advance (10)
        A := a46;
        B := 16;
        C := a48[7:0];
        D := 21;
        E := 43;
        H := 28;
        L := 07;
        SPH := a45[15:8];
        SPL := a45[7:0];
        FlagS := a48[7:0][7];
        FlagZ := is_zero(a48[7:0]);
        FlagA := a51[7:0][4];
        FlagP := parity(a48[7:0]);
        FlagCY := false;
        jump (147E);
      } else {
        advance (10)
        #1486
        #instruction: POP  HL
        let:8 a52 = a45[15:8] in
        let:8 a53 = a45[7:0] in
        let:16 a54 = (1 + (a52,a53)) in
        let:8 a55 = M[(a52,a53)] in
        let:8 a56 = a54[15:8] in
        let:8 a57 = a54[7:0] in
        let:16 a58 = (1 + (a56,a57)) in
        let:8 a59 = M[(a56,a57)] in
        advance (10)
        #1487
        #instruction: LD   BC,0020
        advance (10)
        #148A
        #instruction: ADD  HL,BC
        let:8 a60 = a59 in
        let:8 a61 = a55 in
        let:17 a62 = add17(0020,(a60,a61)) in
        advance (10)
        #148B
        #instruction: POP  BC
        let:8 a63 = a58[15:8] in
        let:8 a64 = a58[7:0] in
        let:16 a65 = (1 + (a63,a64)) in
        let:8 a66 = M[(a63,a64)] in
        let:8 a67 = a65[15:8] in
        let:8 a68 = a65[7:0] in
        let:16 a69 = (1 + (a67,a68)) in
        let:8 a70 = M[(a67,a68)] in
        advance (10)
        #148C
        #instruction: DEC  B
        let:8 a71 = a70 in
        let:16 a72 = addWithCarry(!true,a71,~00) in
        let:8 a73 = (a71 & 0F) in
        let:8 a74 = (~00 & 0F) in
        let:16 a75 = addWithCarry(!true,a73,a74) in
        advance (5)
        #148D
        #instruction: JP   NZ,147C
        if (!is_zero(a72[7:0])) {
          advance (10)
          A := a46;
          B := a72[7:0];
          C := a66;
          D := 21;
          E := 43;
          H := a62[15:0][15:8];
          L := a62[15:0][7:0];
          SPH := a69[15:8];
          SPL := a69[7:0];
          FlagS := a72[7:0][7];
          FlagZ := is_zero(a72[7:0]);
          FlagA := a75[7:0][4];
          FlagP := parity(a72[7:0]);
          FlagCY := a62[16];
          jump (147C);
        } else {
          advance (10)
          #1490
          #instruction: RET
          let:8 a76 = a69[15:8] in
          let:8 a77 = a69[7:0] in
          let:16 a78 = (1 + (a76,a77)) in
          let:8 a79 = M[(a76,a77)] in
          let:8 a80 = a78[15:8] in
          let:8 a81 = a78[7:0] in
          let:16 a82 = (1 + (a80,a81)) in
          let:8 a83 = M[(a80,a81)] in
          advance (10)
          A := a46;
          B := a72[7:0];
          C := a66;
          D := 21;
          E := 43;
          H := a62[15:0][15:8];
          L := a62[15:0][7:0];
          SPH := a82[15:8];
          SPL := a82[7:0];
          FlagS := a72[7:0][7];
          FlagZ := is_zero(a72[7:0]);
          FlagA := a75[7:0][4];
          FlagP := parity(a72[7:0]);
          FlagCY := a62[16];
          jump ((a83,a79));
        }
      }
    } else {
      advance (10)
      #0232
      #instruction: CALL 1A69
      let:8 a84 = a22[15:8] in
      let:8 a85 = a22[7:0] in
      let:16 a86 = (-1 + (a84,a85)) in
      M[a86] := 02;
      let:8 a87 = a86[15:8] in
      let:8 a88 = a86[7:0] in
      let:16 a89 = (-1 + (a87,a88)) in
      M[a89] := 35;
      #return-to: 0235
      advance (17)
      #1A69
      #instruction: PUSH BC
      let:8 a90 = a89[15:8] in
      let:8 a91 = a89[7:0] in
      let:16 a92 = (-1 + (a90,a91)) in
      M[a92] := 16;
      let:8 a93 = a92[15:8] in
      let:8 a94 = a92[7:0] in
      let:16 a95 = (-1 + (a93,a94)) in
      M[a95] := 02;
      advance (11)
      #1A6A
      #instruction: PUSH HL
      let:8 a96 = a95[15:8] in
      let:8 a97 = a95[7:0] in
      let:16 a98 = (-1 + (a96,a97)) in
      M[a98] := 28;
      let:8 a99 = a98[15:8] in
      let:8 a100 = a98[7:0] in
      let:16 a101 = (-1 + (a99,a100)) in
      M[a101] := 06;
      advance (11)
      #1A6B
      #instruction: LD   A,(DE)
      let:8 a102 = M[2142] in
      advance (7)
      #1A6C
      #instruction: OR   (HL)
      let:8 a103 = M[2806] in
      let:8 a104 = a102 in
      let:8 a105 = (a103 | a104) in
      advance (7)
      #1A6D
      #instruction: LD   (HL),A
      let:8 a106 = a105 in
      M[2806] := a106;
      advance (7)
      #1A6E
      #instruction: INC  DE
      advance (5)
      #1A6F
      #instruction: INC  HL
      advance (5)
      #1A70
      #instruction: DEC  C
      let:16 a107 = addWithCarry(!true,02,~00) in
      let:8 a108 = (02 & 0F) in
      let:8 a109 = (~00 & 0F) in
      let:16 a110 = addWithCarry(!true,a108,a109) in
      advance (5)
      #1A71
      #instruction: JP   NZ,1A6B
      if (!is_zero(a107[7:0])) {
        advance (10)
        A := a105;
        B := 16;
        C := a107[7:0];
        D := 21;
        E := 43;
        H := 28;
        L := 07;
        SPH := a101[15:8];
        SPL := a101[7:0];
        FlagS := a107[7:0][7];
        FlagZ := is_zero(a107[7:0]);
        FlagA := a110[7:0][4];
        FlagP := parity(a107[7:0]);
        FlagCY := false;
        jump (1A6B);
      } else {
        advance (10)
        #1A74
        #instruction: POP  HL
        let:8 a111 = a101[15:8] in
        let:8 a112 = a101[7:0] in
        let:16 a113 = (1 + (a111,a112)) in
        let:8 a114 = M[(a111,a112)] in
        let:8 a115 = a113[15:8] in
        let:8 a116 = a113[7:0] in
        let:16 a117 = (1 + (a115,a116)) in
        let:8 a118 = M[(a115,a116)] in
        advance (10)
        #1A75
        #instruction: LD   BC,0020
        advance (10)
        #1A78
        #instruction: ADD  HL,BC
        let:8 a119 = a118 in
        let:8 a120 = a114 in
        let:17 a121 = add17(0020,(a119,a120)) in
        advance (10)
        #1A79
        #instruction: POP  BC
        let:8 a122 = a117[15:8] in
        let:8 a123 = a117[7:0] in
        let:16 a124 = (1 + (a122,a123)) in
        let:8 a125 = M[(a122,a123)] in
        let:8 a126 = a124[15:8] in
        let:8 a127 = a124[7:0] in
        let:16 a128 = (1 + (a126,a127)) in
        let:8 a129 = M[(a126,a127)] in
        advance (10)
        #1A7A
        #instruction: DEC  B
        let:8 a130 = a129 in
        let:16 a131 = addWithCarry(!true,a130,~00) in
        let:8 a132 = (a130 & 0F) in
        let:8 a133 = (~00 & 0F) in
        let:16 a134 = addWithCarry(!true,a132,a133) in
        advance (5)
        #1A7B
        #instruction: JP   NZ,1A69
        if (!is_zero(a131[7:0])) {
          advance (10)
          A := a105;
          B := a131[7:0];
          C := a125;
          D := 21;
          E := 43;
          H := a121[15:0][15:8];
          L := a121[15:0][7:0];
          SPH := a128[15:8];
          SPL := a128[7:0];
          FlagS := a131[7:0][7];
          FlagZ := is_zero(a131[7:0]);
          FlagA := a134[7:0][4];
          FlagP := parity(a131[7:0]);
          FlagCY := a121[16];
          jump (1A69);
        } else {
          advance (10)
          #1A7E
          #instruction: RET
          let:8 a135 = a128[15:8] in
          let:8 a136 = a128[7:0] in
          let:16 a137 = (1 + (a135,a136)) in
          let:8 a138 = M[(a135,a136)] in
          let:8 a139 = a137[15:8] in
          let:8 a140 = a137[7:0] in
          let:16 a141 = (1 + (a139,a140)) in
          let:8 a142 = M[(a139,a140)] in
          advance (10)
          A := a105;
          B := a131[7:0];
          C := a125;
          D := 21;
          E := 43;
          H := a121[15:0][15:8];
          L := a121[15:0][7:0];
          SPH := a141[15:8];
          SPL := a141[7:0];
          FlagS := a131[7:0][7];
          FlagZ := is_zero(a131[7:0]);
          FlagA := a134[7:0][4];
          FlagP := parity(a131[7:0]);
          FlagCY := a121[16];
          jump ((a142,a138));
        }
      }
    }

0B69:

    #0B69
    #instruction: LD   A,01
    advance (7)
    #0B6B
    #instruction: LD   (20C1),A
    M[20C1] := 01;
    advance (13)
    #0B6E
    #instruction: CALL 01CF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 71;
    #return-to: 0B71
    advance (17)
    #01CF
    #instruction: LD   A,01
    advance (7)
    #01D1
    #instruction: LD   B,E0
    advance (7)
    #01D3
    #instruction: LD   HL,2402
    advance (10)
    #01D6
    #instruction: JP   14CC
    advance (10)
    #14CC
    #instruction: PUSH BC
    let:8 a7 = C in
    let:8 a8 = a6[15:8] in
    let:8 a9 = a6[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := E0;
    let:8 a11 = a10[15:8] in
    let:8 a12 = a10[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a7;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    M[2402] := 01;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a14 = add17(0020,2402) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    let:8 a19 = a17[15:8] in
    let:8 a20 = a17[7:0] in
    let:16 a21 = (1 + (a19,a20)) in
    let:8 a22 = M[(a19,a20)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a23 = a22 in
    let:16 a24 = addWithCarry(!true,a23,~00) in
    let:8 a25 = (a23 & 0F) in
    let:8 a26 = (~00 & 0F) in
    let:16 a27 = addWithCarry(!true,a25,a26) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a24[7:0])) {
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a28 = a21[15:8] in
      let:8 a29 = a21[7:0] in
      let:16 a30 = (1 + (a28,a29)) in
      let:8 a31 = M[(a28,a29)] in
      let:8 a32 = a30[15:8] in
      let:8 a33 = a30[7:0] in
      let:16 a34 = (1 + (a32,a33)) in
      let:8 a35 = M[(a32,a33)] in
      advance (10)
      A := 01;
      B := a24[7:0];
      C := a18;
      H := a14[15:0][15:8];
      L := a14[15:0][7:0];
      SPH := a34[15:8];
      SPL := a34[7:0];
      FlagS := a24[7:0][7];
      FlagZ := is_zero(a24[7:0]);
      FlagA := a27[7:0][4];
      FlagP := parity(a24[7:0]);
      FlagCY := a14[16];
      jump ((a35,a31));
    }

0B71:

    #0B71
    #instruction: CALL 1618
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 0B74
    advance (17)
    #1618
    #instruction: LD   A,(2015)
    let:8 a7 = M[2015] in
    advance (13)
    #161B
    #instruction: CP   FF
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~FF) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~FF & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #161D
    #instruction: RET  NZ
    if (!is_zero(a9[7:0])) {
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (11)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (5)
      #161E
      #instruction: LD   HL,2010
      advance (10)
      #1621
      #instruction: LD   A,(HL)
      let:8 a21 = M[2010] in
      advance (7)
      #1622
      #instruction: INC  HL
      advance (5)
      #1623
      #instruction: LD   B,(HL)
      let:8 a22 = M[2011] in
      advance (7)
      #1624
      #instruction: OR   B
      let:8 a23 = a22 in
      let:8 a24 = a21 in
      let:8 a25 = (a23 | a24) in
      advance (4)
      #1625
      #instruction: RET  NZ
      if (!is_zero(a25)) {
        let:8 a26 = a6[15:8] in
        let:8 a27 = a6[7:0] in
        let:16 a28 = (1 + (a26,a27)) in
        let:8 a29 = M[(a26,a27)] in
        let:8 a30 = a28[15:8] in
        let:8 a31 = a28[7:0] in
        let:16 a32 = (1 + (a30,a31)) in
        let:8 a33 = M[(a30,a31)] in
        advance (11)
        A := a25;
        B := a22;
        H := 20;
        L := 11;
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a25[7];
        FlagZ := is_zero(a25);
        FlagA := false;
        FlagP := parity(a25);
        FlagCY := false;
        jump ((a33,a29));
      } else {
        advance (5)
        #1626
        #instruction: LD   A,(2025)
        let:8 a34 = M[2025] in
        advance (13)
        #1629
        #instruction: AND  A
        let:8 a35 = a34 in
        let:8 a36 = a34 in
        let:8 a37 = (a35 & a36) in
        let:8 a38 = (a35 | a36) in
        advance (4)
        #162A
        #instruction: RET  NZ
        if (!is_zero(a37)) {
          let:8 a39 = a6[15:8] in
          let:8 a40 = a6[7:0] in
          let:16 a41 = (1 + (a39,a40)) in
          let:8 a42 = M[(a39,a40)] in
          let:8 a43 = a41[15:8] in
          let:8 a44 = a41[7:0] in
          let:16 a45 = (1 + (a43,a44)) in
          let:8 a46 = M[(a43,a44)] in
          advance (11)
          A := a37;
          B := a22;
          H := 20;
          L := 11;
          SPH := a45[15:8];
          SPL := a45[7:0];
          FlagS := a37[7];
          FlagZ := is_zero(a37);
          FlagA := a38[3];
          FlagP := parity(a37);
          FlagCY := false;
          jump ((a46,a42));
        } else {
          advance (5)
          #162B
          #instruction: LD   A,(20EF)
          let:8 a47 = M[20EF] in
          advance (13)
          #162E
          #instruction: AND  A
          let:8 a48 = a47 in
          let:8 a49 = a47 in
          let:8 a50 = (a48 & a49) in
          let:8 a51 = (a48 | a49) in
          advance (4)
          #162F
          #instruction: JP   Z,1652
          if (is_zero(a50)) {
            advance (10)
            #1652
            #instruction: LD   HL,2025
            advance (10)
            #1655
            #instruction: LD   (HL),01
            M[2025] := 01;
            advance (10)
            #1657
            #instruction: LD   HL,(20ED)
            let:8 a52 = M[20ED] in
            let:8 a53 = M[20EE] in
            advance (16)
            #165A
            #instruction: INC  HL
            let:8 a54 = a53 in
            let:8 a55 = a52 in
            let:16 a56 = (1 + (a54,a55)) in
            advance (5)
            #165B
            #instruction: LD   A,L
            let:8 a57 = a56[7:0] in
            advance (5)
            #165C
            #instruction: CP   7E
            let:8 a58 = a57 in
            let:16 a59 = addWithCarry(!false,a58,~7E) in
            let:8 a60 = (a58 & 0F) in
            let:8 a61 = (~7E & 0F) in
            let:16 a62 = addWithCarry(!false,a60,a61) in
            advance (7)
            #165E
            #instruction: JP   CY,1663
            if (!a59[15:8][0]) {
              advance (10)
              #1663
              #instruction: LD   (20ED),HL
              let:8 a63 = a56[7:0] in
              M[20ED] := a63;
              let:8 a64 = a56[15:8] in
              M[20EE] := a64;
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              let:8 a65 = a56[15:8] in
              let:8 a66 = a56[7:0] in
              let:8 a67 = M[(a65,a66)] in
              advance (7)
              #1667
              #instruction: LD   (201D),A
              let:8 a68 = a67 in
              M[201D] := a68;
              advance (13)
              #166A
              #instruction: RET
              let:8 a69 = a6[15:8] in
              let:8 a70 = a6[7:0] in
              let:16 a71 = (1 + (a69,a70)) in
              let:8 a72 = M[(a69,a70)] in
              let:8 a73 = a71[15:8] in
              let:8 a74 = a71[7:0] in
              let:16 a75 = (1 + (a73,a74)) in
              let:8 a76 = M[(a73,a74)] in
              advance (10)
              A := a67;
              B := a22;
              H := a56[15:8];
              L := a56[7:0];
              SPH := a75[15:8];
              SPL := a75[7:0];
              FlagS := a59[7:0][7];
              FlagZ := is_zero(a59[7:0]);
              FlagA := a62[7:0][4];
              FlagP := parity(a59[7:0]);
              FlagCY := !a59[15:8][0];
              jump ((a76,a72));
            } else {
              advance (10)
              #1661
              #instruction: LD   L,74
              advance (7)
              #1663
              #instruction: LD   (20ED),HL
              M[20ED] := 74;
              let:8 a77 = a56[15:8] in
              M[20EE] := a77;
              advance (16)
              #1666
              #instruction: LD   A,(HL)
              let:8 a78 = a56[15:8] in
              let:8 a79 = M[(a78,74)] in
              advance (7)
              #1667
              #instruction: LD   (201D),A
              let:8 a80 = a79 in
              M[201D] := a80;
              advance (13)
              #166A
              #instruction: RET
              let:8 a81 = a6[15:8] in
              let:8 a82 = a6[7:0] in
              let:16 a83 = (1 + (a81,a82)) in
              let:8 a84 = M[(a81,a82)] in
              let:8 a85 = a83[15:8] in
              let:8 a86 = a83[7:0] in
              let:16 a87 = (1 + (a85,a86)) in
              let:8 a88 = M[(a85,a86)] in
              advance (10)
              A := a79;
              B := a22;
              H := a56[15:8];
              L := 74;
              SPH := a87[15:8];
              SPL := a87[7:0];
              FlagS := a59[7:0][7];
              FlagZ := is_zero(a59[7:0]);
              FlagA := a62[7:0][4];
              FlagP := parity(a59[7:0]);
              FlagCY := !a59[15:8][0];
              jump ((a88,a84));
            }
          } else {
            advance (10)
            #1632
            #instruction: LD   A,(202D)
            let:8 a89 = M[202D] in
            advance (13)
            #1635
            #instruction: AND  A
            let:8 a90 = a89 in
            let:8 a91 = a89 in
            let:8 a92 = (a90 & a91) in
            let:8 a93 = (a90 | a91) in
            advance (4)
            #1636
            #instruction: JP   NZ,1648
            if (!is_zero(a92)) {
              advance (10)
              #1648
              #instruction: CALL 17C0
              let:8 a94 = a6[15:8] in
              let:8 a95 = a6[7:0] in
              let:16 a96 = (-1 + (a94,a95)) in
              M[a96] := 16;
              let:8 a97 = a96[15:8] in
              let:8 a98 = a96[7:0] in
              let:16 a99 = (-1 + (a97,a98)) in
              M[a99] := 4B;
              #return-to: 164B
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              let:8 a100 = M[2067] in
              advance (13)
              #17C3
              #instruction: RRCA
              let:8 a101 = a100 in
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!a101[0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:8 a102 = a99[15:8] in
                let:8 a103 = a99[7:0] in
                let:16 a104 = (1 + (a102,a103)) in
                let:8 a105 = M[(a102,a103)] in
                let:8 a106 = a104[15:8] in
                let:8 a107 = a104[7:0] in
                let:16 a108 = (1 + (a106,a107)) in
                let:8 a109 = M[(a106,a107)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := a22;
                H := 20;
                L := 11;
                SPH := a108[15:8];
                SPL := a108[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a101[0];
                jump ((a109,a105));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:8 a110 = a99[15:8] in
                let:8 a111 = a99[7:0] in
                let:16 a112 = (1 + (a110,a111)) in
                let:8 a113 = M[(a110,a111)] in
                let:8 a114 = a112[15:8] in
                let:8 a115 = a112[7:0] in
                let:16 a116 = (1 + (a114,a115)) in
                let:8 a117 = M[(a114,a115)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := a22;
                H := 20;
                L := 11;
                SPH := a116[15:8];
                SPL := a116[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a101[0];
                jump ((a117,a113));
              }
            } else {
              advance (10)
              #1639
              #instruction: CALL 17C0
              let:8 a118 = a6[15:8] in
              let:8 a119 = a6[7:0] in
              let:16 a120 = (-1 + (a118,a119)) in
              M[a120] := 16;
              let:8 a121 = a120[15:8] in
              let:8 a122 = a120[7:0] in
              let:16 a123 = (-1 + (a121,a122)) in
              M[a123] := 3C;
              #return-to: 163C
              advance (17)
              #17C0
              #instruction: LD   A,(2067)
              let:8 a124 = M[2067] in
              advance (13)
              #17C3
              #instruction: RRCA
              let:8 a125 = a124 in
              advance (4)
              #17C4
              #instruction: JP   NC,17CA
              if (!a125[0]) {
                advance (10)
                #17CA
                #instruction: IN   02
                advance (10)
                #17CC
                #instruction: RET
                let:8 a126 = a123[15:8] in
                let:8 a127 = a123[7:0] in
                let:16 a128 = (1 + (a126,a127)) in
                let:8 a129 = M[(a126,a127)] in
                let:8 a130 = a128[15:8] in
                let:8 a131 = a128[7:0] in
                let:16 a132 = (1 + (a130,a131)) in
                let:8 a133 = M[(a130,a131)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off));
                B := a22;
                H := 20;
                L := 11;
                SPH := a132[15:8];
                SPL := a132[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a125[0];
                jump ((a133,a129));
              } else {
                advance (10)
                #17C7
                #instruction: IN   01
                advance (10)
                #17C9
                #instruction: RET
                let:8 a134 = a123[15:8] in
                let:8 a135 = a123[7:0] in
                let:16 a136 = (1 + (a134,a135)) in
                let:8 a137 = M[(a134,a135)] in
                let:8 a138 = a136[15:8] in
                let:8 a139 = a136[7:0] in
                let:16 a140 = (1 + (a138,a139)) in
                let:8 a141 = M[(a138,a139)] in
                advance (10)
                A := updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right));
                B := a22;
                H := 20;
                L := 11;
                SPH := a140[15:8];
                SPL := a140[7:0];
                FlagS := a92[7];
                FlagZ := is_zero(a92);
                FlagA := a93[3];
                FlagP := parity(a92);
                FlagCY := a125[0];
                jump ((a141,a137));
              }
            }
          }
        }
      }
    }

0B74:

    #0B74
    #instruction: CALL 0BF1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 77;
    #return-to: 0B77
    advance (17)
    #0BF1
    #instruction: CALL 190A
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 0B;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F4;
    #return-to: 0BF4
    advance (17)
    #190A
    #instruction: CALL 14D8
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 19;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 0D;
    #return-to: 190D
    advance (17)
    #14D8
    #instruction: LD   A,(2025)
    let:8 a19 = M[2025] in
    advance (13)
    #14DB
    #instruction: CP   05
    let:8 a20 = a19 in
    let:16 a21 = addWithCarry(!false,a20,~05) in
    let:8 a22 = (a20 & 0F) in
    let:8 a23 = (~05 & 0F) in
    let:16 a24 = addWithCarry(!false,a22,a23) in
    advance (7)
    #14DD
    #instruction: RET  Z
    if (is_zero(a21[7:0])) {
      let:8 a25 = a18[15:8] in
      let:8 a26 = a18[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      let:8 a29 = a27[15:8] in
      let:8 a30 = a27[7:0] in
      let:16 a31 = (1 + (a29,a30)) in
      let:8 a32 = M[(a29,a30)] in
      advance (11)
      A := a19;
      SPH := a31[15:8];
      SPL := a31[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := !a21[15:8][0];
      jump ((a32,a28));
    } else {
      advance (5)
      #14DE
      #instruction: CP   02
      let:8 a33 = a19 in
      let:16 a34 = addWithCarry(!false,a33,~02) in
      let:8 a35 = (a33 & 0F) in
      let:8 a36 = (~02 & 0F) in
      let:16 a37 = addWithCarry(!false,a35,a36) in
      advance (7)
      #14E0
      #instruction: RET  NZ
      if (!is_zero(a34[7:0])) {
        let:8 a38 = a18[15:8] in
        let:8 a39 = a18[7:0] in
        let:16 a40 = (1 + (a38,a39)) in
        let:8 a41 = M[(a38,a39)] in
        let:8 a42 = a40[15:8] in
        let:8 a43 = a40[7:0] in
        let:16 a44 = (1 + (a42,a43)) in
        let:8 a45 = M[(a42,a43)] in
        advance (11)
        A := a19;
        SPH := a44[15:8];
        SPL := a44[7:0];
        FlagS := a34[7:0][7];
        FlagZ := is_zero(a34[7:0]);
        FlagA := a37[7:0][4];
        FlagP := parity(a34[7:0]);
        FlagCY := !a34[15:8][0];
        jump ((a45,a41));
      } else {
        advance (5)
        #14E1
        #instruction: LD   A,(2029)
        let:8 a46 = M[2029] in
        advance (13)
        #14E4
        #instruction: CP   D8
        let:8 a47 = a46 in
        let:16 a48 = addWithCarry(!false,a47,~D8) in
        let:8 a49 = (a47 & 0F) in
        let:8 a50 = (~D8 & 0F) in
        let:16 a51 = addWithCarry(!false,a49,a50) in
        advance (7)
        #14E6
        #instruction: LD   B,A
        let:8 a52 = a46 in
        advance (5)
        #14E7
        #instruction: JP   NC,1530
        if (!!a48[15:8][0]) {
          advance (10)
          #1530
          #instruction: LD   A,03
          advance (7)
          #1532
          #instruction: LD   (2025),A
          M[2025] := 03;
          advance (13)
          #1535
          #instruction: JP   154A
          advance (10)
          #154A
          #instruction: XOR  A
          let:8 a53 = (03 ^ 03) in
          advance (4)
          #154B
          #instruction: LD   (2002),A
          let:8 a54 = a53 in
          M[2002] := a54;
          advance (13)
          #154E
          #instruction: LD   B,F7
          advance (7)
          #1550
          #instruction: JP   19DC
          advance (10)
          #19DC
          #instruction: LD   A,(2094)
          let:8 a55 = M[2094] in
          advance (13)
          #19DF
          #instruction: AND  B
          let:8 a56 = a55 in
          let:8 a57 = (F7 & a56) in
          let:8 a58 = (F7 | a56) in
          advance (4)
          #19E0
          #instruction: LD   (2094),A
          let:8 a59 = a57 in
          M[2094] := a59;
          advance (13)
          #19E3
          #instruction: OUT  03
          let:8 a60 = a57 in
          sound_control(Ufo,a60[0]);
          sound_control(Shot,a60[1]);
          sound_control(PlayerDie,a60[2]);
          sound_control(InvaderDie,a60[3]);
          sound_control(ExtraLife,a60[4]);
          advance (10)
          #19E5
          #instruction: RET
          let:8 a61 = a18[15:8] in
          let:8 a62 = a18[7:0] in
          let:16 a63 = (1 + (a61,a62)) in
          let:8 a64 = M[(a61,a62)] in
          let:8 a65 = a63[15:8] in
          let:8 a66 = a63[7:0] in
          let:16 a67 = (1 + (a65,a66)) in
          let:8 a68 = M[(a65,a66)] in
          advance (10)
          A := a57;
          B := F7;
          SPH := a67[15:8];
          SPL := a67[7:0];
          FlagS := a57[7];
          FlagZ := is_zero(a57);
          FlagA := a58[3];
          FlagP := parity(a57);
          FlagCY := false;
          jump ((a68,a64));
        } else {
          advance (10)
          #14EA
          #instruction: LD   A,(2002)
          let:8 a69 = M[2002] in
          advance (13)
          #14ED
          #instruction: AND  A
          let:8 a70 = a69 in
          let:8 a71 = a69 in
          let:8 a72 = (a70 & a71) in
          let:8 a73 = (a70 | a71) in
          advance (4)
          #14EE
          #instruction: RET  Z
          if (is_zero(a72)) {
            let:8 a74 = a18[15:8] in
            let:8 a75 = a18[7:0] in
            let:16 a76 = (1 + (a74,a75)) in
            let:8 a77 = M[(a74,a75)] in
            let:8 a78 = a76[15:8] in
            let:8 a79 = a76[7:0] in
            let:16 a80 = (1 + (a78,a79)) in
            let:8 a81 = M[(a78,a79)] in
            advance (11)
            A := a72;
            B := a52;
            SPH := a80[15:8];
            SPL := a80[7:0];
            FlagS := a72[7];
            FlagZ := is_zero(a72);
            FlagA := a73[3];
            FlagP := parity(a72);
            FlagCY := false;
            jump ((a81,a77));
          } else {
            advance (5)
            #14EF
            #instruction: LD   A,B
            let:8 a82 = a52 in
            advance (5)
            #14F0
            #instruction: CP   CE
            let:8 a83 = a82 in
            let:16 a84 = addWithCarry(!false,a83,~CE) in
            let:8 a85 = (a83 & 0F) in
            let:8 a86 = (~CE & 0F) in
            let:16 a87 = addWithCarry(!false,a85,a86) in
            advance (7)
            #14F2
            #instruction: JP   NC,1579
            if (!!a84[15:8][0]) {
              advance (10)
              #1579
              #instruction: LD   A,01
              advance (7)
              #157B
              #instruction: LD   (2085),A
              M[2085] := 01;
              advance (13)
              #157E
              #instruction: JP   1545
              advance (10)
              A := 01;
              B := a52;
              SPH := a18[15:8];
              SPL := a18[7:0];
              FlagS := a84[7:0][7];
              FlagZ := is_zero(a84[7:0]);
              FlagA := a87[7:0][4];
              FlagP := parity(a84[7:0]);
              FlagCY := !a84[15:8][0];
              jump (1545);
            } else {
              advance (10)
              #14F5
              #instruction: ADD  06
              let:8 a88 = a82 in
              let:16 a89 = addWithCarry(false,06,a88) in
              let:8 a90 = (06 & 0F) in
              let:8 a91 = (a88 & 0F) in
              let:16 a92 = addWithCarry(false,a90,a91) in
              advance (7)
              #14F7
              #instruction: LD   B,A
              let:8 a93 = a89[7:0] in
              advance (5)
              #14F8
              #instruction: LD   A,(2009)
              let:8 a94 = M[2009] in
              advance (13)
              #14FB
              #instruction: CP   90
              let:8 a95 = a94 in
              let:16 a96 = addWithCarry(!false,a95,~90) in
              let:8 a97 = (a95 & 0F) in
              let:8 a98 = (~90 & 0F) in
              let:16 a99 = addWithCarry(!false,a97,a98) in
              advance (7)
              #14FD
              #instruction: JP   NC,1504
              if (!!a96[15:8][0]) {
                advance (10)
                #1504
                #instruction: LD   L,B
                let:8 a100 = a93 in
                advance (5)
                #1505
                #instruction: CALL 1562
                let:8 a101 = a18[15:8] in
                let:8 a102 = a18[7:0] in
                let:16 a103 = (-1 + (a101,a102)) in
                M[a103] := 15;
                let:8 a104 = a103[15:8] in
                let:8 a105 = a103[7:0] in
                let:16 a106 = (-1 + (a104,a105)) in
                M[a106] := 08;
                #return-to: 1508
                advance (17)
                #1562
                #instruction: LD   A,(2009)
                let:8 a107 = M[2009] in
                advance (13)
                #1565
                #instruction: LD   H,L
                let:8 a108 = a100 in
                advance (5)
                #1566
                #instruction: CALL 1554
                let:8 a109 = a106[15:8] in
                let:8 a110 = a106[7:0] in
                let:16 a111 = (-1 + (a109,a110)) in
                M[a111] := 15;
                let:8 a112 = a111[15:8] in
                let:8 a113 = a111[7:0] in
                let:16 a114 = (-1 + (a112,a113)) in
                M[a114] := 69;
                #return-to: 1569
                advance (17)
                #1554
                #instruction: LD   C,00
                advance (7)
                #1556
                #instruction: CP   H
                let:8 a115 = a107 in
                let:8 a116 = a108 in
                let:16 a117 = addWithCarry(!false,a115,~a116) in
                let:8 a118 = (a115 & 0F) in
                let:8 a119 = (~a116 & 0F) in
                let:16 a120 = addWithCarry(!false,a118,a119) in
                advance (4)
                #1557
                #instruction: CALL NC,1590
                if (!!a117[15:8][0]) {
                  let:8 a121 = a114[15:8] in
                  let:8 a122 = a114[7:0] in
                  let:16 a123 = (-1 + (a121,a122)) in
                  M[a123] := 15;
                  let:8 a124 = a123[15:8] in
                  let:8 a125 = a123[7:0] in
                  let:16 a126 = (-1 + (a124,a125)) in
                  M[a126] := 5A;
                  #return-to: 155A
                  advance (17)
                  #1590
                  #instruction: INC  C
                  let:16 a127 = addWithCarry(true,00,00) in
                  let:8 a128 = (00 & 0F) in
                  let:8 a129 = (00 & 0F) in
                  let:16 a130 = addWithCarry(true,a128,a129) in
                  advance (5)
                  #1591
                  #instruction: ADD  10
                  let:8 a131 = a107 in
                  let:16 a132 = addWithCarry(false,10,a131) in
                  let:8 a133 = (10 & 0F) in
                  let:8 a134 = (a131 & 0F) in
                  let:16 a135 = addWithCarry(false,a133,a134) in
                  advance (7)
                  #1593
                  #instruction: JP   MI,1590
                  if (a132[7:0][7]) {
                    advance (10)
                    A := a132[7:0];
                    B := a93;
                    C := a127[7:0];
                    H := a108;
                    L := a100;
                    SPH := a126[15:8];
                    SPL := a126[7:0];
                    FlagS := a132[7:0][7];
                    FlagZ := is_zero(a132[7:0]);
                    FlagA := a135[7:0][4];
                    FlagP := parity(a132[7:0]);
                    FlagCY := a132[15:8][0];
                    jump (1590);
                  } else {
                    advance (10)
                    #1596
                    #instruction: RET
                    let:8 a136 = a126[15:8] in
                    let:8 a137 = a126[7:0] in
                    let:16 a138 = (1 + (a136,a137)) in
                    let:8 a139 = M[(a136,a137)] in
                    let:8 a140 = a138[15:8] in
                    let:8 a141 = a138[7:0] in
                    let:16 a142 = (1 + (a140,a141)) in
                    let:8 a143 = M[(a140,a141)] in
                    advance (10)
                    A := a132[7:0];
                    B := a93;
                    C := a127[7:0];
                    H := a108;
                    L := a100;
                    SPH := a142[15:8];
                    SPL := a142[7:0];
                    FlagS := a132[7:0][7];
                    FlagZ := is_zero(a132[7:0]);
                    FlagA := a135[7:0][4];
                    FlagP := parity(a132[7:0]);
                    FlagCY := a132[15:8][0];
                    jump ((a143,a139));
                  }
                } else {
                  advance (11)
                  A := a107;
                  B := a93;
                  C := 00;
                  H := a108;
                  L := a100;
                  SPH := a114[15:8];
                  SPL := a114[7:0];
                  FlagS := a117[7:0][7];
                  FlagZ := is_zero(a117[7:0]);
                  FlagA := a120[7:0][4];
                  FlagP := parity(a117[7:0]);
                  FlagCY := !a117[15:8][0];
                  jump (155A);
                }
              } else {
                advance (10)
                #1500
                #instruction: CP   B
                let:8 a144 = a94 in
                let:8 a145 = a93 in
                let:16 a146 = addWithCarry(!false,a144,~a145) in
                let:8 a147 = (a144 & 0F) in
                let:8 a148 = (~a145 & 0F) in
                let:16 a149 = addWithCarry(!false,a147,a148) in
                advance (4)
                #1501
                #instruction: JP   NC,1530
                if (!!a146[15:8][0]) {
                  advance (10)
                  #1530
                  #instruction: LD   A,03
                  advance (7)
                  #1532
                  #instruction: LD   (2025),A
                  M[2025] := 03;
                  advance (13)
                  #1535
                  #instruction: JP   154A
                  advance (10)
                  #154A
                  #instruction: XOR  A
                  let:8 a150 = (03 ^ 03) in
                  advance (4)
                  #154B
                  #instruction: LD   (2002),A
                  let:8 a151 = a150 in
                  M[2002] := a151;
                  advance (13)
                  #154E
                  #instruction: LD   B,F7
                  advance (7)
                  #1550
                  #instruction: JP   19DC
                  advance (10)
                  #19DC
                  #instruction: LD   A,(2094)
                  let:8 a152 = M[2094] in
                  advance (13)
                  #19DF
                  #instruction: AND  B
                  let:8 a153 = a152 in
                  let:8 a154 = (F7 & a153) in
                  let:8 a155 = (F7 | a153) in
                  advance (4)
                  #19E0
                  #instruction: LD   (2094),A
                  let:8 a156 = a154 in
                  M[2094] := a156;
                  advance (13)
                  #19E3
                  #instruction: OUT  03
                  let:8 a157 = a154 in
                  sound_control(Ufo,a157[0]);
                  sound_control(Shot,a157[1]);
                  sound_control(PlayerDie,a157[2]);
                  sound_control(InvaderDie,a157[3]);
                  sound_control(ExtraLife,a157[4]);
                  advance (10)
                  #19E5
                  #instruction: RET
                  let:8 a158 = a18[15:8] in
                  let:8 a159 = a18[7:0] in
                  let:16 a160 = (1 + (a158,a159)) in
                  let:8 a161 = M[(a158,a159)] in
                  let:8 a162 = a160[15:8] in
                  let:8 a163 = a160[7:0] in
                  let:16 a164 = (1 + (a162,a163)) in
                  let:8 a165 = M[(a162,a163)] in
                  advance (10)
                  A := a154;
                  B := F7;
                  SPH := a164[15:8];
                  SPL := a164[7:0];
                  FlagS := a154[7];
                  FlagZ := is_zero(a154);
                  FlagA := a155[3];
                  FlagP := parity(a154);
                  FlagCY := false;
                  jump ((a165,a161));
                } else {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  let:8 a166 = a93 in
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:8 a167 = a18[15:8] in
                  let:8 a168 = a18[7:0] in
                  let:16 a169 = (-1 + (a167,a168)) in
                  M[a169] := 15;
                  let:8 a170 = a169[15:8] in
                  let:8 a171 = a169[7:0] in
                  let:16 a172 = (-1 + (a170,a171)) in
                  M[a172] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  let:8 a173 = M[2009] in
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  let:8 a174 = a166 in
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:8 a175 = a172[15:8] in
                  let:8 a176 = a172[7:0] in
                  let:16 a177 = (-1 + (a175,a176)) in
                  M[a177] := 15;
                  let:8 a178 = a177[15:8] in
                  let:8 a179 = a177[7:0] in
                  let:16 a180 = (-1 + (a178,a179)) in
                  M[a180] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a181 = a173 in
                  let:8 a182 = a174 in
                  let:16 a183 = addWithCarry(!false,a181,~a182) in
                  let:8 a184 = (a181 & 0F) in
                  let:8 a185 = (~a182 & 0F) in
                  let:16 a186 = addWithCarry(!false,a184,a185) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a183[15:8][0]) {
                    let:8 a187 = a180[15:8] in
                    let:8 a188 = a180[7:0] in
                    let:16 a189 = (-1 + (a187,a188)) in
                    M[a189] := 15;
                    let:8 a190 = a189[15:8] in
                    let:8 a191 = a189[7:0] in
                    let:16 a192 = (-1 + (a190,a191)) in
                    M[a192] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a193 = addWithCarry(true,00,00) in
                    let:8 a194 = (00 & 0F) in
                    let:8 a195 = (00 & 0F) in
                    let:16 a196 = addWithCarry(true,a194,a195) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a197 = a173 in
                    let:16 a198 = addWithCarry(false,10,a197) in
                    let:8 a199 = (10 & 0F) in
                    let:8 a200 = (a197 & 0F) in
                    let:16 a201 = addWithCarry(false,a199,a200) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a198[7:0][7]) {
                      advance (10)
                      A := a198[7:0];
                      B := a93;
                      C := a193[7:0];
                      H := a174;
                      L := a166;
                      SPH := a192[15:8];
                      SPL := a192[7:0];
                      FlagS := a198[7:0][7];
                      FlagZ := is_zero(a198[7:0]);
                      FlagA := a201[7:0][4];
                      FlagP := parity(a198[7:0]);
                      FlagCY := a198[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a202 = a192[15:8] in
                      let:8 a203 = a192[7:0] in
                      let:16 a204 = (1 + (a202,a203)) in
                      let:8 a205 = M[(a202,a203)] in
                      let:8 a206 = a204[15:8] in
                      let:8 a207 = a204[7:0] in
                      let:16 a208 = (1 + (a206,a207)) in
                      let:8 a209 = M[(a206,a207)] in
                      advance (10)
                      A := a198[7:0];
                      B := a93;
                      C := a193[7:0];
                      H := a174;
                      L := a166;
                      SPH := a208[15:8];
                      SPL := a208[7:0];
                      FlagS := a198[7:0][7];
                      FlagZ := is_zero(a198[7:0]);
                      FlagA := a201[7:0][4];
                      FlagP := parity(a198[7:0]);
                      FlagCY := a198[15:8][0];
                      jump ((a209,a205));
                    }
                  } else {
                    advance (11)
                    A := a173;
                    B := a93;
                    C := 00;
                    H := a174;
                    L := a166;
                    SPH := a180[15:8];
                    SPL := a180[7:0];
                    FlagS := a183[7:0][7];
                    FlagZ := is_zero(a183[7:0]);
                    FlagA := a186[7:0][4];
                    FlagP := parity(a183[7:0]);
                    FlagCY := !a183[15:8][0];
                    jump (155A);
                  }
                }
              }
            }
          }
        }
      }
    }

0B77:

    #0B77
    #instruction: OUT  06
    let:8 a1 = A in
    unknown_output(6,a1);
    advance (10)
    #0B79
    #instruction: CALL 0A59
    let:8 a2 = SPH in
    let:8 a3 = SPL in
    let:16 a4 = (-1 + (a2,a3)) in
    M[a4] := 0B;
    let:8 a5 = a4[15:8] in
    let:8 a6 = a4[7:0] in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 7C;
    #return-to: 0B7C
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    let:8 a8 = M[2015] in
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:8 a9 = a8 in
    let:16 a10 = addWithCarry(!false,a9,~FF) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~FF & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #0A5E
    #instruction: RET
    let:8 a14 = a7[15:8] in
    let:8 a15 = a7[7:0] in
    let:16 a16 = (1 + (a14,a15)) in
    let:8 a17 = M[(a14,a15)] in
    let:8 a18 = a16[15:8] in
    let:8 a19 = a16[7:0] in
    let:16 a20 = (1 + (a18,a19)) in
    let:8 a21 = M[(a18,a19)] in
    advance (10)
    A := a8;
    SPH := a20[15:8];
    SPL := a20[7:0];
    FlagS := a10[7:0][7];
    FlagZ := is_zero(a10[7:0]);
    FlagA := a13[7:0][4];
    FlagP := parity(a10[7:0]);
    FlagCY := !a10[15:8][0];
    jump ((a21,a17));

0B7C:

    #0B7C
    #instruction: JP   Z,0B71
    if (FlagZ) {
      advance (10)
      jump (0B71);
    } else {
      advance (10)
      #0B7F
      #instruction: XOR  A
      let:8 a1 = A in
      let:8 a2 = A in
      let:8 a3 = (a1 ^ a2) in
      advance (4)
      #0B80
      #instruction: LD   (2025),A
      let:8 a4 = a3 in
      M[2025] := a4;
      advance (13)
      #0B83
      #instruction: CALL 0A59
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (-1 + (a5,a6)) in
      M[a7] := 0B;
      let:8 a8 = a7[15:8] in
      let:8 a9 = a7[7:0] in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 86;
      #return-to: 0B86
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a11 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a12 = a11 in
      let:16 a13 = addWithCarry(!false,a12,~FF) in
      let:8 a14 = (a12 & 0F) in
      let:8 a15 = (~FF & 0F) in
      let:16 a16 = addWithCarry(!false,a14,a15) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a17 = a10[15:8] in
      let:8 a18 = a10[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := a11;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := !a13[15:8][0];
      jump ((a24,a20));
    }

0B86:

    #0B86
    #instruction: JP   NZ,0B83
    if (!FlagZ) {
      advance (10)
      #0B83
      #instruction: CALL 0A59
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 0B;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 86;
      #return-to: 0B86
      advance (17)
      #0A59
      #instruction: LD   A,(2015)
      let:8 a7 = M[2015] in
      advance (13)
      #0A5C
      #instruction: CP   FF
      let:8 a8 = a7 in
      let:16 a9 = addWithCarry(!false,a8,~FF) in
      let:8 a10 = (a8 & 0F) in
      let:8 a11 = (~FF & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #0A5E
      #instruction: RET
      let:8 a13 = a6[15:8] in
      let:8 a14 = a6[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := a7;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (10)
      #0B89
      #instruction: XOR  A
      let:8 a21 = A in
      let:8 a22 = A in
      let:8 a23 = (a21 ^ a22) in
      advance (4)
      #0B8A
      #instruction: LD   (20C1),A
      let:8 a24 = a23 in
      M[20C1] := a24;
      advance (13)
      #0B8D
      #instruction: CALL 0AB1
      let:8 a25 = SPH in
      let:8 a26 = SPL in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 0B;
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 90;
      #return-to: 0B90
      advance (17)
      #0AB1
      #instruction: LD   A,40
      advance (7)
      #0AB3
      #instruction: JP   0AD7
      advance (10)
      #0AD7
      #instruction: LD   (20C0),A
      M[20C0] := 40;
      advance (13)
      #0ADA
      #instruction: LD   A,(20C0)
      let:8 a31 = M[20C0] in
      advance (13)
      #0ADD
      #instruction: AND  A
      let:8 a32 = a31 in
      let:8 a33 = a31 in
      let:8 a34 = (a32 & a33) in
      let:8 a35 = (a32 | a33) in
      advance (4)
      #0ADE
      #instruction: JP   NZ,0ADA
      if (!is_zero(a34)) {
        advance (10)
        A := a34;
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a34[7];
        FlagZ := is_zero(a34);
        FlagA := a35[3];
        FlagP := parity(a34);
        FlagCY := false;
        jump (0ADA);
      } else {
        advance (10)
        #0AE1
        #instruction: RET
        let:8 a36 = a30[15:8] in
        let:8 a37 = a30[7:0] in
        let:16 a38 = (1 + (a36,a37)) in
        let:8 a39 = M[(a36,a37)] in
        let:8 a40 = a38[15:8] in
        let:8 a41 = a38[7:0] in
        let:16 a42 = (1 + (a40,a41)) in
        let:8 a43 = M[(a40,a41)] in
        advance (10)
        A := a34;
        SPH := a42[15:8];
        SPL := a42[7:0];
        FlagS := a34[7];
        FlagZ := is_zero(a34);
        FlagA := a35[3];
        FlagP := parity(a34);
        FlagCY := false;
        jump ((a43,a39));
      }
    }

0B90:

    #0B90
    #instruction: CALL 1988
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 93;
    #return-to: 0B93
    advance (17)
    #1988
    #instruction: JP   09D6
    advance (10)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = (1F & 03) in
    let:8 a8 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a9 = a7 in
    let:16 a10 = addWithCarry(!false,a9,~1C) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a18 = a6[15:8] in
        let:8 a19 = a6[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a25,a21));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a26 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a27 = a26[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a28 = a27 in
      let:16 a29 = addWithCarry(!false,a28,~40) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~40 & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a29[15:8][0]) {
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a33 = a6[15:8] in
        let:8 a34 = a6[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump ((a40,a36));
      }
    }

0B93:

    #0B93
    #instruction: LD   C,0C
    advance (7)
    #0B95
    #instruction: LD   HL,2C11
    advance (10)
    #0B98
    #instruction: LD   DE,1F90
    advance (10)
    #0B9B
    #instruction: CALL 08F3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 9E;
    #return-to: 0B9E
    advance (17)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1F;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 90;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 08;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 2C;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 11;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(0008,0008) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,08);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 0C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

0B9E:

    #0B9E
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0BA1
    #instruction: CP   00
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0BA3
    #instruction: JP   NZ,0BAE
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0BAE);
    } else {
      advance (10)
      #0BA6
      #instruction: LD   HL,3311
      advance (10)
      #0BA9
      #instruction: LD   A,02
      advance (7)
      #0BAB
      #instruction: CALL 08FF
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 0B;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := AE;
      #return-to: 0BAE
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a13 = a12[15:8] in
      let:8 a14 = a12[7:0] in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 33;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := 11;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a19 = add17(0002,0002) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a20 = a19[15:0][15:8] in
      let:8 a21 = a19[15:0][7:0] in
      let:8 a22 = a19[15:0][15:8] in
      let:8 a23 = a19[15:0][7:0] in
      let:17 a24 = add17((a20,a21),(a22,a23)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a25 = a24[15:0][15:8] in
      let:8 a26 = a24[15:0][7:0] in
      let:8 a27 = a24[15:0][15:8] in
      let:8 a28 = a24[15:0][7:0] in
      let:17 a29 = add17((a25,a26),(a27,a28)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a30 = a29[15:0][15:8] in
      let:8 a31 = a29[15:0][7:0] in
      let:17 a32 = add17(1E00,(a30,a31)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a33 = a32[15:0][15:8] in
      let:8 a34 = a32[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a35 = a18[15:8] in
      let:8 a36 = a18[7:0] in
      let:16 a37 = (1 + (a35,a36)) in
      let:8 a38 = M[(a35,a36)] in
      let:8 a39 = a37[15:8] in
      let:8 a40 = a37[7:0] in
      let:16 a41 = (1 + (a39,a40)) in
      let:8 a42 = M[(a39,a40)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,02);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a43 = C in
      let:8 a44 = a41[15:8] in
      let:8 a45 = a41[7:0] in
      let:16 a46 = (-1 + (a44,a45)) in
      M[a46] := 08;
      let:8 a47 = a46[15:8] in
      let:8 a48 = a46[7:0] in
      let:16 a49 = (-1 + (a47,a48)) in
      M[a49] := a43;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a50 = a33 in
      let:8 a51 = a34 in
      let:8 a52 = M[(a50,a51)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a53 = a52 in
      let:8 a54 = a42 in
      let:8 a55 = a38 in
      M[(a54,a55)] := a53;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a56 = a33 in
      let:8 a57 = a34 in
      let:16 a58 = (1 + (a56,a57)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a59 = a42 in
      let:8 a60 = a38 in
      let:17 a61 = add17(0020,(a59,a60)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a62 = a49[15:8] in
      let:8 a63 = a49[7:0] in
      let:16 a64 = (1 + (a62,a63)) in
      let:8 a65 = M[(a62,a63)] in
      let:8 a66 = a64[15:8] in
      let:8 a67 = a64[7:0] in
      let:16 a68 = (1 + (a66,a67)) in
      let:8 a69 = M[(a66,a67)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a70 = a69 in
      let:16 a71 = addWithCarry(!true,a70,~00) in
      let:8 a72 = (a70 & 0F) in
      let:8 a73 = (~00 & 0F) in
      let:16 a74 = addWithCarry(!true,a72,a73) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a71[7:0])) {
        advance (10)
        A := a52;
        B := a71[7:0];
        C := a65;
        D := a58[15:8];
        E := a58[7:0];
        H := a61[15:0][15:8];
        L := a61[15:0][7:0];
        SPH := a68[15:8];
        SPL := a68[7:0];
        FlagS := a71[7:0][7];
        FlagZ := is_zero(a71[7:0]);
        FlagA := a74[7:0][4];
        FlagP := parity(a71[7:0]);
        FlagCY := a61[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a75 = a68[15:8] in
        let:8 a76 = a68[7:0] in
        let:16 a77 = (1 + (a75,a76)) in
        let:8 a78 = M[(a75,a76)] in
        let:8 a79 = a77[15:8] in
        let:8 a80 = a77[7:0] in
        let:16 a81 = (1 + (a79,a80)) in
        let:8 a82 = M[(a79,a80)] in
        advance (10)
        A := a52;
        B := a71[7:0];
        C := a65;
        D := a58[15:8];
        E := a58[7:0];
        H := a61[15:0][15:8];
        L := a61[15:0][7:0];
        SPH := a81[15:8];
        SPL := a81[7:0];
        FlagS := a71[7:0][7];
        FlagZ := is_zero(a71[7:0]);
        FlagA := a74[7:0][4];
        FlagP := parity(a71[7:0]);
        FlagCY := a61[16];
        jump ((a82,a78));
      }
    }

0BAE:

    #0BAE
    #instruction: LD   BC,1F9C
    advance (10)
    #0BB1
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B4;
    #return-to: 0BB4
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a7 = addWithCarry(!false,0D,~FF) in
    let:8 a8 = (0D & 0F) in
    let:8 a9 = (~FF & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a7[7:0])) {
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (11)
      A := 0D;
      B := 1F;
      C := 9C;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := true;
      jump ((a18,a14));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a19 = (1F & 1F) in
      let:8 a20 = (1F | 1F) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a21 = a6[15:8] in
      let:8 a22 = a6[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := a19;
      B := 1F;
      C := A0;
      D := 1F;
      E := 50;
      H := 2A;
      L := 0D;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a19[7];
      FlagZ := is_zero(a19);
      FlagA := a20[3];
      FlagP := parity(a19);
      FlagCY := false;
      jump ((a28,a24));
    }

0BB4:

    #0BB4
    #instruction: CALL 184C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := B7;
    #return-to: 0BB7
    advance (17)
    #184C
    #instruction: PUSH BC
    let:8 a7 = B in
    let:8 a8 = C in
    let:8 a9 = a6[15:8] in
    let:8 a10 = a6[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a7;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := a8;
    advance (11)
    #184D
    #instruction: LD   A,(206C)
    let:8 a15 = M[206C] in
    advance (13)
    #1850
    #instruction: LD   C,A
    let:8 a16 = a15 in
    advance (5)
    #1851
    #instruction: CALL 0A93
    let:8 a17 = a14[15:8] in
    let:8 a18 = a14[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 18;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := 54;
    #return-to: 1854
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:8 a23 = D in
    let:8 a24 = E in
    let:8 a25 = a22[15:8] in
    let:8 a26 = a22[7:0] in
    let:16 a27 = (-1 + (a25,a26)) in
    M[a27] := a23;
    let:8 a28 = a27[15:8] in
    let:8 a29 = a27[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a24;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    let:8 a31 = D in
    let:8 a32 = E in
    let:8 a33 = M[(a31,a32)] in
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a34 = a30[15:8] in
    let:8 a35 = a30[7:0] in
    let:16 a36 = (-1 + (a34,a35)) in
    M[a36] := 0A;
    let:8 a37 = a36[15:8] in
    let:8 a38 = a36[7:0] in
    let:16 a39 = (-1 + (a37,a38)) in
    M[a39] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a40 = H in
    let:8 a41 = L in
    let:8 a42 = a39[15:8] in
    let:8 a43 = a39[7:0] in
    let:16 a44 = (-1 + (a42,a43)) in
    M[a44] := a40;
    let:8 a45 = a44[15:8] in
    let:8 a46 = a44[7:0] in
    let:16 a47 = (-1 + (a45,a46)) in
    M[a47] := a41;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a48 = a33 in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a49 = a48 in
    let:8 a50 = a48 in
    let:17 a51 = add17((00,a49),(00,a50)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a52 = a51[15:0][15:8] in
    let:8 a53 = a51[15:0][7:0] in
    let:8 a54 = a51[15:0][15:8] in
    let:8 a55 = a51[15:0][7:0] in
    let:17 a56 = add17((a52,a53),(a54,a55)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a57 = a56[15:0][15:8] in
    let:8 a58 = a56[15:0][7:0] in
    let:8 a59 = a56[15:0][15:8] in
    let:8 a60 = a56[15:0][7:0] in
    let:17 a61 = add17((a57,a58),(a59,a60)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a62 = a61[15:0][15:8] in
    let:8 a63 = a61[15:0][7:0] in
    let:17 a64 = add17(1E00,(a62,a63)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a65 = a64[15:0][15:8] in
    let:8 a66 = a64[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a67 = a47[15:8] in
    let:8 a68 = a47[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a75 = a33 in
    unknown_output(6,a75);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a76 = a16 in
    let:8 a77 = a73[15:8] in
    let:8 a78 = a73[7:0] in
    let:16 a79 = (-1 + (a77,a78)) in
    M[a79] := 08;
    let:8 a80 = a79[15:8] in
    let:8 a81 = a79[7:0] in
    let:16 a82 = (-1 + (a80,a81)) in
    M[a82] := a76;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a83 = a65 in
    let:8 a84 = a66 in
    let:8 a85 = M[(a83,a84)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a86 = a85 in
    let:8 a87 = a74 in
    let:8 a88 = a70 in
    M[(a87,a88)] := a86;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a89 = a65 in
    let:8 a90 = a66 in
    let:16 a91 = (1 + (a89,a90)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a92 = a74 in
    let:8 a93 = a70 in
    let:17 a94 = add17(0020,(a92,a93)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a95 = a82[15:8] in
    let:8 a96 = a82[7:0] in
    let:16 a97 = (1 + (a95,a96)) in
    let:8 a98 = M[(a95,a96)] in
    let:8 a99 = a97[15:8] in
    let:8 a100 = a97[7:0] in
    let:16 a101 = (1 + (a99,a100)) in
    let:8 a102 = M[(a99,a100)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a103 = a102 in
    let:16 a104 = addWithCarry(!true,a103,~00) in
    let:8 a105 = (a103 & 0F) in
    let:8 a106 = (~00 & 0F) in
    let:16 a107 = addWithCarry(!true,a105,a106) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a104[7:0])) {
      advance (10)
      A := a85;
      B := a104[7:0];
      C := a98;
      D := a91[15:8];
      E := a91[7:0];
      H := a94[15:0][15:8];
      L := a94[15:0][7:0];
      SPH := a101[15:8];
      SPL := a101[7:0];
      FlagS := a104[7:0][7];
      FlagZ := is_zero(a104[7:0]);
      FlagA := a107[7:0][4];
      FlagP := parity(a104[7:0]);
      FlagCY := a94[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a108 = a101[15:8] in
      let:8 a109 = a101[7:0] in
      let:16 a110 = (1 + (a108,a109)) in
      let:8 a111 = M[(a108,a109)] in
      let:8 a112 = a110[15:8] in
      let:8 a113 = a110[7:0] in
      let:16 a114 = (1 + (a112,a113)) in
      let:8 a115 = M[(a112,a113)] in
      advance (10)
      A := a85;
      B := a104[7:0];
      C := a98;
      D := a91[15:8];
      E := a91[7:0];
      H := a94[15:0][15:8];
      L := a94[15:0][7:0];
      SPH := a114[15:8];
      SPL := a114[7:0];
      FlagS := a104[7:0][7];
      FlagZ := is_zero(a104[7:0]);
      FlagA := a107[7:0][4];
      FlagP := parity(a104[7:0]);
      FlagCY := a94[16];
      jump ((a115,a111));
    }

0BB7:

    #0BB7
    #instruction: IN   02
    advance (10)
    #0BB9
    #instruction: RLCA
    let:8 a1 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,is_pressed([dip3] lives (3,4,5,6) lsb)),1,is_pressed([dip5] lives (3,4,5,6) msb)),2,is_pressed(TILT)),3,is_pressed([dip6] extra ship at 1000)),4,is_pressed(player2 shoot)),5,is_pressed(player2 left)),6,is_pressed(player2 right)),7,is_pressed([dip7] coin info off)) in
    advance (4)
    #0BBA
    #instruction: JP   CY,0BC3
    if (a1[7]) {
      advance (10)
      A := updateBit((a1 << 01),0,a1[7]);
      FlagCY := a1[7];
      jump (0BC3);
    } else {
      advance (10)
      #0BBD
      #instruction: LD   BC,1FA0
      advance (10)
      #0BC0
      #instruction: CALL 183A
      let:8 a2 = SPH in
      let:8 a3 = SPL in
      let:16 a4 = (-1 + (a2,a3)) in
      M[a4] := 0B;
      let:8 a5 = a4[15:8] in
      let:8 a6 = a4[7:0] in
      let:16 a7 = (-1 + (a5,a6)) in
      M[a7] := C3;
      #return-to: 0BC3
      advance (17)
      #183A
      #instruction: CALL 1856
      let:8 a8 = a7[15:8] in
      let:8 a9 = a7[7:0] in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 18;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := 3D;
      #return-to: 183D
      advance (17)
      #1856
      #instruction: LD   A,(BC)
      advance (7)
      #1857
      #instruction: CP   FF
      let:16 a14 = addWithCarry(!false,0A,~FF) in
      let:8 a15 = (0A & 0F) in
      let:8 a16 = (~FF & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #1859
      #instruction: SCF
      advance (4)
      #185A
      #instruction: RET  Z
      if (is_zero(a14[7:0])) {
        let:8 a18 = a13[15:8] in
        let:8 a19 = a13[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (11)
        A := 0A;
        B := 1F;
        C := A0;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := true;
        jump ((a25,a21));
      } else {
        advance (5)
        #185B
        #instruction: LD   L,A
        advance (5)
        #185C
        #instruction: INC  BC
        advance (5)
        #185D
        #instruction: LD   A,(BC)
        advance (7)
        #185E
        #instruction: LD   H,A
        advance (5)
        #185F
        #instruction: INC  BC
        advance (5)
        #1860
        #instruction: LD   A,(BC)
        advance (7)
        #1861
        #instruction: LD   E,A
        advance (5)
        #1862
        #instruction: INC  BC
        advance (5)
        #1863
        #instruction: LD   A,(BC)
        advance (7)
        #1864
        #instruction: LD   D,A
        advance (5)
        #1865
        #instruction: INC  BC
        advance (5)
        #1866
        #instruction: AND  A
        let:8 a26 = (1F & 1F) in
        let:8 a27 = (1F | 1F) in
        advance (4)
        #1867
        #instruction: RET
        let:8 a28 = a13[15:8] in
        let:8 a29 = a13[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (10)
        A := a26;
        B := 1F;
        C := A4;
        D := 1F;
        E := 62;
        H := 2A;
        L := 0A;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a26[7];
        FlagZ := is_zero(a26);
        FlagA := a27[3];
        FlagP := parity(a26);
        FlagCY := false;
        jump ((a35,a31));
      }
    }

0BC3:

    #0BC3
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C6;
    #return-to: 0BC6
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

0BC6:

    #0BC6
    #instruction: LD   A,(20EC)
    let:8 a1 = M[20EC] in
    advance (13)
    #0BC9
    #instruction: CP   00
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #0BCB
    #instruction: JP   NZ,0BDA
    if (!is_zero(a3[7:0])) {
      advance (10)
      A := a1;
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump (0BDA);
    } else {
      advance (10)
      #0BCE
      #instruction: LD   DE,1FD5
      advance (10)
      #0BD1
      #instruction: CALL 0AE2
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 0B;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := D4;
      #return-to: 0BD4
      advance (17)
      #0AE2
      #instruction: LD   HL,20C2
      advance (10)
      #0AE5
      #instruction: LD   B,0C
      advance (7)
      #0AE7
      #instruction: JP   1A32
      advance (10)
      #1A32
      #instruction: LD   A,(DE)
      advance (7)
      #1A33
      #instruction: LD   (HL),A
      M[20C2] := 00;
      advance (7)
      #1A34
      #instruction: INC  HL
      advance (5)
      #1A35
      #instruction: INC  DE
      advance (5)
      #1A36
      #instruction: DEC  B
      let:16 a13 = addWithCarry(!true,0C,~00) in
      let:8 a14 = (0C & 0F) in
      let:8 a15 = (~00 & 0F) in
      let:16 a16 = addWithCarry(!true,a14,a15) in
      advance (5)
      #1A37
      #instruction: JP   NZ,1A32
      if (!is_zero(a13[7:0])) {
        advance (10)
        A := 00;
        B := a13[7:0];
        D := 1F;
        E := D6;
        H := 20;
        L := C3;
        SPH := a12[15:8];
        SPL := a12[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := !a3[15:8][0];
        jump (1A32);
      } else {
        advance (10)
        #1A3A
        #instruction: RET
        let:8 a17 = a12[15:8] in
        let:8 a18 = a12[7:0] in
        let:16 a19 = (1 + (a17,a18)) in
        let:8 a20 = M[(a17,a18)] in
        let:8 a21 = a19[15:8] in
        let:8 a22 = a19[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        advance (10)
        A := 00;
        B := a13[7:0];
        D := 1F;
        E := D6;
        H := 20;
        L := C3;
        SPH := a23[15:8];
        SPL := a23[7:0];
        FlagS := a13[7:0][7];
        FlagZ := is_zero(a13[7:0]);
        FlagA := a16[7:0][4];
        FlagP := parity(a13[7:0]);
        FlagCY := !a3[15:8][0];
        jump ((a24,a20));
      }
    }

0BD4:

    #0BD4
    #instruction: CALL 0A80
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D7;
    #return-to: 0BD7
    advance (17)
    #0A80
    #instruction: LD   A,02
    advance (7)
    #0A82
    #instruction: LD   (20C1),A
    M[20C1] := 02;
    advance (13)
    #0A85
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0A87
    #instruction: LD   A,(20CB)
    let:8 a7 = M[20CB] in
    advance (13)
    #0A8A
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0A8B
    #instruction: JP   Z,0A85
    if (is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0A85);
    } else {
      advance (10)
      #0A8E
      #instruction: XOR  A
      let:8 a12 = a10 in
      let:8 a13 = a10 in
      let:8 a14 = (a12 ^ a13) in
      advance (4)
      #0A8F
      #instruction: LD   (20C1),A
      let:8 a15 = a14 in
      M[20C1] := a15;
      advance (13)
      #0A92
      #instruction: RET
      let:8 a16 = a6[15:8] in
      let:8 a17 = a6[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a14;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := false;
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a23,a19));
    }

0BD7:

    #0BD7
    #instruction: CALL 189E
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 0BDA
    advance (17)
    #189E
    #instruction: LD   HL,2050
    advance (10)
    #18A1
    #instruction: LD   DE,1BC0
    advance (10)
    #18A4
    #instruction: LD   B,10
    advance (7)
    #18A6
    #instruction: CALL 1A32
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 18;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := A9;
    #return-to: 18A9
    advance (17)
    #1A32
    #instruction: LD   A,(DE)
    advance (7)
    #1A33
    #instruction: LD   (HL),A
    M[2050] := 00;
    advance (7)
    #1A34
    #instruction: INC  HL
    advance (5)
    #1A35
    #instruction: INC  DE
    advance (5)
    #1A36
    #instruction: DEC  B
    let:16 a13 = addWithCarry(!true,10,~00) in
    let:8 a14 = (10 & 0F) in
    let:8 a15 = (~00 & 0F) in
    let:16 a16 = addWithCarry(!true,a14,a15) in
    advance (5)
    #1A37
    #instruction: JP   NZ,1A32
    if (!is_zero(a13[7:0])) {
      advance (10)
      A := 00;
      B := a13[7:0];
      D := 1B;
      E := C1;
      H := 20;
      L := 51;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      jump (1A32);
    } else {
      advance (10)
      #1A3A
      #instruction: RET
      let:8 a17 = a12[15:8] in
      let:8 a18 = a12[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := 00;
      B := a13[7:0];
      D := 1B;
      E := C1;
      H := 20;
      L := 51;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      jump ((a24,a20));
    }

0BDA:

    #0BDA
    #instruction: LD   HL,20EC
    advance (10)
    #0BDD
    #instruction: LD   A,(HL)
    let:8 a1 = M[20EC] in
    advance (7)
    #0BDE
    #instruction: INC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(true,a2,00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (00 & 0F) in
    let:16 a6 = addWithCarry(true,a4,a5) in
    advance (5)
    #0BDF
    #instruction: AND  01
    let:8 a7 = a3[7:0] in
    let:8 a8 = (01 & a7) in
    let:8 a9 = (01 | a7) in
    advance (7)
    #0BE1
    #instruction: LD   (HL),A
    let:8 a10 = a8 in
    M[20EC] := a10;
    advance (7)
    #0BE2
    #instruction: CALL 09D6
    let:8 a11 = SPH in
    let:8 a12 = SPL in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := 0B;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := E5;
    #return-to: 0BE5
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a17 = (1F & 03) in
    let:8 a18 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a19 = a17 in
    let:16 a20 = addWithCarry(!false,a19,~1C) in
    let:8 a21 = (a19 & 0F) in
    let:8 a22 = (~1C & 0F) in
    let:16 a23 = addWithCarry(!false,a21,a22) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a20[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a24 = addWithCarry(!false,24,~40) in
      let:8 a25 = (24 & 0F) in
      let:8 a26 = (~40 & 0F) in
      let:16 a27 = addWithCarry(!false,a25,a26) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a24[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a28 = a16[15:8] in
        let:8 a29 = a16[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        let:8 a32 = a30[15:8] in
        let:8 a33 = a30[7:0] in
        let:16 a34 = (1 + (a32,a33)) in
        let:8 a35 = M[(a32,a33)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a34[15:8];
        SPL := a34[7:0];
        FlagS := a24[7:0][7];
        FlagZ := is_zero(a24[7:0]);
        FlagA := a27[7:0][4];
        FlagP := parity(a24[7:0]);
        FlagCY := !a24[15:8][0];
        jump ((a35,a31));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a36 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a37 = a36[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a38 = a37 in
      let:16 a39 = addWithCarry(!false,a38,~40) in
      let:8 a40 = (a38 & 0F) in
      let:8 a41 = (~40 & 0F) in
      let:16 a42 = addWithCarry(!false,a40,a41) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a39[15:8][0]) {
        advance (10)
        A := a37;
        D := 00;
        E := 06;
        H := a36[15:0][15:8];
        L := a36[15:0][7:0];
        SPH := a16[15:8];
        SPL := a16[7:0];
        FlagS := a39[7:0][7];
        FlagZ := is_zero(a39[7:0]);
        FlagA := a42[7:0][4];
        FlagP := parity(a39[7:0]);
        FlagCY := !a39[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a43 = a16[15:8] in
        let:8 a44 = a16[7:0] in
        let:16 a45 = (1 + (a43,a44)) in
        let:8 a46 = M[(a43,a44)] in
        let:8 a47 = a45[15:8] in
        let:8 a48 = a45[7:0] in
        let:16 a49 = (1 + (a47,a48)) in
        let:8 a50 = M[(a47,a48)] in
        advance (10)
        A := a37;
        D := 00;
        E := 06;
        H := a36[15:0][15:8];
        L := a36[15:0][7:0];
        SPH := a49[15:8];
        SPL := a49[7:0];
        FlagS := a39[7:0][7];
        FlagZ := is_zero(a39[7:0]);
        FlagA := a42[7:0][4];
        FlagP := parity(a39[7:0]);
        FlagCY := !a39[15:8][0];
        jump ((a50,a46));
      }
    }

0BE5:

    #0BE5
    #instruction: JP   18DF
    advance (10)
    jump (18DF);

0BEE:

    #0BEE
    #instruction: JP   0B0B
    advance (10)
    #0B0B
    #instruction: CALL 0ACF
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 0B;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0E;
    #return-to: 0B0E
    advance (17)
    #0ACF
    #instruction: LD   HL,2B14
    advance (10)
    #0AD2
    #instruction: LD   C,0F
    advance (7)
    #0AD4
    #instruction: JP   0A93
    advance (10)
    #0A93
    #instruction: PUSH DE
    let:8 a7 = D in
    let:8 a8 = E in
    let:8 a9 = a6[15:8] in
    let:8 a10 = a6[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := a7;
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := a8;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    let:8 a15 = D in
    let:8 a16 = E in
    let:8 a17 = M[(a15,a16)] in
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a18 = a14[15:8] in
    let:8 a19 = a14[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := 0A;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := 2B;
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:16 a29 = (-1 + (a27,a28)) in
    M[a29] := 14;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a30 = a17 in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a31 = a30 in
    let:8 a32 = a30 in
    let:17 a33 = add17((00,a31),(00,a32)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a34 = a33[15:0][15:8] in
    let:8 a35 = a33[15:0][7:0] in
    let:8 a36 = a33[15:0][15:8] in
    let:8 a37 = a33[15:0][7:0] in
    let:17 a38 = add17((a34,a35),(a36,a37)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    let:8 a41 = a38[15:0][15:8] in
    let:8 a42 = a38[15:0][7:0] in
    let:17 a43 = add17((a39,a40),(a41,a42)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a44 = a43[15:0][15:8] in
    let:8 a45 = a43[15:0][7:0] in
    let:17 a46 = add17(1E00,(a44,a45)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a47 = a46[15:0][15:8] in
    let:8 a48 = a46[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a49 = a29[15:8] in
    let:8 a50 = a29[7:0] in
    let:16 a51 = (1 + (a49,a50)) in
    let:8 a52 = M[(a49,a50)] in
    let:8 a53 = a51[15:8] in
    let:8 a54 = a51[7:0] in
    let:16 a55 = (1 + (a53,a54)) in
    let:8 a56 = M[(a53,a54)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a57 = a17 in
    unknown_output(6,a57);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a58 = a55[15:8] in
    let:8 a59 = a55[7:0] in
    let:16 a60 = (-1 + (a58,a59)) in
    M[a60] := 08;
    let:8 a61 = a60[15:8] in
    let:8 a62 = a60[7:0] in
    let:16 a63 = (-1 + (a61,a62)) in
    M[a63] := 0F;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a64 = a47 in
    let:8 a65 = a48 in
    let:8 a66 = M[(a64,a65)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a67 = a66 in
    let:8 a68 = a56 in
    let:8 a69 = a52 in
    M[(a68,a69)] := a67;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a70 = a47 in
    let:8 a71 = a48 in
    let:16 a72 = (1 + (a70,a71)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a73 = a56 in
    let:8 a74 = a52 in
    let:17 a75 = add17(0020,(a73,a74)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a76 = a63[15:8] in
    let:8 a77 = a63[7:0] in
    let:16 a78 = (1 + (a76,a77)) in
    let:8 a79 = M[(a76,a77)] in
    let:8 a80 = a78[15:8] in
    let:8 a81 = a78[7:0] in
    let:16 a82 = (1 + (a80,a81)) in
    let:8 a83 = M[(a80,a81)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a84 = a83 in
    let:16 a85 = addWithCarry(!true,a84,~00) in
    let:8 a86 = (a84 & 0F) in
    let:8 a87 = (~00 & 0F) in
    let:16 a88 = addWithCarry(!true,a86,a87) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a85[7:0])) {
      advance (10)
      A := a66;
      B := a85[7:0];
      C := a79;
      D := a72[15:8];
      E := a72[7:0];
      H := a75[15:0][15:8];
      L := a75[15:0][7:0];
      SPH := a82[15:8];
      SPL := a82[7:0];
      FlagS := a85[7:0][7];
      FlagZ := is_zero(a85[7:0]);
      FlagA := a88[7:0][4];
      FlagP := parity(a85[7:0]);
      FlagCY := a75[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a89 = a82[15:8] in
      let:8 a90 = a82[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      let:8 a92 = M[(a89,a90)] in
      let:8 a93 = a91[15:8] in
      let:8 a94 = a91[7:0] in
      let:16 a95 = (1 + (a93,a94)) in
      let:8 a96 = M[(a93,a94)] in
      advance (10)
      A := a66;
      B := a85[7:0];
      C := a79;
      D := a72[15:8];
      E := a72[7:0];
      H := a75[15:0][15:8];
      L := a75[15:0][7:0];
      SPH := a95[15:8];
      SPL := a95[7:0];
      FlagS := a85[7:0][7];
      FlagZ := is_zero(a85[7:0]);
      FlagA := a88[7:0][4];
      FlagP := parity(a85[7:0]);
      FlagCY := a75[16];
      jump ((a96,a92));
    }

0BF4:

    #0BF4
    #instruction: JP   199A
    advance (10)
    #199A
    #instruction: LD   A,(201E)
    let:8 a1 = M[201E] in
    advance (13)
    #199D
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #199E
    #instruction: JP   NZ,19AC
    if (!is_zero(a4)) {
      advance (10)
      #19AC
      #instruction: IN   01
      advance (10)
      #19AE
      #instruction: AND  76
      let:8 a6 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
      let:8 a7 = (76 & a6) in
      let:8 a8 = (76 | a6) in
      advance (7)
      #19B0
      #instruction: CP   34
      let:8 a9 = a7 in
      let:16 a10 = addWithCarry(!false,a9,~34) in
      let:8 a11 = (a9 & 0F) in
      let:8 a12 = (~34 & 0F) in
      let:16 a13 = addWithCarry(!false,a11,a12) in
      advance (7)
      #19B2
      #instruction: RET  NZ
      if (!is_zero(a10[7:0])) {
        let:8 a14 = SPH in
        let:8 a15 = SPL in
        let:16 a16 = (1 + (a14,a15)) in
        let:8 a17 = M[(a14,a15)] in
        let:8 a18 = a16[15:8] in
        let:8 a19 = a16[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        advance (11)
        A := a7;
        SPH := a20[15:8];
        SPL := a20[7:0];
        FlagS := a10[7:0][7];
        FlagZ := is_zero(a10[7:0]);
        FlagA := a13[7:0][4];
        FlagP := parity(a10[7:0]);
        FlagCY := !a10[15:8][0];
        jump ((a21,a17));
      } else {
        advance (5)
        #19B3
        #instruction: LD   HL,2E1B
        advance (10)
        #19B6
        #instruction: LD   DE,0BF7
        advance (10)
        #19B9
        #instruction: LD   C,09
        advance (7)
        #19BB
        #instruction: JP   08F3
        advance (10)
        #08F3
        #instruction: LD   A,(DE)
        advance (7)
        #08F4
        #instruction: PUSH DE
        let:8 a22 = SPH in
        let:8 a23 = SPL in
        let:16 a24 = (-1 + (a22,a23)) in
        M[a24] := 0B;
        let:8 a25 = a24[15:8] in
        let:8 a26 = a24[7:0] in
        let:16 a27 = (-1 + (a25,a26)) in
        M[a27] := F7;
        advance (11)
        #08F5
        #instruction: CALL 08FF
        let:8 a28 = a27[15:8] in
        let:8 a29 = a27[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 08;
        let:8 a31 = a30[15:8] in
        let:8 a32 = a30[7:0] in
        let:16 a33 = (-1 + (a31,a32)) in
        M[a33] := F8;
        #return-to: 08F8
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a34 = a33[15:8] in
        let:8 a35 = a33[7:0] in
        let:16 a36 = (-1 + (a34,a35)) in
        M[a36] := 2E;
        let:8 a37 = a36[15:8] in
        let:8 a38 = a36[7:0] in
        let:16 a39 = (-1 + (a37,a38)) in
        M[a39] := 1B;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a40 = add17(0013,0013) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a41 = a40[15:0][15:8] in
        let:8 a42 = a40[15:0][7:0] in
        let:8 a43 = a40[15:0][15:8] in
        let:8 a44 = a40[15:0][7:0] in
        let:17 a45 = add17((a41,a42),(a43,a44)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a46 = a45[15:0][15:8] in
        let:8 a47 = a45[15:0][7:0] in
        let:8 a48 = a45[15:0][15:8] in
        let:8 a49 = a45[15:0][7:0] in
        let:17 a50 = add17((a46,a47),(a48,a49)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a51 = a50[15:0][15:8] in
        let:8 a52 = a50[15:0][7:0] in
        let:17 a53 = add17(1E00,(a51,a52)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a54 = a53[15:0][15:8] in
        let:8 a55 = a53[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a56 = a39[15:8] in
        let:8 a57 = a39[7:0] in
        let:16 a58 = (1 + (a56,a57)) in
        let:8 a59 = M[(a56,a57)] in
        let:8 a60 = a58[15:8] in
        let:8 a61 = a58[7:0] in
        let:16 a62 = (1 + (a60,a61)) in
        let:8 a63 = M[(a60,a61)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        unknown_output(6,13);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a64 = a62[15:8] in
        let:8 a65 = a62[7:0] in
        let:16 a66 = (-1 + (a64,a65)) in
        M[a66] := 08;
        let:8 a67 = a66[15:8] in
        let:8 a68 = a66[7:0] in
        let:16 a69 = (-1 + (a67,a68)) in
        M[a69] := 09;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a70 = a54 in
        let:8 a71 = a55 in
        let:8 a72 = M[(a70,a71)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a73 = a72 in
        let:8 a74 = a63 in
        let:8 a75 = a59 in
        M[(a74,a75)] := a73;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a76 = a54 in
        let:8 a77 = a55 in
        let:16 a78 = (1 + (a76,a77)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a79 = a63 in
        let:8 a80 = a59 in
        let:17 a81 = add17(0020,(a79,a80)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a82 = a69[15:8] in
        let:8 a83 = a69[7:0] in
        let:16 a84 = (1 + (a82,a83)) in
        let:8 a85 = M[(a82,a83)] in
        let:8 a86 = a84[15:8] in
        let:8 a87 = a84[7:0] in
        let:16 a88 = (1 + (a86,a87)) in
        let:8 a89 = M[(a86,a87)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a90 = a89 in
        let:16 a91 = addWithCarry(!true,a90,~00) in
        let:8 a92 = (a90 & 0F) in
        let:8 a93 = (~00 & 0F) in
        let:16 a94 = addWithCarry(!true,a92,a93) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a91[7:0])) {
          advance (10)
          A := a72;
          B := a91[7:0];
          C := a85;
          D := a78[15:8];
          E := a78[7:0];
          H := a81[15:0][15:8];
          L := a81[15:0][7:0];
          SPH := a88[15:8];
          SPL := a88[7:0];
          FlagS := a91[7:0][7];
          FlagZ := is_zero(a91[7:0]);
          FlagA := a94[7:0][4];
          FlagP := parity(a91[7:0]);
          FlagCY := a81[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a95 = a88[15:8] in
          let:8 a96 = a88[7:0] in
          let:16 a97 = (1 + (a95,a96)) in
          let:8 a98 = M[(a95,a96)] in
          let:8 a99 = a97[15:8] in
          let:8 a100 = a97[7:0] in
          let:16 a101 = (1 + (a99,a100)) in
          let:8 a102 = M[(a99,a100)] in
          advance (10)
          A := a72;
          B := a91[7:0];
          C := a85;
          D := a78[15:8];
          E := a78[7:0];
          H := a81[15:0][15:8];
          L := a81[15:0][7:0];
          SPH := a101[15:8];
          SPL := a101[7:0];
          FlagS := a91[7:0][7];
          FlagZ := is_zero(a91[7:0]);
          FlagA := a94[7:0][4];
          FlagP := parity(a91[7:0]);
          FlagCY := a81[16];
          jump ((a102,a98));
        }
      }
    } else {
      advance (10)
      #19A1
      #instruction: IN   01
      advance (10)
      #19A3
      #instruction: AND  76
      let:8 a103 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
      let:8 a104 = (76 & a103) in
      let:8 a105 = (76 | a103) in
      advance (7)
      #19A5
      #instruction: SUB  72
      let:8 a106 = a104 in
      let:16 a107 = addWithCarry(!false,a106,~72) in
      let:8 a108 = (a106 & 0F) in
      let:8 a109 = (~72 & 0F) in
      let:16 a110 = addWithCarry(!false,a108,a109) in
      advance (7)
      #19A7
      #instruction: RET  NZ
      if (!is_zero(a107[7:0])) {
        let:8 a111 = SPH in
        let:8 a112 = SPL in
        let:16 a113 = (1 + (a111,a112)) in
        let:8 a114 = M[(a111,a112)] in
        let:8 a115 = a113[15:8] in
        let:8 a116 = a113[7:0] in
        let:16 a117 = (1 + (a115,a116)) in
        let:8 a118 = M[(a115,a116)] in
        advance (11)
        A := a107[7:0];
        SPH := a117[15:8];
        SPL := a117[7:0];
        FlagS := a107[7:0][7];
        FlagZ := is_zero(a107[7:0]);
        FlagA := a110[7:0][4];
        FlagP := parity(a107[7:0]);
        FlagCY := !a107[15:8][0];
        jump ((a118,a114));
      } else {
        advance (5)
        #19A8
        #instruction: INC  A
        let:8 a119 = a107[7:0] in
        let:16 a120 = addWithCarry(true,a119,00) in
        let:8 a121 = (a119 & 0F) in
        let:8 a122 = (00 & 0F) in
        let:16 a123 = addWithCarry(true,a121,a122) in
        advance (5)
        #19A9
        #instruction: LD   (201E),A
        let:8 a124 = a120[7:0] in
        M[201E] := a124;
        advance (13)
        #19AC
        #instruction: IN   01
        advance (10)
        #19AE
        #instruction: AND  76
        let:8 a125 = updateBit(updateBit(updateBit(updateBit(updateBit(updateBit(00,0,!is_pressed(coin entry)),1,is_pressed(player2 start)),2,is_pressed(player1 start)),4,is_pressed(player1 shoot)),5,is_pressed(player1 left)),6,is_pressed(player1 right)) in
        let:8 a126 = (76 & a125) in
        let:8 a127 = (76 | a125) in
        advance (7)
        #19B0
        #instruction: CP   34
        let:8 a128 = a126 in
        let:16 a129 = addWithCarry(!false,a128,~34) in
        let:8 a130 = (a128 & 0F) in
        let:8 a131 = (~34 & 0F) in
        let:16 a132 = addWithCarry(!false,a130,a131) in
        advance (7)
        #19B2
        #instruction: RET  NZ
        if (!is_zero(a129[7:0])) {
          let:8 a133 = SPH in
          let:8 a134 = SPL in
          let:16 a135 = (1 + (a133,a134)) in
          let:8 a136 = M[(a133,a134)] in
          let:8 a137 = a135[15:8] in
          let:8 a138 = a135[7:0] in
          let:16 a139 = (1 + (a137,a138)) in
          let:8 a140 = M[(a137,a138)] in
          advance (11)
          A := a126;
          SPH := a139[15:8];
          SPL := a139[7:0];
          FlagS := a129[7:0][7];
          FlagZ := is_zero(a129[7:0]);
          FlagA := a132[7:0][4];
          FlagP := parity(a129[7:0]);
          FlagCY := !a129[15:8][0];
          jump ((a140,a136));
        } else {
          advance (5)
          #19B3
          #instruction: LD   HL,2E1B
          advance (10)
          #19B6
          #instruction: LD   DE,0BF7
          advance (10)
          #19B9
          #instruction: LD   C,09
          advance (7)
          #19BB
          #instruction: JP   08F3
          advance (10)
          #08F3
          #instruction: LD   A,(DE)
          advance (7)
          #08F4
          #instruction: PUSH DE
          let:8 a141 = SPH in
          let:8 a142 = SPL in
          let:16 a143 = (-1 + (a141,a142)) in
          M[a143] := 0B;
          let:8 a144 = a143[15:8] in
          let:8 a145 = a143[7:0] in
          let:16 a146 = (-1 + (a144,a145)) in
          M[a146] := F7;
          advance (11)
          #08F5
          #instruction: CALL 08FF
          let:8 a147 = a146[15:8] in
          let:8 a148 = a146[7:0] in
          let:16 a149 = (-1 + (a147,a148)) in
          M[a149] := 08;
          let:8 a150 = a149[15:8] in
          let:8 a151 = a149[7:0] in
          let:16 a152 = (-1 + (a150,a151)) in
          M[a152] := F8;
          #return-to: 08F8
          advance (17)
          #08FF
          #instruction: LD   DE,1E00
          advance (10)
          #0902
          #instruction: PUSH HL
          let:8 a153 = a152[15:8] in
          let:8 a154 = a152[7:0] in
          let:16 a155 = (-1 + (a153,a154)) in
          M[a155] := 2E;
          let:8 a156 = a155[15:8] in
          let:8 a157 = a155[7:0] in
          let:16 a158 = (-1 + (a156,a157)) in
          M[a158] := 1B;
          advance (11)
          #0903
          #instruction: LD   H,00
          advance (7)
          #0905
          #instruction: LD   L,A
          advance (5)
          #0906
          #instruction: ADD  HL,HL
          let:17 a159 = add17(0013,0013) in
          advance (10)
          #0907
          #instruction: ADD  HL,HL
          let:8 a160 = a159[15:0][15:8] in
          let:8 a161 = a159[15:0][7:0] in
          let:8 a162 = a159[15:0][15:8] in
          let:8 a163 = a159[15:0][7:0] in
          let:17 a164 = add17((a160,a161),(a162,a163)) in
          advance (10)
          #0908
          #instruction: ADD  HL,HL
          let:8 a165 = a164[15:0][15:8] in
          let:8 a166 = a164[15:0][7:0] in
          let:8 a167 = a164[15:0][15:8] in
          let:8 a168 = a164[15:0][7:0] in
          let:17 a169 = add17((a165,a166),(a167,a168)) in
          advance (10)
          #0909
          #instruction: ADD  HL,DE
          let:8 a170 = a169[15:0][15:8] in
          let:8 a171 = a169[15:0][7:0] in
          let:17 a172 = add17(1E00,(a170,a171)) in
          advance (10)
          #090A
          #instruction: EX   DE,HL
          let:8 a173 = a172[15:0][15:8] in
          let:8 a174 = a172[15:0][7:0] in
          advance (4)
          #090B
          #instruction: POP  HL
          let:8 a175 = a158[15:8] in
          let:8 a176 = a158[7:0] in
          let:16 a177 = (1 + (a175,a176)) in
          let:8 a178 = M[(a175,a176)] in
          let:8 a179 = a177[15:8] in
          let:8 a180 = a177[7:0] in
          let:16 a181 = (1 + (a179,a180)) in
          let:8 a182 = M[(a179,a180)] in
          advance (10)
          #090C
          #instruction: LD   B,08
          advance (7)
          #090E
          #instruction: OUT  06
          unknown_output(6,13);
          advance (10)
          #0910
          #instruction: JP   1439
          advance (10)
          #1439
          #instruction: PUSH BC
          let:8 a183 = a181[15:8] in
          let:8 a184 = a181[7:0] in
          let:16 a185 = (-1 + (a183,a184)) in
          M[a185] := 08;
          let:8 a186 = a185[15:8] in
          let:8 a187 = a185[7:0] in
          let:16 a188 = (-1 + (a186,a187)) in
          M[a188] := 09;
          advance (11)
          #143A
          #instruction: LD   A,(DE)
          let:8 a189 = a173 in
          let:8 a190 = a174 in
          let:8 a191 = M[(a189,a190)] in
          advance (7)
          #143B
          #instruction: LD   (HL),A
          let:8 a192 = a191 in
          let:8 a193 = a182 in
          let:8 a194 = a178 in
          M[(a193,a194)] := a192;
          advance (7)
          #143C
          #instruction: INC  DE
          let:8 a195 = a173 in
          let:8 a196 = a174 in
          let:16 a197 = (1 + (a195,a196)) in
          advance (5)
          #143D
          #instruction: LD   BC,0020
          advance (10)
          #1440
          #instruction: ADD  HL,BC
          let:8 a198 = a182 in
          let:8 a199 = a178 in
          let:17 a200 = add17(0020,(a198,a199)) in
          advance (10)
          #1441
          #instruction: POP  BC
          let:8 a201 = a188[15:8] in
          let:8 a202 = a188[7:0] in
          let:16 a203 = (1 + (a201,a202)) in
          let:8 a204 = M[(a201,a202)] in
          let:8 a205 = a203[15:8] in
          let:8 a206 = a203[7:0] in
          let:16 a207 = (1 + (a205,a206)) in
          let:8 a208 = M[(a205,a206)] in
          advance (10)
          #1442
          #instruction: DEC  B
          let:8 a209 = a208 in
          let:16 a210 = addWithCarry(!true,a209,~00) in
          let:8 a211 = (a209 & 0F) in
          let:8 a212 = (~00 & 0F) in
          let:16 a213 = addWithCarry(!true,a211,a212) in
          advance (5)
          #1443
          #instruction: JP   NZ,1439
          if (!is_zero(a210[7:0])) {
            advance (10)
            A := a191;
            B := a210[7:0];
            C := a204;
            D := a197[15:8];
            E := a197[7:0];
            H := a200[15:0][15:8];
            L := a200[15:0][7:0];
            SPH := a207[15:8];
            SPL := a207[7:0];
            FlagS := a210[7:0][7];
            FlagZ := is_zero(a210[7:0]);
            FlagA := a213[7:0][4];
            FlagP := parity(a210[7:0]);
            FlagCY := a200[16];
            jump (1439);
          } else {
            advance (10)
            #1446
            #instruction: RET
            let:8 a214 = a207[15:8] in
            let:8 a215 = a207[7:0] in
            let:16 a216 = (1 + (a214,a215)) in
            let:8 a217 = M[(a214,a215)] in
            let:8 a218 = a216[15:8] in
            let:8 a219 = a216[7:0] in
            let:16 a220 = (1 + (a218,a219)) in
            let:8 a221 = M[(a218,a219)] in
            advance (10)
            A := a191;
            B := a210[7:0];
            C := a204;
            D := a197[15:8];
            E := a197[7:0];
            H := a200[15:0][15:8];
            L := a200[15:0][7:0];
            SPH := a220[15:8];
            SPL := a220[7:0];
            FlagS := a210[7:0][7];
            FlagZ := is_zero(a210[7:0]);
            FlagA := a213[7:0][4];
            FlagP := parity(a210[7:0]);
            FlagCY := a200[16];
            jump ((a221,a217));
          }
        }
      }
    }

1404:

    #1404
    #instruction: NOP
    advance (4)
    #1405
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1406
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1407
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #1408
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #140A
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #140C
    #instruction: OR   (HL)
    let:8 a24 = H in
    let:8 a25 = L in
    let:8 a26 = M[(a24,a25)] in
    let:8 a27 = a23 in
    let:8 a28 = (a26 | a27) in
    advance (7)
    #140D
    #instruction: LD   (HL),A
    let:8 a29 = a28 in
    let:8 a30 = H in
    let:8 a31 = L in
    M[(a30,a31)] := a29;
    advance (7)
    #140E
    #instruction: INC  HL
    let:8 a32 = H in
    let:8 a33 = L in
    let:16 a34 = (1 + (a32,a33)) in
    advance (5)
    #140F
    #instruction: INC  DE
    let:8 a35 = D in
    let:8 a36 = E in
    let:16 a37 = (1 + (a35,a36)) in
    advance (5)
    #1410
    #instruction: XOR  A
    let:8 a38 = a28 in
    let:8 a39 = a28 in
    let:8 a40 = (a38 ^ a39) in
    advance (4)
    #1411
    #instruction: OUT  04
    let:8 a41 = a40 in
    advance (10)
    #1413
    #instruction: IN   03
    let:8 a42 = (Shifter_OFF & 07) in
    let:8 a43 = (~Shifter_OFF & 07) in
    let:8 a44 = ((a41 << a42) | ((a20 >> a43) >> 01)) in
    advance (10)
    #1415
    #instruction: OR   (HL)
    let:8 a45 = a34[15:8] in
    let:8 a46 = a34[7:0] in
    let:8 a47 = M[(a45,a46)] in
    let:8 a48 = a44 in
    let:8 a49 = (a47 | a48) in
    advance (7)
    #1416
    #instruction: LD   (HL),A
    let:8 a50 = a49 in
    let:8 a51 = a34[15:8] in
    let:8 a52 = a34[7:0] in
    M[(a51,a52)] := a50;
    advance (7)
    #1417
    #instruction: POP  HL
    let:8 a53 = a16[15:8] in
    let:8 a54 = a16[7:0] in
    let:16 a55 = (1 + (a53,a54)) in
    let:8 a56 = M[(a53,a54)] in
    let:8 a57 = a55[15:8] in
    let:8 a58 = a55[7:0] in
    let:16 a59 = (1 + (a57,a58)) in
    let:8 a60 = M[(a57,a58)] in
    advance (10)
    #1418
    #instruction: LD   BC,0020
    advance (10)
    #141B
    #instruction: ADD  HL,BC
    let:8 a61 = a60 in
    let:8 a62 = a56 in
    let:17 a63 = add17(0020,(a61,a62)) in
    advance (10)
    #141C
    #instruction: POP  BC
    let:8 a64 = a59[15:8] in
    let:8 a65 = a59[7:0] in
    let:16 a66 = (1 + (a64,a65)) in
    let:8 a67 = M[(a64,a65)] in
    let:8 a68 = a66[15:8] in
    let:8 a69 = a66[7:0] in
    let:16 a70 = (1 + (a68,a69)) in
    let:8 a71 = M[(a68,a69)] in
    advance (10)
    #141D
    #instruction: DEC  B
    let:8 a72 = a71 in
    let:16 a73 = addWithCarry(!true,a72,~00) in
    let:8 a74 = (a72 & 0F) in
    let:8 a75 = (~00 & 0F) in
    let:16 a76 = addWithCarry(!true,a74,a75) in
    advance (5)
    #141E
    #instruction: JP   NZ,1405
    if (!is_zero(a73[7:0])) {
      advance (10)
      A := a49;
      B := a73[7:0];
      C := a67;
      D := a37[15:8];
      E := a37[7:0];
      H := a63[15:0][15:8];
      L := a63[15:0][7:0];
      SPH := a70[15:8];
      SPL := a70[7:0];
      FlagS := a73[7:0][7];
      FlagZ := is_zero(a73[7:0]);
      FlagA := a76[7:0][4];
      FlagP := parity(a73[7:0]);
      FlagCY := a63[16];
      Shifter_HI := a41;
      Shifter_LO := a20;
      jump (1405);
    } else {
      advance (10)
      #1421
      #instruction: RET
      let:8 a77 = a70[15:8] in
      let:8 a78 = a70[7:0] in
      let:16 a79 = (1 + (a77,a78)) in
      let:8 a80 = M[(a77,a78)] in
      let:8 a81 = a79[15:8] in
      let:8 a82 = a79[7:0] in
      let:16 a83 = (1 + (a81,a82)) in
      let:8 a84 = M[(a81,a82)] in
      advance (10)
      A := a49;
      B := a73[7:0];
      C := a67;
      D := a37[15:8];
      E := a37[7:0];
      H := a63[15:0][15:8];
      L := a63[15:0][7:0];
      SPH := a83[15:8];
      SPL := a83[7:0];
      FlagS := a73[7:0][7];
      FlagZ := is_zero(a73[7:0]);
      FlagA := a76[7:0][4];
      FlagP := parity(a73[7:0]);
      FlagCY := a63[16];
      Shifter_HI := a41;
      Shifter_LO := a20;
      jump ((a84,a80));
    }

1427:

    #1427
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1428
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1429
    #instruction: XOR  A
    let:8 a17 = A in
    let:8 a18 = A in
    let:8 a19 = (a17 ^ a18) in
    advance (4)
    #142A
    #instruction: LD   (HL),A
    let:8 a20 = a19 in
    let:8 a21 = H in
    let:8 a22 = L in
    M[(a21,a22)] := a20;
    advance (7)
    #142B
    #instruction: INC  HL
    let:8 a23 = H in
    let:8 a24 = L in
    let:16 a25 = (1 + (a23,a24)) in
    advance (5)
    #142C
    #instruction: LD   (HL),A
    let:8 a26 = a19 in
    let:8 a27 = a25[15:8] in
    let:8 a28 = a25[7:0] in
    M[(a27,a28)] := a26;
    advance (7)
    #142D
    #instruction: INC  HL
    let:8 a29 = a25[15:8] in
    let:8 a30 = a25[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    advance (5)
    #142E
    #instruction: POP  HL
    let:8 a32 = a16[15:8] in
    let:8 a33 = a16[7:0] in
    let:16 a34 = (1 + (a32,a33)) in
    let:8 a35 = M[(a32,a33)] in
    let:8 a36 = a34[15:8] in
    let:8 a37 = a34[7:0] in
    let:16 a38 = (1 + (a36,a37)) in
    let:8 a39 = M[(a36,a37)] in
    advance (10)
    #142F
    #instruction: LD   BC,0020
    advance (10)
    #1432
    #instruction: ADD  HL,BC
    let:8 a40 = a39 in
    let:8 a41 = a35 in
    let:17 a42 = add17(0020,(a40,a41)) in
    advance (10)
    #1433
    #instruction: POP  BC
    let:8 a43 = a38[15:8] in
    let:8 a44 = a38[7:0] in
    let:16 a45 = (1 + (a43,a44)) in
    let:8 a46 = M[(a43,a44)] in
    let:8 a47 = a45[15:8] in
    let:8 a48 = a45[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    advance (10)
    #1434
    #instruction: DEC  B
    let:8 a51 = a50 in
    let:16 a52 = addWithCarry(!true,a51,~00) in
    let:8 a53 = (a51 & 0F) in
    let:8 a54 = (~00 & 0F) in
    let:16 a55 = addWithCarry(!true,a53,a54) in
    advance (5)
    #1435
    #instruction: JP   NZ,1427
    if (!is_zero(a52[7:0])) {
      advance (10)
      A := a19;
      B := a52[7:0];
      C := a46;
      H := a42[15:0][15:8];
      L := a42[15:0][7:0];
      SPH := a49[15:8];
      SPL := a49[7:0];
      FlagS := a52[7:0][7];
      FlagZ := is_zero(a52[7:0]);
      FlagA := a55[7:0][4];
      FlagP := parity(a52[7:0]);
      FlagCY := a42[16];
      jump (1427);
    } else {
      advance (10)
      #1438
      #instruction: RET
      let:8 a56 = a49[15:8] in
      let:8 a57 = a49[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      let:8 a60 = a58[15:8] in
      let:8 a61 = a58[7:0] in
      let:16 a62 = (1 + (a60,a61)) in
      let:8 a63 = M[(a60,a61)] in
      advance (10)
      A := a19;
      B := a52[7:0];
      C := a46;
      H := a42[15:0][15:8];
      L := a42[15:0][7:0];
      SPH := a62[15:8];
      SPL := a62[7:0];
      FlagS := a52[7:0][7];
      FlagZ := is_zero(a52[7:0]);
      FlagA := a55[7:0][4];
      FlagP := parity(a52[7:0]);
      FlagCY := a42[16];
      jump ((a63,a59));
    }

1455:

    #1455
    #instruction: PUSH BC
    let:8 a1 = B in
    let:8 a2 = C in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #1456
    #instruction: PUSH HL
    let:8 a9 = H in
    let:8 a10 = L in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #1457
    #instruction: LD   A,(DE)
    let:8 a17 = D in
    let:8 a18 = E in
    let:8 a19 = M[(a17,a18)] in
    advance (7)
    #1458
    #instruction: OUT  04
    let:8 a20 = a19 in
    advance (10)
    #145A
    #instruction: IN   03
    let:8 a21 = (Shifter_OFF & 07) in
    let:8 a22 = (~Shifter_OFF & 07) in
    let:8 a23 = ((a20 << a21) | ((Shifter_HI >> a22) >> 01)) in
    advance (10)
    #145C
    #instruction: CPL
    let:8 a24 = a23 in
    advance (4)
    #145D
    #instruction: AND  (HL)
    let:8 a25 = H in
    let:8 a26 = L in
    let:8 a27 = M[(a25,a26)] in
    let:8 a28 = ~a24 in
    let:8 a29 = (a27 & a28) in
    let:8 a30 = (a27 | a28) in
    advance (7)
    #145E
    #instruction: LD   (HL),A
    let:8 a31 = a29 in
    let:8 a32 = H in
    let:8 a33 = L in
    M[(a32,a33)] := a31;
    advance (7)
    #145F
    #instruction: INC  HL
    let:8 a34 = H in
    let:8 a35 = L in
    let:16 a36 = (1 + (a34,a35)) in
    advance (5)
    #1460
    #instruction: INC  DE
    let:8 a37 = D in
    let:8 a38 = E in
    let:16 a39 = (1 + (a37,a38)) in
    advance (5)
    #1461
    #instruction: XOR  A
    let:8 a40 = a29 in
    let:8 a41 = a29 in
    let:8 a42 = (a40 ^ a41) in
    advance (4)
    #1462
    #instruction: OUT  04
    let:8 a43 = a42 in
    advance (10)
    #1464
    #instruction: IN   03
    let:8 a44 = (Shifter_OFF & 07) in
    let:8 a45 = (~Shifter_OFF & 07) in
    let:8 a46 = ((a43 << a44) | ((a20 >> a45) >> 01)) in
    advance (10)
    #1466
    #instruction: CPL
    let:8 a47 = a46 in
    advance (4)
    #1467
    #instruction: AND  (HL)
    let:8 a48 = a36[15:8] in
    let:8 a49 = a36[7:0] in
    let:8 a50 = M[(a48,a49)] in
    let:8 a51 = ~a47 in
    let:8 a52 = (a50 & a51) in
    let:8 a53 = (a50 | a51) in
    advance (7)
    #1468
    #instruction: LD   (HL),A
    let:8 a54 = a52 in
    let:8 a55 = a36[15:8] in
    let:8 a56 = a36[7:0] in
    M[(a55,a56)] := a54;
    advance (7)
    #1469
    #instruction: POP  HL
    let:8 a57 = a16[15:8] in
    let:8 a58 = a16[7:0] in
    let:16 a59 = (1 + (a57,a58)) in
    let:8 a60 = M[(a57,a58)] in
    let:8 a61 = a59[15:8] in
    let:8 a62 = a59[7:0] in
    let:16 a63 = (1 + (a61,a62)) in
    let:8 a64 = M[(a61,a62)] in
    advance (10)
    #146A
    #instruction: LD   BC,0020
    advance (10)
    #146D
    #instruction: ADD  HL,BC
    let:8 a65 = a64 in
    let:8 a66 = a60 in
    let:17 a67 = add17(0020,(a65,a66)) in
    advance (10)
    #146E
    #instruction: POP  BC
    let:8 a68 = a63[15:8] in
    let:8 a69 = a63[7:0] in
    let:16 a70 = (1 + (a68,a69)) in
    let:8 a71 = M[(a68,a69)] in
    let:8 a72 = a70[15:8] in
    let:8 a73 = a70[7:0] in
    let:16 a74 = (1 + (a72,a73)) in
    let:8 a75 = M[(a72,a73)] in
    advance (10)
    #146F
    #instruction: DEC  B
    let:8 a76 = a75 in
    let:16 a77 = addWithCarry(!true,a76,~00) in
    let:8 a78 = (a76 & 0F) in
    let:8 a79 = (~00 & 0F) in
    let:16 a80 = addWithCarry(!true,a78,a79) in
    advance (5)
    #1470
    #instruction: JP   NZ,1455
    if (!is_zero(a77[7:0])) {
      advance (10)
      A := a52;
      B := a77[7:0];
      C := a71;
      D := a39[15:8];
      E := a39[7:0];
      H := a67[15:0][15:8];
      L := a67[15:0][7:0];
      SPH := a74[15:8];
      SPL := a74[7:0];
      FlagS := a77[7:0][7];
      FlagZ := is_zero(a77[7:0]);
      FlagA := a80[7:0][4];
      FlagP := parity(a77[7:0]);
      FlagCY := a67[16];
      Shifter_HI := a43;
      Shifter_LO := a20;
      jump (1455);
    } else {
      advance (10)
      #1473
      #instruction: RET
      let:8 a81 = a74[15:8] in
      let:8 a82 = a74[7:0] in
      let:16 a83 = (1 + (a81,a82)) in
      let:8 a84 = M[(a81,a82)] in
      let:8 a85 = a83[15:8] in
      let:8 a86 = a83[7:0] in
      let:16 a87 = (1 + (a85,a86)) in
      let:8 a88 = M[(a85,a86)] in
      advance (10)
      A := a52;
      B := a77[7:0];
      C := a71;
      D := a39[15:8];
      E := a39[7:0];
      H := a67[15:0][15:8];
      L := a67[15:0][7:0];
      SPH := a87[15:8];
      SPL := a87[7:0];
      FlagS := a77[7:0][7];
      FlagZ := is_zero(a77[7:0]);
      FlagA := a80[7:0][4];
      FlagP := parity(a77[7:0]);
      FlagCY := a67[16];
      Shifter_HI := a43;
      Shifter_LO := a20;
      jump ((a88,a84));
    }

1494:

    #1494
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #1495
    #instruction: LD   (2061),A
    let:8 a4 = a3 in
    M[2061] := a4;
    advance (13)
    #1498
    #instruction: PUSH BC
    let:8 a5 = B in
    let:8 a6 = C in
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := a5;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a6;
    advance (11)
    #1499
    #instruction: PUSH HL
    let:8 a13 = H in
    let:8 a14 = L in
    let:8 a15 = a12[15:8] in
    let:8 a16 = a12[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := a13;
    let:8 a18 = a17[15:8] in
    let:8 a19 = a17[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a14;
    advance (11)
    #149A
    #instruction: LD   A,(DE)
    let:8 a21 = D in
    let:8 a22 = E in
    let:8 a23 = M[(a21,a22)] in
    advance (7)
    #149B
    #instruction: OUT  04
    let:8 a24 = a23 in
    advance (10)
    #149D
    #instruction: IN   03
    let:8 a25 = (Shifter_OFF & 07) in
    let:8 a26 = (~Shifter_OFF & 07) in
    let:8 a27 = ((a24 << a25) | ((Shifter_HI >> a26) >> 01)) in
    advance (10)
    #149F
    #instruction: PUSH PSW
    let:8 a28 = a27 in
    let:8 a29 = a20[15:8] in
    let:8 a30 = a20[7:0] in
    let:16 a31 = (-1 + (a29,a30)) in
    M[a31] := a28;
    let:8 a32 = a31[15:8] in
    let:8 a33 = a31[7:0] in
    let:16 a34 = (-1 + (a32,a33)) in
    M[a34] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a3[7]),6,is_zero(a3)),4,false),2,parity(a3)),0,false);
    advance (11)
    #14A0
    #instruction: AND  (HL)
    let:8 a35 = H in
    let:8 a36 = L in
    let:8 a37 = M[(a35,a36)] in
    let:8 a38 = a27 in
    let:8 a39 = (a37 & a38) in
    let:8 a40 = (a37 | a38) in
    advance (7)
    #14A1
    #instruction: JP   Z,14A9
    if (is_zero(a39)) {
      advance (10)
      #14A9
      #instruction: POP  PSW
      let:8 a41 = a34[15:8] in
      let:8 a42 = a34[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      #14AA
      #instruction: OR   (HL)
      let:8 a49 = H in
      let:8 a50 = L in
      let:8 a51 = M[(a49,a50)] in
      let:8 a52 = a48 in
      let:8 a53 = (a51 | a52) in
      advance (7)
      #14AB
      #instruction: LD   (HL),A
      let:8 a54 = a53 in
      let:8 a55 = H in
      let:8 a56 = L in
      M[(a55,a56)] := a54;
      advance (7)
      #14AC
      #instruction: INC  HL
      let:8 a57 = H in
      let:8 a58 = L in
      let:16 a59 = (1 + (a57,a58)) in
      advance (5)
      #14AD
      #instruction: INC  DE
      let:8 a60 = D in
      let:8 a61 = E in
      let:16 a62 = (1 + (a60,a61)) in
      advance (5)
      #14AE
      #instruction: XOR  A
      let:8 a63 = a53 in
      let:8 a64 = a53 in
      let:8 a65 = (a63 ^ a64) in
      advance (4)
      #14AF
      #instruction: OUT  04
      let:8 a66 = a65 in
      advance (10)
      #14B1
      #instruction: IN   03
      let:8 a67 = (Shifter_OFF & 07) in
      let:8 a68 = (~Shifter_OFF & 07) in
      let:8 a69 = ((a66 << a67) | ((a24 >> a68) >> 01)) in
      advance (10)
      #14B3
      #instruction: PUSH PSW
      let:8 a70 = a69 in
      let:8 a71 = a47[15:8] in
      let:8 a72 = a47[7:0] in
      let:16 a73 = (-1 + (a71,a72)) in
      M[a73] := a70;
      let:8 a74 = a73[15:8] in
      let:8 a75 = a73[7:0] in
      let:16 a76 = (-1 + (a74,a75)) in
      M[a76] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a65[7]),6,is_zero(a65)),4,false),2,parity(a65)),0,false);
      advance (11)
      #14B4
      #instruction: AND  (HL)
      let:8 a77 = a59[15:8] in
      let:8 a78 = a59[7:0] in
      let:8 a79 = M[(a77,a78)] in
      let:8 a80 = a69 in
      let:8 a81 = (a79 & a80) in
      let:8 a82 = (a79 | a80) in
      advance (7)
      #14B5
      #instruction: JP   Z,14BD
      if (is_zero(a81)) {
        advance (10)
        #14BD
        #instruction: POP  PSW
        let:8 a83 = a76[15:8] in
        let:8 a84 = a76[7:0] in
        let:16 a85 = (1 + (a83,a84)) in
        let:8 a86 = M[(a83,a84)] in
        let:8 a87 = a85[15:8] in
        let:8 a88 = a85[7:0] in
        let:16 a89 = (1 + (a87,a88)) in
        let:8 a90 = M[(a87,a88)] in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a91 = a59[15:8] in
        let:8 a92 = a59[7:0] in
        let:8 a93 = M[(a91,a92)] in
        let:8 a94 = a90 in
        let:8 a95 = (a93 | a94) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        let:8 a96 = a95 in
        let:8 a97 = a59[15:8] in
        let:8 a98 = a59[7:0] in
        M[(a97,a98)] := a96;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:8 a99 = a89[15:8] in
        let:8 a100 = a89[7:0] in
        let:16 a101 = (1 + (a99,a100)) in
        let:8 a102 = M[(a99,a100)] in
        let:8 a103 = a101[15:8] in
        let:8 a104 = a101[7:0] in
        let:16 a105 = (1 + (a103,a104)) in
        let:8 a106 = M[(a103,a104)] in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:8 a107 = a106 in
        let:8 a108 = a102 in
        let:17 a109 = add17(0020,(a107,a108)) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:8 a110 = a105[15:8] in
        let:8 a111 = a105[7:0] in
        let:16 a112 = (1 + (a110,a111)) in
        let:8 a113 = M[(a110,a111)] in
        let:8 a114 = a112[15:8] in
        let:8 a115 = a112[7:0] in
        let:16 a116 = (1 + (a114,a115)) in
        let:8 a117 = M[(a114,a115)] in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:8 a118 = a117 in
        let:16 a119 = addWithCarry(!true,a118,~00) in
        let:8 a120 = (a118 & 0F) in
        let:8 a121 = (~00 & 0F) in
        let:16 a122 = addWithCarry(!true,a120,a121) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a119[7:0])) {
          advance (10)
          A := a95;
          B := a119[7:0];
          C := a113;
          D := a62[15:8];
          E := a62[7:0];
          H := a109[15:0][15:8];
          L := a109[15:0][7:0];
          SPH := a116[15:8];
          SPL := a116[7:0];
          FlagS := a119[7:0][7];
          FlagZ := is_zero(a119[7:0]);
          FlagA := a122[7:0][4];
          FlagP := parity(a119[7:0]);
          FlagCY := a109[16];
          Shifter_HI := a66;
          Shifter_LO := a24;
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:8 a123 = a116[15:8] in
          let:8 a124 = a116[7:0] in
          let:16 a125 = (1 + (a123,a124)) in
          let:8 a126 = M[(a123,a124)] in
          let:8 a127 = a125[15:8] in
          let:8 a128 = a125[7:0] in
          let:16 a129 = (1 + (a127,a128)) in
          let:8 a130 = M[(a127,a128)] in
          advance (10)
          A := a95;
          B := a119[7:0];
          C := a113;
          D := a62[15:8];
          E := a62[7:0];
          H := a109[15:0][15:8];
          L := a109[15:0][7:0];
          SPH := a129[15:8];
          SPL := a129[7:0];
          FlagS := a119[7:0][7];
          FlagZ := is_zero(a119[7:0]);
          FlagA := a122[7:0][4];
          FlagP := parity(a119[7:0]);
          FlagCY := a109[16];
          Shifter_HI := a66;
          Shifter_LO := a24;
          jump ((a130,a126));
        }
      } else {
        advance (10)
        #14B8
        #instruction: LD   A,01
        advance (7)
        #14BA
        #instruction: LD   (2061),A
        M[2061] := 01;
        advance (13)
        #14BD
        #instruction: POP  PSW
        let:8 a131 = a76[15:8] in
        let:8 a132 = a76[7:0] in
        let:16 a133 = (1 + (a131,a132)) in
        let:8 a134 = M[(a131,a132)] in
        let:8 a135 = a133[15:8] in
        let:8 a136 = a133[7:0] in
        let:16 a137 = (1 + (a135,a136)) in
        let:8 a138 = M[(a135,a136)] in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a139 = a59[15:8] in
        let:8 a140 = a59[7:0] in
        let:8 a141 = M[(a139,a140)] in
        let:8 a142 = a138 in
        let:8 a143 = (a141 | a142) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        let:8 a144 = a143 in
        let:8 a145 = a59[15:8] in
        let:8 a146 = a59[7:0] in
        M[(a145,a146)] := a144;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:8 a147 = a137[15:8] in
        let:8 a148 = a137[7:0] in
        let:16 a149 = (1 + (a147,a148)) in
        let:8 a150 = M[(a147,a148)] in
        let:8 a151 = a149[15:8] in
        let:8 a152 = a149[7:0] in
        let:16 a153 = (1 + (a151,a152)) in
        let:8 a154 = M[(a151,a152)] in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:8 a155 = a154 in
        let:8 a156 = a150 in
        let:17 a157 = add17(0020,(a155,a156)) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:8 a158 = a153[15:8] in
        let:8 a159 = a153[7:0] in
        let:16 a160 = (1 + (a158,a159)) in
        let:8 a161 = M[(a158,a159)] in
        let:8 a162 = a160[15:8] in
        let:8 a163 = a160[7:0] in
        let:16 a164 = (1 + (a162,a163)) in
        let:8 a165 = M[(a162,a163)] in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:8 a166 = a165 in
        let:16 a167 = addWithCarry(!true,a166,~00) in
        let:8 a168 = (a166 & 0F) in
        let:8 a169 = (~00 & 0F) in
        let:16 a170 = addWithCarry(!true,a168,a169) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a167[7:0])) {
          advance (10)
          A := a143;
          B := a167[7:0];
          C := a161;
          D := a62[15:8];
          E := a62[7:0];
          H := a157[15:0][15:8];
          L := a157[15:0][7:0];
          SPH := a164[15:8];
          SPL := a164[7:0];
          FlagS := a167[7:0][7];
          FlagZ := is_zero(a167[7:0]);
          FlagA := a170[7:0][4];
          FlagP := parity(a167[7:0]);
          FlagCY := a157[16];
          Shifter_HI := a66;
          Shifter_LO := a24;
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:8 a171 = a164[15:8] in
          let:8 a172 = a164[7:0] in
          let:16 a173 = (1 + (a171,a172)) in
          let:8 a174 = M[(a171,a172)] in
          let:8 a175 = a173[15:8] in
          let:8 a176 = a173[7:0] in
          let:16 a177 = (1 + (a175,a176)) in
          let:8 a178 = M[(a175,a176)] in
          advance (10)
          A := a143;
          B := a167[7:0];
          C := a161;
          D := a62[15:8];
          E := a62[7:0];
          H := a157[15:0][15:8];
          L := a157[15:0][7:0];
          SPH := a177[15:8];
          SPL := a177[7:0];
          FlagS := a167[7:0][7];
          FlagZ := is_zero(a167[7:0]);
          FlagA := a170[7:0][4];
          FlagP := parity(a167[7:0]);
          FlagCY := a157[16];
          Shifter_HI := a66;
          Shifter_LO := a24;
          jump ((a178,a174));
        }
      }
    } else {
      advance (10)
      #14A4
      #instruction: LD   A,01
      advance (7)
      #14A6
      #instruction: LD   (2061),A
      M[2061] := 01;
      advance (13)
      #14A9
      #instruction: POP  PSW
      let:8 a179 = a34[15:8] in
      let:8 a180 = a34[7:0] in
      let:16 a181 = (1 + (a179,a180)) in
      let:8 a182 = M[(a179,a180)] in
      let:8 a183 = a181[15:8] in
      let:8 a184 = a181[7:0] in
      let:16 a185 = (1 + (a183,a184)) in
      let:8 a186 = M[(a183,a184)] in
      advance (10)
      #14AA
      #instruction: OR   (HL)
      let:8 a187 = H in
      let:8 a188 = L in
      let:8 a189 = M[(a187,a188)] in
      let:8 a190 = a186 in
      let:8 a191 = (a189 | a190) in
      advance (7)
      #14AB
      #instruction: LD   (HL),A
      let:8 a192 = a191 in
      let:8 a193 = H in
      let:8 a194 = L in
      M[(a193,a194)] := a192;
      advance (7)
      #14AC
      #instruction: INC  HL
      let:8 a195 = H in
      let:8 a196 = L in
      let:16 a197 = (1 + (a195,a196)) in
      advance (5)
      #14AD
      #instruction: INC  DE
      let:8 a198 = D in
      let:8 a199 = E in
      let:16 a200 = (1 + (a198,a199)) in
      advance (5)
      #14AE
      #instruction: XOR  A
      let:8 a201 = a191 in
      let:8 a202 = a191 in
      let:8 a203 = (a201 ^ a202) in
      advance (4)
      #14AF
      #instruction: OUT  04
      let:8 a204 = a203 in
      advance (10)
      #14B1
      #instruction: IN   03
      let:8 a205 = (Shifter_OFF & 07) in
      let:8 a206 = (~Shifter_OFF & 07) in
      let:8 a207 = ((a204 << a205) | ((a24 >> a206) >> 01)) in
      advance (10)
      #14B3
      #instruction: PUSH PSW
      let:8 a208 = a207 in
      let:8 a209 = a185[15:8] in
      let:8 a210 = a185[7:0] in
      let:16 a211 = (-1 + (a209,a210)) in
      M[a211] := a208;
      let:8 a212 = a211[15:8] in
      let:8 a213 = a211[7:0] in
      let:16 a214 = (-1 + (a212,a213)) in
      M[a214] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a203[7]),6,is_zero(a203)),4,false),2,parity(a203)),0,false);
      advance (11)
      #14B4
      #instruction: AND  (HL)
      let:8 a215 = a197[15:8] in
      let:8 a216 = a197[7:0] in
      let:8 a217 = M[(a215,a216)] in
      let:8 a218 = a207 in
      let:8 a219 = (a217 & a218) in
      let:8 a220 = (a217 | a218) in
      advance (7)
      #14B5
      #instruction: JP   Z,14BD
      if (is_zero(a219)) {
        advance (10)
        #14BD
        #instruction: POP  PSW
        let:8 a221 = a214[15:8] in
        let:8 a222 = a214[7:0] in
        let:16 a223 = (1 + (a221,a222)) in
        let:8 a224 = M[(a221,a222)] in
        let:8 a225 = a223[15:8] in
        let:8 a226 = a223[7:0] in
        let:16 a227 = (1 + (a225,a226)) in
        let:8 a228 = M[(a225,a226)] in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a229 = a197[15:8] in
        let:8 a230 = a197[7:0] in
        let:8 a231 = M[(a229,a230)] in
        let:8 a232 = a228 in
        let:8 a233 = (a231 | a232) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        let:8 a234 = a233 in
        let:8 a235 = a197[15:8] in
        let:8 a236 = a197[7:0] in
        M[(a235,a236)] := a234;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:8 a237 = a227[15:8] in
        let:8 a238 = a227[7:0] in
        let:16 a239 = (1 + (a237,a238)) in
        let:8 a240 = M[(a237,a238)] in
        let:8 a241 = a239[15:8] in
        let:8 a242 = a239[7:0] in
        let:16 a243 = (1 + (a241,a242)) in
        let:8 a244 = M[(a241,a242)] in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:8 a245 = a244 in
        let:8 a246 = a240 in
        let:17 a247 = add17(0020,(a245,a246)) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:8 a248 = a243[15:8] in
        let:8 a249 = a243[7:0] in
        let:16 a250 = (1 + (a248,a249)) in
        let:8 a251 = M[(a248,a249)] in
        let:8 a252 = a250[15:8] in
        let:8 a253 = a250[7:0] in
        let:16 a254 = (1 + (a252,a253)) in
        let:8 a255 = M[(a252,a253)] in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:8 a256 = a255 in
        let:16 a257 = addWithCarry(!true,a256,~00) in
        let:8 a258 = (a256 & 0F) in
        let:8 a259 = (~00 & 0F) in
        let:16 a260 = addWithCarry(!true,a258,a259) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a257[7:0])) {
          advance (10)
          A := a233;
          B := a257[7:0];
          C := a251;
          D := a200[15:8];
          E := a200[7:0];
          H := a247[15:0][15:8];
          L := a247[15:0][7:0];
          SPH := a254[15:8];
          SPL := a254[7:0];
          FlagS := a257[7:0][7];
          FlagZ := is_zero(a257[7:0]);
          FlagA := a260[7:0][4];
          FlagP := parity(a257[7:0]);
          FlagCY := a247[16];
          Shifter_HI := a204;
          Shifter_LO := a24;
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:8 a261 = a254[15:8] in
          let:8 a262 = a254[7:0] in
          let:16 a263 = (1 + (a261,a262)) in
          let:8 a264 = M[(a261,a262)] in
          let:8 a265 = a263[15:8] in
          let:8 a266 = a263[7:0] in
          let:16 a267 = (1 + (a265,a266)) in
          let:8 a268 = M[(a265,a266)] in
          advance (10)
          A := a233;
          B := a257[7:0];
          C := a251;
          D := a200[15:8];
          E := a200[7:0];
          H := a247[15:0][15:8];
          L := a247[15:0][7:0];
          SPH := a267[15:8];
          SPL := a267[7:0];
          FlagS := a257[7:0][7];
          FlagZ := is_zero(a257[7:0]);
          FlagA := a260[7:0][4];
          FlagP := parity(a257[7:0]);
          FlagCY := a247[16];
          Shifter_HI := a204;
          Shifter_LO := a24;
          jump ((a268,a264));
        }
      } else {
        advance (10)
        #14B8
        #instruction: LD   A,01
        advance (7)
        #14BA
        #instruction: LD   (2061),A
        M[2061] := 01;
        advance (13)
        #14BD
        #instruction: POP  PSW
        let:8 a269 = a214[15:8] in
        let:8 a270 = a214[7:0] in
        let:16 a271 = (1 + (a269,a270)) in
        let:8 a272 = M[(a269,a270)] in
        let:8 a273 = a271[15:8] in
        let:8 a274 = a271[7:0] in
        let:16 a275 = (1 + (a273,a274)) in
        let:8 a276 = M[(a273,a274)] in
        advance (10)
        #14BE
        #instruction: OR   (HL)
        let:8 a277 = a197[15:8] in
        let:8 a278 = a197[7:0] in
        let:8 a279 = M[(a277,a278)] in
        let:8 a280 = a276 in
        let:8 a281 = (a279 | a280) in
        advance (7)
        #14BF
        #instruction: LD   (HL),A
        let:8 a282 = a281 in
        let:8 a283 = a197[15:8] in
        let:8 a284 = a197[7:0] in
        M[(a283,a284)] := a282;
        advance (7)
        #14C0
        #instruction: POP  HL
        let:8 a285 = a275[15:8] in
        let:8 a286 = a275[7:0] in
        let:16 a287 = (1 + (a285,a286)) in
        let:8 a288 = M[(a285,a286)] in
        let:8 a289 = a287[15:8] in
        let:8 a290 = a287[7:0] in
        let:16 a291 = (1 + (a289,a290)) in
        let:8 a292 = M[(a289,a290)] in
        advance (10)
        #14C1
        #instruction: LD   BC,0020
        advance (10)
        #14C4
        #instruction: ADD  HL,BC
        let:8 a293 = a292 in
        let:8 a294 = a288 in
        let:17 a295 = add17(0020,(a293,a294)) in
        advance (10)
        #14C5
        #instruction: POP  BC
        let:8 a296 = a291[15:8] in
        let:8 a297 = a291[7:0] in
        let:16 a298 = (1 + (a296,a297)) in
        let:8 a299 = M[(a296,a297)] in
        let:8 a300 = a298[15:8] in
        let:8 a301 = a298[7:0] in
        let:16 a302 = (1 + (a300,a301)) in
        let:8 a303 = M[(a300,a301)] in
        advance (10)
        #14C6
        #instruction: DEC  B
        let:8 a304 = a303 in
        let:16 a305 = addWithCarry(!true,a304,~00) in
        let:8 a306 = (a304 & 0F) in
        let:8 a307 = (~00 & 0F) in
        let:16 a308 = addWithCarry(!true,a306,a307) in
        advance (5)
        #14C7
        #instruction: JP   NZ,1498
        if (!is_zero(a305[7:0])) {
          advance (10)
          A := a281;
          B := a305[7:0];
          C := a299;
          D := a200[15:8];
          E := a200[7:0];
          H := a295[15:0][15:8];
          L := a295[15:0][7:0];
          SPH := a302[15:8];
          SPL := a302[7:0];
          FlagS := a305[7:0][7];
          FlagZ := is_zero(a305[7:0]);
          FlagA := a308[7:0][4];
          FlagP := parity(a305[7:0]);
          FlagCY := a295[16];
          Shifter_HI := a204;
          Shifter_LO := a24;
          jump (1498);
        } else {
          advance (10)
          #14CA
          #instruction: RET
          let:8 a309 = a302[15:8] in
          let:8 a310 = a302[7:0] in
          let:16 a311 = (1 + (a309,a310)) in
          let:8 a312 = M[(a309,a310)] in
          let:8 a313 = a311[15:8] in
          let:8 a314 = a311[7:0] in
          let:16 a315 = (1 + (a313,a314)) in
          let:8 a316 = M[(a313,a314)] in
          advance (10)
          A := a281;
          B := a305[7:0];
          C := a299;
          D := a200[15:8];
          E := a200[7:0];
          H := a295[15:0][15:8];
          L := a295[15:0][7:0];
          SPH := a315[15:8];
          SPL := a315[7:0];
          FlagS := a305[7:0][7];
          FlagZ := is_zero(a305[7:0]);
          FlagA := a308[7:0][4];
          FlagP := parity(a305[7:0]);
          FlagCY := a295[16];
          Shifter_HI := a204;
          Shifter_LO := a24;
          jump ((a316,a312));
        }
      }
    }

1508:

    #1508
    #instruction: LD   A,(202A)
    let:8 a1 = M[202A] in
    advance (13)
    #150B
    #instruction: LD   H,A
    let:8 a2 = a1 in
    advance (5)
    #150C
    #instruction: CALL 156F
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 15;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 0F;
    #return-to: 150F
    advance (17)
    #156F
    #instruction: LD   A,(200A)
    let:8 a9 = M[200A] in
    advance (13)
    #1572
    #instruction: CALL 1554
    let:8 a10 = a8[15:8] in
    let:8 a11 = a8[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 15;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 75;
    #return-to: 1575
    advance (17)
    #1554
    #instruction: LD   C,00
    advance (7)
    #1556
    #instruction: CP   H
    let:8 a16 = a9 in
    let:8 a17 = a2 in
    let:16 a18 = addWithCarry(!false,a16,~a17) in
    let:8 a19 = (a16 & 0F) in
    let:8 a20 = (~a17 & 0F) in
    let:16 a21 = addWithCarry(!false,a19,a20) in
    advance (4)
    #1557
    #instruction: CALL NC,1590
    if (!!a18[15:8][0]) {
      let:8 a22 = a15[15:8] in
      let:8 a23 = a15[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 15;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 5A;
      #return-to: 155A
      advance (17)
      #1590
      #instruction: INC  C
      let:16 a28 = addWithCarry(true,00,00) in
      let:8 a29 = (00 & 0F) in
      let:8 a30 = (00 & 0F) in
      let:16 a31 = addWithCarry(true,a29,a30) in
      advance (5)
      #1591
      #instruction: ADD  10
      let:8 a32 = a9 in
      let:16 a33 = addWithCarry(false,10,a32) in
      let:8 a34 = (10 & 0F) in
      let:8 a35 = (a32 & 0F) in
      let:16 a36 = addWithCarry(false,a34,a35) in
      advance (7)
      #1593
      #instruction: JP   MI,1590
      if (a33[7:0][7]) {
        advance (10)
        A := a33[7:0];
        C := a28[7:0];
        H := a2;
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a33[7:0][7];
        FlagZ := is_zero(a33[7:0]);
        FlagA := a36[7:0][4];
        FlagP := parity(a33[7:0]);
        FlagCY := a33[15:8][0];
        jump (1590);
      } else {
        advance (10)
        #1596
        #instruction: RET
        let:8 a37 = a27[15:8] in
        let:8 a38 = a27[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a33[7:0];
        C := a28[7:0];
        H := a2;
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a33[7:0][7];
        FlagZ := is_zero(a33[7:0]);
        FlagA := a36[7:0][4];
        FlagP := parity(a33[7:0]);
        FlagCY := a33[15:8][0];
        jump ((a44,a40));
      }
    } else {
      advance (11)
      A := a9;
      C := 00;
      H := a2;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a18[7:0][7];
      FlagZ := is_zero(a18[7:0]);
      FlagA := a21[7:0][4];
      FlagP := parity(a18[7:0]);
      FlagCY := !a18[15:8][0];
      jump (155A);
    }

150F:

    #150F
    #instruction: LD   (2064),HL
    let:8 a1 = L in
    M[2064] := a1;
    let:8 a2 = H in
    M[2065] := a2;
    advance (16)
    #1512
    #instruction: LD   A,05
    advance (7)
    #1514
    #instruction: LD   (2025),A
    M[2025] := 05;
    advance (13)
    #1517
    #instruction: CALL 1581
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 15;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 1A;
    #return-to: 151A
    advance (17)
    #1581
    #instruction: LD   A,B
    let:8 a9 = B in
    advance (5)
    #1582
    #instruction: RLCA
    let:8 a10 = a9 in
    advance (4)
    #1583
    #instruction: RLCA
    let:8 a11 = updateBit((a10 << 01),0,a10[7]) in
    advance (4)
    #1584
    #instruction: RLCA
    let:8 a12 = updateBit((a11 << 01),0,a11[7]) in
    advance (4)
    #1585
    #instruction: ADD  B
    let:8 a13 = B in
    let:8 a14 = updateBit((a12 << 01),0,a12[7]) in
    let:16 a15 = addWithCarry(false,a13,a14) in
    let:8 a16 = (a13 & 0F) in
    let:8 a17 = (a14 & 0F) in
    let:16 a18 = addWithCarry(false,a16,a17) in
    advance (4)
    #1586
    #instruction: ADD  B
    let:8 a19 = B in
    let:8 a20 = a15[7:0] in
    let:16 a21 = addWithCarry(false,a19,a20) in
    let:8 a22 = (a19 & 0F) in
    let:8 a23 = (a20 & 0F) in
    let:16 a24 = addWithCarry(false,a22,a23) in
    advance (4)
    #1587
    #instruction: ADD  B
    let:8 a25 = B in
    let:8 a26 = a21[7:0] in
    let:16 a27 = addWithCarry(false,a25,a26) in
    let:8 a28 = (a25 & 0F) in
    let:8 a29 = (a26 & 0F) in
    let:16 a30 = addWithCarry(false,a28,a29) in
    advance (4)
    #1588
    #instruction: ADD  C
    let:8 a31 = C in
    let:8 a32 = a27[7:0] in
    let:16 a33 = addWithCarry(false,a31,a32) in
    let:8 a34 = (a31 & 0F) in
    let:8 a35 = (a32 & 0F) in
    let:16 a36 = addWithCarry(false,a34,a35) in
    advance (4)
    #1589
    #instruction: DEC  A
    let:8 a37 = a33[7:0] in
    let:16 a38 = addWithCarry(!true,a37,~00) in
    let:8 a39 = (a37 & 0F) in
    let:8 a40 = (~00 & 0F) in
    let:16 a41 = addWithCarry(!true,a39,a40) in
    advance (5)
    #158A
    #instruction: LD   L,A
    let:8 a42 = a38[7:0] in
    advance (5)
    #158B
    #instruction: LD   A,(2067)
    let:8 a43 = M[2067] in
    advance (13)
    #158E
    #instruction: LD   H,A
    let:8 a44 = a43 in
    advance (5)
    #158F
    #instruction: RET
    let:8 a45 = a8[15:8] in
    let:8 a46 = a8[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (1 + (a49,a50)) in
    let:8 a52 = M[(a49,a50)] in
    advance (10)
    A := a43;
    H := a44;
    L := a42;
    SPH := a51[15:8];
    SPL := a51[7:0];
    FlagS := a38[7:0][7];
    FlagZ := is_zero(a38[7:0]);
    FlagA := a41[7:0][4];
    FlagP := parity(a38[7:0]);
    FlagCY := a33[15:8][0];
    jump ((a52,a48));

151A:

    #151A
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #151B
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #151C
    #instruction: JP   Z,1530
    if (is_zero(a6)) {
      advance (10)
      #1530
      #instruction: LD   A,03
      advance (7)
      #1532
      #instruction: LD   (2025),A
      M[2025] := 03;
      advance (13)
      #1535
      #instruction: JP   154A
      advance (10)
      #154A
      #instruction: XOR  A
      let:8 a8 = (03 ^ 03) in
      advance (4)
      #154B
      #instruction: LD   (2002),A
      let:8 a9 = a8 in
      M[2002] := a9;
      advance (13)
      #154E
      #instruction: LD   B,F7
      advance (7)
      #1550
      #instruction: JP   19DC
      advance (10)
      #19DC
      #instruction: LD   A,(2094)
      let:8 a10 = M[2094] in
      advance (13)
      #19DF
      #instruction: AND  B
      let:8 a11 = a10 in
      let:8 a12 = (F7 & a11) in
      let:8 a13 = (F7 | a11) in
      advance (4)
      #19E0
      #instruction: LD   (2094),A
      let:8 a14 = a12 in
      M[2094] := a14;
      advance (13)
      #19E3
      #instruction: OUT  03
      let:8 a15 = a12 in
      sound_control(Ufo,a15[0]);
      sound_control(Shot,a15[1]);
      sound_control(PlayerDie,a15[2]);
      sound_control(InvaderDie,a15[3]);
      sound_control(ExtraLife,a15[4]);
      advance (10)
      #19E5
      #instruction: RET
      let:8 a16 = SPH in
      let:8 a17 = SPL in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a12;
      B := F7;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a12[7];
      FlagZ := is_zero(a12);
      FlagA := a13[3];
      FlagP := parity(a12);
      FlagCY := false;
      jump ((a23,a19));
    } else {
      advance (10)
      #151F
      #instruction: LD   (HL),00
      let:8 a24 = H in
      let:8 a25 = L in
      M[(a24,a25)] := 00;
      advance (10)
      #1521
      #instruction: CALL 0A5F
      let:8 a26 = SPH in
      let:8 a27 = SPL in
      let:16 a28 = (-1 + (a26,a27)) in
      M[a28] := 15;
      let:8 a29 = a28[15:8] in
      let:8 a30 = a28[7:0] in
      let:16 a31 = (-1 + (a29,a30)) in
      M[a31] := 24;
      #return-to: 1524
      advance (17)
      #0A5F
      #instruction: LD   A,(20EF)
      let:8 a32 = M[20EF] in
      advance (13)
      #0A62
      #instruction: AND  A
      let:8 a33 = a32 in
      let:8 a34 = a32 in
      let:8 a35 = (a33 & a34) in
      let:8 a36 = (a33 | a34) in
      advance (4)
      #0A63
      #instruction: JP   Z,0A7C
      if (is_zero(a35)) {
        advance (10)
        #0A7C
        #instruction: LD   HL,2062
        advance (10)
        #0A7F
        #instruction: RET
        let:8 a37 = a31[15:8] in
        let:8 a38 = a31[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        A := a35;
        H := 20;
        L := 62;
        SPH := a43[15:8];
        SPL := a43[7:0];
        FlagS := a35[7];
        FlagZ := is_zero(a35);
        FlagA := a36[3];
        FlagP := parity(a35);
        FlagCY := false;
        jump ((a44,a40));
      } else {
        advance (10)
        #0A66
        #instruction: LD   C,B
        let:8 a45 = B in
        advance (5)
        #0A67
        #instruction: LD   B,08
        advance (7)
        #0A69
        #instruction: CALL 18FA
        let:8 a46 = a31[15:8] in
        let:8 a47 = a31[7:0] in
        let:16 a48 = (-1 + (a46,a47)) in
        M[a48] := 0A;
        let:8 a49 = a48[15:8] in
        let:8 a50 = a48[7:0] in
        let:16 a51 = (-1 + (a49,a50)) in
        M[a51] := 6C;
        #return-to: 0A6C
        advance (17)
        #18FA
        #instruction: LD   A,(2094)
        let:8 a52 = M[2094] in
        advance (13)
        #18FD
        #instruction: OR   B
        let:8 a53 = a52 in
        let:8 a54 = (08 | a53) in
        advance (4)
        #18FE
        #instruction: LD   (2094),A
        let:8 a55 = a54 in
        M[2094] := a55;
        advance (13)
        #1901
        #instruction: OUT  03
        let:8 a56 = a54 in
        sound_control(Ufo,a56[0]);
        sound_control(Shot,a56[1]);
        sound_control(PlayerDie,a56[2]);
        sound_control(InvaderDie,a56[3]);
        sound_control(ExtraLife,a56[4]);
        advance (10)
        #1903
        #instruction: RET
        let:8 a57 = a51[15:8] in
        let:8 a58 = a51[7:0] in
        let:16 a59 = (1 + (a57,a58)) in
        let:8 a60 = M[(a57,a58)] in
        let:8 a61 = a59[15:8] in
        let:8 a62 = a59[7:0] in
        let:16 a63 = (1 + (a61,a62)) in
        let:8 a64 = M[(a61,a62)] in
        advance (10)
        A := a54;
        B := 08;
        C := a45;
        SPH := a63[15:8];
        SPL := a63[7:0];
        FlagS := a54[7];
        FlagZ := is_zero(a54);
        FlagA := false;
        FlagP := parity(a54);
        FlagCY := false;
        jump ((a64,a60));
      }
    }

1524:

    #1524
    #instruction: CALL 1A3B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 15;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 27;
    #return-to: 1527
    advance (17)
    #1A3B
    #instruction: LD   E,(HL)
    let:8 a7 = H in
    let:8 a8 = L in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1A3C
    #instruction: INC  HL
    let:8 a10 = H in
    let:8 a11 = L in
    let:16 a12 = (1 + (a10,a11)) in
    advance (5)
    #1A3D
    #instruction: LD   D,(HL)
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:8 a15 = M[(a13,a14)] in
    advance (7)
    #1A3E
    #instruction: INC  HL
    let:8 a16 = a12[15:8] in
    let:8 a17 = a12[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    advance (5)
    #1A3F
    #instruction: LD   A,(HL)
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:8 a21 = M[(a19,a20)] in
    advance (7)
    #1A40
    #instruction: INC  HL
    let:8 a22 = a18[15:8] in
    let:8 a23 = a18[7:0] in
    let:16 a24 = (1 + (a22,a23)) in
    advance (5)
    #1A41
    #instruction: LD   C,(HL)
    let:8 a25 = a24[15:8] in
    let:8 a26 = a24[7:0] in
    let:8 a27 = M[(a25,a26)] in
    advance (7)
    #1A42
    #instruction: INC  HL
    let:8 a28 = a24[15:8] in
    let:8 a29 = a24[7:0] in
    let:16 a30 = (1 + (a28,a29)) in
    advance (5)
    #1A43
    #instruction: LD   B,(HL)
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:8 a33 = M[(a31,a32)] in
    advance (7)
    #1A44
    #instruction: LD   H,C
    let:8 a34 = a27 in
    advance (5)
    #1A45
    #instruction: LD   L,A
    let:8 a35 = a21 in
    advance (5)
    #1A46
    #instruction: RET
    let:8 a36 = a6[15:8] in
    let:8 a37 = a6[7:0] in
    let:16 a38 = (1 + (a36,a37)) in
    let:8 a39 = M[(a36,a37)] in
    let:8 a40 = a38[15:8] in
    let:8 a41 = a38[7:0] in
    let:16 a42 = (1 + (a40,a41)) in
    let:8 a43 = M[(a40,a41)] in
    advance (10)
    A := a21;
    B := a33;
    C := a27;
    D := a15;
    E := a9;
    H := a34;
    L := a35;
    SPH := a42[15:8];
    SPL := a42[7:0];
    jump ((a43,a39));

1527:

    #1527
    #instruction: CALL 15D3
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 15;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2A;
    #return-to: 152A
    advance (17)
    #15D3
    #instruction: CALL 1474
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 15;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a13 = L in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a14 = a13 in
    let:8 a15 = (07 & a14) in
    let:8 a16 = (07 | a14) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a17 = a15 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a18 = B in
    let:8 a19 = C in
    let:8 a20 = a12[15:8] in
    let:8 a21 = a12[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := a18;
    let:8 a23 = a22[15:8] in
    let:8 a24 = a22[7:0] in
    let:16 a25 = (-1 + (a23,a24)) in
    M[a25] := a19;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a26 = H in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a27 = a26 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a28 = updateBit((a27 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a29 = L in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a30 = a29 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a31 = updateBit((a30 >> 01),7,a27[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a32 = addWithCarry(!true,03,~00) in
    let:8 a33 = (03 & 0F) in
    let:8 a34 = (~00 & 0F) in
    let:16 a35 = addWithCarry(!true,a33,a34) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a32[7:0])) {
      advance (10)
      A := updateBit((a30 >> 01),7,a27[0]);
      B := a32[7:0];
      H := a28;
      L := a31;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagS := a32[7:0][7];
      FlagZ := is_zero(a32[7:0]);
      FlagA := a35[7:0][4];
      FlagP := parity(a32[7:0]);
      FlagCY := a30[0];
      Shifter_OFF := a17;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a36 = a28 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a37 = a36 in
      let:8 a38 = (3F & a37) in
      let:8 a39 = (3F | a37) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a40 = a38 in
      let:8 a41 = (20 | a40) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a42 = a41 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a43 = a25[15:8] in
      let:8 a44 = a25[7:0] in
      let:16 a45 = (1 + (a43,a44)) in
      let:8 a46 = M[(a43,a44)] in
      let:8 a47 = a45[15:8] in
      let:8 a48 = a45[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a51 = a49[15:8] in
      let:8 a52 = a49[7:0] in
      let:16 a53 = (1 + (a51,a52)) in
      let:8 a54 = M[(a51,a52)] in
      let:8 a55 = a53[15:8] in
      let:8 a56 = a53[7:0] in
      let:16 a57 = (1 + (a55,a56)) in
      let:8 a58 = M[(a55,a56)] in
      advance (10)
      A := a41;
      B := a50;
      C := a46;
      H := a42;
      L := a31;
      SPH := a57[15:8];
      SPL := a57[7:0];
      FlagS := a41[7];
      FlagZ := is_zero(a41);
      FlagA := false;
      FlagP := parity(a41);
      FlagCY := false;
      Shifter_OFF := a17;
      jump ((a58,a54));
    }

152A:

    #152A
    #instruction: LD   A,10
    advance (7)
    #152C
    #instruction: LD   (2003),A
    M[2003] := 10;
    advance (13)
    #152F
    #instruction: RET
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    A := 10;
    SPH := a7[15:8];
    SPL := a7[7:0];
    jump ((a8,a4));

1545:

    #1545
    #instruction: LD   A,04
    advance (7)
    #1547
    #instruction: LD   (2025),A
    M[2025] := 04;
    advance (13)
    #154A
    #instruction: XOR  A
    let:8 a1 = (04 ^ 04) in
    advance (4)
    #154B
    #instruction: LD   (2002),A
    let:8 a2 = a1 in
    M[2002] := a2;
    advance (13)
    #154E
    #instruction: LD   B,F7
    advance (7)
    #1550
    #instruction: JP   19DC
    advance (10)
    #19DC
    #instruction: LD   A,(2094)
    let:8 a3 = M[2094] in
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a4 = a3 in
    let:8 a5 = (F7 & a4) in
    let:8 a6 = (F7 | a4) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    let:8 a7 = a5 in
    M[2094] := a7;
    advance (13)
    #19E3
    #instruction: OUT  03
    let:8 a8 = a5 in
    sound_control(Ufo,a8[0]);
    sound_control(Shot,a8[1]);
    sound_control(PlayerDie,a8[2]);
    sound_control(InvaderDie,a8[3]);
    sound_control(ExtraLife,a8[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:8 a9 = SPH in
    let:8 a10 = SPL in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    A := a5;
    B := F7;
    SPH := a15[15:8];
    SPL := a15[7:0];
    FlagS := a5[7];
    FlagZ := is_zero(a5);
    FlagA := a6[3];
    FlagP := parity(a5);
    FlagCY := false;
    jump ((a16,a12));

155A:

    #155A
    #instruction: CP   H
    let:8 a1 = A in
    let:8 a2 = H in
    let:16 a3 = addWithCarry(!false,a1,~a2) in
    let:8 a4 = (a1 & 0F) in
    let:8 a5 = (~a2 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (4)
    #155B
    #instruction: RET  NC
    if (!!a3[15:8][0]) {
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (1 + (a7,a8)) in
      let:8 a10 = M[(a7,a8)] in
      let:8 a11 = a9[15:8] in
      let:8 a12 = a9[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      advance (11)
      SPH := a13[15:8];
      SPL := a13[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a14,a10));
    } else {
      advance (5)
      #155C
      #instruction: ADD  10
      let:8 a15 = A in
      let:16 a16 = addWithCarry(false,10,a15) in
      let:8 a17 = (10 & 0F) in
      let:8 a18 = (a15 & 0F) in
      let:16 a19 = addWithCarry(false,a17,a18) in
      advance (7)
      #155E
      #instruction: INC  C
      let:8 a20 = C in
      let:16 a21 = addWithCarry(true,a20,00) in
      let:8 a22 = (a20 & 0F) in
      let:8 a23 = (00 & 0F) in
      let:16 a24 = addWithCarry(true,a22,a23) in
      advance (5)
      #155F
      #instruction: JP   155A
      advance (10)
      A := a16[7:0];
      C := a21[7:0];
      FlagS := a21[7:0][7];
      FlagZ := is_zero(a21[7:0]);
      FlagA := a24[7:0][4];
      FlagP := parity(a21[7:0]);
      FlagCY := a16[15:8][0];
      jump (155A);
    }

1569:

    #1569
    #instruction: LD   B,C
    let:8 a1 = C in
    advance (5)
    #156A
    #instruction: DEC  B
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #156B
    #instruction: SBC  10
    let:8 a7 = A in
    let:16 a8 = addWithCarry(!FlagCY,a7,~10) in
    let:8 a9 = (a7 & 0F) in
    let:8 a10 = (~10 & 0F) in
    let:16 a11 = addWithCarry(!FlagCY,a9,a10) in
    advance (7)
    #156D
    #instruction: LD   L,A
    let:8 a12 = a8[7:0] in
    advance (5)
    #156E
    #instruction: RET
    let:8 a13 = SPH in
    let:8 a14 = SPL in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a8[7:0];
    B := a3[7:0];
    L := a12;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a8[7:0][7];
    FlagZ := is_zero(a8[7:0]);
    FlagA := a11[7:0][4];
    FlagP := parity(a8[7:0]);
    FlagCY := !a8[15:8][0];
    jump ((a20,a16));

1575:

    #1575
    #instruction: SBC  10
    let:8 a1 = A in
    let:16 a2 = addWithCarry(!FlagCY,a1,~10) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~10 & 0F) in
    let:16 a5 = addWithCarry(!FlagCY,a3,a4) in
    advance (7)
    #1577
    #instruction: LD   H,A
    let:8 a6 = a2[7:0] in
    advance (5)
    #1578
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a2[7:0];
    H := a6;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a2[7:0][7];
    FlagZ := is_zero(a2[7:0]);
    FlagA := a5[7:0][4];
    FlagP := parity(a2[7:0]);
    FlagCY := !a2[15:8][0];
    jump ((a14,a10));

15A4:

    #15A4
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #15A5
      #instruction: LD   B,FE
      advance (7)
      #15A7
      #instruction: LD   A,01
      advance (7)
      #15A9
      #instruction: LD   (200D),A
      M[200D] := 01;
      advance (13)
      #15AC
      #instruction: LD   A,B
      advance (5)
      #15AD
      #instruction: LD   (2008),A
      M[2008] := FE;
      advance (13)
      #15B0
      #instruction: LD   A,(200E)
      let:8 a9 = M[200E] in
      advance (13)
      #15B3
      #instruction: LD   (2007),A
      let:8 a10 = a9 in
      M[2007] := a10;
      advance (13)
      #15B6
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a9;
      B := FE;
      SPH := a17[15:8];
      SPL := a17[7:0];
      jump ((a18,a14));
    }

15BD:

    #15BD
    #instruction: RET  NC
    if (!FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #15BE
      #instruction: CALL 18F1
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 15;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := C1;
      #return-to: 15C1
      advance (17)
      #18F1
      #instruction: LD   B,02
      advance (7)
      #18F3
      #instruction: LD   A,(2082)
      let:8 a15 = M[2082] in
      advance (13)
      #18F6
      #instruction: DEC  A
      let:8 a16 = a15 in
      let:16 a17 = addWithCarry(!true,a16,~00) in
      let:8 a18 = (a16 & 0F) in
      let:8 a19 = (~00 & 0F) in
      let:16 a20 = addWithCarry(!true,a18,a19) in
      advance (5)
      #18F7
      #instruction: RET  NZ
      if (!is_zero(a17[7:0])) {
        let:8 a21 = a14[15:8] in
        let:8 a22 = a14[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        let:8 a25 = a23[15:8] in
        let:8 a26 = a23[7:0] in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        advance (11)
        A := a17[7:0];
        B := 02;
        SPH := a27[15:8];
        SPL := a27[7:0];
        FlagS := a17[7:0][7];
        FlagZ := is_zero(a17[7:0]);
        FlagA := a20[7:0][4];
        FlagP := parity(a17[7:0]);
        jump ((a28,a24));
      } else {
        advance (5)
        #18F8
        #instruction: INC  B
        let:16 a29 = addWithCarry(true,02,00) in
        let:8 a30 = (02 & 0F) in
        let:8 a31 = (00 & 0F) in
        let:16 a32 = addWithCarry(true,a30,a31) in
        advance (5)
        #18F9
        #instruction: RET
        let:8 a33 = a14[15:8] in
        let:8 a34 = a14[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a17[7:0];
        B := a29[7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        jump ((a40,a36));
      }
    }

15C1:

    #15C1
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #15C2
    #instruction: JP   15A9
    advance (10)
    #15A9
    #instruction: LD   (200D),A
    let:8 a4 = a3 in
    M[200D] := a4;
    advance (13)
    #15AC
    #instruction: LD   A,B
    let:8 a5 = B in
    advance (5)
    #15AD
    #instruction: LD   (2008),A
    let:8 a6 = a5 in
    M[2008] := a6;
    advance (13)
    #15B0
    #instruction: LD   A,(200E)
    let:8 a7 = M[200E] in
    advance (13)
    #15B3
    #instruction: LD   (2007),A
    let:8 a8 = a7 in
    M[2007] := a8;
    advance (13)
    #15B6
    #instruction: RET
    let:8 a9 = SPH in
    let:8 a10 = SPL in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    A := a7;
    SPH := a15[15:8];
    SPL := a15[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a16,a12));

15D6:

    #15D6
    #instruction: PUSH HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := a1;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := a2;
    advance (11)
    #15D7
    #instruction: PUSH BC
    let:8 a9 = B in
    let:8 a10 = C in
    let:8 a11 = a8[15:8] in
    let:8 a12 = a8[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a9;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := a10;
    advance (11)
    #15D8
    #instruction: PUSH HL
    let:8 a17 = H in
    let:8 a18 = L in
    let:8 a19 = a16[15:8] in
    let:8 a20 = a16[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := a17;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := a18;
    advance (11)
    #15D9
    #instruction: LD   A,(DE)
    let:8 a25 = D in
    let:8 a26 = E in
    let:8 a27 = M[(a25,a26)] in
    advance (7)
    #15DA
    #instruction: OUT  04
    let:8 a28 = a27 in
    advance (10)
    #15DC
    #instruction: IN   03
    let:8 a29 = (Shifter_OFF & 07) in
    let:8 a30 = (~Shifter_OFF & 07) in
    let:8 a31 = ((a28 << a29) | ((Shifter_HI >> a30) >> 01)) in
    advance (10)
    #15DE
    #instruction: LD   (HL),A
    let:8 a32 = a31 in
    let:8 a33 = H in
    let:8 a34 = L in
    M[(a33,a34)] := a32;
    advance (7)
    #15DF
    #instruction: INC  HL
    let:8 a35 = H in
    let:8 a36 = L in
    let:16 a37 = (1 + (a35,a36)) in
    advance (5)
    #15E0
    #instruction: INC  DE
    let:8 a38 = D in
    let:8 a39 = E in
    let:16 a40 = (1 + (a38,a39)) in
    advance (5)
    #15E1
    #instruction: XOR  A
    let:8 a41 = a31 in
    let:8 a42 = a31 in
    let:8 a43 = (a41 ^ a42) in
    advance (4)
    #15E2
    #instruction: OUT  04
    let:8 a44 = a43 in
    advance (10)
    #15E4
    #instruction: IN   03
    let:8 a45 = (Shifter_OFF & 07) in
    let:8 a46 = (~Shifter_OFF & 07) in
    let:8 a47 = ((a44 << a45) | ((a28 >> a46) >> 01)) in
    advance (10)
    #15E6
    #instruction: LD   (HL),A
    let:8 a48 = a47 in
    let:8 a49 = a37[15:8] in
    let:8 a50 = a37[7:0] in
    M[(a49,a50)] := a48;
    advance (7)
    #15E7
    #instruction: POP  HL
    let:8 a51 = a24[15:8] in
    let:8 a52 = a24[7:0] in
    let:16 a53 = (1 + (a51,a52)) in
    let:8 a54 = M[(a51,a52)] in
    let:8 a55 = a53[15:8] in
    let:8 a56 = a53[7:0] in
    let:16 a57 = (1 + (a55,a56)) in
    let:8 a58 = M[(a55,a56)] in
    advance (10)
    #15E8
    #instruction: LD   BC,0020
    advance (10)
    #15EB
    #instruction: ADD  HL,BC
    let:8 a59 = a58 in
    let:8 a60 = a54 in
    let:17 a61 = add17(0020,(a59,a60)) in
    advance (10)
    #15EC
    #instruction: POP  BC
    let:8 a62 = a57[15:8] in
    let:8 a63 = a57[7:0] in
    let:16 a64 = (1 + (a62,a63)) in
    let:8 a65 = M[(a62,a63)] in
    let:8 a66 = a64[15:8] in
    let:8 a67 = a64[7:0] in
    let:16 a68 = (1 + (a66,a67)) in
    let:8 a69 = M[(a66,a67)] in
    advance (10)
    #15ED
    #instruction: DEC  B
    let:8 a70 = a69 in
    let:16 a71 = addWithCarry(!true,a70,~00) in
    let:8 a72 = (a70 & 0F) in
    let:8 a73 = (~00 & 0F) in
    let:16 a74 = addWithCarry(!true,a72,a73) in
    advance (5)
    #15EE
    #instruction: JP   NZ,15D7
    if (!is_zero(a71[7:0])) {
      advance (10)
      A := a47;
      B := a71[7:0];
      C := a65;
      D := a40[15:8];
      E := a40[7:0];
      H := a61[15:0][15:8];
      L := a61[15:0][7:0];
      SPH := a68[15:8];
      SPL := a68[7:0];
      FlagS := a71[7:0][7];
      FlagZ := is_zero(a71[7:0]);
      FlagA := a74[7:0][4];
      FlagP := parity(a71[7:0]);
      FlagCY := a61[16];
      Shifter_HI := a44;
      Shifter_LO := a28;
      jump (15D7);
    } else {
      advance (10)
      #15F1
      #instruction: POP  HL
      let:8 a75 = a68[15:8] in
      let:8 a76 = a68[7:0] in
      let:16 a77 = (1 + (a75,a76)) in
      let:8 a78 = M[(a75,a76)] in
      let:8 a79 = a77[15:8] in
      let:8 a80 = a77[7:0] in
      let:16 a81 = (1 + (a79,a80)) in
      let:8 a82 = M[(a79,a80)] in
      advance (10)
      #15F2
      #instruction: RET
      let:8 a83 = a81[15:8] in
      let:8 a84 = a81[7:0] in
      let:16 a85 = (1 + (a83,a84)) in
      let:8 a86 = M[(a83,a84)] in
      let:8 a87 = a85[15:8] in
      let:8 a88 = a85[7:0] in
      let:16 a89 = (1 + (a87,a88)) in
      let:8 a90 = M[(a87,a88)] in
      advance (10)
      A := a47;
      B := a71[7:0];
      C := a65;
      D := a40[15:8];
      E := a40[7:0];
      H := a82;
      L := a78;
      SPH := a89[15:8];
      SPL := a89[7:0];
      FlagS := a71[7:0][7];
      FlagZ := is_zero(a71[7:0]);
      FlagA := a74[7:0][4];
      FlagP := parity(a71[7:0]);
      FlagCY := a61[16];
      Shifter_HI := a44;
      Shifter_LO := a28;
      jump ((a90,a86));
    }

15F6:

    #15F6
    #instruction: LD   BC,3700
    advance (10)
    #15F9
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #15FA
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #15FB
    #instruction: JP   Z,15FF
    if (is_zero(a6)) {
      advance (10)
      #15FF
      #instruction: INC  HL
      let:8 a8 = H in
      let:8 a9 = L in
      let:16 a10 = (1 + (a8,a9)) in
      advance (5)
      #1600
      #instruction: DEC  B
      let:16 a11 = addWithCarry(!true,37,~00) in
      let:8 a12 = (37 & 0F) in
      let:8 a13 = (~00 & 0F) in
      let:16 a14 = addWithCarry(!true,a12,a13) in
      advance (5)
      #1601
      #instruction: JP   NZ,15F9
      if (!is_zero(a11[7:0])) {
        advance (10)
        A := a6;
        B := a11[7:0];
        C := 00;
        H := a10[15:8];
        L := a10[7:0];
        FlagS := a11[7:0][7];
        FlagZ := is_zero(a11[7:0]);
        FlagA := a14[7:0][4];
        FlagP := parity(a11[7:0]);
        FlagCY := false;
        jump (15F9);
      } else {
        advance (10)
        #1604
        #instruction: LD   A,C
        advance (5)
        #1605
        #instruction: LD   (2082),A
        M[2082] := 00;
        advance (13)
        #1608
        #instruction: CP   01
        let:16 a15 = addWithCarry(!false,00,~01) in
        let:8 a16 = (00 & 0F) in
        let:8 a17 = (~01 & 0F) in
        let:16 a18 = addWithCarry(!false,a16,a17) in
        advance (7)
        #160A
        #instruction: RET  NZ
        if (!is_zero(a15[7:0])) {
          let:8 a19 = SPH in
          let:8 a20 = SPL in
          let:16 a21 = (1 + (a19,a20)) in
          let:8 a22 = M[(a19,a20)] in
          let:8 a23 = a21[15:8] in
          let:8 a24 = a21[7:0] in
          let:16 a25 = (1 + (a23,a24)) in
          let:8 a26 = M[(a23,a24)] in
          advance (11)
          A := 00;
          B := a11[7:0];
          C := 00;
          H := a10[15:8];
          L := a10[7:0];
          SPH := a25[15:8];
          SPL := a25[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a15[15:8][0];
          jump ((a26,a22));
        } else {
          advance (5)
          #160B
          #instruction: LD   HL,206B
          advance (10)
          #160E
          #instruction: LD   (HL),01
          M[206B] := 01;
          advance (10)
          #1610
          #instruction: RET
          let:8 a27 = SPH in
          let:8 a28 = SPL in
          let:16 a29 = (1 + (a27,a28)) in
          let:8 a30 = M[(a27,a28)] in
          let:8 a31 = a29[15:8] in
          let:8 a32 = a29[7:0] in
          let:16 a33 = (1 + (a31,a32)) in
          let:8 a34 = M[(a31,a32)] in
          advance (10)
          A := 00;
          B := a11[7:0];
          C := 00;
          H := 20;
          L := 6B;
          SPH := a33[15:8];
          SPL := a33[7:0];
          FlagS := a15[7:0][7];
          FlagZ := is_zero(a15[7:0]);
          FlagA := a18[7:0][4];
          FlagP := parity(a15[7:0]);
          FlagCY := !a15[15:8][0];
          jump ((a34,a30));
        }
      }
    } else {
      advance (10)
      #15FE
      #instruction: INC  C
      let:16 a35 = addWithCarry(true,00,00) in
      let:8 a36 = (00 & 0F) in
      let:8 a37 = (00 & 0F) in
      let:16 a38 = addWithCarry(true,a36,a37) in
      advance (5)
      #15FF
      #instruction: INC  HL
      let:8 a39 = H in
      let:8 a40 = L in
      let:16 a41 = (1 + (a39,a40)) in
      advance (5)
      #1600
      #instruction: DEC  B
      let:16 a42 = addWithCarry(!true,37,~00) in
      let:8 a43 = (37 & 0F) in
      let:8 a44 = (~00 & 0F) in
      let:16 a45 = addWithCarry(!true,a43,a44) in
      advance (5)
      #1601
      #instruction: JP   NZ,15F9
      if (!is_zero(a42[7:0])) {
        advance (10)
        A := a6;
        B := a42[7:0];
        C := a35[7:0];
        H := a41[15:8];
        L := a41[7:0];
        FlagS := a42[7:0][7];
        FlagZ := is_zero(a42[7:0]);
        FlagA := a45[7:0][4];
        FlagP := parity(a42[7:0]);
        FlagCY := false;
        jump (15F9);
      } else {
        advance (10)
        #1604
        #instruction: LD   A,C
        let:8 a46 = a35[7:0] in
        advance (5)
        #1605
        #instruction: LD   (2082),A
        let:8 a47 = a46 in
        M[2082] := a47;
        advance (13)
        #1608
        #instruction: CP   01
        let:8 a48 = a46 in
        let:16 a49 = addWithCarry(!false,a48,~01) in
        let:8 a50 = (a48 & 0F) in
        let:8 a51 = (~01 & 0F) in
        let:16 a52 = addWithCarry(!false,a50,a51) in
        advance (7)
        #160A
        #instruction: RET  NZ
        if (!is_zero(a49[7:0])) {
          let:8 a53 = SPH in
          let:8 a54 = SPL in
          let:16 a55 = (1 + (a53,a54)) in
          let:8 a56 = M[(a53,a54)] in
          let:8 a57 = a55[15:8] in
          let:8 a58 = a55[7:0] in
          let:16 a59 = (1 + (a57,a58)) in
          let:8 a60 = M[(a57,a58)] in
          advance (11)
          A := a46;
          B := a42[7:0];
          C := a35[7:0];
          H := a41[15:8];
          L := a41[7:0];
          SPH := a59[15:8];
          SPL := a59[7:0];
          FlagS := a49[7:0][7];
          FlagZ := is_zero(a49[7:0]);
          FlagA := a52[7:0][4];
          FlagP := parity(a49[7:0]);
          FlagCY := !a49[15:8][0];
          jump ((a60,a56));
        } else {
          advance (5)
          #160B
          #instruction: LD   HL,206B
          advance (10)
          #160E
          #instruction: LD   (HL),01
          M[206B] := 01;
          advance (10)
          #1610
          #instruction: RET
          let:8 a61 = SPH in
          let:8 a62 = SPL in
          let:16 a63 = (1 + (a61,a62)) in
          let:8 a64 = M[(a61,a62)] in
          let:8 a65 = a63[15:8] in
          let:8 a66 = a63[7:0] in
          let:16 a67 = (1 + (a65,a66)) in
          let:8 a68 = M[(a65,a66)] in
          advance (10)
          A := a46;
          B := a42[7:0];
          C := a35[7:0];
          H := 20;
          L := 6B;
          SPH := a67[15:8];
          SPL := a67[7:0];
          FlagS := a49[7:0][7];
          FlagZ := is_zero(a49[7:0]);
          FlagA := a52[7:0][4];
          FlagP := parity(a49[7:0]);
          FlagCY := !a49[15:8][0];
          jump ((a68,a64));
        }
      }
    }

163C:

    #163C
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    #163E
    #instruction: RET  Z
    if (is_zero(a2)) {
      let:8 a4 = SPH in
      let:8 a5 = SPL in
      let:16 a6 = (1 + (a4,a5)) in
      let:8 a7 = M[(a4,a5)] in
      let:8 a8 = a6[15:8] in
      let:8 a9 = a6[7:0] in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      advance (11)
      A := a2;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a11,a7));
    } else {
      advance (5)
      #163F
      #instruction: LD   A,01
      advance (7)
      #1641
      #instruction: LD   (2025),A
      M[2025] := 01;
      advance (13)
      #1644
      #instruction: LD   (202D),A
      M[202D] := 01;
      advance (13)
      #1647
      #instruction: RET
      let:8 a12 = SPH in
      let:8 a13 = SPL in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := 01;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a19,a15));
    }

164B:

    #164B
    #instruction: AND  10
    let:8 a1 = A in
    let:8 a2 = (10 & a1) in
    let:8 a3 = (10 | a1) in
    advance (7)
    #164D
    #instruction: RET  NZ
    if (!is_zero(a2)) {
      let:8 a4 = SPH in
      let:8 a5 = SPL in
      let:16 a6 = (1 + (a4,a5)) in
      let:8 a7 = M[(a4,a5)] in
      let:8 a8 = a6[15:8] in
      let:8 a9 = a6[7:0] in
      let:16 a10 = (1 + (a8,a9)) in
      let:8 a11 = M[(a8,a9)] in
      advance (11)
      A := a2;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a11,a7));
    } else {
      advance (5)
      #164E
      #instruction: LD   (202D),A
      let:8 a12 = a2 in
      M[202D] := a12;
      advance (13)
      #1651
      #instruction: RET
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := a2;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a2[7];
      FlagZ := is_zero(a2);
      FlagA := a3[3];
      FlagP := parity(a2);
      FlagCY := false;
      jump ((a20,a16));
    }

1671:

    #1671
    #instruction: CALL 1910
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 74;
    #return-to: 1674
    advance (17)
    #1910
    #instruction: LD   HL,20E7
    advance (10)
    #1913
    #instruction: LD   A,(2067)
    let:8 a7 = M[2067] in
    advance (13)
    #1916
    #instruction: RRCA
    let:8 a8 = a7 in
    advance (4)
    #1917
    #instruction: RET  CY
    if (a8[0]) {
      let:8 a9 = a6[15:8] in
      let:8 a10 = a6[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E7;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagCY := a8[0];
      jump ((a16,a12));
    } else {
      advance (5)
      #1918
      #instruction: INC  HL
      advance (5)
      #1919
      #instruction: RET
      let:8 a17 = a6[15:8] in
      let:8 a18 = a6[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E8;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagCY := a8[0];
      jump ((a24,a20));
    }

1674:

    #1674
    #instruction: LD   (HL),00
    let:8 a1 = H in
    let:8 a2 = L in
    M[(a1,a2)] := 00;
    advance (10)
    #1676
    #instruction: CALL 09CA
    let:8 a3 = SPH in
    let:8 a4 = SPL in
    let:16 a5 = (-1 + (a3,a4)) in
    M[a5] := 16;
    let:8 a6 = a5[15:8] in
    let:8 a7 = a5[7:0] in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 79;
    #return-to: 1679
    advance (17)
    #09CA
    #instruction: LD   A,(2067)
    let:8 a9 = M[2067] in
    advance (13)
    #09CD
    #instruction: RRCA
    let:8 a10 = a9 in
    advance (4)
    #09CE
    #instruction: LD   HL,20F8
    advance (10)
    #09D1
    #instruction: RET  CY
    if (a10[0]) {
      let:8 a11 = a8[15:8] in
      let:8 a12 = a8[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (11)
      A := updateBit((a10 >> 01),7,a10[0]);
      H := 20;
      L := F8;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagCY := a10[0];
      jump ((a18,a14));
    } else {
      advance (5)
      #09D2
      #instruction: LD   HL,20FC
      advance (10)
      #09D5
      #instruction: RET
      let:8 a19 = a8[15:8] in
      let:8 a20 = a8[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      let:8 a23 = a21[15:8] in
      let:8 a24 = a21[7:0] in
      let:16 a25 = (1 + (a23,a24)) in
      let:8 a26 = M[(a23,a24)] in
      advance (10)
      A := updateBit((a10 >> 01),7,a10[0]);
      H := 20;
      L := FC;
      SPH := a25[15:8];
      SPL := a25[7:0];
      FlagCY := a10[0];
      jump ((a26,a22));
    }

1679:

    #1679
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #167A
    #instruction: LD   DE,20F5
    advance (10)
    #167D
    #instruction: LD   A,(DE)
    let:8 a4 = M[20F5] in
    advance (7)
    #167E
    #instruction: CP   (HL)
    let:8 a5 = a4 in
    let:8 a6 = a3[15:8] in
    let:8 a7 = a3[7:0] in
    let:8 a8 = M[(a6,a7)] in
    let:16 a9 = addWithCarry(!false,a5,~a8) in
    let:8 a10 = (a5 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #167F
    #instruction: DEC  DE
    advance (5)
    #1680
    #instruction: DEC  HL
    let:8 a13 = a3[15:8] in
    let:8 a14 = a3[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    advance (5)
    #1681
    #instruction: LD   A,(DE)
    let:8 a16 = M[20F4] in
    advance (7)
    #1682
    #instruction: JP   Z,168B
    if (is_zero(a9[7:0])) {
      advance (10)
      #168B
      #instruction: CP   (HL)
      let:8 a17 = a16 in
      let:8 a18 = a15[15:8] in
      let:8 a19 = a15[7:0] in
      let:8 a20 = M[(a18,a19)] in
      let:16 a21 = addWithCarry(!false,a17,~a20) in
      let:8 a22 = (a17 & 0F) in
      let:8 a23 = (~a20 & 0F) in
      let:16 a24 = addWithCarry(!false,a22,a23) in
      advance (7)
      #168C
      #instruction: JP   NC,1698
      if (!!a21[15:8][0]) {
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a21[15:8][0];
        jump (1698);
      } else {
        advance (10)
        #168F
        #instruction: LD   A,(HL)
        let:8 a25 = a15[15:8] in
        let:8 a26 = a15[7:0] in
        let:8 a27 = M[(a25,a26)] in
        advance (7)
        #1690
        #instruction: LD   (DE),A
        let:8 a28 = a27 in
        M[20F4] := a28;
        advance (7)
        #1691
        #instruction: INC  DE
        advance (5)
        #1692
        #instruction: INC  HL
        let:8 a29 = a15[15:8] in
        let:8 a30 = a15[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        advance (5)
        #1693
        #instruction: LD   A,(HL)
        let:8 a32 = a31[15:8] in
        let:8 a33 = a31[7:0] in
        let:8 a34 = M[(a32,a33)] in
        advance (7)
        #1694
        #instruction: LD   (DE),A
        let:8 a35 = a34 in
        M[20F5] := a35;
        advance (7)
        #1695
        #instruction: CALL 1950
        let:8 a36 = SPH in
        let:8 a37 = SPL in
        let:16 a38 = (-1 + (a36,a37)) in
        M[a38] := 16;
        let:8 a39 = a38[15:8] in
        let:8 a40 = a38[7:0] in
        let:16 a41 = (-1 + (a39,a40)) in
        M[a41] := 98;
        #return-to: 1698
        advance (17)
        #1950
        #instruction: LD   HL,20F4
        advance (10)
        #1953
        #instruction: JP   1931
        advance (10)
        #1931
        #instruction: LD   E,(HL)
        let:8 a42 = M[20F4] in
        advance (7)
        #1932
        #instruction: INC  HL
        advance (5)
        #1933
        #instruction: LD   D,(HL)
        let:8 a43 = M[20F5] in
        advance (7)
        #1934
        #instruction: INC  HL
        advance (5)
        #1935
        #instruction: LD   A,(HL)
        let:8 a44 = M[20F6] in
        advance (7)
        #1936
        #instruction: INC  HL
        advance (5)
        #1937
        #instruction: LD   H,(HL)
        let:8 a45 = M[20F7] in
        advance (7)
        #1938
        #instruction: LD   L,A
        let:8 a46 = a44 in
        advance (5)
        #1939
        #instruction: JP   09AD
        advance (10)
        #09AD
        #instruction: LD   A,D
        let:8 a47 = a43 in
        advance (5)
        #09AE
        #instruction: CALL 09B2
        let:8 a48 = a41[15:8] in
        let:8 a49 = a41[7:0] in
        let:16 a50 = (-1 + (a48,a49)) in
        M[a50] := 09;
        let:8 a51 = a50[15:8] in
        let:8 a52 = a50[7:0] in
        let:16 a53 = (-1 + (a51,a52)) in
        M[a53] := B1;
        #return-to: 09B1
        advance (17)
        #09B2
        #instruction: PUSH DE
        let:8 a54 = a43 in
        let:8 a55 = a42 in
        let:8 a56 = a53[15:8] in
        let:8 a57 = a53[7:0] in
        let:16 a58 = (-1 + (a56,a57)) in
        M[a58] := a54;
        let:8 a59 = a58[15:8] in
        let:8 a60 = a58[7:0] in
        let:16 a61 = (-1 + (a59,a60)) in
        M[a61] := a55;
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:8 a62 = a47 in
        let:8 a63 = a61[15:8] in
        let:8 a64 = a61[7:0] in
        let:16 a65 = (-1 + (a63,a64)) in
        M[a65] := a62;
        let:8 a66 = a65[15:8] in
        let:8 a67 = a65[7:0] in
        let:16 a68 = (-1 + (a66,a67)) in
        M[a68] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a21[7:0][7]),6,is_zero(a21[7:0])),4,a24[7:0][4]),2,parity(a21[7:0])),0,!a21[15:8][0]);
        advance (11)
        #09B4
        #instruction: RRCA
        let:8 a69 = a47 in
        advance (4)
        #09B5
        #instruction: RRCA
        let:8 a70 = updateBit((a69 >> 01),7,a69[0]) in
        advance (4)
        #09B6
        #instruction: RRCA
        let:8 a71 = updateBit((a70 >> 01),7,a70[0]) in
        advance (4)
        #09B7
        #instruction: RRCA
        let:8 a72 = updateBit((a71 >> 01),7,a71[0]) in
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a73 = updateBit((a72 >> 01),7,a72[0]) in
        let:8 a74 = (0F & a73) in
        let:8 a75 = (0F | a73) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:8 a76 = a68[15:8] in
        let:8 a77 = a68[7:0] in
        let:16 a78 = (-1 + (a76,a77)) in
        M[a78] := 09;
        let:8 a79 = a78[15:8] in
        let:8 a80 = a78[7:0] in
        let:16 a81 = (-1 + (a79,a80)) in
        M[a81] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:8 a82 = a74 in
        let:16 a83 = addWithCarry(false,1A,a82) in
        let:8 a84 = (1A & 0F) in
        let:8 a85 = (a82 & 0F) in
        let:16 a86 = addWithCarry(false,a84,a85) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a87 = a45 in
        let:8 a88 = a46 in
        let:8 a89 = a81[15:8] in
        let:8 a90 = a81[7:0] in
        let:16 a91 = (-1 + (a89,a90)) in
        M[a91] := a87;
        let:8 a92 = a91[15:8] in
        let:8 a93 = a91[7:0] in
        let:16 a94 = (-1 + (a92,a93)) in
        M[a94] := a88;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        let:8 a95 = a83[7:0] in
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:8 a96 = a95 in
        let:8 a97 = a95 in
        let:17 a98 = add17((00,a96),(00,a97)) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a99 = a98[15:0][15:8] in
        let:8 a100 = a98[15:0][7:0] in
        let:8 a101 = a98[15:0][15:8] in
        let:8 a102 = a98[15:0][7:0] in
        let:17 a103 = add17((a99,a100),(a101,a102)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a104 = a103[15:0][15:8] in
        let:8 a105 = a103[15:0][7:0] in
        let:8 a106 = a103[15:0][15:8] in
        let:8 a107 = a103[15:0][7:0] in
        let:17 a108 = add17((a104,a105),(a106,a107)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a109 = a108[15:0][15:8] in
        let:8 a110 = a108[15:0][7:0] in
        let:17 a111 = add17(1E00,(a109,a110)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a112 = a111[15:0][15:8] in
        let:8 a113 = a111[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a114 = a94[15:8] in
        let:8 a115 = a94[7:0] in
        let:16 a116 = (1 + (a114,a115)) in
        let:8 a117 = M[(a114,a115)] in
        let:8 a118 = a116[15:8] in
        let:8 a119 = a116[7:0] in
        let:16 a120 = (1 + (a118,a119)) in
        let:8 a121 = M[(a118,a119)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        let:8 a122 = a83[7:0] in
        unknown_output(6,a122);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a123 = C in
        let:8 a124 = a120[15:8] in
        let:8 a125 = a120[7:0] in
        let:16 a126 = (-1 + (a124,a125)) in
        M[a126] := 08;
        let:8 a127 = a126[15:8] in
        let:8 a128 = a126[7:0] in
        let:16 a129 = (-1 + (a127,a128)) in
        M[a129] := a123;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a130 = a112 in
        let:8 a131 = a113 in
        let:8 a132 = M[(a130,a131)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a133 = a132 in
        let:8 a134 = a121 in
        let:8 a135 = a117 in
        M[(a134,a135)] := a133;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a136 = a112 in
        let:8 a137 = a113 in
        let:16 a138 = (1 + (a136,a137)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a139 = a121 in
        let:8 a140 = a117 in
        let:17 a141 = add17(0020,(a139,a140)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a142 = a129[15:8] in
        let:8 a143 = a129[7:0] in
        let:16 a144 = (1 + (a142,a143)) in
        let:8 a145 = M[(a142,a143)] in
        let:8 a146 = a144[15:8] in
        let:8 a147 = a144[7:0] in
        let:16 a148 = (1 + (a146,a147)) in
        let:8 a149 = M[(a146,a147)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a150 = a149 in
        let:16 a151 = addWithCarry(!true,a150,~00) in
        let:8 a152 = (a150 & 0F) in
        let:8 a153 = (~00 & 0F) in
        let:16 a154 = addWithCarry(!true,a152,a153) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a151[7:0])) {
          advance (10)
          A := a132;
          B := a151[7:0];
          C := a145;
          D := a138[15:8];
          E := a138[7:0];
          H := a141[15:0][15:8];
          L := a141[15:0][7:0];
          SPH := a148[15:8];
          SPL := a148[7:0];
          FlagS := a151[7:0][7];
          FlagZ := is_zero(a151[7:0]);
          FlagA := a154[7:0][4];
          FlagP := parity(a151[7:0]);
          FlagCY := a141[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a155 = a148[15:8] in
          let:8 a156 = a148[7:0] in
          let:16 a157 = (1 + (a155,a156)) in
          let:8 a158 = M[(a155,a156)] in
          let:8 a159 = a157[15:8] in
          let:8 a160 = a157[7:0] in
          let:16 a161 = (1 + (a159,a160)) in
          let:8 a162 = M[(a159,a160)] in
          advance (10)
          A := a132;
          B := a151[7:0];
          C := a145;
          D := a138[15:8];
          E := a138[7:0];
          H := a141[15:0][15:8];
          L := a141[15:0][7:0];
          SPH := a161[15:8];
          SPL := a161[7:0];
          FlagS := a151[7:0][7];
          FlagZ := is_zero(a151[7:0]);
          FlagA := a154[7:0][4];
          FlagP := parity(a151[7:0]);
          FlagCY := a141[16];
          jump ((a162,a158));
        }
      }
    } else {
      advance (10)
      #1685
      #instruction: JP   NC,1698
      if (!!a9[15:8][0]) {
        advance (10)
        A := a16;
        D := 20;
        E := F4;
        H := a15[15:8];
        L := a15[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump (1698);
      } else {
        advance (10)
        #1688
        #instruction: JP   168F
        advance (10)
        #168F
        #instruction: LD   A,(HL)
        let:8 a163 = a15[15:8] in
        let:8 a164 = a15[7:0] in
        let:8 a165 = M[(a163,a164)] in
        advance (7)
        #1690
        #instruction: LD   (DE),A
        let:8 a166 = a165 in
        M[20F4] := a166;
        advance (7)
        #1691
        #instruction: INC  DE
        advance (5)
        #1692
        #instruction: INC  HL
        let:8 a167 = a15[15:8] in
        let:8 a168 = a15[7:0] in
        let:16 a169 = (1 + (a167,a168)) in
        advance (5)
        #1693
        #instruction: LD   A,(HL)
        let:8 a170 = a169[15:8] in
        let:8 a171 = a169[7:0] in
        let:8 a172 = M[(a170,a171)] in
        advance (7)
        #1694
        #instruction: LD   (DE),A
        let:8 a173 = a172 in
        M[20F5] := a173;
        advance (7)
        #1695
        #instruction: CALL 1950
        let:8 a174 = SPH in
        let:8 a175 = SPL in
        let:16 a176 = (-1 + (a174,a175)) in
        M[a176] := 16;
        let:8 a177 = a176[15:8] in
        let:8 a178 = a176[7:0] in
        let:16 a179 = (-1 + (a177,a178)) in
        M[a179] := 98;
        #return-to: 1698
        advance (17)
        #1950
        #instruction: LD   HL,20F4
        advance (10)
        #1953
        #instruction: JP   1931
        advance (10)
        #1931
        #instruction: LD   E,(HL)
        let:8 a180 = M[20F4] in
        advance (7)
        #1932
        #instruction: INC  HL
        advance (5)
        #1933
        #instruction: LD   D,(HL)
        let:8 a181 = M[20F5] in
        advance (7)
        #1934
        #instruction: INC  HL
        advance (5)
        #1935
        #instruction: LD   A,(HL)
        let:8 a182 = M[20F6] in
        advance (7)
        #1936
        #instruction: INC  HL
        advance (5)
        #1937
        #instruction: LD   H,(HL)
        let:8 a183 = M[20F7] in
        advance (7)
        #1938
        #instruction: LD   L,A
        let:8 a184 = a182 in
        advance (5)
        #1939
        #instruction: JP   09AD
        advance (10)
        #09AD
        #instruction: LD   A,D
        let:8 a185 = a181 in
        advance (5)
        #09AE
        #instruction: CALL 09B2
        let:8 a186 = a179[15:8] in
        let:8 a187 = a179[7:0] in
        let:16 a188 = (-1 + (a186,a187)) in
        M[a188] := 09;
        let:8 a189 = a188[15:8] in
        let:8 a190 = a188[7:0] in
        let:16 a191 = (-1 + (a189,a190)) in
        M[a191] := B1;
        #return-to: 09B1
        advance (17)
        #09B2
        #instruction: PUSH DE
        let:8 a192 = a181 in
        let:8 a193 = a180 in
        let:8 a194 = a191[15:8] in
        let:8 a195 = a191[7:0] in
        let:16 a196 = (-1 + (a194,a195)) in
        M[a196] := a192;
        let:8 a197 = a196[15:8] in
        let:8 a198 = a196[7:0] in
        let:16 a199 = (-1 + (a197,a198)) in
        M[a199] := a193;
        advance (11)
        #09B3
        #instruction: PUSH PSW
        let:8 a200 = a185 in
        let:8 a201 = a199[15:8] in
        let:8 a202 = a199[7:0] in
        let:16 a203 = (-1 + (a201,a202)) in
        M[a203] := a200;
        let:8 a204 = a203[15:8] in
        let:8 a205 = a203[7:0] in
        let:16 a206 = (-1 + (a204,a205)) in
        M[a206] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a9[7:0][7]),6,is_zero(a9[7:0])),4,a12[7:0][4]),2,parity(a9[7:0])),0,!a9[15:8][0]);
        advance (11)
        #09B4
        #instruction: RRCA
        let:8 a207 = a185 in
        advance (4)
        #09B5
        #instruction: RRCA
        let:8 a208 = updateBit((a207 >> 01),7,a207[0]) in
        advance (4)
        #09B6
        #instruction: RRCA
        let:8 a209 = updateBit((a208 >> 01),7,a208[0]) in
        advance (4)
        #09B7
        #instruction: RRCA
        let:8 a210 = updateBit((a209 >> 01),7,a209[0]) in
        advance (4)
        #09B8
        #instruction: AND  0F
        let:8 a211 = updateBit((a210 >> 01),7,a210[0]) in
        let:8 a212 = (0F & a211) in
        let:8 a213 = (0F | a211) in
        advance (7)
        #09BA
        #instruction: CALL 09C5
        let:8 a214 = a206[15:8] in
        let:8 a215 = a206[7:0] in
        let:16 a216 = (-1 + (a214,a215)) in
        M[a216] := 09;
        let:8 a217 = a216[15:8] in
        let:8 a218 = a216[7:0] in
        let:16 a219 = (-1 + (a217,a218)) in
        M[a219] := BD;
        #return-to: 09BD
        advance (17)
        #09C5
        #instruction: ADD  1A
        let:8 a220 = a212 in
        let:16 a221 = addWithCarry(false,1A,a220) in
        let:8 a222 = (1A & 0F) in
        let:8 a223 = (a220 & 0F) in
        let:16 a224 = addWithCarry(false,a222,a223) in
        advance (7)
        #09C7
        #instruction: JP   08FF
        advance (10)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a225 = a183 in
        let:8 a226 = a184 in
        let:8 a227 = a219[15:8] in
        let:8 a228 = a219[7:0] in
        let:16 a229 = (-1 + (a227,a228)) in
        M[a229] := a225;
        let:8 a230 = a229[15:8] in
        let:8 a231 = a229[7:0] in
        let:16 a232 = (-1 + (a230,a231)) in
        M[a232] := a226;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        let:8 a233 = a221[7:0] in
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:8 a234 = a233 in
        let:8 a235 = a233 in
        let:17 a236 = add17((00,a234),(00,a235)) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a237 = a236[15:0][15:8] in
        let:8 a238 = a236[15:0][7:0] in
        let:8 a239 = a236[15:0][15:8] in
        let:8 a240 = a236[15:0][7:0] in
        let:17 a241 = add17((a237,a238),(a239,a240)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a242 = a241[15:0][15:8] in
        let:8 a243 = a241[15:0][7:0] in
        let:8 a244 = a241[15:0][15:8] in
        let:8 a245 = a241[15:0][7:0] in
        let:17 a246 = add17((a242,a243),(a244,a245)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a247 = a246[15:0][15:8] in
        let:8 a248 = a246[15:0][7:0] in
        let:17 a249 = add17(1E00,(a247,a248)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a250 = a249[15:0][15:8] in
        let:8 a251 = a249[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a252 = a232[15:8] in
        let:8 a253 = a232[7:0] in
        let:16 a254 = (1 + (a252,a253)) in
        let:8 a255 = M[(a252,a253)] in
        let:8 a256 = a254[15:8] in
        let:8 a257 = a254[7:0] in
        let:16 a258 = (1 + (a256,a257)) in
        let:8 a259 = M[(a256,a257)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        let:8 a260 = a221[7:0] in
        unknown_output(6,a260);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a261 = C in
        let:8 a262 = a258[15:8] in
        let:8 a263 = a258[7:0] in
        let:16 a264 = (-1 + (a262,a263)) in
        M[a264] := 08;
        let:8 a265 = a264[15:8] in
        let:8 a266 = a264[7:0] in
        let:16 a267 = (-1 + (a265,a266)) in
        M[a267] := a261;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a268 = a250 in
        let:8 a269 = a251 in
        let:8 a270 = M[(a268,a269)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a271 = a270 in
        let:8 a272 = a259 in
        let:8 a273 = a255 in
        M[(a272,a273)] := a271;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a274 = a250 in
        let:8 a275 = a251 in
        let:16 a276 = (1 + (a274,a275)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a277 = a259 in
        let:8 a278 = a255 in
        let:17 a279 = add17(0020,(a277,a278)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a280 = a267[15:8] in
        let:8 a281 = a267[7:0] in
        let:16 a282 = (1 + (a280,a281)) in
        let:8 a283 = M[(a280,a281)] in
        let:8 a284 = a282[15:8] in
        let:8 a285 = a282[7:0] in
        let:16 a286 = (1 + (a284,a285)) in
        let:8 a287 = M[(a284,a285)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a288 = a287 in
        let:16 a289 = addWithCarry(!true,a288,~00) in
        let:8 a290 = (a288 & 0F) in
        let:8 a291 = (~00 & 0F) in
        let:16 a292 = addWithCarry(!true,a290,a291) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a289[7:0])) {
          advance (10)
          A := a270;
          B := a289[7:0];
          C := a283;
          D := a276[15:8];
          E := a276[7:0];
          H := a279[15:0][15:8];
          L := a279[15:0][7:0];
          SPH := a286[15:8];
          SPL := a286[7:0];
          FlagS := a289[7:0][7];
          FlagZ := is_zero(a289[7:0]);
          FlagA := a292[7:0][4];
          FlagP := parity(a289[7:0]);
          FlagCY := a279[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a293 = a286[15:8] in
          let:8 a294 = a286[7:0] in
          let:16 a295 = (1 + (a293,a294)) in
          let:8 a296 = M[(a293,a294)] in
          let:8 a297 = a295[15:8] in
          let:8 a298 = a295[7:0] in
          let:16 a299 = (1 + (a297,a298)) in
          let:8 a300 = M[(a297,a298)] in
          advance (10)
          A := a270;
          B := a289[7:0];
          C := a283;
          D := a276[15:8];
          E := a276[7:0];
          H := a279[15:0][15:8];
          L := a279[15:0][7:0];
          SPH := a299[15:8];
          SPL := a299[7:0];
          FlagS := a289[7:0][7];
          FlagZ := is_zero(a289[7:0]);
          FlagA := a292[7:0][4];
          FlagP := parity(a289[7:0]);
          FlagCY := a279[16];
          jump ((a300,a296));
        }
      }
    }

1698:

    #1698
    #instruction: LD   A,(20CE)
    let:8 a1 = M[20CE] in
    advance (13)
    #169B
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #169C
    #instruction: JP   Z,16C9
    if (is_zero(a4)) {
      advance (10)
      #16C9
      #instruction: LD   HL,2D18
      advance (10)
      #16CC
      #instruction: LD   DE,1AA6
      advance (10)
      #16CF
      #instruction: LD   C,0A
      advance (7)
      #16D1
      #instruction: CALL 0A93
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 16;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := D4;
      #return-to: 16D4
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 1A;
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 0A;
      let:8 a21 = a20[15:8] in
      let:8 a22 = a20[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := 2D;
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:16 a29 = (-1 + (a27,a28)) in
      M[a29] := 18;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a30 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a31 = a30[15:0][15:8] in
      let:8 a32 = a30[15:0][7:0] in
      let:8 a33 = a30[15:0][15:8] in
      let:8 a34 = a30[15:0][7:0] in
      let:17 a35 = add17((a31,a32),(a33,a34)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a36 = a35[15:0][15:8] in
      let:8 a37 = a35[15:0][7:0] in
      let:8 a38 = a35[15:0][15:8] in
      let:8 a39 = a35[15:0][7:0] in
      let:17 a40 = add17((a36,a37),(a38,a39)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a41 = a40[15:0][15:8] in
      let:8 a42 = a40[15:0][7:0] in
      let:17 a43 = add17(1E00,(a41,a42)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a44 = a43[15:0][15:8] in
      let:8 a45 = a43[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a46 = a29[15:8] in
      let:8 a47 = a29[7:0] in
      let:16 a48 = (1 + (a46,a47)) in
      let:8 a49 = M[(a46,a47)] in
      let:8 a50 = a48[15:8] in
      let:8 a51 = a48[7:0] in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,06);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a54 = a52[15:8] in
      let:8 a55 = a52[7:0] in
      let:16 a56 = (-1 + (a54,a55)) in
      M[a56] := 08;
      let:8 a57 = a56[15:8] in
      let:8 a58 = a56[7:0] in
      let:16 a59 = (-1 + (a57,a58)) in
      M[a59] := 0A;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a60 = a44 in
      let:8 a61 = a45 in
      let:8 a62 = M[(a60,a61)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a63 = a62 in
      let:8 a64 = a53 in
      let:8 a65 = a49 in
      M[(a64,a65)] := a63;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a66 = a44 in
      let:8 a67 = a45 in
      let:16 a68 = (1 + (a66,a67)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a69 = a53 in
      let:8 a70 = a49 in
      let:17 a71 = add17(0020,(a69,a70)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a72 = a59[15:8] in
      let:8 a73 = a59[7:0] in
      let:16 a74 = (1 + (a72,a73)) in
      let:8 a75 = M[(a72,a73)] in
      let:8 a76 = a74[15:8] in
      let:8 a77 = a74[7:0] in
      let:16 a78 = (1 + (a76,a77)) in
      let:8 a79 = M[(a76,a77)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a80 = a79 in
      let:16 a81 = addWithCarry(!true,a80,~00) in
      let:8 a82 = (a80 & 0F) in
      let:8 a83 = (~00 & 0F) in
      let:16 a84 = addWithCarry(!true,a82,a83) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a81[7:0])) {
        advance (10)
        A := a62;
        B := a81[7:0];
        C := a75;
        D := a68[15:8];
        E := a68[7:0];
        H := a71[15:0][15:8];
        L := a71[15:0][7:0];
        SPH := a78[15:8];
        SPL := a78[7:0];
        FlagS := a81[7:0][7];
        FlagZ := is_zero(a81[7:0]);
        FlagA := a84[7:0][4];
        FlagP := parity(a81[7:0]);
        FlagCY := a71[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a85 = a78[15:8] in
        let:8 a86 = a78[7:0] in
        let:16 a87 = (1 + (a85,a86)) in
        let:8 a88 = M[(a85,a86)] in
        let:8 a89 = a87[15:8] in
        let:8 a90 = a87[7:0] in
        let:16 a91 = (1 + (a89,a90)) in
        let:8 a92 = M[(a89,a90)] in
        advance (10)
        A := a62;
        B := a81[7:0];
        C := a75;
        D := a68[15:8];
        E := a68[7:0];
        H := a71[15:0][15:8];
        L := a71[15:0][7:0];
        SPH := a91[15:8];
        SPL := a91[7:0];
        FlagS := a81[7:0][7];
        FlagZ := is_zero(a81[7:0]);
        FlagA := a84[7:0][4];
        FlagP := parity(a81[7:0]);
        FlagCY := a71[16];
        jump ((a92,a88));
      }
    } else {
      advance (10)
      #169F
      #instruction: LD   HL,2803
      advance (10)
      #16A2
      #instruction: LD   DE,1AA6
      advance (10)
      #16A5
      #instruction: LD   C,14
      advance (7)
      #16A7
      #instruction: CALL 0A93
      let:8 a93 = SPH in
      let:8 a94 = SPL in
      let:16 a95 = (-1 + (a93,a94)) in
      M[a95] := 16;
      let:8 a96 = a95[15:8] in
      let:8 a97 = a95[7:0] in
      let:16 a98 = (-1 + (a96,a97)) in
      M[a98] := AA;
      #return-to: 16AA
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a99 = a98[15:8] in
      let:8 a100 = a98[7:0] in
      let:16 a101 = (-1 + (a99,a100)) in
      M[a101] := 1A;
      let:8 a102 = a101[15:8] in
      let:8 a103 = a101[7:0] in
      let:16 a104 = (-1 + (a102,a103)) in
      M[a104] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a105 = a104[15:8] in
      let:8 a106 = a104[7:0] in
      let:16 a107 = (-1 + (a105,a106)) in
      M[a107] := 0A;
      let:8 a108 = a107[15:8] in
      let:8 a109 = a107[7:0] in
      let:16 a110 = (-1 + (a108,a109)) in
      M[a110] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a111 = a110[15:8] in
      let:8 a112 = a110[7:0] in
      let:16 a113 = (-1 + (a111,a112)) in
      M[a113] := 28;
      let:8 a114 = a113[15:8] in
      let:8 a115 = a113[7:0] in
      let:16 a116 = (-1 + (a114,a115)) in
      M[a116] := 03;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a117 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a118 = a117[15:0][15:8] in
      let:8 a119 = a117[15:0][7:0] in
      let:8 a120 = a117[15:0][15:8] in
      let:8 a121 = a117[15:0][7:0] in
      let:17 a122 = add17((a118,a119),(a120,a121)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a123 = a122[15:0][15:8] in
      let:8 a124 = a122[15:0][7:0] in
      let:8 a125 = a122[15:0][15:8] in
      let:8 a126 = a122[15:0][7:0] in
      let:17 a127 = add17((a123,a124),(a125,a126)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a128 = a127[15:0][15:8] in
      let:8 a129 = a127[15:0][7:0] in
      let:17 a130 = add17(1E00,(a128,a129)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a131 = a130[15:0][15:8] in
      let:8 a132 = a130[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a133 = a116[15:8] in
      let:8 a134 = a116[7:0] in
      let:16 a135 = (1 + (a133,a134)) in
      let:8 a136 = M[(a133,a134)] in
      let:8 a137 = a135[15:8] in
      let:8 a138 = a135[7:0] in
      let:16 a139 = (1 + (a137,a138)) in
      let:8 a140 = M[(a137,a138)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,06);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a141 = a139[15:8] in
      let:8 a142 = a139[7:0] in
      let:16 a143 = (-1 + (a141,a142)) in
      M[a143] := 08;
      let:8 a144 = a143[15:8] in
      let:8 a145 = a143[7:0] in
      let:16 a146 = (-1 + (a144,a145)) in
      M[a146] := 14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a147 = a131 in
      let:8 a148 = a132 in
      let:8 a149 = M[(a147,a148)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a150 = a149 in
      let:8 a151 = a140 in
      let:8 a152 = a136 in
      M[(a151,a152)] := a150;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a153 = a131 in
      let:8 a154 = a132 in
      let:16 a155 = (1 + (a153,a154)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a156 = a140 in
      let:8 a157 = a136 in
      let:17 a158 = add17(0020,(a156,a157)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a159 = a146[15:8] in
      let:8 a160 = a146[7:0] in
      let:16 a161 = (1 + (a159,a160)) in
      let:8 a162 = M[(a159,a160)] in
      let:8 a163 = a161[15:8] in
      let:8 a164 = a161[7:0] in
      let:16 a165 = (1 + (a163,a164)) in
      let:8 a166 = M[(a163,a164)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a167 = a166 in
      let:16 a168 = addWithCarry(!true,a167,~00) in
      let:8 a169 = (a167 & 0F) in
      let:8 a170 = (~00 & 0F) in
      let:16 a171 = addWithCarry(!true,a169,a170) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a168[7:0])) {
        advance (10)
        A := a149;
        B := a168[7:0];
        C := a162;
        D := a155[15:8];
        E := a155[7:0];
        H := a158[15:0][15:8];
        L := a158[15:0][7:0];
        SPH := a165[15:8];
        SPL := a165[7:0];
        FlagS := a168[7:0][7];
        FlagZ := is_zero(a168[7:0]);
        FlagA := a171[7:0][4];
        FlagP := parity(a168[7:0]);
        FlagCY := a158[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a172 = a165[15:8] in
        let:8 a173 = a165[7:0] in
        let:16 a174 = (1 + (a172,a173)) in
        let:8 a175 = M[(a172,a173)] in
        let:8 a176 = a174[15:8] in
        let:8 a177 = a174[7:0] in
        let:16 a178 = (1 + (a176,a177)) in
        let:8 a179 = M[(a176,a177)] in
        advance (10)
        A := a149;
        B := a168[7:0];
        C := a162;
        D := a155[15:8];
        E := a155[7:0];
        H := a158[15:0][15:8];
        L := a158[15:0][7:0];
        SPH := a178[15:8];
        SPL := a178[7:0];
        FlagS := a168[7:0][7];
        FlagZ := is_zero(a168[7:0]);
        FlagA := a171[7:0][4];
        FlagP := parity(a168[7:0]);
        FlagCY := a158[16];
        jump ((a179,a175));
      }
    }

16AA:

    #16AA
    #instruction: DEC  H
    let:8 a1 = H in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    #16AB
    #instruction: DEC  H
    let:8 a6 = a2[7:0] in
    let:16 a7 = addWithCarry(!true,a6,~00) in
    let:8 a8 = (a6 & 0F) in
    let:8 a9 = (~00 & 0F) in
    let:16 a10 = addWithCarry(!true,a8,a9) in
    advance (5)
    #16AC
    #instruction: LD   B,1B
    advance (7)
    #16AE
    #instruction: LD   A,(2067)
    let:8 a11 = M[2067] in
    advance (13)
    #16B1
    #instruction: RRCA
    let:8 a12 = a11 in
    advance (4)
    #16B2
    #instruction: JP   CY,16B7
    if (a12[0]) {
      advance (10)
      #16B7
      #instruction: LD   A,B
      advance (5)
      #16B8
      #instruction: CALL 08FF
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (-1 + (a13,a14)) in
      M[a15] := 16;
      let:8 a16 = a15[15:8] in
      let:8 a17 = a15[7:0] in
      let:16 a18 = (-1 + (a16,a17)) in
      M[a18] := BB;
      #return-to: 16BB
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a19 = a7[7:0] in
      let:8 a20 = L in
      let:8 a21 = a18[15:8] in
      let:8 a22 = a18[7:0] in
      let:16 a23 = (-1 + (a21,a22)) in
      M[a23] := a19;
      let:8 a24 = a23[15:8] in
      let:8 a25 = a23[7:0] in
      let:16 a26 = (-1 + (a24,a25)) in
      M[a26] := a20;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a27 = add17(001B,001B) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a28 = a27[15:0][15:8] in
      let:8 a29 = a27[15:0][7:0] in
      let:8 a30 = a27[15:0][15:8] in
      let:8 a31 = a27[15:0][7:0] in
      let:17 a32 = add17((a28,a29),(a30,a31)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a33 = a32[15:0][15:8] in
      let:8 a34 = a32[15:0][7:0] in
      let:8 a35 = a32[15:0][15:8] in
      let:8 a36 = a32[15:0][7:0] in
      let:17 a37 = add17((a33,a34),(a35,a36)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a38 = a37[15:0][15:8] in
      let:8 a39 = a37[15:0][7:0] in
      let:17 a40 = add17(1E00,(a38,a39)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a41 = a40[15:0][15:8] in
      let:8 a42 = a40[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a43 = a26[15:8] in
      let:8 a44 = a26[7:0] in
      let:16 a45 = (1 + (a43,a44)) in
      let:8 a46 = M[(a43,a44)] in
      let:8 a47 = a45[15:8] in
      let:8 a48 = a45[7:0] in
      let:16 a49 = (1 + (a47,a48)) in
      let:8 a50 = M[(a47,a48)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,1B);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a51 = C in
      let:8 a52 = a49[15:8] in
      let:8 a53 = a49[7:0] in
      let:16 a54 = (-1 + (a52,a53)) in
      M[a54] := 08;
      let:8 a55 = a54[15:8] in
      let:8 a56 = a54[7:0] in
      let:16 a57 = (-1 + (a55,a56)) in
      M[a57] := a51;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a58 = a41 in
      let:8 a59 = a42 in
      let:8 a60 = M[(a58,a59)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a61 = a60 in
      let:8 a62 = a50 in
      let:8 a63 = a46 in
      M[(a62,a63)] := a61;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a64 = a41 in
      let:8 a65 = a42 in
      let:16 a66 = (1 + (a64,a65)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a67 = a50 in
      let:8 a68 = a46 in
      let:17 a69 = add17(0020,(a67,a68)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a70 = a57[15:8] in
      let:8 a71 = a57[7:0] in
      let:16 a72 = (1 + (a70,a71)) in
      let:8 a73 = M[(a70,a71)] in
      let:8 a74 = a72[15:8] in
      let:8 a75 = a72[7:0] in
      let:16 a76 = (1 + (a74,a75)) in
      let:8 a77 = M[(a74,a75)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a78 = a77 in
      let:16 a79 = addWithCarry(!true,a78,~00) in
      let:8 a80 = (a78 & 0F) in
      let:8 a81 = (~00 & 0F) in
      let:16 a82 = addWithCarry(!true,a80,a81) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a79[7:0])) {
        advance (10)
        A := a60;
        B := a79[7:0];
        C := a73;
        D := a66[15:8];
        E := a66[7:0];
        H := a69[15:0][15:8];
        L := a69[15:0][7:0];
        SPH := a76[15:8];
        SPL := a76[7:0];
        FlagS := a79[7:0][7];
        FlagZ := is_zero(a79[7:0]);
        FlagA := a82[7:0][4];
        FlagP := parity(a79[7:0]);
        FlagCY := a69[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a83 = a76[15:8] in
        let:8 a84 = a76[7:0] in
        let:16 a85 = (1 + (a83,a84)) in
        let:8 a86 = M[(a83,a84)] in
        let:8 a87 = a85[15:8] in
        let:8 a88 = a85[7:0] in
        let:16 a89 = (1 + (a87,a88)) in
        let:8 a90 = M[(a87,a88)] in
        advance (10)
        A := a60;
        B := a79[7:0];
        C := a73;
        D := a66[15:8];
        E := a66[7:0];
        H := a69[15:0][15:8];
        L := a69[15:0][7:0];
        SPH := a89[15:8];
        SPL := a89[7:0];
        FlagS := a79[7:0][7];
        FlagZ := is_zero(a79[7:0]);
        FlagA := a82[7:0][4];
        FlagP := parity(a79[7:0]);
        FlagCY := a69[16];
        jump ((a90,a86));
      }
    } else {
      advance (10)
      #16B5
      #instruction: LD   B,1C
      advance (7)
      #16B7
      #instruction: LD   A,B
      advance (5)
      #16B8
      #instruction: CALL 08FF
      let:8 a91 = SPH in
      let:8 a92 = SPL in
      let:16 a93 = (-1 + (a91,a92)) in
      M[a93] := 16;
      let:8 a94 = a93[15:8] in
      let:8 a95 = a93[7:0] in
      let:16 a96 = (-1 + (a94,a95)) in
      M[a96] := BB;
      #return-to: 16BB
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a97 = a7[7:0] in
      let:8 a98 = L in
      let:8 a99 = a96[15:8] in
      let:8 a100 = a96[7:0] in
      let:16 a101 = (-1 + (a99,a100)) in
      M[a101] := a97;
      let:8 a102 = a101[15:8] in
      let:8 a103 = a101[7:0] in
      let:16 a104 = (-1 + (a102,a103)) in
      M[a104] := a98;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a105 = add17(001C,001C) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a106 = a105[15:0][15:8] in
      let:8 a107 = a105[15:0][7:0] in
      let:8 a108 = a105[15:0][15:8] in
      let:8 a109 = a105[15:0][7:0] in
      let:17 a110 = add17((a106,a107),(a108,a109)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a111 = a110[15:0][15:8] in
      let:8 a112 = a110[15:0][7:0] in
      let:8 a113 = a110[15:0][15:8] in
      let:8 a114 = a110[15:0][7:0] in
      let:17 a115 = add17((a111,a112),(a113,a114)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a116 = a115[15:0][15:8] in
      let:8 a117 = a115[15:0][7:0] in
      let:17 a118 = add17(1E00,(a116,a117)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a119 = a118[15:0][15:8] in
      let:8 a120 = a118[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a121 = a104[15:8] in
      let:8 a122 = a104[7:0] in
      let:16 a123 = (1 + (a121,a122)) in
      let:8 a124 = M[(a121,a122)] in
      let:8 a125 = a123[15:8] in
      let:8 a126 = a123[7:0] in
      let:16 a127 = (1 + (a125,a126)) in
      let:8 a128 = M[(a125,a126)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,1C);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a129 = C in
      let:8 a130 = a127[15:8] in
      let:8 a131 = a127[7:0] in
      let:16 a132 = (-1 + (a130,a131)) in
      M[a132] := 08;
      let:8 a133 = a132[15:8] in
      let:8 a134 = a132[7:0] in
      let:16 a135 = (-1 + (a133,a134)) in
      M[a135] := a129;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a136 = a119 in
      let:8 a137 = a120 in
      let:8 a138 = M[(a136,a137)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a139 = a138 in
      let:8 a140 = a128 in
      let:8 a141 = a124 in
      M[(a140,a141)] := a139;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a142 = a119 in
      let:8 a143 = a120 in
      let:16 a144 = (1 + (a142,a143)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a145 = a128 in
      let:8 a146 = a124 in
      let:17 a147 = add17(0020,(a145,a146)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a148 = a135[15:8] in
      let:8 a149 = a135[7:0] in
      let:16 a150 = (1 + (a148,a149)) in
      let:8 a151 = M[(a148,a149)] in
      let:8 a152 = a150[15:8] in
      let:8 a153 = a150[7:0] in
      let:16 a154 = (1 + (a152,a153)) in
      let:8 a155 = M[(a152,a153)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a156 = a155 in
      let:16 a157 = addWithCarry(!true,a156,~00) in
      let:8 a158 = (a156 & 0F) in
      let:8 a159 = (~00 & 0F) in
      let:16 a160 = addWithCarry(!true,a158,a159) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a157[7:0])) {
        advance (10)
        A := a138;
        B := a157[7:0];
        C := a151;
        D := a144[15:8];
        E := a144[7:0];
        H := a147[15:0][15:8];
        L := a147[15:0][7:0];
        SPH := a154[15:8];
        SPL := a154[7:0];
        FlagS := a157[7:0][7];
        FlagZ := is_zero(a157[7:0]);
        FlagA := a160[7:0][4];
        FlagP := parity(a157[7:0]);
        FlagCY := a147[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a161 = a154[15:8] in
        let:8 a162 = a154[7:0] in
        let:16 a163 = (1 + (a161,a162)) in
        let:8 a164 = M[(a161,a162)] in
        let:8 a165 = a163[15:8] in
        let:8 a166 = a163[7:0] in
        let:16 a167 = (1 + (a165,a166)) in
        let:8 a168 = M[(a165,a166)] in
        advance (10)
        A := a138;
        B := a157[7:0];
        C := a151;
        D := a144[15:8];
        E := a144[7:0];
        H := a147[15:0][15:8];
        L := a147[15:0][7:0];
        SPH := a167[15:8];
        SPL := a167[7:0];
        FlagS := a157[7:0][7];
        FlagZ := is_zero(a157[7:0]);
        FlagA := a160[7:0][4];
        FlagP := parity(a157[7:0]);
        FlagCY := a147[16];
        jump ((a168,a164));
      }
    }

16BB:

    #16BB
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := BE;
    #return-to: 16BE
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

16BE:

    #16BE
    #instruction: CALL 18E7
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := C1;
    #return-to: 16C1
    advance (17)
    #18E7
    #instruction: LD   A,(2067)
    let:8 a7 = M[2067] in
    advance (13)
    #18EA
    #instruction: LD   HL,20E7
    advance (10)
    #18ED
    #instruction: RRCA
    let:8 a8 = a7 in
    advance (4)
    #18EE
    #instruction: RET  NC
    if (!a8[0]) {
      let:8 a9 = a6[15:8] in
      let:8 a10 = a6[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (11)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E7;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagCY := a8[0];
      jump ((a16,a12));
    } else {
      advance (5)
      #18EF
      #instruction: INC  HL
      advance (5)
      #18F0
      #instruction: RET
      let:8 a17 = a6[15:8] in
      let:8 a18 = a6[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := updateBit((a8 >> 01),7,a8[0]);
      H := 20;
      L := E8;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagCY := a8[0];
      jump ((a24,a20));
    }

16C1:

    #16C1
    #instruction: LD   A,(HL)
    let:8 a1 = H in
    let:8 a2 = L in
    let:8 a3 = M[(a1,a2)] in
    advance (7)
    #16C2
    #instruction: AND  A
    let:8 a4 = a3 in
    let:8 a5 = a3 in
    let:8 a6 = (a4 & a5) in
    let:8 a7 = (a4 | a5) in
    advance (4)
    #16C3
    #instruction: JP   Z,16C9
    if (is_zero(a6)) {
      advance (10)
      #16C9
      #instruction: LD   HL,2D18
      advance (10)
      #16CC
      #instruction: LD   DE,1AA6
      advance (10)
      #16CF
      #instruction: LD   C,0A
      advance (7)
      #16D1
      #instruction: CALL 0A93
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 16;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := D4;
      #return-to: 16D4
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a14 = a13[15:8] in
      let:8 a15 = a13[7:0] in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := 1A;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := A6;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := 0A;
      let:8 a23 = a22[15:8] in
      let:8 a24 = a22[7:0] in
      let:16 a25 = (-1 + (a23,a24)) in
      M[a25] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a26 = a25[15:8] in
      let:8 a27 = a25[7:0] in
      let:16 a28 = (-1 + (a26,a27)) in
      M[a28] := 2D;
      let:8 a29 = a28[15:8] in
      let:8 a30 = a28[7:0] in
      let:16 a31 = (-1 + (a29,a30)) in
      M[a31] := 18;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:17 a32 = add17(0006,0006) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a33 = a32[15:0][15:8] in
      let:8 a34 = a32[15:0][7:0] in
      let:8 a35 = a32[15:0][15:8] in
      let:8 a36 = a32[15:0][7:0] in
      let:17 a37 = add17((a33,a34),(a35,a36)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a38 = a37[15:0][15:8] in
      let:8 a39 = a37[15:0][7:0] in
      let:8 a40 = a37[15:0][15:8] in
      let:8 a41 = a37[15:0][7:0] in
      let:17 a42 = add17((a38,a39),(a40,a41)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a43 = a42[15:0][15:8] in
      let:8 a44 = a42[15:0][7:0] in
      let:17 a45 = add17(1E00,(a43,a44)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a46 = a45[15:0][15:8] in
      let:8 a47 = a45[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a48 = a31[15:8] in
      let:8 a49 = a31[7:0] in
      let:16 a50 = (1 + (a48,a49)) in
      let:8 a51 = M[(a48,a49)] in
      let:8 a52 = a50[15:8] in
      let:8 a53 = a50[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      unknown_output(6,06);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (-1 + (a56,a57)) in
      M[a58] := 08;
      let:8 a59 = a58[15:8] in
      let:8 a60 = a58[7:0] in
      let:16 a61 = (-1 + (a59,a60)) in
      M[a61] := 0A;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a62 = a46 in
      let:8 a63 = a47 in
      let:8 a64 = M[(a62,a63)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a65 = a64 in
      let:8 a66 = a55 in
      let:8 a67 = a51 in
      M[(a66,a67)] := a65;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a68 = a46 in
      let:8 a69 = a47 in
      let:16 a70 = (1 + (a68,a69)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a71 = a55 in
      let:8 a72 = a51 in
      let:17 a73 = add17(0020,(a71,a72)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a74 = a61[15:8] in
      let:8 a75 = a61[7:0] in
      let:16 a76 = (1 + (a74,a75)) in
      let:8 a77 = M[(a74,a75)] in
      let:8 a78 = a76[15:8] in
      let:8 a79 = a76[7:0] in
      let:16 a80 = (1 + (a78,a79)) in
      let:8 a81 = M[(a78,a79)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a82 = a81 in
      let:16 a83 = addWithCarry(!true,a82,~00) in
      let:8 a84 = (a82 & 0F) in
      let:8 a85 = (~00 & 0F) in
      let:16 a86 = addWithCarry(!true,a84,a85) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a83[7:0])) {
        advance (10)
        A := a64;
        B := a83[7:0];
        C := a77;
        D := a70[15:8];
        E := a70[7:0];
        H := a73[15:0][15:8];
        L := a73[15:0][7:0];
        SPH := a80[15:8];
        SPL := a80[7:0];
        FlagS := a83[7:0][7];
        FlagZ := is_zero(a83[7:0]);
        FlagA := a86[7:0][4];
        FlagP := parity(a83[7:0]);
        FlagCY := a73[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a87 = a80[15:8] in
        let:8 a88 = a80[7:0] in
        let:16 a89 = (1 + (a87,a88)) in
        let:8 a90 = M[(a87,a88)] in
        let:8 a91 = a89[15:8] in
        let:8 a92 = a89[7:0] in
        let:16 a93 = (1 + (a91,a92)) in
        let:8 a94 = M[(a91,a92)] in
        advance (10)
        A := a64;
        B := a83[7:0];
        C := a77;
        D := a70[15:8];
        E := a70[7:0];
        H := a73[15:0][15:8];
        L := a73[15:0][7:0];
        SPH := a93[15:8];
        SPL := a93[7:0];
        FlagS := a83[7:0][7];
        FlagZ := is_zero(a83[7:0]);
        FlagA := a86[7:0][4];
        FlagP := parity(a83[7:0]);
        FlagCY := a73[16];
        jump ((a94,a90));
      }
    } else {
      advance (10)
      #16C6
      #instruction: JP   02ED
      advance (10)
      #02ED
      #instruction: LD   A,(2067)
      let:8 a95 = M[2067] in
      advance (13)
      #02F0
      #instruction: PUSH PSW
      let:8 a96 = a95 in
      let:8 a97 = SPH in
      let:8 a98 = SPL in
      let:16 a99 = (-1 + (a97,a98)) in
      M[a99] := a96;
      let:8 a100 = a99[15:8] in
      let:8 a101 = a99[7:0] in
      let:16 a102 = (-1 + (a100,a101)) in
      M[a102] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a6[7]),6,is_zero(a6)),4,a7[3]),2,parity(a6)),0,false);
      advance (11)
      #02F1
      #instruction: RRCA
      let:8 a103 = a95 in
      advance (4)
      #02F2
      #instruction: JP   CY,0332
      if (a103[0]) {
        advance (10)
        #0332
        #instruction: CALL 0209
        let:8 a104 = a102[15:8] in
        let:8 a105 = a102[7:0] in
        let:16 a106 = (-1 + (a104,a105)) in
        M[a106] := 03;
        let:8 a107 = a106[15:8] in
        let:8 a108 = a106[7:0] in
        let:16 a109 = (-1 + (a107,a108)) in
        M[a109] := 35;
        #return-to: 0335
        advance (17)
        #0209
        #instruction: LD   A,01
        advance (7)
        #020B
        #instruction: JP   021B
        advance (10)
        #021B
        #instruction: LD   DE,2142
        advance (10)
        #021E
        #instruction: LD   (2081),A
        M[2081] := 01;
        advance (13)
        #0221
        #instruction: LD   BC,1602
        advance (10)
        #0224
        #instruction: LD   HL,2806
        advance (10)
        #0227
        #instruction: LD   A,04
        advance (7)
        #0229
        #instruction: PUSH PSW
        let:8 a110 = a109[15:8] in
        let:8 a111 = a109[7:0] in
        let:16 a112 = (-1 + (a110,a111)) in
        M[a112] := 04;
        let:8 a113 = a112[15:8] in
        let:8 a114 = a112[7:0] in
        let:16 a115 = (-1 + (a113,a114)) in
        M[a115] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a6[7]),6,is_zero(a6)),4,a7[3]),2,parity(a6)),0,a103[0]);
        advance (11)
        #022A
        #instruction: PUSH BC
        let:8 a116 = a115[15:8] in
        let:8 a117 = a115[7:0] in
        let:16 a118 = (-1 + (a116,a117)) in
        M[a118] := 16;
        let:8 a119 = a118[15:8] in
        let:8 a120 = a118[7:0] in
        let:16 a121 = (-1 + (a119,a120)) in
        M[a121] := 02;
        advance (11)
        #022B
        #instruction: LD   A,(2081)
        let:8 a122 = M[2081] in
        advance (13)
        #022E
        #instruction: AND  A
        let:8 a123 = a122 in
        let:8 a124 = a122 in
        let:8 a125 = (a123 & a124) in
        let:8 a126 = (a123 | a124) in
        advance (4)
        #022F
        #instruction: JP   NZ,0242
        if (!is_zero(a125)) {
          advance (10)
          #0242
          #instruction: CALL 147C
          let:8 a127 = a121[15:8] in
          let:8 a128 = a121[7:0] in
          let:16 a129 = (-1 + (a127,a128)) in
          M[a129] := 02;
          let:8 a130 = a129[15:8] in
          let:8 a131 = a129[7:0] in
          let:16 a132 = (-1 + (a130,a131)) in
          M[a132] := 45;
          #return-to: 0245
          advance (17)
          #147C
          #instruction: PUSH BC
          let:8 a133 = a132[15:8] in
          let:8 a134 = a132[7:0] in
          let:16 a135 = (-1 + (a133,a134)) in
          M[a135] := 16;
          let:8 a136 = a135[15:8] in
          let:8 a137 = a135[7:0] in
          let:16 a138 = (-1 + (a136,a137)) in
          M[a138] := 02;
          advance (11)
          #147D
          #instruction: PUSH HL
          let:8 a139 = a138[15:8] in
          let:8 a140 = a138[7:0] in
          let:16 a141 = (-1 + (a139,a140)) in
          M[a141] := 28;
          let:8 a142 = a141[15:8] in
          let:8 a143 = a141[7:0] in
          let:16 a144 = (-1 + (a142,a143)) in
          M[a144] := 06;
          advance (11)
          #147E
          #instruction: LD   A,(HL)
          let:8 a145 = M[2806] in
          advance (7)
          #147F
          #instruction: LD   (DE),A
          let:8 a146 = a145 in
          M[2142] := a146;
          advance (7)
          #1480
          #instruction: INC  DE
          advance (5)
          #1481
          #instruction: INC  HL
          advance (5)
          #1482
          #instruction: DEC  C
          let:16 a147 = addWithCarry(!true,02,~00) in
          let:8 a148 = (02 & 0F) in
          let:8 a149 = (~00 & 0F) in
          let:16 a150 = addWithCarry(!true,a148,a149) in
          advance (5)
          #1483
          #instruction: JP   NZ,147E
          if (!is_zero(a147[7:0])) {
            advance (10)
            A := a145;
            B := 16;
            C := a147[7:0];
            D := 21;
            E := 43;
            H := 28;
            L := 07;
            SPH := a144[15:8];
            SPL := a144[7:0];
            FlagS := a147[7:0][7];
            FlagZ := is_zero(a147[7:0]);
            FlagA := a150[7:0][4];
            FlagP := parity(a147[7:0]);
            FlagCY := false;
            jump (147E);
          } else {
            advance (10)
            #1486
            #instruction: POP  HL
            let:8 a151 = a144[15:8] in
            let:8 a152 = a144[7:0] in
            let:16 a153 = (1 + (a151,a152)) in
            let:8 a154 = M[(a151,a152)] in
            let:8 a155 = a153[15:8] in
            let:8 a156 = a153[7:0] in
            let:16 a157 = (1 + (a155,a156)) in
            let:8 a158 = M[(a155,a156)] in
            advance (10)
            #1487
            #instruction: LD   BC,0020
            advance (10)
            #148A
            #instruction: ADD  HL,BC
            let:8 a159 = a158 in
            let:8 a160 = a154 in
            let:17 a161 = add17(0020,(a159,a160)) in
            advance (10)
            #148B
            #instruction: POP  BC
            let:8 a162 = a157[15:8] in
            let:8 a163 = a157[7:0] in
            let:16 a164 = (1 + (a162,a163)) in
            let:8 a165 = M[(a162,a163)] in
            let:8 a166 = a164[15:8] in
            let:8 a167 = a164[7:0] in
            let:16 a168 = (1 + (a166,a167)) in
            let:8 a169 = M[(a166,a167)] in
            advance (10)
            #148C
            #instruction: DEC  B
            let:8 a170 = a169 in
            let:16 a171 = addWithCarry(!true,a170,~00) in
            let:8 a172 = (a170 & 0F) in
            let:8 a173 = (~00 & 0F) in
            let:16 a174 = addWithCarry(!true,a172,a173) in
            advance (5)
            #148D
            #instruction: JP   NZ,147C
            if (!is_zero(a171[7:0])) {
              advance (10)
              A := a145;
              B := a171[7:0];
              C := a165;
              D := 21;
              E := 43;
              H := a161[15:0][15:8];
              L := a161[15:0][7:0];
              SPH := a168[15:8];
              SPL := a168[7:0];
              FlagS := a171[7:0][7];
              FlagZ := is_zero(a171[7:0]);
              FlagA := a174[7:0][4];
              FlagP := parity(a171[7:0]);
              FlagCY := a161[16];
              jump (147C);
            } else {
              advance (10)
              #1490
              #instruction: RET
              let:8 a175 = a168[15:8] in
              let:8 a176 = a168[7:0] in
              let:16 a177 = (1 + (a175,a176)) in
              let:8 a178 = M[(a175,a176)] in
              let:8 a179 = a177[15:8] in
              let:8 a180 = a177[7:0] in
              let:16 a181 = (1 + (a179,a180)) in
              let:8 a182 = M[(a179,a180)] in
              advance (10)
              A := a145;
              B := a171[7:0];
              C := a165;
              D := 21;
              E := 43;
              H := a161[15:0][15:8];
              L := a161[15:0][7:0];
              SPH := a181[15:8];
              SPL := a181[7:0];
              FlagS := a171[7:0][7];
              FlagZ := is_zero(a171[7:0]);
              FlagA := a174[7:0][4];
              FlagP := parity(a171[7:0]);
              FlagCY := a161[16];
              jump ((a182,a178));
            }
          }
        } else {
          advance (10)
          #0232
          #instruction: CALL 1A69
          let:8 a183 = a121[15:8] in
          let:8 a184 = a121[7:0] in
          let:16 a185 = (-1 + (a183,a184)) in
          M[a185] := 02;
          let:8 a186 = a185[15:8] in
          let:8 a187 = a185[7:0] in
          let:16 a188 = (-1 + (a186,a187)) in
          M[a188] := 35;
          #return-to: 0235
          advance (17)
          #1A69
          #instruction: PUSH BC
          let:8 a189 = a188[15:8] in
          let:8 a190 = a188[7:0] in
          let:16 a191 = (-1 + (a189,a190)) in
          M[a191] := 16;
          let:8 a192 = a191[15:8] in
          let:8 a193 = a191[7:0] in
          let:16 a194 = (-1 + (a192,a193)) in
          M[a194] := 02;
          advance (11)
          #1A6A
          #instruction: PUSH HL
          let:8 a195 = a194[15:8] in
          let:8 a196 = a194[7:0] in
          let:16 a197 = (-1 + (a195,a196)) in
          M[a197] := 28;
          let:8 a198 = a197[15:8] in
          let:8 a199 = a197[7:0] in
          let:16 a200 = (-1 + (a198,a199)) in
          M[a200] := 06;
          advance (11)
          #1A6B
          #instruction: LD   A,(DE)
          let:8 a201 = M[2142] in
          advance (7)
          #1A6C
          #instruction: OR   (HL)
          let:8 a202 = M[2806] in
          let:8 a203 = a201 in
          let:8 a204 = (a202 | a203) in
          advance (7)
          #1A6D
          #instruction: LD   (HL),A
          let:8 a205 = a204 in
          M[2806] := a205;
          advance (7)
          #1A6E
          #instruction: INC  DE
          advance (5)
          #1A6F
          #instruction: INC  HL
          advance (5)
          #1A70
          #instruction: DEC  C
          let:16 a206 = addWithCarry(!true,02,~00) in
          let:8 a207 = (02 & 0F) in
          let:8 a208 = (~00 & 0F) in
          let:16 a209 = addWithCarry(!true,a207,a208) in
          advance (5)
          #1A71
          #instruction: JP   NZ,1A6B
          if (!is_zero(a206[7:0])) {
            advance (10)
            A := a204;
            B := 16;
            C := a206[7:0];
            D := 21;
            E := 43;
            H := 28;
            L := 07;
            SPH := a200[15:8];
            SPL := a200[7:0];
            FlagS := a206[7:0][7];
            FlagZ := is_zero(a206[7:0]);
            FlagA := a209[7:0][4];
            FlagP := parity(a206[7:0]);
            FlagCY := false;
            jump (1A6B);
          } else {
            advance (10)
            #1A74
            #instruction: POP  HL
            let:8 a210 = a200[15:8] in
            let:8 a211 = a200[7:0] in
            let:16 a212 = (1 + (a210,a211)) in
            let:8 a213 = M[(a210,a211)] in
            let:8 a214 = a212[15:8] in
            let:8 a215 = a212[7:0] in
            let:16 a216 = (1 + (a214,a215)) in
            let:8 a217 = M[(a214,a215)] in
            advance (10)
            #1A75
            #instruction: LD   BC,0020
            advance (10)
            #1A78
            #instruction: ADD  HL,BC
            let:8 a218 = a217 in
            let:8 a219 = a213 in
            let:17 a220 = add17(0020,(a218,a219)) in
            advance (10)
            #1A79
            #instruction: POP  BC
            let:8 a221 = a216[15:8] in
            let:8 a222 = a216[7:0] in
            let:16 a223 = (1 + (a221,a222)) in
            let:8 a224 = M[(a221,a222)] in
            let:8 a225 = a223[15:8] in
            let:8 a226 = a223[7:0] in
            let:16 a227 = (1 + (a225,a226)) in
            let:8 a228 = M[(a225,a226)] in
            advance (10)
            #1A7A
            #instruction: DEC  B
            let:8 a229 = a228 in
            let:16 a230 = addWithCarry(!true,a229,~00) in
            let:8 a231 = (a229 & 0F) in
            let:8 a232 = (~00 & 0F) in
            let:16 a233 = addWithCarry(!true,a231,a232) in
            advance (5)
            #1A7B
            #instruction: JP   NZ,1A69
            if (!is_zero(a230[7:0])) {
              advance (10)
              A := a204;
              B := a230[7:0];
              C := a224;
              D := 21;
              E := 43;
              H := a220[15:0][15:8];
              L := a220[15:0][7:0];
              SPH := a227[15:8];
              SPL := a227[7:0];
              FlagS := a230[7:0][7];
              FlagZ := is_zero(a230[7:0]);
              FlagA := a233[7:0][4];
              FlagP := parity(a230[7:0]);
              FlagCY := a220[16];
              jump (1A69);
            } else {
              advance (10)
              #1A7E
              #instruction: RET
              let:8 a234 = a227[15:8] in
              let:8 a235 = a227[7:0] in
              let:16 a236 = (1 + (a234,a235)) in
              let:8 a237 = M[(a234,a235)] in
              let:8 a238 = a236[15:8] in
              let:8 a239 = a236[7:0] in
              let:16 a240 = (1 + (a238,a239)) in
              let:8 a241 = M[(a238,a239)] in
              advance (10)
              A := a204;
              B := a230[7:0];
              C := a224;
              D := 21;
              E := 43;
              H := a220[15:0][15:8];
              L := a220[15:0][7:0];
              SPH := a240[15:8];
              SPL := a240[7:0];
              FlagS := a230[7:0][7];
              FlagZ := is_zero(a230[7:0]);
              FlagA := a233[7:0][4];
              FlagP := parity(a230[7:0]);
              FlagCY := a220[16];
              jump ((a241,a237));
            }
          }
        }
      } else {
        advance (10)
        #02F5
        #instruction: CALL 020E
        let:8 a242 = a102[15:8] in
        let:8 a243 = a102[7:0] in
        let:16 a244 = (-1 + (a242,a243)) in
        M[a244] := 02;
        let:8 a245 = a244[15:8] in
        let:8 a246 = a244[7:0] in
        let:16 a247 = (-1 + (a245,a246)) in
        M[a247] := F8;
        #return-to: 02F8
        advance (17)
        #020E
        #instruction: LD   A,01
        advance (7)
        #0210
        #instruction: JP   0214
        advance (10)
        #0214
        #instruction: LD   DE,2242
        advance (10)
        #0217
        #instruction: JP   021E
        advance (10)
        #021E
        #instruction: LD   (2081),A
        M[2081] := 01;
        advance (13)
        #0221
        #instruction: LD   BC,1602
        advance (10)
        #0224
        #instruction: LD   HL,2806
        advance (10)
        #0227
        #instruction: LD   A,04
        advance (7)
        #0229
        #instruction: PUSH PSW
        let:8 a248 = a247[15:8] in
        let:8 a249 = a247[7:0] in
        let:16 a250 = (-1 + (a248,a249)) in
        M[a250] := 04;
        let:8 a251 = a250[15:8] in
        let:8 a252 = a250[7:0] in
        let:16 a253 = (-1 + (a251,a252)) in
        M[a253] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a6[7]),6,is_zero(a6)),4,a7[3]),2,parity(a6)),0,a103[0]);
        advance (11)
        #022A
        #instruction: PUSH BC
        let:8 a254 = a253[15:8] in
        let:8 a255 = a253[7:0] in
        let:16 a256 = (-1 + (a254,a255)) in
        M[a256] := 16;
        let:8 a257 = a256[15:8] in
        let:8 a258 = a256[7:0] in
        let:16 a259 = (-1 + (a257,a258)) in
        M[a259] := 02;
        advance (11)
        #022B
        #instruction: LD   A,(2081)
        let:8 a260 = M[2081] in
        advance (13)
        #022E
        #instruction: AND  A
        let:8 a261 = a260 in
        let:8 a262 = a260 in
        let:8 a263 = (a261 & a262) in
        let:8 a264 = (a261 | a262) in
        advance (4)
        #022F
        #instruction: JP   NZ,0242
        if (!is_zero(a263)) {
          advance (10)
          #0242
          #instruction: CALL 147C
          let:8 a265 = a259[15:8] in
          let:8 a266 = a259[7:0] in
          let:16 a267 = (-1 + (a265,a266)) in
          M[a267] := 02;
          let:8 a268 = a267[15:8] in
          let:8 a269 = a267[7:0] in
          let:16 a270 = (-1 + (a268,a269)) in
          M[a270] := 45;
          #return-to: 0245
          advance (17)
          #147C
          #instruction: PUSH BC
          let:8 a271 = a270[15:8] in
          let:8 a272 = a270[7:0] in
          let:16 a273 = (-1 + (a271,a272)) in
          M[a273] := 16;
          let:8 a274 = a273[15:8] in
          let:8 a275 = a273[7:0] in
          let:16 a276 = (-1 + (a274,a275)) in
          M[a276] := 02;
          advance (11)
          #147D
          #instruction: PUSH HL
          let:8 a277 = a276[15:8] in
          let:8 a278 = a276[7:0] in
          let:16 a279 = (-1 + (a277,a278)) in
          M[a279] := 28;
          let:8 a280 = a279[15:8] in
          let:8 a281 = a279[7:0] in
          let:16 a282 = (-1 + (a280,a281)) in
          M[a282] := 06;
          advance (11)
          #147E
          #instruction: LD   A,(HL)
          let:8 a283 = M[2806] in
          advance (7)
          #147F
          #instruction: LD   (DE),A
          let:8 a284 = a283 in
          M[2242] := a284;
          advance (7)
          #1480
          #instruction: INC  DE
          advance (5)
          #1481
          #instruction: INC  HL
          advance (5)
          #1482
          #instruction: DEC  C
          let:16 a285 = addWithCarry(!true,02,~00) in
          let:8 a286 = (02 & 0F) in
          let:8 a287 = (~00 & 0F) in
          let:16 a288 = addWithCarry(!true,a286,a287) in
          advance (5)
          #1483
          #instruction: JP   NZ,147E
          if (!is_zero(a285[7:0])) {
            advance (10)
            A := a283;
            B := 16;
            C := a285[7:0];
            D := 22;
            E := 43;
            H := 28;
            L := 07;
            SPH := a282[15:8];
            SPL := a282[7:0];
            FlagS := a285[7:0][7];
            FlagZ := is_zero(a285[7:0]);
            FlagA := a288[7:0][4];
            FlagP := parity(a285[7:0]);
            FlagCY := false;
            jump (147E);
          } else {
            advance (10)
            #1486
            #instruction: POP  HL
            let:8 a289 = a282[15:8] in
            let:8 a290 = a282[7:0] in
            let:16 a291 = (1 + (a289,a290)) in
            let:8 a292 = M[(a289,a290)] in
            let:8 a293 = a291[15:8] in
            let:8 a294 = a291[7:0] in
            let:16 a295 = (1 + (a293,a294)) in
            let:8 a296 = M[(a293,a294)] in
            advance (10)
            #1487
            #instruction: LD   BC,0020
            advance (10)
            #148A
            #instruction: ADD  HL,BC
            let:8 a297 = a296 in
            let:8 a298 = a292 in
            let:17 a299 = add17(0020,(a297,a298)) in
            advance (10)
            #148B
            #instruction: POP  BC
            let:8 a300 = a295[15:8] in
            let:8 a301 = a295[7:0] in
            let:16 a302 = (1 + (a300,a301)) in
            let:8 a303 = M[(a300,a301)] in
            let:8 a304 = a302[15:8] in
            let:8 a305 = a302[7:0] in
            let:16 a306 = (1 + (a304,a305)) in
            let:8 a307 = M[(a304,a305)] in
            advance (10)
            #148C
            #instruction: DEC  B
            let:8 a308 = a307 in
            let:16 a309 = addWithCarry(!true,a308,~00) in
            let:8 a310 = (a308 & 0F) in
            let:8 a311 = (~00 & 0F) in
            let:16 a312 = addWithCarry(!true,a310,a311) in
            advance (5)
            #148D
            #instruction: JP   NZ,147C
            if (!is_zero(a309[7:0])) {
              advance (10)
              A := a283;
              B := a309[7:0];
              C := a303;
              D := 22;
              E := 43;
              H := a299[15:0][15:8];
              L := a299[15:0][7:0];
              SPH := a306[15:8];
              SPL := a306[7:0];
              FlagS := a309[7:0][7];
              FlagZ := is_zero(a309[7:0]);
              FlagA := a312[7:0][4];
              FlagP := parity(a309[7:0]);
              FlagCY := a299[16];
              jump (147C);
            } else {
              advance (10)
              #1490
              #instruction: RET
              let:8 a313 = a306[15:8] in
              let:8 a314 = a306[7:0] in
              let:16 a315 = (1 + (a313,a314)) in
              let:8 a316 = M[(a313,a314)] in
              let:8 a317 = a315[15:8] in
              let:8 a318 = a315[7:0] in
              let:16 a319 = (1 + (a317,a318)) in
              let:8 a320 = M[(a317,a318)] in
              advance (10)
              A := a283;
              B := a309[7:0];
              C := a303;
              D := 22;
              E := 43;
              H := a299[15:0][15:8];
              L := a299[15:0][7:0];
              SPH := a319[15:8];
              SPL := a319[7:0];
              FlagS := a309[7:0][7];
              FlagZ := is_zero(a309[7:0]);
              FlagA := a312[7:0][4];
              FlagP := parity(a309[7:0]);
              FlagCY := a299[16];
              jump ((a320,a316));
            }
          }
        } else {
          advance (10)
          #0232
          #instruction: CALL 1A69
          let:8 a321 = a259[15:8] in
          let:8 a322 = a259[7:0] in
          let:16 a323 = (-1 + (a321,a322)) in
          M[a323] := 02;
          let:8 a324 = a323[15:8] in
          let:8 a325 = a323[7:0] in
          let:16 a326 = (-1 + (a324,a325)) in
          M[a326] := 35;
          #return-to: 0235
          advance (17)
          #1A69
          #instruction: PUSH BC
          let:8 a327 = a326[15:8] in
          let:8 a328 = a326[7:0] in
          let:16 a329 = (-1 + (a327,a328)) in
          M[a329] := 16;
          let:8 a330 = a329[15:8] in
          let:8 a331 = a329[7:0] in
          let:16 a332 = (-1 + (a330,a331)) in
          M[a332] := 02;
          advance (11)
          #1A6A
          #instruction: PUSH HL
          let:8 a333 = a332[15:8] in
          let:8 a334 = a332[7:0] in
          let:16 a335 = (-1 + (a333,a334)) in
          M[a335] := 28;
          let:8 a336 = a335[15:8] in
          let:8 a337 = a335[7:0] in
          let:16 a338 = (-1 + (a336,a337)) in
          M[a338] := 06;
          advance (11)
          #1A6B
          #instruction: LD   A,(DE)
          let:8 a339 = M[2242] in
          advance (7)
          #1A6C
          #instruction: OR   (HL)
          let:8 a340 = M[2806] in
          let:8 a341 = a339 in
          let:8 a342 = (a340 | a341) in
          advance (7)
          #1A6D
          #instruction: LD   (HL),A
          let:8 a343 = a342 in
          M[2806] := a343;
          advance (7)
          #1A6E
          #instruction: INC  DE
          advance (5)
          #1A6F
          #instruction: INC  HL
          advance (5)
          #1A70
          #instruction: DEC  C
          let:16 a344 = addWithCarry(!true,02,~00) in
          let:8 a345 = (02 & 0F) in
          let:8 a346 = (~00 & 0F) in
          let:16 a347 = addWithCarry(!true,a345,a346) in
          advance (5)
          #1A71
          #instruction: JP   NZ,1A6B
          if (!is_zero(a344[7:0])) {
            advance (10)
            A := a342;
            B := 16;
            C := a344[7:0];
            D := 22;
            E := 43;
            H := 28;
            L := 07;
            SPH := a338[15:8];
            SPL := a338[7:0];
            FlagS := a344[7:0][7];
            FlagZ := is_zero(a344[7:0]);
            FlagA := a347[7:0][4];
            FlagP := parity(a344[7:0]);
            FlagCY := false;
            jump (1A6B);
          } else {
            advance (10)
            #1A74
            #instruction: POP  HL
            let:8 a348 = a338[15:8] in
            let:8 a349 = a338[7:0] in
            let:16 a350 = (1 + (a348,a349)) in
            let:8 a351 = M[(a348,a349)] in
            let:8 a352 = a350[15:8] in
            let:8 a353 = a350[7:0] in
            let:16 a354 = (1 + (a352,a353)) in
            let:8 a355 = M[(a352,a353)] in
            advance (10)
            #1A75
            #instruction: LD   BC,0020
            advance (10)
            #1A78
            #instruction: ADD  HL,BC
            let:8 a356 = a355 in
            let:8 a357 = a351 in
            let:17 a358 = add17(0020,(a356,a357)) in
            advance (10)
            #1A79
            #instruction: POP  BC
            let:8 a359 = a354[15:8] in
            let:8 a360 = a354[7:0] in
            let:16 a361 = (1 + (a359,a360)) in
            let:8 a362 = M[(a359,a360)] in
            let:8 a363 = a361[15:8] in
            let:8 a364 = a361[7:0] in
            let:16 a365 = (1 + (a363,a364)) in
            let:8 a366 = M[(a363,a364)] in
            advance (10)
            #1A7A
            #instruction: DEC  B
            let:8 a367 = a366 in
            let:16 a368 = addWithCarry(!true,a367,~00) in
            let:8 a369 = (a367 & 0F) in
            let:8 a370 = (~00 & 0F) in
            let:16 a371 = addWithCarry(!true,a369,a370) in
            advance (5)
            #1A7B
            #instruction: JP   NZ,1A69
            if (!is_zero(a368[7:0])) {
              advance (10)
              A := a342;
              B := a368[7:0];
              C := a362;
              D := 22;
              E := 43;
              H := a358[15:0][15:8];
              L := a358[15:0][7:0];
              SPH := a365[15:8];
              SPL := a365[7:0];
              FlagS := a368[7:0][7];
              FlagZ := is_zero(a368[7:0]);
              FlagA := a371[7:0][4];
              FlagP := parity(a368[7:0]);
              FlagCY := a358[16];
              jump (1A69);
            } else {
              advance (10)
              #1A7E
              #instruction: RET
              let:8 a372 = a365[15:8] in
              let:8 a373 = a365[7:0] in
              let:16 a374 = (1 + (a372,a373)) in
              let:8 a375 = M[(a372,a373)] in
              let:8 a376 = a374[15:8] in
              let:8 a377 = a374[7:0] in
              let:16 a378 = (1 + (a376,a377)) in
              let:8 a379 = M[(a376,a377)] in
              advance (10)
              A := a342;
              B := a368[7:0];
              C := a362;
              D := 22;
              E := 43;
              H := a358[15:0][15:8];
              L := a358[15:0][7:0];
              SPH := a378[15:8];
              SPL := a378[7:0];
              FlagS := a368[7:0][7];
              FlagZ := is_zero(a368[7:0]);
              FlagA := a371[7:0][4];
              FlagP := parity(a368[7:0]);
              FlagCY := a358[16];
              jump ((a379,a375));
            }
          }
        }
      }
    }

16D4:

    #16D4
    #instruction: CALL 0AB6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := D7;
    #return-to: 16D7
    advance (17)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

16D7:

    #16D7
    #instruction: CALL 09D6
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DA;
    #return-to: 16DA
    advance (17)
    #09D6
    #instruction: LD   HL,2402
    advance (10)
    #09D9
    #instruction: LD   (HL),00
    M[2402] := 00;
    advance (10)
    #09DB
    #instruction: INC  HL
    advance (5)
    #09DC
    #instruction: LD   A,L
    advance (5)
    #09DD
    #instruction: AND  1F
    let:8 a7 = (1F & 03) in
    let:8 a8 = (1F | 03) in
    advance (7)
    #09DF
    #instruction: CP   1C
    let:8 a9 = a7 in
    let:16 a10 = addWithCarry(!false,a9,~1C) in
    let:8 a11 = (a9 & 0F) in
    let:8 a12 = (~1C & 0F) in
    let:16 a13 = addWithCarry(!false,a11,a12) in
    advance (7)
    #09E1
    #instruction: JP   CY,09E8
    if (!a10[15:8][0]) {
      advance (10)
      #09E8
      #instruction: LD   A,H
      advance (5)
      #09E9
      #instruction: CP   40
      let:16 a14 = addWithCarry(!false,24,~40) in
      let:8 a15 = (24 & 0F) in
      let:8 a16 = (~40 & 0F) in
      let:16 a17 = addWithCarry(!false,a15,a16) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a14[15:8][0]) {
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a18 = a6[15:8] in
        let:8 a19 = a6[7:0] in
        let:16 a20 = (1 + (a18,a19)) in
        let:8 a21 = M[(a18,a19)] in
        let:8 a22 = a20[15:8] in
        let:8 a23 = a20[7:0] in
        let:16 a24 = (1 + (a22,a23)) in
        let:8 a25 = M[(a22,a23)] in
        advance (10)
        A := 24;
        H := 24;
        L := 03;
        SPH := a24[15:8];
        SPL := a24[7:0];
        FlagS := a14[7:0][7];
        FlagZ := is_zero(a14[7:0]);
        FlagA := a17[7:0][4];
        FlagP := parity(a14[7:0]);
        FlagCY := !a14[15:8][0];
        jump ((a25,a21));
      }
    } else {
      advance (10)
      #09E4
      #instruction: LD   DE,0006
      advance (10)
      #09E7
      #instruction: ADD  HL,DE
      let:17 a26 = add17(0006,2403) in
      advance (10)
      #09E8
      #instruction: LD   A,H
      let:8 a27 = a26[15:0][15:8] in
      advance (5)
      #09E9
      #instruction: CP   40
      let:8 a28 = a27 in
      let:16 a29 = addWithCarry(!false,a28,~40) in
      let:8 a30 = (a28 & 0F) in
      let:8 a31 = (~40 & 0F) in
      let:16 a32 = addWithCarry(!false,a30,a31) in
      advance (7)
      #09EB
      #instruction: JP   CY,09D9
      if (!a29[15:8][0]) {
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a6[15:8];
        SPL := a6[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump (09D9);
      } else {
        advance (10)
        #09EE
        #instruction: RET
        let:8 a33 = a6[15:8] in
        let:8 a34 = a6[7:0] in
        let:16 a35 = (1 + (a33,a34)) in
        let:8 a36 = M[(a33,a34)] in
        let:8 a37 = a35[15:8] in
        let:8 a38 = a35[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        advance (10)
        A := a27;
        D := 00;
        E := 06;
        H := a26[15:0][15:8];
        L := a26[15:0][7:0];
        SPH := a39[15:8];
        SPL := a39[7:0];
        FlagS := a29[7:0][7];
        FlagZ := is_zero(a29[7:0]);
        FlagA := a32[7:0][4];
        FlagP := parity(a29[7:0]);
        FlagCY := !a29[15:8][0];
        jump ((a40,a36));
      }
    }

16DA:

    #16DA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #16DB
    #instruction: LD   (20EF),A
    let:8 a4 = a3 in
    M[20EF] := a4;
    advance (13)
    #16DE
    #instruction: OUT  05
    let:8 a5 = a3 in
    sound_control(FleetMovement1,a5[0]);
    sound_control(FleetMovement2,a5[1]);
    sound_control(FleetMovement3,a5[2]);
    sound_control(FleetMovement4,a5[3]);
    sound_control(UfoHit,a5[4]);
    advance (10)
    #16E0
    #instruction: CALL 19D1
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 16;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := E3;
    #return-to: 16E3
    advance (17)
    #19D1
    #instruction: LD   A,01
    advance (7)
    #19D3
    #instruction: LD   (20E9),A
    M[20E9] := 01;
    advance (13)
    #19D6
    #instruction: RET
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (1 + (a12,a13)) in
    let:8 a15 = M[(a12,a13)] in
    let:8 a16 = a14[15:8] in
    let:8 a17 = a14[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    let:8 a19 = M[(a16,a17)] in
    advance (10)
    A := 01;
    SPH := a18[15:8];
    SPL := a18[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := false;
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a19,a15));

16E3:

    #16E3
    #instruction: JP   0B89
    advance (10)
    #0B89
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #0B8A
    #instruction: LD   (20C1),A
    let:8 a4 = a3 in
    M[20C1] := a4;
    advance (13)
    #0B8D
    #instruction: CALL 0AB1
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 0B;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := 90;
    #return-to: 0B90
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a11 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a12 = a11 in
    let:8 a13 = a11 in
    let:8 a14 = (a12 & a13) in
    let:8 a15 = (a12 | a13) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a14)) {
      advance (10)
      A := a14;
      SPH := a10[15:8];
      SPL := a10[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := a15[3];
      FlagP := parity(a14);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a16 = a10[15:8] in
      let:8 a17 = a10[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      let:8 a20 = a18[15:8] in
      let:8 a21 = a18[7:0] in
      let:16 a22 = (1 + (a20,a21)) in
      let:8 a23 = M[(a20,a21)] in
      advance (10)
      A := a14;
      SPH := a22[15:8];
      SPL := a22[7:0];
      FlagS := a14[7];
      FlagZ := is_zero(a14);
      FlagA := a15[3];
      FlagP := parity(a14);
      FlagCY := false;
      jump ((a23,a19));
    }

16F1:

    #16F1
    #instruction: LD   B,04
    advance (7)
    #16F3
    #instruction: CALL 18FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F6;
    #return-to: 16F6
    advance (17)
    #18FA
    #instruction: LD   A,(2094)
    let:8 a7 = M[2094] in
    advance (13)
    #18FD
    #instruction: OR   B
    let:8 a8 = a7 in
    let:8 a9 = (04 | a8) in
    advance (4)
    #18FE
    #instruction: LD   (2094),A
    let:8 a10 = a9 in
    M[2094] := a10;
    advance (13)
    #1901
    #instruction: OUT  03
    let:8 a11 = a9 in
    sound_control(Ufo,a11[0]);
    sound_control(Shot,a11[1]);
    sound_control(PlayerDie,a11[2]);
    sound_control(InvaderDie,a11[3]);
    sound_control(ExtraLife,a11[4]);
    advance (10)
    #1903
    #instruction: RET
    let:8 a12 = a6[15:8] in
    let:8 a13 = a6[7:0] in
    let:16 a14 = (1 + (a12,a13)) in
    let:8 a15 = M[(a12,a13)] in
    let:8 a16 = a14[15:8] in
    let:8 a17 = a14[7:0] in
    let:16 a18 = (1 + (a16,a17)) in
    let:8 a19 = M[(a16,a17)] in
    advance (10)
    A := a9;
    B := 04;
    SPH := a18[15:8];
    SPL := a18[7:0];
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := false;
    FlagP := parity(a9);
    FlagCY := false;
    jump ((a19,a15));

16F6:

    #16F6
    #instruction: CALL 0A59
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 16;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F9;
    #return-to: 16F9
    advance (17)
    #0A59
    #instruction: LD   A,(2015)
    let:8 a7 = M[2015] in
    advance (13)
    #0A5C
    #instruction: CP   FF
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,a8,~FF) in
    let:8 a10 = (a8 & 0F) in
    let:8 a11 = (~FF & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (7)
    #0A5E
    #instruction: RET
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a7;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a9[7:0][7];
    FlagZ := is_zero(a9[7:0]);
    FlagA := a12[7:0][4];
    FlagP := parity(a9[7:0]);
    FlagCY := !a9[15:8][0];
    jump ((a20,a16));

16F9:

    #16F9
    #instruction: JP   NZ,16EE
    if (!FlagZ) {
      advance (10)
      #16EE
      #instruction: CALL 14D8
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 16;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := F1;
      #return-to: 16F1
      advance (17)
      #14D8
      #instruction: LD   A,(2025)
      let:8 a7 = M[2025] in
      advance (13)
      #14DB
      #instruction: CP   05
      let:8 a8 = a7 in
      let:16 a9 = addWithCarry(!false,a8,~05) in
      let:8 a10 = (a8 & 0F) in
      let:8 a11 = (~05 & 0F) in
      let:16 a12 = addWithCarry(!false,a10,a11) in
      advance (7)
      #14DD
      #instruction: RET  Z
      if (is_zero(a9[7:0])) {
        let:8 a13 = a6[15:8] in
        let:8 a14 = a6[7:0] in
        let:16 a15 = (1 + (a13,a14)) in
        let:8 a16 = M[(a13,a14)] in
        let:8 a17 = a15[15:8] in
        let:8 a18 = a15[7:0] in
        let:16 a19 = (1 + (a17,a18)) in
        let:8 a20 = M[(a17,a18)] in
        advance (11)
        A := a7;
        SPH := a19[15:8];
        SPL := a19[7:0];
        FlagS := a9[7:0][7];
        FlagZ := is_zero(a9[7:0]);
        FlagA := a12[7:0][4];
        FlagP := parity(a9[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((a20,a16));
      } else {
        advance (5)
        #14DE
        #instruction: CP   02
        let:8 a21 = a7 in
        let:16 a22 = addWithCarry(!false,a21,~02) in
        let:8 a23 = (a21 & 0F) in
        let:8 a24 = (~02 & 0F) in
        let:16 a25 = addWithCarry(!false,a23,a24) in
        advance (7)
        #14E0
        #instruction: RET  NZ
        if (!is_zero(a22[7:0])) {
          let:8 a26 = a6[15:8] in
          let:8 a27 = a6[7:0] in
          let:16 a28 = (1 + (a26,a27)) in
          let:8 a29 = M[(a26,a27)] in
          let:8 a30 = a28[15:8] in
          let:8 a31 = a28[7:0] in
          let:16 a32 = (1 + (a30,a31)) in
          let:8 a33 = M[(a30,a31)] in
          advance (11)
          A := a7;
          SPH := a32[15:8];
          SPL := a32[7:0];
          FlagS := a22[7:0][7];
          FlagZ := is_zero(a22[7:0]);
          FlagA := a25[7:0][4];
          FlagP := parity(a22[7:0]);
          FlagCY := !a22[15:8][0];
          jump ((a33,a29));
        } else {
          advance (5)
          #14E1
          #instruction: LD   A,(2029)
          let:8 a34 = M[2029] in
          advance (13)
          #14E4
          #instruction: CP   D8
          let:8 a35 = a34 in
          let:16 a36 = addWithCarry(!false,a35,~D8) in
          let:8 a37 = (a35 & 0F) in
          let:8 a38 = (~D8 & 0F) in
          let:16 a39 = addWithCarry(!false,a37,a38) in
          advance (7)
          #14E6
          #instruction: LD   B,A
          let:8 a40 = a34 in
          advance (5)
          #14E7
          #instruction: JP   NC,1530
          if (!!a36[15:8][0]) {
            advance (10)
            #1530
            #instruction: LD   A,03
            advance (7)
            #1532
            #instruction: LD   (2025),A
            M[2025] := 03;
            advance (13)
            #1535
            #instruction: JP   154A
            advance (10)
            #154A
            #instruction: XOR  A
            let:8 a41 = (03 ^ 03) in
            advance (4)
            #154B
            #instruction: LD   (2002),A
            let:8 a42 = a41 in
            M[2002] := a42;
            advance (13)
            #154E
            #instruction: LD   B,F7
            advance (7)
            #1550
            #instruction: JP   19DC
            advance (10)
            #19DC
            #instruction: LD   A,(2094)
            let:8 a43 = M[2094] in
            advance (13)
            #19DF
            #instruction: AND  B
            let:8 a44 = a43 in
            let:8 a45 = (F7 & a44) in
            let:8 a46 = (F7 | a44) in
            advance (4)
            #19E0
            #instruction: LD   (2094),A
            let:8 a47 = a45 in
            M[2094] := a47;
            advance (13)
            #19E3
            #instruction: OUT  03
            let:8 a48 = a45 in
            sound_control(Ufo,a48[0]);
            sound_control(Shot,a48[1]);
            sound_control(PlayerDie,a48[2]);
            sound_control(InvaderDie,a48[3]);
            sound_control(ExtraLife,a48[4]);
            advance (10)
            #19E5
            #instruction: RET
            let:8 a49 = a6[15:8] in
            let:8 a50 = a6[7:0] in
            let:16 a51 = (1 + (a49,a50)) in
            let:8 a52 = M[(a49,a50)] in
            let:8 a53 = a51[15:8] in
            let:8 a54 = a51[7:0] in
            let:16 a55 = (1 + (a53,a54)) in
            let:8 a56 = M[(a53,a54)] in
            advance (10)
            A := a45;
            B := F7;
            SPH := a55[15:8];
            SPL := a55[7:0];
            FlagS := a45[7];
            FlagZ := is_zero(a45);
            FlagA := a46[3];
            FlagP := parity(a45);
            FlagCY := false;
            jump ((a56,a52));
          } else {
            advance (10)
            #14EA
            #instruction: LD   A,(2002)
            let:8 a57 = M[2002] in
            advance (13)
            #14ED
            #instruction: AND  A
            let:8 a58 = a57 in
            let:8 a59 = a57 in
            let:8 a60 = (a58 & a59) in
            let:8 a61 = (a58 | a59) in
            advance (4)
            #14EE
            #instruction: RET  Z
            if (is_zero(a60)) {
              let:8 a62 = a6[15:8] in
              let:8 a63 = a6[7:0] in
              let:16 a64 = (1 + (a62,a63)) in
              let:8 a65 = M[(a62,a63)] in
              let:8 a66 = a64[15:8] in
              let:8 a67 = a64[7:0] in
              let:16 a68 = (1 + (a66,a67)) in
              let:8 a69 = M[(a66,a67)] in
              advance (11)
              A := a60;
              B := a40;
              SPH := a68[15:8];
              SPL := a68[7:0];
              FlagS := a60[7];
              FlagZ := is_zero(a60);
              FlagA := a61[3];
              FlagP := parity(a60);
              FlagCY := false;
              jump ((a69,a65));
            } else {
              advance (5)
              #14EF
              #instruction: LD   A,B
              let:8 a70 = a40 in
              advance (5)
              #14F0
              #instruction: CP   CE
              let:8 a71 = a70 in
              let:16 a72 = addWithCarry(!false,a71,~CE) in
              let:8 a73 = (a71 & 0F) in
              let:8 a74 = (~CE & 0F) in
              let:16 a75 = addWithCarry(!false,a73,a74) in
              advance (7)
              #14F2
              #instruction: JP   NC,1579
              if (!!a72[15:8][0]) {
                advance (10)
                #1579
                #instruction: LD   A,01
                advance (7)
                #157B
                #instruction: LD   (2085),A
                M[2085] := 01;
                advance (13)
                #157E
                #instruction: JP   1545
                advance (10)
                A := 01;
                B := a40;
                SPH := a6[15:8];
                SPL := a6[7:0];
                FlagS := a72[7:0][7];
                FlagZ := is_zero(a72[7:0]);
                FlagA := a75[7:0][4];
                FlagP := parity(a72[7:0]);
                FlagCY := !a72[15:8][0];
                jump (1545);
              } else {
                advance (10)
                #14F5
                #instruction: ADD  06
                let:8 a76 = a70 in
                let:16 a77 = addWithCarry(false,06,a76) in
                let:8 a78 = (06 & 0F) in
                let:8 a79 = (a76 & 0F) in
                let:16 a80 = addWithCarry(false,a78,a79) in
                advance (7)
                #14F7
                #instruction: LD   B,A
                let:8 a81 = a77[7:0] in
                advance (5)
                #14F8
                #instruction: LD   A,(2009)
                let:8 a82 = M[2009] in
                advance (13)
                #14FB
                #instruction: CP   90
                let:8 a83 = a82 in
                let:16 a84 = addWithCarry(!false,a83,~90) in
                let:8 a85 = (a83 & 0F) in
                let:8 a86 = (~90 & 0F) in
                let:16 a87 = addWithCarry(!false,a85,a86) in
                advance (7)
                #14FD
                #instruction: JP   NC,1504
                if (!!a84[15:8][0]) {
                  advance (10)
                  #1504
                  #instruction: LD   L,B
                  let:8 a88 = a81 in
                  advance (5)
                  #1505
                  #instruction: CALL 1562
                  let:8 a89 = a6[15:8] in
                  let:8 a90 = a6[7:0] in
                  let:16 a91 = (-1 + (a89,a90)) in
                  M[a91] := 15;
                  let:8 a92 = a91[15:8] in
                  let:8 a93 = a91[7:0] in
                  let:16 a94 = (-1 + (a92,a93)) in
                  M[a94] := 08;
                  #return-to: 1508
                  advance (17)
                  #1562
                  #instruction: LD   A,(2009)
                  let:8 a95 = M[2009] in
                  advance (13)
                  #1565
                  #instruction: LD   H,L
                  let:8 a96 = a88 in
                  advance (5)
                  #1566
                  #instruction: CALL 1554
                  let:8 a97 = a94[15:8] in
                  let:8 a98 = a94[7:0] in
                  let:16 a99 = (-1 + (a97,a98)) in
                  M[a99] := 15;
                  let:8 a100 = a99[15:8] in
                  let:8 a101 = a99[7:0] in
                  let:16 a102 = (-1 + (a100,a101)) in
                  M[a102] := 69;
                  #return-to: 1569
                  advance (17)
                  #1554
                  #instruction: LD   C,00
                  advance (7)
                  #1556
                  #instruction: CP   H
                  let:8 a103 = a95 in
                  let:8 a104 = a96 in
                  let:16 a105 = addWithCarry(!false,a103,~a104) in
                  let:8 a106 = (a103 & 0F) in
                  let:8 a107 = (~a104 & 0F) in
                  let:16 a108 = addWithCarry(!false,a106,a107) in
                  advance (4)
                  #1557
                  #instruction: CALL NC,1590
                  if (!!a105[15:8][0]) {
                    let:8 a109 = a102[15:8] in
                    let:8 a110 = a102[7:0] in
                    let:16 a111 = (-1 + (a109,a110)) in
                    M[a111] := 15;
                    let:8 a112 = a111[15:8] in
                    let:8 a113 = a111[7:0] in
                    let:16 a114 = (-1 + (a112,a113)) in
                    M[a114] := 5A;
                    #return-to: 155A
                    advance (17)
                    #1590
                    #instruction: INC  C
                    let:16 a115 = addWithCarry(true,00,00) in
                    let:8 a116 = (00 & 0F) in
                    let:8 a117 = (00 & 0F) in
                    let:16 a118 = addWithCarry(true,a116,a117) in
                    advance (5)
                    #1591
                    #instruction: ADD  10
                    let:8 a119 = a95 in
                    let:16 a120 = addWithCarry(false,10,a119) in
                    let:8 a121 = (10 & 0F) in
                    let:8 a122 = (a119 & 0F) in
                    let:16 a123 = addWithCarry(false,a121,a122) in
                    advance (7)
                    #1593
                    #instruction: JP   MI,1590
                    if (a120[7:0][7]) {
                      advance (10)
                      A := a120[7:0];
                      B := a81;
                      C := a115[7:0];
                      H := a96;
                      L := a88;
                      SPH := a114[15:8];
                      SPL := a114[7:0];
                      FlagS := a120[7:0][7];
                      FlagZ := is_zero(a120[7:0]);
                      FlagA := a123[7:0][4];
                      FlagP := parity(a120[7:0]);
                      FlagCY := a120[15:8][0];
                      jump (1590);
                    } else {
                      advance (10)
                      #1596
                      #instruction: RET
                      let:8 a124 = a114[15:8] in
                      let:8 a125 = a114[7:0] in
                      let:16 a126 = (1 + (a124,a125)) in
                      let:8 a127 = M[(a124,a125)] in
                      let:8 a128 = a126[15:8] in
                      let:8 a129 = a126[7:0] in
                      let:16 a130 = (1 + (a128,a129)) in
                      let:8 a131 = M[(a128,a129)] in
                      advance (10)
                      A := a120[7:0];
                      B := a81;
                      C := a115[7:0];
                      H := a96;
                      L := a88;
                      SPH := a130[15:8];
                      SPL := a130[7:0];
                      FlagS := a120[7:0][7];
                      FlagZ := is_zero(a120[7:0]);
                      FlagA := a123[7:0][4];
                      FlagP := parity(a120[7:0]);
                      FlagCY := a120[15:8][0];
                      jump ((a131,a127));
                    }
                  } else {
                    advance (11)
                    A := a95;
                    B := a81;
                    C := 00;
                    H := a96;
                    L := a88;
                    SPH := a102[15:8];
                    SPL := a102[7:0];
                    FlagS := a105[7:0][7];
                    FlagZ := is_zero(a105[7:0]);
                    FlagA := a108[7:0][4];
                    FlagP := parity(a105[7:0]);
                    FlagCY := !a105[15:8][0];
                    jump (155A);
                  }
                } else {
                  advance (10)
                  #1500
                  #instruction: CP   B
                  let:8 a132 = a82 in
                  let:8 a133 = a81 in
                  let:16 a134 = addWithCarry(!false,a132,~a133) in
                  let:8 a135 = (a132 & 0F) in
                  let:8 a136 = (~a133 & 0F) in
                  let:16 a137 = addWithCarry(!false,a135,a136) in
                  advance (4)
                  #1501
                  #instruction: JP   NC,1530
                  if (!!a134[15:8][0]) {
                    advance (10)
                    #1530
                    #instruction: LD   A,03
                    advance (7)
                    #1532
                    #instruction: LD   (2025),A
                    M[2025] := 03;
                    advance (13)
                    #1535
                    #instruction: JP   154A
                    advance (10)
                    #154A
                    #instruction: XOR  A
                    let:8 a138 = (03 ^ 03) in
                    advance (4)
                    #154B
                    #instruction: LD   (2002),A
                    let:8 a139 = a138 in
                    M[2002] := a139;
                    advance (13)
                    #154E
                    #instruction: LD   B,F7
                    advance (7)
                    #1550
                    #instruction: JP   19DC
                    advance (10)
                    #19DC
                    #instruction: LD   A,(2094)
                    let:8 a140 = M[2094] in
                    advance (13)
                    #19DF
                    #instruction: AND  B
                    let:8 a141 = a140 in
                    let:8 a142 = (F7 & a141) in
                    let:8 a143 = (F7 | a141) in
                    advance (4)
                    #19E0
                    #instruction: LD   (2094),A
                    let:8 a144 = a142 in
                    M[2094] := a144;
                    advance (13)
                    #19E3
                    #instruction: OUT  03
                    let:8 a145 = a142 in
                    sound_control(Ufo,a145[0]);
                    sound_control(Shot,a145[1]);
                    sound_control(PlayerDie,a145[2]);
                    sound_control(InvaderDie,a145[3]);
                    sound_control(ExtraLife,a145[4]);
                    advance (10)
                    #19E5
                    #instruction: RET
                    let:8 a146 = a6[15:8] in
                    let:8 a147 = a6[7:0] in
                    let:16 a148 = (1 + (a146,a147)) in
                    let:8 a149 = M[(a146,a147)] in
                    let:8 a150 = a148[15:8] in
                    let:8 a151 = a148[7:0] in
                    let:16 a152 = (1 + (a150,a151)) in
                    let:8 a153 = M[(a150,a151)] in
                    advance (10)
                    A := a142;
                    B := F7;
                    SPH := a152[15:8];
                    SPL := a152[7:0];
                    FlagS := a142[7];
                    FlagZ := is_zero(a142);
                    FlagA := a143[3];
                    FlagP := parity(a142);
                    FlagCY := false;
                    jump ((a153,a149));
                  } else {
                    advance (10)
                    #1504
                    #instruction: LD   L,B
                    let:8 a154 = a81 in
                    advance (5)
                    #1505
                    #instruction: CALL 1562
                    let:8 a155 = a6[15:8] in
                    let:8 a156 = a6[7:0] in
                    let:16 a157 = (-1 + (a155,a156)) in
                    M[a157] := 15;
                    let:8 a158 = a157[15:8] in
                    let:8 a159 = a157[7:0] in
                    let:16 a160 = (-1 + (a158,a159)) in
                    M[a160] := 08;
                    #return-to: 1508
                    advance (17)
                    #1562
                    #instruction: LD   A,(2009)
                    let:8 a161 = M[2009] in
                    advance (13)
                    #1565
                    #instruction: LD   H,L
                    let:8 a162 = a154 in
                    advance (5)
                    #1566
                    #instruction: CALL 1554
                    let:8 a163 = a160[15:8] in
                    let:8 a164 = a160[7:0] in
                    let:16 a165 = (-1 + (a163,a164)) in
                    M[a165] := 15;
                    let:8 a166 = a165[15:8] in
                    let:8 a167 = a165[7:0] in
                    let:16 a168 = (-1 + (a166,a167)) in
                    M[a168] := 69;
                    #return-to: 1569
                    advance (17)
                    #1554
                    #instruction: LD   C,00
                    advance (7)
                    #1556
                    #instruction: CP   H
                    let:8 a169 = a161 in
                    let:8 a170 = a162 in
                    let:16 a171 = addWithCarry(!false,a169,~a170) in
                    let:8 a172 = (a169 & 0F) in
                    let:8 a173 = (~a170 & 0F) in
                    let:16 a174 = addWithCarry(!false,a172,a173) in
                    advance (4)
                    #1557
                    #instruction: CALL NC,1590
                    if (!!a171[15:8][0]) {
                      let:8 a175 = a168[15:8] in
                      let:8 a176 = a168[7:0] in
                      let:16 a177 = (-1 + (a175,a176)) in
                      M[a177] := 15;
                      let:8 a178 = a177[15:8] in
                      let:8 a179 = a177[7:0] in
                      let:16 a180 = (-1 + (a178,a179)) in
                      M[a180] := 5A;
                      #return-to: 155A
                      advance (17)
                      #1590
                      #instruction: INC  C
                      let:16 a181 = addWithCarry(true,00,00) in
                      let:8 a182 = (00 & 0F) in
                      let:8 a183 = (00 & 0F) in
                      let:16 a184 = addWithCarry(true,a182,a183) in
                      advance (5)
                      #1591
                      #instruction: ADD  10
                      let:8 a185 = a161 in
                      let:16 a186 = addWithCarry(false,10,a185) in
                      let:8 a187 = (10 & 0F) in
                      let:8 a188 = (a185 & 0F) in
                      let:16 a189 = addWithCarry(false,a187,a188) in
                      advance (7)
                      #1593
                      #instruction: JP   MI,1590
                      if (a186[7:0][7]) {
                        advance (10)
                        A := a186[7:0];
                        B := a81;
                        C := a181[7:0];
                        H := a162;
                        L := a154;
                        SPH := a180[15:8];
                        SPL := a180[7:0];
                        FlagS := a186[7:0][7];
                        FlagZ := is_zero(a186[7:0]);
                        FlagA := a189[7:0][4];
                        FlagP := parity(a186[7:0]);
                        FlagCY := a186[15:8][0];
                        jump (1590);
                      } else {
                        advance (10)
                        #1596
                        #instruction: RET
                        let:8 a190 = a180[15:8] in
                        let:8 a191 = a180[7:0] in
                        let:16 a192 = (1 + (a190,a191)) in
                        let:8 a193 = M[(a190,a191)] in
                        let:8 a194 = a192[15:8] in
                        let:8 a195 = a192[7:0] in
                        let:16 a196 = (1 + (a194,a195)) in
                        let:8 a197 = M[(a194,a195)] in
                        advance (10)
                        A := a186[7:0];
                        B := a81;
                        C := a181[7:0];
                        H := a162;
                        L := a154;
                        SPH := a196[15:8];
                        SPL := a196[7:0];
                        FlagS := a186[7:0][7];
                        FlagZ := is_zero(a186[7:0]);
                        FlagA := a189[7:0][4];
                        FlagP := parity(a186[7:0]);
                        FlagCY := a186[15:8][0];
                        jump ((a197,a193));
                      }
                    } else {
                      advance (11)
                      A := a161;
                      B := a81;
                      C := 00;
                      H := a162;
                      L := a154;
                      SPH := a168[15:8];
                      SPL := a168[7:0];
                      FlagS := a171[7:0][7];
                      FlagZ := is_zero(a171[7:0]);
                      FlagA := a174[7:0][4];
                      FlagP := parity(a171[7:0]);
                      FlagCY := !a171[15:8][0];
                      jump (155A);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      advance (10)
      #16FC
      #instruction: CALL 19D7
      let:8 a198 = SPH in
      let:8 a199 = SPL in
      let:16 a200 = (-1 + (a198,a199)) in
      M[a200] := 16;
      let:8 a201 = a200[15:8] in
      let:8 a202 = a200[7:0] in
      let:16 a203 = (-1 + (a201,a202)) in
      M[a203] := FF;
      #return-to: 16FF
      advance (17)
      #19D7
      #instruction: XOR  A
      let:8 a204 = A in
      let:8 a205 = A in
      let:8 a206 = (a204 ^ a205) in
      advance (4)
      #19D8
      #instruction: JP   19D3
      advance (10)
      #19D3
      #instruction: LD   (20E9),A
      let:8 a207 = a206 in
      M[20E9] := a207;
      advance (13)
      #19D6
      #instruction: RET
      let:8 a208 = a203[15:8] in
      let:8 a209 = a203[7:0] in
      let:16 a210 = (1 + (a208,a209)) in
      let:8 a211 = M[(a208,a209)] in
      let:8 a212 = a210[15:8] in
      let:8 a213 = a210[7:0] in
      let:16 a214 = (1 + (a212,a213)) in
      let:8 a215 = M[(a212,a213)] in
      advance (10)
      A := a206;
      SPH := a214[15:8];
      SPL := a214[7:0];
      FlagS := a206[7];
      FlagZ := is_zero(a206);
      FlagA := false;
      FlagP := parity(a206);
      FlagCY := false;
      jump ((a215,a211));
    }

16FF:

    #16FF
    #instruction: LD   HL,2701
    advance (10)
    #1702
    #instruction: CALL 19FA
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 05;
    #return-to: 1705
    advance (17)
    #19FA
    #instruction: LD   B,10
    advance (7)
    #19FC
    #instruction: CALL 14CB
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 19;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := FF;
    #return-to: 19FF
    advance (17)
    #14CB
    #instruction: XOR  A
    let:8 a13 = A in
    let:8 a14 = A in
    let:8 a15 = (a13 ^ a14) in
    advance (4)
    #14CC
    #instruction: PUSH BC
    let:8 a16 = C in
    let:8 a17 = a12[15:8] in
    let:8 a18 = a12[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 10;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := a16;
    advance (11)
    #14CD
    #instruction: LD   (HL),A
    let:8 a23 = a15 in
    M[2701] := a23;
    advance (7)
    #14CE
    #instruction: LD   BC,0020
    advance (10)
    #14D1
    #instruction: ADD  HL,BC
    let:17 a24 = add17(0020,2701) in
    advance (10)
    #14D2
    #instruction: POP  BC
    let:8 a25 = a22[15:8] in
    let:8 a26 = a22[7:0] in
    let:16 a27 = (1 + (a25,a26)) in
    let:8 a28 = M[(a25,a26)] in
    let:8 a29 = a27[15:8] in
    let:8 a30 = a27[7:0] in
    let:16 a31 = (1 + (a29,a30)) in
    let:8 a32 = M[(a29,a30)] in
    advance (10)
    #14D3
    #instruction: DEC  B
    let:8 a33 = a32 in
    let:16 a34 = addWithCarry(!true,a33,~00) in
    let:8 a35 = (a33 & 0F) in
    let:8 a36 = (~00 & 0F) in
    let:16 a37 = addWithCarry(!true,a35,a36) in
    advance (5)
    #14D4
    #instruction: JP   NZ,14CC
    if (!is_zero(a34[7:0])) {
      advance (10)
      A := a15;
      B := a34[7:0];
      C := a28;
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a31[15:8];
      SPL := a31[7:0];
      FlagS := a34[7:0][7];
      FlagZ := is_zero(a34[7:0]);
      FlagA := a37[7:0][4];
      FlagP := parity(a34[7:0]);
      FlagCY := a24[16];
      jump (14CC);
    } else {
      advance (10)
      #14D7
      #instruction: RET
      let:8 a38 = a31[15:8] in
      let:8 a39 = a31[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      let:8 a41 = M[(a38,a39)] in
      let:8 a42 = a40[15:8] in
      let:8 a43 = a40[7:0] in
      let:16 a44 = (1 + (a42,a43)) in
      let:8 a45 = M[(a42,a43)] in
      advance (10)
      A := a15;
      B := a34[7:0];
      C := a28;
      H := a24[15:0][15:8];
      L := a24[15:0][7:0];
      SPH := a44[15:8];
      SPL := a44[7:0];
      FlagS := a34[7:0][7];
      FlagZ := is_zero(a34[7:0]);
      FlagA := a37[7:0][4];
      FlagP := parity(a34[7:0]);
      FlagCY := a24[16];
      jump ((a45,a41));
    }

1705:

    #1705
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #1706
    #instruction: CALL 1A8B
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 17;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 09;
    #return-to: 1709
    advance (17)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a10 = a3 in
    let:8 a11 = (0F & a10) in
    let:8 a12 = (0F | a10) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:8 a13 = a11 in
    let:16 a14 = addWithCarry(false,1A,a13) in
    let:8 a15 = (1A & 0F) in
    let:8 a16 = (a13 & 0F) in
    let:16 a17 = addWithCarry(false,a15,a16) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a18 = a9[15:8] in
    let:8 a19 = a9[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := 25;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a24 = a14[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a25 = a24 in
    let:8 a26 = a24 in
    let:17 a27 = add17((00,a25),(00,a26)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a28 = a27[15:0][15:8] in
    let:8 a29 = a27[15:0][7:0] in
    let:8 a30 = a27[15:0][15:8] in
    let:8 a31 = a27[15:0][7:0] in
    let:17 a32 = add17((a28,a29),(a30,a31)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a33 = a32[15:0][15:8] in
    let:8 a34 = a32[15:0][7:0] in
    let:8 a35 = a32[15:0][15:8] in
    let:8 a36 = a32[15:0][7:0] in
    let:17 a37 = add17((a33,a34),(a35,a36)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a38 = a37[15:0][15:8] in
    let:8 a39 = a37[15:0][7:0] in
    let:17 a40 = add17(1E00,(a38,a39)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a41 = a40[15:0][15:8] in
    let:8 a42 = a40[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a43 = a23[15:8] in
    let:8 a44 = a23[7:0] in
    let:16 a45 = (1 + (a43,a44)) in
    let:8 a46 = M[(a43,a44)] in
    let:8 a47 = a45[15:8] in
    let:8 a48 = a45[7:0] in
    let:16 a49 = (1 + (a47,a48)) in
    let:8 a50 = M[(a47,a48)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a51 = a14[7:0] in
    unknown_output(6,a51);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a52 = C in
    let:8 a53 = a49[15:8] in
    let:8 a54 = a49[7:0] in
    let:16 a55 = (-1 + (a53,a54)) in
    M[a55] := 08;
    let:8 a56 = a55[15:8] in
    let:8 a57 = a55[7:0] in
    let:16 a58 = (-1 + (a56,a57)) in
    M[a58] := a52;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a59 = a41 in
    let:8 a60 = a42 in
    let:8 a61 = M[(a59,a60)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a62 = a61 in
    let:8 a63 = a50 in
    let:8 a64 = a46 in
    M[(a63,a64)] := a62;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a65 = a41 in
    let:8 a66 = a42 in
    let:16 a67 = (1 + (a65,a66)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a68 = a50 in
    let:8 a69 = a46 in
    let:17 a70 = add17(0020,(a68,a69)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a71 = a58[15:8] in
    let:8 a72 = a58[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    let:8 a75 = a73[15:8] in
    let:8 a76 = a73[7:0] in
    let:16 a77 = (1 + (a75,a76)) in
    let:8 a78 = M[(a75,a76)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a79 = a78 in
    let:16 a80 = addWithCarry(!true,a79,~00) in
    let:8 a81 = (a79 & 0F) in
    let:8 a82 = (~00 & 0F) in
    let:16 a83 = addWithCarry(!true,a81,a82) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a80[7:0])) {
      advance (10)
      A := a61;
      B := a80[7:0];
      C := a74;
      D := a67[15:8];
      E := a67[7:0];
      H := a70[15:0][15:8];
      L := a70[15:0][7:0];
      SPH := a77[15:8];
      SPL := a77[7:0];
      FlagS := a80[7:0][7];
      FlagZ := is_zero(a80[7:0]);
      FlagA := a83[7:0][4];
      FlagP := parity(a80[7:0]);
      FlagCY := a70[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a84 = a77[15:8] in
      let:8 a85 = a77[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      let:8 a88 = a86[15:8] in
      let:8 a89 = a86[7:0] in
      let:16 a90 = (1 + (a88,a89)) in
      let:8 a91 = M[(a88,a89)] in
      advance (10)
      A := a61;
      B := a80[7:0];
      C := a74;
      D := a67[15:8];
      E := a67[7:0];
      H := a70[15:0][15:8];
      L := a70[15:0][7:0];
      SPH := a90[15:8];
      SPL := a90[7:0];
      FlagS := a80[7:0][7];
      FlagZ := is_zero(a80[7:0]);
      FlagA := a83[7:0][4];
      FlagP := parity(a80[7:0]);
      FlagCY := a70[16];
      jump ((a91,a87));
    }

1709:

    #1709
    #instruction: LD   B,FB
    advance (7)
    #170B
    #instruction: JP   196B
    advance (10)
    #196B
    #instruction: CALL 19DC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 6E;
    #return-to: 196E
    advance (17)
    #19DC
    #instruction: LD   A,(2094)
    let:8 a7 = M[2094] in
    advance (13)
    #19DF
    #instruction: AND  B
    let:8 a8 = a7 in
    let:8 a9 = (FB & a8) in
    let:8 a10 = (FB | a8) in
    advance (4)
    #19E0
    #instruction: LD   (2094),A
    let:8 a11 = a9 in
    M[2094] := a11;
    advance (13)
    #19E3
    #instruction: OUT  03
    let:8 a12 = a9 in
    sound_control(Ufo,a12[0]);
    sound_control(Shot,a12[1]);
    sound_control(PlayerDie,a12[2]);
    sound_control(InvaderDie,a12[3]);
    sound_control(ExtraLife,a12[4]);
    advance (10)
    #19E5
    #instruction: RET
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (1 + (a17,a18)) in
    let:8 a20 = M[(a17,a18)] in
    advance (10)
    A := a9;
    B := FB;
    SPH := a19[15:8];
    SPL := a19[7:0];
    FlagS := a9[7];
    FlagZ := is_zero(a9);
    FlagA := a10[3];
    FlagP := parity(a9);
    FlagCY := false;
    jump ((a20,a16));

1711:

    #1711
    #instruction: INC  HL
    let:8 a1 = H in
    let:8 a2 = L in
    let:16 a3 = (1 + (a1,a2)) in
    advance (5)
    #1712
    #instruction: LD   A,(HL)
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:8 a6 = M[(a4,a5)] in
    advance (7)
    #1713
    #instruction: LD   DE,1CB8
    advance (10)
    #1716
    #instruction: LD   HL,1AA1
    advance (10)
    #1719
    #instruction: LD   C,04
    advance (7)
    #171B
    #instruction: LD   B,A
    let:8 a7 = a6 in
    advance (5)
    #171C
    #instruction: LD   A,(DE)
    advance (7)
    #171D
    #instruction: CP   B
    let:8 a8 = a7 in
    let:16 a9 = addWithCarry(!false,02,~a8) in
    let:8 a10 = (02 & 0F) in
    let:8 a11 = (~a8 & 0F) in
    let:16 a12 = addWithCarry(!false,a10,a11) in
    advance (4)
    #171E
    #instruction: JP   NC,1727
    if (!!a9[15:8][0]) {
      advance (10)
      #1727
      #instruction: LD   A,(HL)
      advance (7)
      #1728
      #instruction: LD   (20CF),A
      M[20CF] := 30;
      advance (13)
      #172B
      #instruction: RET
      let:8 a13 = SPH in
      let:8 a14 = SPL in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      let:8 a17 = a15[15:8] in
      let:8 a18 = a15[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      advance (10)
      A := 30;
      B := a7;
      C := 04;
      D := 1C;
      E := B8;
      H := 1A;
      L := A1;
      SPH := a19[15:8];
      SPL := a19[7:0];
      FlagS := a9[7:0][7];
      FlagZ := is_zero(a9[7:0]);
      FlagA := a12[7:0][4];
      FlagP := parity(a9[7:0]);
      FlagCY := !a9[15:8][0];
      jump ((a20,a16));
    } else {
      advance (10)
      #1721
      #instruction: INC  HL
      advance (5)
      #1722
      #instruction: INC  DE
      advance (5)
      #1723
      #instruction: DEC  C
      let:16 a21 = addWithCarry(!true,04,~00) in
      let:8 a22 = (04 & 0F) in
      let:8 a23 = (~00 & 0F) in
      let:16 a24 = addWithCarry(!true,a22,a23) in
      advance (5)
      #1724
      #instruction: JP   NZ,171C
      if (!is_zero(a21[7:0])) {
        advance (10)
        A := 02;
        B := a7;
        C := a21[7:0];
        D := 1C;
        E := B9;
        H := 1A;
        L := A2;
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a9[15:8][0];
        jump (171C);
      } else {
        advance (10)
        #1727
        #instruction: LD   A,(HL)
        advance (7)
        #1728
        #instruction: LD   (20CF),A
        M[20CF] := 10;
        advance (13)
        #172B
        #instruction: RET
        let:8 a25 = SPH in
        let:8 a26 = SPL in
        let:16 a27 = (1 + (a25,a26)) in
        let:8 a28 = M[(a25,a26)] in
        let:8 a29 = a27[15:8] in
        let:8 a30 = a27[7:0] in
        let:16 a31 = (1 + (a29,a30)) in
        let:8 a32 = M[(a29,a30)] in
        advance (10)
        A := 10;
        B := a7;
        C := a21[7:0];
        D := 1C;
        E := B9;
        H := 1A;
        L := A2;
        SPH := a31[15:8];
        SPL := a31[7:0];
        FlagS := a21[7:0][7];
        FlagZ := is_zero(a21[7:0]);
        FlagA := a24[7:0][4];
        FlagP := parity(a21[7:0]);
        FlagCY := !a9[15:8][0];
        jump ((a32,a28));
      }
    }

1747:

    #1747
    #instruction: LD   A,(2068)
    let:8 a1 = M[2068] in
    advance (13)
    #174A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #174B
    #instruction: JP   Z,176D
    if (is_zero(a4)) {
      advance (10)
      #176D
      #instruction: LD   A,(2098)
      let:8 a6 = M[2098] in
      advance (13)
      #1770
      #instruction: AND  30
      let:8 a7 = a6 in
      let:8 a8 = (30 & a7) in
      let:8 a9 = (30 | a7) in
      advance (7)
      #1772
      #instruction: OUT  05
      let:8 a10 = a8 in
      sound_control(FleetMovement1,a10[0]);
      sound_control(FleetMovement2,a10[1]);
      sound_control(FleetMovement3,a10[2]);
      sound_control(FleetMovement4,a10[3]);
      sound_control(UfoHit,a10[4]);
      advance (10)
      #1774
      #instruction: RET
      let:8 a11 = SPH in
      let:8 a12 = SPL in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (10)
      A := a8;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a8[7];
      FlagZ := is_zero(a8);
      FlagA := a9[3];
      FlagP := parity(a8);
      FlagCY := false;
      jump ((a18,a14));
    } else {
      advance (10)
      #174E
      #instruction: LD   HL,2096
      advance (10)
      #1751
      #instruction: DEC  (HL)
      let:8 a19 = M[2096] in
      let:16 a20 = addWithCarry(!true,a19,~00) in
      let:8 a21 = (a19 & 0F) in
      let:8 a22 = (~00 & 0F) in
      let:16 a23 = addWithCarry(!true,a21,a22) in
      M[2096] := a20[7:0];
      advance (10)
      #1752
      #instruction: RET  NZ
      if (!is_zero(a20[7:0])) {
        let:8 a24 = SPH in
        let:8 a25 = SPL in
        let:16 a26 = (1 + (a24,a25)) in
        let:8 a27 = M[(a24,a25)] in
        let:8 a28 = a26[15:8] in
        let:8 a29 = a26[7:0] in
        let:16 a30 = (1 + (a28,a29)) in
        let:8 a31 = M[(a28,a29)] in
        advance (11)
        A := a4;
        H := 20;
        L := 96;
        SPH := a30[15:8];
        SPL := a30[7:0];
        FlagS := a20[7:0][7];
        FlagZ := is_zero(a20[7:0]);
        FlagA := a23[7:0][4];
        FlagP := parity(a20[7:0]);
        FlagCY := false;
        jump ((a31,a27));
      } else {
        advance (5)
        #1753
        #instruction: LD   HL,2098
        advance (10)
        #1756
        #instruction: LD   A,(HL)
        let:8 a32 = M[2098] in
        advance (7)
        #1757
        #instruction: OUT  05
        let:8 a33 = a32 in
        sound_control(FleetMovement1,a33[0]);
        sound_control(FleetMovement2,a33[1]);
        sound_control(FleetMovement3,a33[2]);
        sound_control(FleetMovement4,a33[3]);
        sound_control(UfoHit,a33[4]);
        advance (10)
        #1759
        #instruction: LD   A,(2082)
        let:8 a34 = M[2082] in
        advance (13)
        #175C
        #instruction: AND  A
        let:8 a35 = a34 in
        let:8 a36 = a34 in
        let:8 a37 = (a35 & a36) in
        let:8 a38 = (a35 | a36) in
        advance (4)
        #175D
        #instruction: JP   Z,176D
        if (is_zero(a37)) {
          advance (10)
          #176D
          #instruction: LD   A,(2098)
          let:8 a39 = M[2098] in
          advance (13)
          #1770
          #instruction: AND  30
          let:8 a40 = a39 in
          let:8 a41 = (30 & a40) in
          let:8 a42 = (30 | a40) in
          advance (7)
          #1772
          #instruction: OUT  05
          let:8 a43 = a41 in
          sound_control(FleetMovement1,a43[0]);
          sound_control(FleetMovement2,a43[1]);
          sound_control(FleetMovement3,a43[2]);
          sound_control(FleetMovement4,a43[3]);
          sound_control(UfoHit,a43[4]);
          advance (10)
          #1774
          #instruction: RET
          let:8 a44 = SPH in
          let:8 a45 = SPL in
          let:16 a46 = (1 + (a44,a45)) in
          let:8 a47 = M[(a44,a45)] in
          let:8 a48 = a46[15:8] in
          let:8 a49 = a46[7:0] in
          let:16 a50 = (1 + (a48,a49)) in
          let:8 a51 = M[(a48,a49)] in
          advance (10)
          A := a41;
          H := 20;
          L := 98;
          SPH := a50[15:8];
          SPL := a50[7:0];
          FlagS := a41[7];
          FlagZ := is_zero(a41);
          FlagA := a42[3];
          FlagP := parity(a41);
          FlagCY := false;
          jump ((a51,a47));
        } else {
          advance (10)
          #1760
          #instruction: DEC  HL
          advance (5)
          #1761
          #instruction: LD   A,(HL)
          let:8 a52 = M[2097] in
          advance (7)
          #1762
          #instruction: DEC  HL
          advance (5)
          #1763
          #instruction: LD   (HL),A
          let:8 a53 = a52 in
          M[2096] := a53;
          advance (7)
          #1764
          #instruction: DEC  HL
          advance (5)
          #1765
          #instruction: LD   (HL),01
          M[2095] := 01;
          advance (10)
          #1767
          #instruction: LD   A,04
          advance (7)
          #1769
          #instruction: LD   (209B),A
          M[209B] := 04;
          advance (13)
          #176C
          #instruction: RET
          let:8 a54 = SPH in
          let:8 a55 = SPL in
          let:16 a56 = (1 + (a54,a55)) in
          let:8 a57 = M[(a54,a55)] in
          let:8 a58 = a56[15:8] in
          let:8 a59 = a56[7:0] in
          let:16 a60 = (1 + (a58,a59)) in
          let:8 a61 = M[(a58,a59)] in
          advance (10)
          A := 04;
          H := 20;
          L := 95;
          SPH := a60[15:8];
          SPL := a60[7:0];
          FlagS := a37[7];
          FlagZ := is_zero(a37);
          FlagA := a38[3];
          FlagP := parity(a37);
          FlagCY := false;
          jump ((a61,a57));
        }
      }
    }

17B4:

    #17B4
    #instruction: LD   B,EF
    advance (7)
    #17B6
    #instruction: LD   HL,2098
    advance (10)
    #17B9
    #instruction: LD   A,(HL)
    let:8 a1 = M[2098] in
    advance (7)
    #17BA
    #instruction: AND  B
    let:8 a2 = a1 in
    let:8 a3 = (EF & a2) in
    let:8 a4 = (EF | a2) in
    advance (4)
    #17BB
    #instruction: LD   (HL),A
    let:8 a5 = a3 in
    M[2098] := a5;
    advance (7)
    #17BC
    #instruction: OUT  05
    let:8 a6 = a3 in
    sound_control(FleetMovement1,a6[0]);
    sound_control(FleetMovement2,a6[1]);
    sound_control(FleetMovement3,a6[2]);
    sound_control(FleetMovement4,a6[3]);
    sound_control(UfoHit,a6[4]);
    advance (10)
    #17BE
    #instruction: RET
    let:8 a7 = SPH in
    let:8 a8 = SPL in
    let:16 a9 = (1 + (a7,a8)) in
    let:8 a10 = M[(a7,a8)] in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    advance (10)
    A := a3;
    B := EF;
    H := 20;
    L := 98;
    SPH := a13[15:8];
    SPL := a13[7:0];
    FlagS := a3[7];
    FlagZ := is_zero(a3);
    FlagA := a4[3];
    FlagP := parity(a3);
    FlagCY := false;
    jump ((a14,a10));

17DF:

    #17DF
    #instruction: DEC  B
    let:8 a1 = B in
    let:16 a2 = addWithCarry(!true,a1,~00) in
    let:8 a3 = (a1 & 0F) in
    let:8 a4 = (~00 & 0F) in
    let:16 a5 = addWithCarry(!true,a3,a4) in
    advance (5)
    #17E0
    #instruction: JP   NZ,17DC
    if (!is_zero(a2[7:0])) {
      advance (10)
      #17DC
      #instruction: CALL 09D6
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 17;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := DF;
      #return-to: 17DF
      advance (17)
      #09D6
      #instruction: LD   HL,2402
      advance (10)
      #09D9
      #instruction: LD   (HL),00
      M[2402] := 00;
      advance (10)
      #09DB
      #instruction: INC  HL
      advance (5)
      #09DC
      #instruction: LD   A,L
      advance (5)
      #09DD
      #instruction: AND  1F
      let:8 a12 = (1F & 03) in
      let:8 a13 = (1F | 03) in
      advance (7)
      #09DF
      #instruction: CP   1C
      let:8 a14 = a12 in
      let:16 a15 = addWithCarry(!false,a14,~1C) in
      let:8 a16 = (a14 & 0F) in
      let:8 a17 = (~1C & 0F) in
      let:16 a18 = addWithCarry(!false,a16,a17) in
      advance (7)
      #09E1
      #instruction: JP   CY,09E8
      if (!a15[15:8][0]) {
        advance (10)
        #09E8
        #instruction: LD   A,H
        advance (5)
        #09E9
        #instruction: CP   40
        let:16 a19 = addWithCarry(!false,24,~40) in
        let:8 a20 = (24 & 0F) in
        let:8 a21 = (~40 & 0F) in
        let:16 a22 = addWithCarry(!false,a20,a21) in
        advance (7)
        #09EB
        #instruction: JP   CY,09D9
        if (!a19[15:8][0]) {
          advance (10)
          A := 24;
          B := a2[7:0];
          H := 24;
          L := 03;
          SPH := a11[15:8];
          SPL := a11[7:0];
          FlagS := a19[7:0][7];
          FlagZ := is_zero(a19[7:0]);
          FlagA := a22[7:0][4];
          FlagP := parity(a19[7:0]);
          FlagCY := !a19[15:8][0];
          jump (09D9);
        } else {
          advance (10)
          #09EE
          #instruction: RET
          let:8 a23 = a11[15:8] in
          let:8 a24 = a11[7:0] in
          let:16 a25 = (1 + (a23,a24)) in
          let:8 a26 = M[(a23,a24)] in
          let:8 a27 = a25[15:8] in
          let:8 a28 = a25[7:0] in
          let:16 a29 = (1 + (a27,a28)) in
          let:8 a30 = M[(a27,a28)] in
          advance (10)
          A := 24;
          B := a2[7:0];
          H := 24;
          L := 03;
          SPH := a29[15:8];
          SPL := a29[7:0];
          FlagS := a19[7:0][7];
          FlagZ := is_zero(a19[7:0]);
          FlagA := a22[7:0][4];
          FlagP := parity(a19[7:0]);
          FlagCY := !a19[15:8][0];
          jump ((a30,a26));
        }
      } else {
        advance (10)
        #09E4
        #instruction: LD   DE,0006
        advance (10)
        #09E7
        #instruction: ADD  HL,DE
        let:17 a31 = add17(0006,2403) in
        advance (10)
        #09E8
        #instruction: LD   A,H
        let:8 a32 = a31[15:0][15:8] in
        advance (5)
        #09E9
        #instruction: CP   40
        let:8 a33 = a32 in
        let:16 a34 = addWithCarry(!false,a33,~40) in
        let:8 a35 = (a33 & 0F) in
        let:8 a36 = (~40 & 0F) in
        let:16 a37 = addWithCarry(!false,a35,a36) in
        advance (7)
        #09EB
        #instruction: JP   CY,09D9
        if (!a34[15:8][0]) {
          advance (10)
          A := a32;
          B := a2[7:0];
          D := 00;
          E := 06;
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a11[15:8];
          SPL := a11[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := !a34[15:8][0];
          jump (09D9);
        } else {
          advance (10)
          #09EE
          #instruction: RET
          let:8 a38 = a11[15:8] in
          let:8 a39 = a11[7:0] in
          let:16 a40 = (1 + (a38,a39)) in
          let:8 a41 = M[(a38,a39)] in
          let:8 a42 = a40[15:8] in
          let:8 a43 = a40[7:0] in
          let:16 a44 = (1 + (a42,a43)) in
          let:8 a45 = M[(a42,a43)] in
          advance (10)
          A := a32;
          B := a2[7:0];
          D := 00;
          E := 06;
          H := a31[15:0][15:8];
          L := a31[15:0][7:0];
          SPH := a44[15:8];
          SPL := a44[7:0];
          FlagS := a34[7:0][7];
          FlagZ := is_zero(a34[7:0]);
          FlagA := a37[7:0][4];
          FlagP := parity(a34[7:0]);
          FlagCY := !a34[15:8][0];
          jump ((a45,a41));
        }
      }
    } else {
      advance (10)
      #17E3
      #instruction: LD   A,01
      advance (7)
      #17E5
      #instruction: LD   (209A),A
      M[209A] := 01;
      advance (13)
      #17E8
      #instruction: CALL 19D7
      let:8 a46 = SPH in
      let:8 a47 = SPL in
      let:16 a48 = (-1 + (a46,a47)) in
      M[a48] := 17;
      let:8 a49 = a48[15:8] in
      let:8 a50 = a48[7:0] in
      let:16 a51 = (-1 + (a49,a50)) in
      M[a51] := EB;
      #return-to: 17EB
      advance (17)
      #19D7
      #instruction: XOR  A
      let:8 a52 = (01 ^ 01) in
      advance (4)
      #19D8
      #instruction: JP   19D3
      advance (10)
      #19D3
      #instruction: LD   (20E9),A
      let:8 a53 = a52 in
      M[20E9] := a53;
      advance (13)
      #19D6
      #instruction: RET
      let:8 a54 = a51[15:8] in
      let:8 a55 = a51[7:0] in
      let:16 a56 = (1 + (a54,a55)) in
      let:8 a57 = M[(a54,a55)] in
      let:8 a58 = a56[15:8] in
      let:8 a59 = a56[7:0] in
      let:16 a60 = (1 + (a58,a59)) in
      let:8 a61 = M[(a58,a59)] in
      advance (10)
      A := a52;
      B := a2[7:0];
      SPH := a60[15:8];
      SPL := a60[7:0];
      FlagS := a52[7];
      FlagZ := is_zero(a52);
      FlagA := false;
      FlagP := parity(a52);
      FlagCY := false;
      jump ((a61,a57));
    }

17EB:

    #17EB
    #instruction: EI
    enable_interrupts()
    advance (4)
    #17EC
    #instruction: LD   DE,1CBC
    advance (10)
    #17EF
    #instruction: LD   HL,3016
    advance (10)
    #17F2
    #instruction: LD   C,04
    advance (7)
    #17F4
    #instruction: CALL 0A93
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := F7;
    #return-to: 17F7
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1C;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := BC;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 0A;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 30;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 16;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(0013,0013) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,13);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 04;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

17F7:

    #17F7
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 17;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := FA;
    #return-to: 17FA
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

17FA:

    #17FA
    #instruction: XOR  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 ^ a2) in
    advance (4)
    #17FB
    #instruction: LD   (209A),A
    let:8 a4 = a3 in
    M[209A] := a4;
    advance (13)
    #17FE
    #instruction: LD   (2093),A
    let:8 a5 = a3 in
    M[2093] := a5;
    advance (13)
    #1801
    #instruction: JP   16C9
    advance (10)
    #16C9
    #instruction: LD   HL,2D18
    advance (10)
    #16CC
    #instruction: LD   DE,1AA6
    advance (10)
    #16CF
    #instruction: LD   C,0A
    advance (7)
    #16D1
    #instruction: CALL 0A93
    let:8 a6 = SPH in
    let:8 a7 = SPL in
    let:16 a8 = (-1 + (a6,a7)) in
    M[a8] := 16;
    let:8 a9 = a8[15:8] in
    let:8 a10 = a8[7:0] in
    let:16 a11 = (-1 + (a9,a10)) in
    M[a11] := D4;
    #return-to: 16D4
    advance (17)
    #0A93
    #instruction: PUSH DE
    let:8 a12 = a11[15:8] in
    let:8 a13 = a11[7:0] in
    let:16 a14 = (-1 + (a12,a13)) in
    M[a14] := 1A;
    let:8 a15 = a14[15:8] in
    let:8 a16 = a14[7:0] in
    let:16 a17 = (-1 + (a15,a16)) in
    M[a17] := A6;
    advance (11)
    #0A94
    #instruction: LD   A,(DE)
    advance (7)
    #0A95
    #instruction: CALL 08FF
    let:8 a18 = a17[15:8] in
    let:8 a19 = a17[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := 0A;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := 98;
    #return-to: 0A98
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := 2D;
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:16 a29 = (-1 + (a27,a28)) in
    M[a29] := 18;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a30 = add17(0006,0006) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:8 a38 = a35[15:0][15:8] in
    let:8 a39 = a35[15:0][7:0] in
    let:17 a40 = add17((a36,a37),(a38,a39)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a41 = a40[15:0][15:8] in
    let:8 a42 = a40[15:0][7:0] in
    let:17 a43 = add17(1E00,(a41,a42)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a44 = a43[15:0][15:8] in
    let:8 a45 = a43[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a46 = a29[15:8] in
    let:8 a47 = a29[7:0] in
    let:16 a48 = (1 + (a46,a47)) in
    let:8 a49 = M[(a46,a47)] in
    let:8 a50 = a48[15:8] in
    let:8 a51 = a48[7:0] in
    let:16 a52 = (1 + (a50,a51)) in
    let:8 a53 = M[(a50,a51)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,06);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a54 = a52[15:8] in
    let:8 a55 = a52[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := 08;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := 0A;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a60 = a44 in
    let:8 a61 = a45 in
    let:8 a62 = M[(a60,a61)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a63 = a62 in
    let:8 a64 = a53 in
    let:8 a65 = a49 in
    M[(a64,a65)] := a63;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a66 = a44 in
    let:8 a67 = a45 in
    let:16 a68 = (1 + (a66,a67)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a69 = a53 in
    let:8 a70 = a49 in
    let:17 a71 = add17(0020,(a69,a70)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a72 = a59[15:8] in
    let:8 a73 = a59[7:0] in
    let:16 a74 = (1 + (a72,a73)) in
    let:8 a75 = M[(a72,a73)] in
    let:8 a76 = a74[15:8] in
    let:8 a77 = a74[7:0] in
    let:16 a78 = (1 + (a76,a77)) in
    let:8 a79 = M[(a76,a77)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a80 = a79 in
    let:16 a81 = addWithCarry(!true,a80,~00) in
    let:8 a82 = (a80 & 0F) in
    let:8 a83 = (~00 & 0F) in
    let:16 a84 = addWithCarry(!true,a82,a83) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a81[7:0])) {
      advance (10)
      A := a62;
      B := a81[7:0];
      C := a75;
      D := a68[15:8];
      E := a68[7:0];
      H := a71[15:0][15:8];
      L := a71[15:0][7:0];
      SPH := a78[15:8];
      SPL := a78[7:0];
      FlagS := a81[7:0][7];
      FlagZ := is_zero(a81[7:0]);
      FlagA := a84[7:0][4];
      FlagP := parity(a81[7:0]);
      FlagCY := a71[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a85 = a78[15:8] in
      let:8 a86 = a78[7:0] in
      let:16 a87 = (1 + (a85,a86)) in
      let:8 a88 = M[(a85,a86)] in
      let:8 a89 = a87[15:8] in
      let:8 a90 = a87[7:0] in
      let:16 a91 = (1 + (a89,a90)) in
      let:8 a92 = M[(a89,a90)] in
      advance (10)
      A := a62;
      B := a81[7:0];
      C := a75;
      D := a68[15:8];
      E := a68[7:0];
      H := a71[15:0][15:8];
      L := a71[15:0][7:0];
      SPH := a91[15:8];
      SPL := a91[7:0];
      FlagS := a81[7:0][7];
      FlagZ := is_zero(a81[7:0]);
      FlagA := a84[7:0][4];
      FlagP := parity(a81[7:0]);
      FlagCY := a71[16];
      jump ((a92,a88));
    }

1820:

    #1820
    #instruction: LD   A,0A
    advance (7)
    #1822
    #instruction: LD   (206C),A
    M[206C] := 0A;
    advance (13)
    #1825
    #instruction: LD   BC,1DBE
    advance (10)
    #1828
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2B;
    #return-to: 182B
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a7 = addWithCarry(!false,0E,~FF) in
    let:8 a8 = (0E & 0F) in
    let:8 a9 = (~FF & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a7[7:0])) {
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (11)
      A := 0E;
      B := 1D;
      C := BE;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := true;
      jump ((a18,a14));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a19 = (1D & 1D) in
      let:8 a20 = (1D | 1D) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a21 = a6[15:8] in
      let:8 a22 = a6[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := a19;
      B := 1D;
      C := C2;
      D := 1D;
      E := 68;
      H := 2C;
      L := 0E;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a19[7];
      FlagZ := is_zero(a19);
      FlagA := a20[3];
      FlagP := parity(a19);
      FlagCY := false;
      jump ((a28,a24));
    }

182B:

    #182B
    #instruction: JP   CY,1837
    if (FlagCY) {
      advance (10)
      jump (1837);
    } else {
      advance (10)
      #182E
      #instruction: CALL 1844
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (-1 + (a1,a2)) in
      M[a3] := 18;
      let:8 a4 = a3[15:8] in
      let:8 a5 = a3[7:0] in
      let:16 a6 = (-1 + (a4,a5)) in
      M[a6] := 31;
      #return-to: 1831
      advance (17)
      #1844
      #instruction: PUSH BC
      let:8 a7 = B in
      let:8 a8 = C in
      let:8 a9 = a6[15:8] in
      let:8 a10 = a6[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := a7;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := a8;
      advance (11)
      #1845
      #instruction: LD   B,10
      advance (7)
      #1847
      #instruction: CALL 1439
      let:8 a15 = a14[15:8] in
      let:8 a16 = a14[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 18;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := 4A;
      #return-to: 184A
      advance (17)
      #1439
      #instruction: PUSH BC
      let:8 a21 = C in
      let:8 a22 = a20[15:8] in
      let:8 a23 = a20[7:0] in
      let:16 a24 = (-1 + (a22,a23)) in
      M[a24] := 10;
      let:8 a25 = a24[15:8] in
      let:8 a26 = a24[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := a21;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a28 = D in
      let:8 a29 = E in
      let:8 a30 = M[(a28,a29)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a31 = a30 in
      let:8 a32 = H in
      let:8 a33 = L in
      M[(a32,a33)] := a31;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a34 = D in
      let:8 a35 = E in
      let:16 a36 = (1 + (a34,a35)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a37 = H in
      let:8 a38 = L in
      let:17 a39 = add17(0020,(a37,a38)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a40 = a27[15:8] in
      let:8 a41 = a27[7:0] in
      let:16 a42 = (1 + (a40,a41)) in
      let:8 a43 = M[(a40,a41)] in
      let:8 a44 = a42[15:8] in
      let:8 a45 = a42[7:0] in
      let:16 a46 = (1 + (a44,a45)) in
      let:8 a47 = M[(a44,a45)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a48 = a47 in
      let:16 a49 = addWithCarry(!true,a48,~00) in
      let:8 a50 = (a48 & 0F) in
      let:8 a51 = (~00 & 0F) in
      let:16 a52 = addWithCarry(!true,a50,a51) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a49[7:0])) {
        advance (10)
        A := a30;
        B := a49[7:0];
        C := a43;
        D := a36[15:8];
        E := a36[7:0];
        H := a39[15:0][15:8];
        L := a39[15:0][7:0];
        SPH := a46[15:8];
        SPL := a46[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a39[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a53 = a46[15:8] in
        let:8 a54 = a46[7:0] in
        let:16 a55 = (1 + (a53,a54)) in
        let:8 a56 = M[(a53,a54)] in
        let:8 a57 = a55[15:8] in
        let:8 a58 = a55[7:0] in
        let:16 a59 = (1 + (a57,a58)) in
        let:8 a60 = M[(a57,a58)] in
        advance (10)
        A := a30;
        B := a49[7:0];
        C := a43;
        D := a36[15:8];
        E := a36[7:0];
        H := a39[15:0][15:8];
        L := a39[15:0][7:0];
        SPH := a59[15:8];
        SPL := a59[7:0];
        FlagS := a49[7:0][7];
        FlagZ := is_zero(a49[7:0]);
        FlagA := a52[7:0][4];
        FlagP := parity(a49[7:0]);
        FlagCY := a39[16];
        jump ((a60,a56));
      }
    }

1831:

    #1831
    #instruction: JP   1828
    advance (10)
    #1828
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 2B;
    #return-to: 182B
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    let:8 a7 = B in
    let:8 a8 = C in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1857
    #instruction: CP   FF
    let:8 a10 = a9 in
    let:16 a11 = addWithCarry(!false,a10,~FF) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~FF & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a11[7:0])) {
      let:8 a15 = a6[15:8] in
      let:8 a16 = a6[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a9;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := true;
      jump ((a22,a18));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      let:8 a23 = a9 in
      advance (5)
      #185C
      #instruction: INC  BC
      let:8 a24 = B in
      let:8 a25 = C in
      let:16 a26 = (1 + (a24,a25)) in
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:8 a29 = M[(a27,a28)] in
      advance (7)
      #185E
      #instruction: LD   H,A
      let:8 a30 = a29 in
      advance (5)
      #185F
      #instruction: INC  BC
      let:8 a31 = a26[15:8] in
      let:8 a32 = a26[7:0] in
      let:16 a33 = (1 + (a31,a32)) in
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      let:8 a34 = a33[15:8] in
      let:8 a35 = a33[7:0] in
      let:8 a36 = M[(a34,a35)] in
      advance (7)
      #1861
      #instruction: LD   E,A
      let:8 a37 = a36 in
      advance (5)
      #1862
      #instruction: INC  BC
      let:8 a38 = a33[15:8] in
      let:8 a39 = a33[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      let:8 a41 = a40[15:8] in
      let:8 a42 = a40[7:0] in
      let:8 a43 = M[(a41,a42)] in
      advance (7)
      #1864
      #instruction: LD   D,A
      let:8 a44 = a43 in
      advance (5)
      #1865
      #instruction: INC  BC
      let:8 a45 = a40[15:8] in
      let:8 a46 = a40[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a48 = a43 in
      let:8 a49 = a43 in
      let:8 a50 = (a48 & a49) in
      let:8 a51 = (a48 | a49) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a52 = a6[15:8] in
      let:8 a53 = a6[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      advance (10)
      A := a50;
      B := a47[15:8];
      C := a47[7:0];
      D := a44;
      E := a37;
      H := a30;
      L := a23;
      SPH := a58[15:8];
      SPL := a58[7:0];
      FlagS := a50[7];
      FlagZ := is_zero(a50);
      FlagA := a51[3];
      FlagP := parity(a50);
      FlagCY := false;
      jump ((a59,a55));
    }

1834:

    #1834
    #instruction: CALL 0AB1
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 37;
    #return-to: 1837
    advance (17)
    #0AB1
    #instruction: LD   A,40
    advance (7)
    #0AB3
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 40;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a7 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a8 = a7 in
    let:8 a9 = a7 in
    let:8 a10 = (a8 & a9) in
    let:8 a11 = (a8 | a9) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a10)) {
      advance (10)
      A := a10;
      SPH := a6[15:8];
      SPL := a6[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a12 = a6[15:8] in
      let:8 a13 = a6[7:0] in
      let:16 a14 = (1 + (a12,a13)) in
      let:8 a15 = M[(a12,a13)] in
      let:8 a16 = a14[15:8] in
      let:8 a17 = a14[7:0] in
      let:16 a18 = (1 + (a16,a17)) in
      let:8 a19 = M[(a16,a17)] in
      advance (10)
      A := a10;
      SPH := a18[15:8];
      SPL := a18[7:0];
      FlagS := a10[7];
      FlagZ := is_zero(a10);
      FlagA := a11[3];
      FlagP := parity(a10);
      FlagCY := false;
      jump ((a19,a15));
    }

1837:

    #1837
    #instruction: LD   BC,1DCF
    advance (10)
    #183A
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3D;
    #return-to: 183D
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    advance (7)
    #1857
    #instruction: CP   FF
    let:16 a7 = addWithCarry(!false,0E,~FF) in
    let:8 a8 = (0E & 0F) in
    let:8 a9 = (~FF & 0F) in
    let:16 a10 = addWithCarry(!false,a8,a9) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a7[7:0])) {
      let:8 a11 = a6[15:8] in
      let:8 a12 = a6[7:0] in
      let:16 a13 = (1 + (a11,a12)) in
      let:8 a14 = M[(a11,a12)] in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      advance (11)
      A := 0E;
      B := 1D;
      C := CF;
      SPH := a17[15:8];
      SPL := a17[7:0];
      FlagS := a7[7:0][7];
      FlagZ := is_zero(a7[7:0]);
      FlagA := a10[7:0][4];
      FlagP := parity(a7[7:0]);
      FlagCY := true;
      jump ((a18,a14));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      advance (5)
      #185C
      #instruction: INC  BC
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      advance (7)
      #185E
      #instruction: LD   H,A
      advance (5)
      #185F
      #instruction: INC  BC
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      advance (7)
      #1861
      #instruction: LD   E,A
      advance (5)
      #1862
      #instruction: INC  BC
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      advance (7)
      #1864
      #instruction: LD   D,A
      advance (5)
      #1865
      #instruction: INC  BC
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a19 = (1D & 1D) in
      let:8 a20 = (1D | 1D) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a21 = a6[15:8] in
      let:8 a22 = a6[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      let:8 a25 = a23[15:8] in
      let:8 a26 = a23[7:0] in
      let:16 a27 = (1 + (a25,a26)) in
      let:8 a28 = M[(a25,a26)] in
      advance (10)
      A := a19;
      B := 1D;
      C := D3;
      D := 1D;
      E := E0;
      H := 2E;
      L := 0E;
      SPH := a27[15:8];
      SPL := a27[7:0];
      FlagS := a19[7];
      FlagZ := is_zero(a19);
      FlagA := a20[3];
      FlagP := parity(a19);
      FlagCY := false;
      jump ((a28,a24));
    }

183D:

    #183D
    #instruction: RET  CY
    if (FlagCY) {
      let:8 a1 = SPH in
      let:8 a2 = SPL in
      let:16 a3 = (1 + (a1,a2)) in
      let:8 a4 = M[(a1,a2)] in
      let:8 a5 = a3[15:8] in
      let:8 a6 = a3[7:0] in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      advance (11)
      SPH := a7[15:8];
      SPL := a7[7:0];
      jump ((a8,a4));
    } else {
      advance (5)
      #183E
      #instruction: CALL 184C
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := 18;
      let:8 a12 = a11[15:8] in
      let:8 a13 = a11[7:0] in
      let:16 a14 = (-1 + (a12,a13)) in
      M[a14] := 41;
      #return-to: 1841
      advance (17)
      #184C
      #instruction: PUSH BC
      let:8 a15 = B in
      let:8 a16 = C in
      let:8 a17 = a14[15:8] in
      let:8 a18 = a14[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := a15;
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := a16;
      advance (11)
      #184D
      #instruction: LD   A,(206C)
      let:8 a23 = M[206C] in
      advance (13)
      #1850
      #instruction: LD   C,A
      let:8 a24 = a23 in
      advance (5)
      #1851
      #instruction: CALL 0A93
      let:8 a25 = a22[15:8] in
      let:8 a26 = a22[7:0] in
      let:16 a27 = (-1 + (a25,a26)) in
      M[a27] := 18;
      let:8 a28 = a27[15:8] in
      let:8 a29 = a27[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 54;
      #return-to: 1854
      advance (17)
      #0A93
      #instruction: PUSH DE
      let:8 a31 = D in
      let:8 a32 = E in
      let:8 a33 = a30[15:8] in
      let:8 a34 = a30[7:0] in
      let:16 a35 = (-1 + (a33,a34)) in
      M[a35] := a31;
      let:8 a36 = a35[15:8] in
      let:8 a37 = a35[7:0] in
      let:16 a38 = (-1 + (a36,a37)) in
      M[a38] := a32;
      advance (11)
      #0A94
      #instruction: LD   A,(DE)
      let:8 a39 = D in
      let:8 a40 = E in
      let:8 a41 = M[(a39,a40)] in
      advance (7)
      #0A95
      #instruction: CALL 08FF
      let:8 a42 = a38[15:8] in
      let:8 a43 = a38[7:0] in
      let:16 a44 = (-1 + (a42,a43)) in
      M[a44] := 0A;
      let:8 a45 = a44[15:8] in
      let:8 a46 = a44[7:0] in
      let:16 a47 = (-1 + (a45,a46)) in
      M[a47] := 98;
      #return-to: 0A98
      advance (17)
      #08FF
      #instruction: LD   DE,1E00
      advance (10)
      #0902
      #instruction: PUSH HL
      let:8 a48 = H in
      let:8 a49 = L in
      let:8 a50 = a47[15:8] in
      let:8 a51 = a47[7:0] in
      let:16 a52 = (-1 + (a50,a51)) in
      M[a52] := a48;
      let:8 a53 = a52[15:8] in
      let:8 a54 = a52[7:0] in
      let:16 a55 = (-1 + (a53,a54)) in
      M[a55] := a49;
      advance (11)
      #0903
      #instruction: LD   H,00
      advance (7)
      #0905
      #instruction: LD   L,A
      let:8 a56 = a41 in
      advance (5)
      #0906
      #instruction: ADD  HL,HL
      let:8 a57 = a56 in
      let:8 a58 = a56 in
      let:17 a59 = add17((00,a57),(00,a58)) in
      advance (10)
      #0907
      #instruction: ADD  HL,HL
      let:8 a60 = a59[15:0][15:8] in
      let:8 a61 = a59[15:0][7:0] in
      let:8 a62 = a59[15:0][15:8] in
      let:8 a63 = a59[15:0][7:0] in
      let:17 a64 = add17((a60,a61),(a62,a63)) in
      advance (10)
      #0908
      #instruction: ADD  HL,HL
      let:8 a65 = a64[15:0][15:8] in
      let:8 a66 = a64[15:0][7:0] in
      let:8 a67 = a64[15:0][15:8] in
      let:8 a68 = a64[15:0][7:0] in
      let:17 a69 = add17((a65,a66),(a67,a68)) in
      advance (10)
      #0909
      #instruction: ADD  HL,DE
      let:8 a70 = a69[15:0][15:8] in
      let:8 a71 = a69[15:0][7:0] in
      let:17 a72 = add17(1E00,(a70,a71)) in
      advance (10)
      #090A
      #instruction: EX   DE,HL
      let:8 a73 = a72[15:0][15:8] in
      let:8 a74 = a72[15:0][7:0] in
      advance (4)
      #090B
      #instruction: POP  HL
      let:8 a75 = a55[15:8] in
      let:8 a76 = a55[7:0] in
      let:16 a77 = (1 + (a75,a76)) in
      let:8 a78 = M[(a75,a76)] in
      let:8 a79 = a77[15:8] in
      let:8 a80 = a77[7:0] in
      let:16 a81 = (1 + (a79,a80)) in
      let:8 a82 = M[(a79,a80)] in
      advance (10)
      #090C
      #instruction: LD   B,08
      advance (7)
      #090E
      #instruction: OUT  06
      let:8 a83 = a41 in
      unknown_output(6,a83);
      advance (10)
      #0910
      #instruction: JP   1439
      advance (10)
      #1439
      #instruction: PUSH BC
      let:8 a84 = a24 in
      let:8 a85 = a81[15:8] in
      let:8 a86 = a81[7:0] in
      let:16 a87 = (-1 + (a85,a86)) in
      M[a87] := 08;
      let:8 a88 = a87[15:8] in
      let:8 a89 = a87[7:0] in
      let:16 a90 = (-1 + (a88,a89)) in
      M[a90] := a84;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      let:8 a91 = a73 in
      let:8 a92 = a74 in
      let:8 a93 = M[(a91,a92)] in
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a94 = a93 in
      let:8 a95 = a82 in
      let:8 a96 = a78 in
      M[(a95,a96)] := a94;
      advance (7)
      #143C
      #instruction: INC  DE
      let:8 a97 = a73 in
      let:8 a98 = a74 in
      let:16 a99 = (1 + (a97,a98)) in
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a100 = a82 in
      let:8 a101 = a78 in
      let:17 a102 = add17(0020,(a100,a101)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a103 = a90[15:8] in
      let:8 a104 = a90[7:0] in
      let:16 a105 = (1 + (a103,a104)) in
      let:8 a106 = M[(a103,a104)] in
      let:8 a107 = a105[15:8] in
      let:8 a108 = a105[7:0] in
      let:16 a109 = (1 + (a107,a108)) in
      let:8 a110 = M[(a107,a108)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a111 = a110 in
      let:16 a112 = addWithCarry(!true,a111,~00) in
      let:8 a113 = (a111 & 0F) in
      let:8 a114 = (~00 & 0F) in
      let:16 a115 = addWithCarry(!true,a113,a114) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a112[7:0])) {
        advance (10)
        A := a93;
        B := a112[7:0];
        C := a106;
        D := a99[15:8];
        E := a99[7:0];
        H := a102[15:0][15:8];
        L := a102[15:0][7:0];
        SPH := a109[15:8];
        SPL := a109[7:0];
        FlagS := a112[7:0][7];
        FlagZ := is_zero(a112[7:0]);
        FlagA := a115[7:0][4];
        FlagP := parity(a112[7:0]);
        FlagCY := a102[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a116 = a109[15:8] in
        let:8 a117 = a109[7:0] in
        let:16 a118 = (1 + (a116,a117)) in
        let:8 a119 = M[(a116,a117)] in
        let:8 a120 = a118[15:8] in
        let:8 a121 = a118[7:0] in
        let:16 a122 = (1 + (a120,a121)) in
        let:8 a123 = M[(a120,a121)] in
        advance (10)
        A := a93;
        B := a112[7:0];
        C := a106;
        D := a99[15:8];
        E := a99[7:0];
        H := a102[15:0][15:8];
        L := a102[15:0][7:0];
        SPH := a122[15:8];
        SPL := a122[7:0];
        FlagS := a112[7:0][7];
        FlagZ := is_zero(a112[7:0]);
        FlagA := a115[7:0][4];
        FlagP := parity(a112[7:0]);
        FlagCY := a102[16];
        jump ((a123,a119));
      }
    }

1841:

    #1841
    #instruction: JP   183A
    advance (10)
    #183A
    #instruction: CALL 1856
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 3D;
    #return-to: 183D
    advance (17)
    #1856
    #instruction: LD   A,(BC)
    let:8 a7 = B in
    let:8 a8 = C in
    let:8 a9 = M[(a7,a8)] in
    advance (7)
    #1857
    #instruction: CP   FF
    let:8 a10 = a9 in
    let:16 a11 = addWithCarry(!false,a10,~FF) in
    let:8 a12 = (a10 & 0F) in
    let:8 a13 = (~FF & 0F) in
    let:16 a14 = addWithCarry(!false,a12,a13) in
    advance (7)
    #1859
    #instruction: SCF
    advance (4)
    #185A
    #instruction: RET  Z
    if (is_zero(a11[7:0])) {
      let:8 a15 = a6[15:8] in
      let:8 a16 = a6[7:0] in
      let:16 a17 = (1 + (a15,a16)) in
      let:8 a18 = M[(a15,a16)] in
      let:8 a19 = a17[15:8] in
      let:8 a20 = a17[7:0] in
      let:16 a21 = (1 + (a19,a20)) in
      let:8 a22 = M[(a19,a20)] in
      advance (11)
      A := a9;
      SPH := a21[15:8];
      SPL := a21[7:0];
      FlagS := a11[7:0][7];
      FlagZ := is_zero(a11[7:0]);
      FlagA := a14[7:0][4];
      FlagP := parity(a11[7:0]);
      FlagCY := true;
      jump ((a22,a18));
    } else {
      advance (5)
      #185B
      #instruction: LD   L,A
      let:8 a23 = a9 in
      advance (5)
      #185C
      #instruction: INC  BC
      let:8 a24 = B in
      let:8 a25 = C in
      let:16 a26 = (1 + (a24,a25)) in
      advance (5)
      #185D
      #instruction: LD   A,(BC)
      let:8 a27 = a26[15:8] in
      let:8 a28 = a26[7:0] in
      let:8 a29 = M[(a27,a28)] in
      advance (7)
      #185E
      #instruction: LD   H,A
      let:8 a30 = a29 in
      advance (5)
      #185F
      #instruction: INC  BC
      let:8 a31 = a26[15:8] in
      let:8 a32 = a26[7:0] in
      let:16 a33 = (1 + (a31,a32)) in
      advance (5)
      #1860
      #instruction: LD   A,(BC)
      let:8 a34 = a33[15:8] in
      let:8 a35 = a33[7:0] in
      let:8 a36 = M[(a34,a35)] in
      advance (7)
      #1861
      #instruction: LD   E,A
      let:8 a37 = a36 in
      advance (5)
      #1862
      #instruction: INC  BC
      let:8 a38 = a33[15:8] in
      let:8 a39 = a33[7:0] in
      let:16 a40 = (1 + (a38,a39)) in
      advance (5)
      #1863
      #instruction: LD   A,(BC)
      let:8 a41 = a40[15:8] in
      let:8 a42 = a40[7:0] in
      let:8 a43 = M[(a41,a42)] in
      advance (7)
      #1864
      #instruction: LD   D,A
      let:8 a44 = a43 in
      advance (5)
      #1865
      #instruction: INC  BC
      let:8 a45 = a40[15:8] in
      let:8 a46 = a40[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      advance (5)
      #1866
      #instruction: AND  A
      let:8 a48 = a43 in
      let:8 a49 = a43 in
      let:8 a50 = (a48 & a49) in
      let:8 a51 = (a48 | a49) in
      advance (4)
      #1867
      #instruction: RET
      let:8 a52 = a6[15:8] in
      let:8 a53 = a6[7:0] in
      let:16 a54 = (1 + (a52,a53)) in
      let:8 a55 = M[(a52,a53)] in
      let:8 a56 = a54[15:8] in
      let:8 a57 = a54[7:0] in
      let:16 a58 = (1 + (a56,a57)) in
      let:8 a59 = M[(a56,a57)] in
      advance (10)
      A := a50;
      B := a47[15:8];
      C := a47[7:0];
      D := a44;
      E := a37;
      H := a30;
      L := a23;
      SPH := a58[15:8];
      SPL := a58[7:0];
      FlagS := a50[7];
      FlagZ := is_zero(a50);
      FlagA := a51[3];
      FlagP := parity(a50);
      FlagCY := false;
      jump ((a59,a55));
    }

184A:

    #184A
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #184B
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    B := a8;
    C := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

1854:

    #1854
    #instruction: POP  BC
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #1855
    #instruction: RET
    let:8 a9 = a7[15:8] in
    let:8 a10 = a7[7:0] in
    let:16 a11 = (1 + (a9,a10)) in
    let:8 a12 = M[(a9,a10)] in
    let:8 a13 = a11[15:8] in
    let:8 a14 = a11[7:0] in
    let:16 a15 = (1 + (a13,a14)) in
    let:8 a16 = M[(a13,a14)] in
    advance (10)
    B := a8;
    C := a4;
    SPH := a15[15:8];
    SPL := a15[7:0];
    jump ((a16,a12));

1871:

    #1871
    #instruction: LD   B,A
    let:8 a1 = A in
    advance (5)
    #1872
    #instruction: LD   A,(20CA)
    let:8 a2 = M[20CA] in
    advance (13)
    #1875
    #instruction: CP   B
    let:8 a3 = a2 in
    let:8 a4 = a1 in
    let:16 a5 = addWithCarry(!false,a3,~a4) in
    let:8 a6 = (a3 & 0F) in
    let:8 a7 = (~a4 & 0F) in
    let:16 a8 = addWithCarry(!false,a6,a7) in
    advance (4)
    #1876
    #instruction: JP   Z,1898
    if (is_zero(a5[7:0])) {
      advance (10)
      #1898
      #instruction: LD   A,01
      advance (7)
      #189A
      #instruction: LD   (20CB),A
      M[20CB] := 01;
      advance (13)
      #189D
      #instruction: RET
      let:8 a9 = SPH in
      let:8 a10 = SPL in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      let:8 a13 = a11[15:8] in
      let:8 a14 = a11[7:0] in
      let:16 a15 = (1 + (a13,a14)) in
      let:8 a16 = M[(a13,a14)] in
      advance (10)
      A := 01;
      B := a1;
      SPH := a15[15:8];
      SPL := a15[7:0];
      FlagS := a5[7:0][7];
      FlagZ := is_zero(a5[7:0]);
      FlagA := a8[7:0][4];
      FlagP := parity(a5[7:0]);
      FlagCY := !a5[15:8][0];
      jump ((a16,a12));
    } else {
      advance (10)
      #1879
      #instruction: LD   A,(20C2)
      let:8 a17 = M[20C2] in
      advance (13)
      #187C
      #instruction: AND  04
      let:8 a18 = a17 in
      let:8 a19 = (04 & a18) in
      let:8 a20 = (04 | a18) in
      advance (7)
      #187E
      #instruction: LD   HL,(20CC)
      let:8 a21 = M[20CC] in
      let:8 a22 = M[20CD] in
      advance (16)
      #1881
      #instruction: JP   NZ,1888
      if (!is_zero(a19)) {
        advance (10)
        #1888
        #instruction: LD   (20C7),HL
        let:8 a23 = a21 in
        M[20C7] := a23;
        let:8 a24 = a22 in
        M[20C8] := a24;
        advance (16)
        #188B
        #instruction: LD   HL,20C5
        advance (10)
        #188E
        #instruction: CALL 1A3B
        let:8 a25 = SPH in
        let:8 a26 = SPL in
        let:16 a27 = (-1 + (a25,a26)) in
        M[a27] := 18;
        let:8 a28 = a27[15:8] in
        let:8 a29 = a27[7:0] in
        let:16 a30 = (-1 + (a28,a29)) in
        M[a30] := 91;
        #return-to: 1891
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a31 = M[20C5] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a32 = M[20C6] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a33 = M[20C7] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a34 = M[20C8] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a35 = M[20C9] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a36 = a34 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a37 = a33 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a38 = a30[15:8] in
        let:8 a39 = a30[7:0] in
        let:16 a40 = (1 + (a38,a39)) in
        let:8 a41 = M[(a38,a39)] in
        let:8 a42 = a40[15:8] in
        let:8 a43 = a40[7:0] in
        let:16 a44 = (1 + (a42,a43)) in
        let:8 a45 = M[(a42,a43)] in
        advance (10)
        A := a33;
        B := a35;
        C := a34;
        D := a32;
        E := a31;
        H := a36;
        L := a37;
        SPH := a44[15:8];
        SPL := a44[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := false;
        jump ((a45,a41));
      } else {
        advance (10)
        #1884
        #instruction: LD   DE,0030
        advance (10)
        #1887
        #instruction: ADD  HL,DE
        let:8 a46 = a22 in
        let:8 a47 = a21 in
        let:17 a48 = add17(0030,(a46,a47)) in
        advance (10)
        #1888
        #instruction: LD   (20C7),HL
        let:8 a49 = a48[15:0][7:0] in
        M[20C7] := a49;
        let:8 a50 = a48[15:0][15:8] in
        M[20C8] := a50;
        advance (16)
        #188B
        #instruction: LD   HL,20C5
        advance (10)
        #188E
        #instruction: CALL 1A3B
        let:8 a51 = SPH in
        let:8 a52 = SPL in
        let:16 a53 = (-1 + (a51,a52)) in
        M[a53] := 18;
        let:8 a54 = a53[15:8] in
        let:8 a55 = a53[7:0] in
        let:16 a56 = (-1 + (a54,a55)) in
        M[a56] := 91;
        #return-to: 1891
        advance (17)
        #1A3B
        #instruction: LD   E,(HL)
        let:8 a57 = M[20C5] in
        advance (7)
        #1A3C
        #instruction: INC  HL
        advance (5)
        #1A3D
        #instruction: LD   D,(HL)
        let:8 a58 = M[20C6] in
        advance (7)
        #1A3E
        #instruction: INC  HL
        advance (5)
        #1A3F
        #instruction: LD   A,(HL)
        let:8 a59 = M[20C7] in
        advance (7)
        #1A40
        #instruction: INC  HL
        advance (5)
        #1A41
        #instruction: LD   C,(HL)
        let:8 a60 = M[20C8] in
        advance (7)
        #1A42
        #instruction: INC  HL
        advance (5)
        #1A43
        #instruction: LD   B,(HL)
        let:8 a61 = M[20C9] in
        advance (7)
        #1A44
        #instruction: LD   H,C
        let:8 a62 = a60 in
        advance (5)
        #1A45
        #instruction: LD   L,A
        let:8 a63 = a59 in
        advance (5)
        #1A46
        #instruction: RET
        let:8 a64 = a56[15:8] in
        let:8 a65 = a56[7:0] in
        let:16 a66 = (1 + (a64,a65)) in
        let:8 a67 = M[(a64,a65)] in
        let:8 a68 = a66[15:8] in
        let:8 a69 = a66[7:0] in
        let:16 a70 = (1 + (a68,a69)) in
        let:8 a71 = M[(a68,a69)] in
        advance (10)
        A := a59;
        B := a61;
        C := a60;
        D := a58;
        E := a57;
        H := a62;
        L := a63;
        SPH := a70[15:8];
        SPL := a70[7:0];
        FlagS := a19[7];
        FlagZ := is_zero(a19);
        FlagA := a20[3];
        FlagP := parity(a19);
        FlagCY := a48[16];
        jump ((a71,a67));
      }
    }

1891:

    #1891
    #instruction: EX   DE,HL
    let:8 a1 = D in
    let:8 a2 = E in
    let:8 a3 = H in
    let:8 a4 = L in
    advance (4)
    #1892
    #instruction: JP   15D3
    advance (10)
    #15D3
    #instruction: CALL 1474
    let:8 a5 = SPH in
    let:8 a6 = SPL in
    let:16 a7 = (-1 + (a5,a6)) in
    M[a7] := 15;
    let:8 a8 = a7[15:8] in
    let:8 a9 = a7[7:0] in
    let:16 a10 = (-1 + (a8,a9)) in
    M[a10] := D6;
    #return-to: 15D6
    advance (17)
    #1474
    #instruction: LD   A,L
    let:8 a11 = a2 in
    advance (5)
    #1475
    #instruction: AND  07
    let:8 a12 = a11 in
    let:8 a13 = (07 & a12) in
    let:8 a14 = (07 | a12) in
    advance (7)
    #1477
    #instruction: OUT  02
    let:8 a15 = a13 in
    advance (10)
    #1479
    #instruction: JP   1A47
    advance (10)
    #1A47
    #instruction: PUSH BC
    let:8 a16 = B in
    let:8 a17 = C in
    let:8 a18 = a10[15:8] in
    let:8 a19 = a10[7:0] in
    let:16 a20 = (-1 + (a18,a19)) in
    M[a20] := a16;
    let:8 a21 = a20[15:8] in
    let:8 a22 = a20[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a17;
    advance (11)
    #1A48
    #instruction: LD   B,03
    advance (7)
    #1A4A
    #instruction: LD   A,H
    let:8 a24 = a1 in
    advance (5)
    #1A4B
    #instruction: RAR
    let:8 a25 = a24 in
    advance (4)
    #1A4C
    #instruction: LD   H,A
    let:8 a26 = updateBit((a25 >> 01),7,false) in
    advance (5)
    #1A4D
    #instruction: LD   A,L
    let:8 a27 = a2 in
    advance (5)
    #1A4E
    #instruction: RAR
    let:8 a28 = a27 in
    advance (4)
    #1A4F
    #instruction: LD   L,A
    let:8 a29 = updateBit((a28 >> 01),7,a25[0]) in
    advance (5)
    #1A50
    #instruction: DEC  B
    let:16 a30 = addWithCarry(!true,03,~00) in
    let:8 a31 = (03 & 0F) in
    let:8 a32 = (~00 & 0F) in
    let:16 a33 = addWithCarry(!true,a31,a32) in
    advance (5)
    #1A51
    #instruction: JP   NZ,1A4A
    if (!is_zero(a30[7:0])) {
      advance (10)
      A := updateBit((a28 >> 01),7,a25[0]);
      B := a30[7:0];
      D := a3;
      E := a4;
      H := a26;
      L := a29;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a30[7:0][7];
      FlagZ := is_zero(a30[7:0]);
      FlagA := a33[7:0][4];
      FlagP := parity(a30[7:0]);
      FlagCY := a28[0];
      Shifter_OFF := a15;
      jump (1A4A);
    } else {
      advance (10)
      #1A54
      #instruction: LD   A,H
      let:8 a34 = a26 in
      advance (5)
      #1A55
      #instruction: AND  3F
      let:8 a35 = a34 in
      let:8 a36 = (3F & a35) in
      let:8 a37 = (3F | a35) in
      advance (7)
      #1A57
      #instruction: OR   20
      let:8 a38 = a36 in
      let:8 a39 = (20 | a38) in
      advance (7)
      #1A59
      #instruction: LD   H,A
      let:8 a40 = a39 in
      advance (5)
      #1A5A
      #instruction: POP  BC
      let:8 a41 = a23[15:8] in
      let:8 a42 = a23[7:0] in
      let:16 a43 = (1 + (a41,a42)) in
      let:8 a44 = M[(a41,a42)] in
      let:8 a45 = a43[15:8] in
      let:8 a46 = a43[7:0] in
      let:16 a47 = (1 + (a45,a46)) in
      let:8 a48 = M[(a45,a46)] in
      advance (10)
      #1A5B
      #instruction: RET
      let:8 a49 = a47[15:8] in
      let:8 a50 = a47[7:0] in
      let:16 a51 = (1 + (a49,a50)) in
      let:8 a52 = M[(a49,a50)] in
      let:8 a53 = a51[15:8] in
      let:8 a54 = a51[7:0] in
      let:16 a55 = (1 + (a53,a54)) in
      let:8 a56 = M[(a53,a54)] in
      advance (10)
      A := a39;
      B := a48;
      C := a44;
      D := a3;
      E := a4;
      H := a40;
      L := a29;
      SPH := a55[15:8];
      SPL := a55[7:0];
      FlagS := a39[7];
      FlagZ := is_zero(a39);
      FlagA := false;
      FlagP := parity(a39);
      FlagCY := false;
      Shifter_OFF := a15;
      jump ((a56,a52));
    }

18A9:

    #18A9
    #instruction: LD   A,02
    advance (7)
    #18AB
    #instruction: LD   (2080),A
    M[2080] := 02;
    advance (13)
    #18AE
    #instruction: LD   A,FF
    advance (7)
    #18B0
    #instruction: LD   (207E),A
    M[207E] := FF;
    advance (13)
    #18B3
    #instruction: LD   A,04
    advance (7)
    #18B5
    #instruction: LD   (20C1),A
    M[20C1] := 04;
    advance (13)
    #18B8
    #instruction: LD   A,(2055)
    let:8 a1 = M[2055] in
    advance (13)
    #18BB
    #instruction: AND  01
    let:8 a2 = a1 in
    let:8 a3 = (01 & a2) in
    let:8 a4 = (01 | a2) in
    advance (7)
    #18BD
    #instruction: JP   Z,18B8
    if (is_zero(a3)) {
      advance (10)
      A := a3;
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump (18B8);
    } else {
      advance (10)
      #18C0
      #instruction: LD   A,(2055)
      let:8 a5 = M[2055] in
      advance (13)
      #18C3
      #instruction: AND  01
      let:8 a6 = a5 in
      let:8 a7 = (01 & a6) in
      let:8 a8 = (01 | a6) in
      advance (7)
      #18C5
      #instruction: JP   NZ,18C0
      if (!is_zero(a7)) {
        advance (10)
        A := a7;
        FlagS := a7[7];
        FlagZ := is_zero(a7);
        FlagA := a8[3];
        FlagP := parity(a7);
        FlagCY := false;
        jump (18C0);
      } else {
        advance (10)
        #18C8
        #instruction: LD   HL,3311
        advance (10)
        #18CB
        #instruction: LD   A,26
        advance (7)
        #18CD
        #instruction: NOP
        advance (4)
        #18CE
        #instruction: CALL 08FF
        let:8 a9 = SPH in
        let:8 a10 = SPL in
        let:16 a11 = (-1 + (a9,a10)) in
        M[a11] := 18;
        let:8 a12 = a11[15:8] in
        let:8 a13 = a11[7:0] in
        let:16 a14 = (-1 + (a12,a13)) in
        M[a14] := D1;
        #return-to: 18D1
        advance (17)
        #08FF
        #instruction: LD   DE,1E00
        advance (10)
        #0902
        #instruction: PUSH HL
        let:8 a15 = a14[15:8] in
        let:8 a16 = a14[7:0] in
        let:16 a17 = (-1 + (a15,a16)) in
        M[a17] := 33;
        let:8 a18 = a17[15:8] in
        let:8 a19 = a17[7:0] in
        let:16 a20 = (-1 + (a18,a19)) in
        M[a20] := 11;
        advance (11)
        #0903
        #instruction: LD   H,00
        advance (7)
        #0905
        #instruction: LD   L,A
        advance (5)
        #0906
        #instruction: ADD  HL,HL
        let:17 a21 = add17(0026,0026) in
        advance (10)
        #0907
        #instruction: ADD  HL,HL
        let:8 a22 = a21[15:0][15:8] in
        let:8 a23 = a21[15:0][7:0] in
        let:8 a24 = a21[15:0][15:8] in
        let:8 a25 = a21[15:0][7:0] in
        let:17 a26 = add17((a22,a23),(a24,a25)) in
        advance (10)
        #0908
        #instruction: ADD  HL,HL
        let:8 a27 = a26[15:0][15:8] in
        let:8 a28 = a26[15:0][7:0] in
        let:8 a29 = a26[15:0][15:8] in
        let:8 a30 = a26[15:0][7:0] in
        let:17 a31 = add17((a27,a28),(a29,a30)) in
        advance (10)
        #0909
        #instruction: ADD  HL,DE
        let:8 a32 = a31[15:0][15:8] in
        let:8 a33 = a31[15:0][7:0] in
        let:17 a34 = add17(1E00,(a32,a33)) in
        advance (10)
        #090A
        #instruction: EX   DE,HL
        let:8 a35 = a34[15:0][15:8] in
        let:8 a36 = a34[15:0][7:0] in
        advance (4)
        #090B
        #instruction: POP  HL
        let:8 a37 = a20[15:8] in
        let:8 a38 = a20[7:0] in
        let:16 a39 = (1 + (a37,a38)) in
        let:8 a40 = M[(a37,a38)] in
        let:8 a41 = a39[15:8] in
        let:8 a42 = a39[7:0] in
        let:16 a43 = (1 + (a41,a42)) in
        let:8 a44 = M[(a41,a42)] in
        advance (10)
        #090C
        #instruction: LD   B,08
        advance (7)
        #090E
        #instruction: OUT  06
        unknown_output(6,26);
        advance (10)
        #0910
        #instruction: JP   1439
        advance (10)
        #1439
        #instruction: PUSH BC
        let:8 a45 = C in
        let:8 a46 = a43[15:8] in
        let:8 a47 = a43[7:0] in
        let:16 a48 = (-1 + (a46,a47)) in
        M[a48] := 08;
        let:8 a49 = a48[15:8] in
        let:8 a50 = a48[7:0] in
        let:16 a51 = (-1 + (a49,a50)) in
        M[a51] := a45;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        let:8 a52 = a35 in
        let:8 a53 = a36 in
        let:8 a54 = M[(a52,a53)] in
        advance (7)
        #143B
        #instruction: LD   (HL),A
        let:8 a55 = a54 in
        let:8 a56 = a44 in
        let:8 a57 = a40 in
        M[(a56,a57)] := a55;
        advance (7)
        #143C
        #instruction: INC  DE
        let:8 a58 = a35 in
        let:8 a59 = a36 in
        let:16 a60 = (1 + (a58,a59)) in
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:8 a61 = a44 in
        let:8 a62 = a40 in
        let:17 a63 = add17(0020,(a61,a62)) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a64 = a51[15:8] in
        let:8 a65 = a51[7:0] in
        let:16 a66 = (1 + (a64,a65)) in
        let:8 a67 = M[(a64,a65)] in
        let:8 a68 = a66[15:8] in
        let:8 a69 = a66[7:0] in
        let:16 a70 = (1 + (a68,a69)) in
        let:8 a71 = M[(a68,a69)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a72 = a71 in
        let:16 a73 = addWithCarry(!true,a72,~00) in
        let:8 a74 = (a72 & 0F) in
        let:8 a75 = (~00 & 0F) in
        let:16 a76 = addWithCarry(!true,a74,a75) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a73[7:0])) {
          advance (10)
          A := a54;
          B := a73[7:0];
          C := a67;
          D := a60[15:8];
          E := a60[7:0];
          H := a63[15:0][15:8];
          L := a63[15:0][7:0];
          SPH := a70[15:8];
          SPL := a70[7:0];
          FlagS := a73[7:0][7];
          FlagZ := is_zero(a73[7:0]);
          FlagA := a76[7:0][4];
          FlagP := parity(a73[7:0]);
          FlagCY := a63[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a77 = a70[15:8] in
          let:8 a78 = a70[7:0] in
          let:16 a79 = (1 + (a77,a78)) in
          let:8 a80 = M[(a77,a78)] in
          let:8 a81 = a79[15:8] in
          let:8 a82 = a79[7:0] in
          let:16 a83 = (1 + (a81,a82)) in
          let:8 a84 = M[(a81,a82)] in
          advance (10)
          A := a54;
          B := a73[7:0];
          C := a67;
          D := a60[15:8];
          E := a60[7:0];
          H := a63[15:0][15:8];
          L := a63[15:0][7:0];
          SPH := a83[15:8];
          SPL := a83[7:0];
          FlagS := a73[7:0][7];
          FlagZ := is_zero(a73[7:0]);
          FlagA := a76[7:0][4];
          FlagP := parity(a73[7:0]);
          FlagCY := a63[16];
          jump ((a84,a80));
        }
      }
    }

18D1:

    #18D1
    #instruction: JP   0AB6
    advance (10)
    #0AB6
    #instruction: LD   A,80
    advance (7)
    #0AB8
    #instruction: JP   0AD7
    advance (10)
    #0AD7
    #instruction: LD   (20C0),A
    M[20C0] := 80;
    advance (13)
    #0ADA
    #instruction: LD   A,(20C0)
    let:8 a1 = M[20C0] in
    advance (13)
    #0ADD
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #0ADE
    #instruction: JP   NZ,0ADA
    if (!is_zero(a4)) {
      advance (10)
      A := a4;
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump (0ADA);
    } else {
      advance (10)
      #0AE1
      #instruction: RET
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (1 + (a6,a7)) in
      let:8 a9 = M[(a6,a7)] in
      let:8 a10 = a8[15:8] in
      let:8 a11 = a8[7:0] in
      let:16 a12 = (1 + (a10,a11)) in
      let:8 a13 = M[(a10,a11)] in
      advance (10)
      A := a4;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a4[7];
      FlagZ := is_zero(a4);
      FlagA := a5[3];
      FlagP := parity(a4);
      FlagCY := false;
      jump ((a13,a9));
    }

18DC:

    #18DC
    #instruction: CALL 1956
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 18;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := DF;
    #return-to: 18DF
    advance (17)
    #1956
    #instruction: CALL 1A5C
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 19;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := 59;
    #return-to: 1959
    advance (17)
    #1A5C
    #instruction: LD   HL,2400
    advance (10)
    #1A5F
    #instruction: LD   (HL),00
    M[2400] := 00;
    advance (10)
    #1A61
    #instruction: INC  HL
    advance (5)
    #1A62
    #instruction: LD   A,H
    advance (5)
    #1A63
    #instruction: CP   40
    let:16 a13 = addWithCarry(!false,24,~40) in
    let:8 a14 = (24 & 0F) in
    let:8 a15 = (~40 & 0F) in
    let:16 a16 = addWithCarry(!false,a14,a15) in
    advance (7)
    #1A65
    #instruction: JP   NZ,1A5F
    if (!is_zero(a13[7:0])) {
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a12[15:8];
      SPL := a12[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := !a13[15:8][0];
      jump (1A5F);
    } else {
      advance (10)
      #1A68
      #instruction: RET
      let:8 a17 = a12[15:8] in
      let:8 a18 = a12[7:0] in
      let:16 a19 = (1 + (a17,a18)) in
      let:8 a20 = M[(a17,a18)] in
      let:8 a21 = a19[15:8] in
      let:8 a22 = a19[7:0] in
      let:16 a23 = (1 + (a21,a22)) in
      let:8 a24 = M[(a21,a22)] in
      advance (10)
      A := 24;
      H := 24;
      L := 01;
      SPH := a23[15:8];
      SPL := a23[7:0];
      FlagS := a13[7:0][7];
      FlagZ := is_zero(a13[7:0]);
      FlagA := a16[7:0][4];
      FlagP := parity(a13[7:0]);
      FlagCY := !a13[15:8][0];
      jump ((a24,a20));
    }

18DF:

    #18DF
    #instruction: LD   A,08
    advance (7)
    #18E1
    #instruction: LD   (20CF),A
    M[20CF] := 08;
    advance (13)
    #18E4
    #instruction: JP   0AEA
    advance (10)
    #0AEA
    #instruction: XOR  A
    let:8 a1 = (08 ^ 08) in
    advance (4)
    #0AEB
    #instruction: OUT  03
    let:8 a2 = a1 in
    sound_control(Ufo,a2[0]);
    sound_control(Shot,a2[1]);
    sound_control(PlayerDie,a2[2]);
    sound_control(InvaderDie,a2[3]);
    sound_control(ExtraLife,a2[4]);
    advance (10)
    #0AED
    #instruction: OUT  05
    let:8 a3 = a1 in
    sound_control(FleetMovement1,a3[0]);
    sound_control(FleetMovement2,a3[1]);
    sound_control(FleetMovement3,a3[2]);
    sound_control(FleetMovement4,a3[3]);
    sound_control(UfoHit,a3[4]);
    advance (10)
    #0AEF
    #instruction: CALL 1982
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 0A;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := F2;
    #return-to: 0AF2
    advance (17)
    #1982
    #instruction: LD   (20C1),A
    let:8 a10 = a1 in
    M[20C1] := a10;
    advance (13)
    #1985
    #instruction: RET
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (1 + (a11,a12)) in
    let:8 a14 = M[(a11,a12)] in
    let:8 a15 = a13[15:8] in
    let:8 a16 = a13[7:0] in
    let:16 a17 = (1 + (a15,a16)) in
    let:8 a18 = M[(a15,a16)] in
    advance (10)
    A := a1;
    SPH := a17[15:8];
    SPL := a17[7:0];
    FlagS := a1[7];
    FlagZ := is_zero(a1);
    FlagA := false;
    FlagP := parity(a1);
    FlagCY := false;
    jump ((a18,a14));

190D:

    #190D
    #instruction: JP   1597
    advance (10)
    #1597
    #instruction: LD   A,(200D)
    let:8 a1 = M[200D] in
    advance (13)
    #159A
    #instruction: AND  A
    let:8 a2 = a1 in
    let:8 a3 = a1 in
    let:8 a4 = (a2 & a3) in
    let:8 a5 = (a2 | a3) in
    advance (4)
    #159B
    #instruction: JP   NZ,15B7
    if (!is_zero(a4)) {
      advance (10)
      #15B7
      #instruction: LD   HL,2524
      advance (10)
      #15BA
      #instruction: CALL 15C5
      let:8 a6 = SPH in
      let:8 a7 = SPL in
      let:16 a8 = (-1 + (a6,a7)) in
      M[a8] := 15;
      let:8 a9 = a8[15:8] in
      let:8 a10 = a8[7:0] in
      let:16 a11 = (-1 + (a9,a10)) in
      M[a11] := BD;
      #return-to: 15BD
      advance (17)
      #15C5
      #instruction: LD   B,17
      advance (7)
      #15C7
      #instruction: LD   A,(HL)
      let:8 a12 = M[2524] in
      advance (7)
      #15C8
      #instruction: AND  A
      let:8 a13 = a12 in
      let:8 a14 = a12 in
      let:8 a15 = (a13 & a14) in
      let:8 a16 = (a13 | a14) in
      advance (4)
      #15C9
      #instruction: JP   NZ,166B
      if (!is_zero(a15)) {
        advance (10)
        #166B
        #instruction: SCF
        advance (4)
        #166C
        #instruction: RET
        let:8 a17 = a11[15:8] in
        let:8 a18 = a11[7:0] in
        let:16 a19 = (1 + (a17,a18)) in
        let:8 a20 = M[(a17,a18)] in
        let:8 a21 = a19[15:8] in
        let:8 a22 = a19[7:0] in
        let:16 a23 = (1 + (a21,a22)) in
        let:8 a24 = M[(a21,a22)] in
        advance (10)
        A := a15;
        B := 17;
        H := 25;
        L := 24;
        SPH := a23[15:8];
        SPL := a23[7:0];
        FlagS := a15[7];
        FlagZ := is_zero(a15);
        FlagA := a16[3];
        FlagP := parity(a15);
        FlagCY := true;
        jump ((a24,a20));
      } else {
        advance (10)
        #15CC
        #instruction: INC  HL
        advance (5)
        #15CD
        #instruction: DEC  B
        let:16 a25 = addWithCarry(!true,17,~00) in
        let:8 a26 = (17 & 0F) in
        let:8 a27 = (~00 & 0F) in
        let:16 a28 = addWithCarry(!true,a26,a27) in
        advance (5)
        #15CE
        #instruction: JP   NZ,15C7
        if (!is_zero(a25[7:0])) {
          advance (10)
          A := a15;
          B := a25[7:0];
          H := 25;
          L := 25;
          SPH := a11[15:8];
          SPL := a11[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := false;
          jump (15C7);
        } else {
          advance (10)
          #15D1
          #instruction: RET
          let:8 a29 = a11[15:8] in
          let:8 a30 = a11[7:0] in
          let:16 a31 = (1 + (a29,a30)) in
          let:8 a32 = M[(a29,a30)] in
          let:8 a33 = a31[15:8] in
          let:8 a34 = a31[7:0] in
          let:16 a35 = (1 + (a33,a34)) in
          let:8 a36 = M[(a33,a34)] in
          advance (10)
          A := a15;
          B := a25[7:0];
          H := 25;
          L := 25;
          SPH := a35[15:8];
          SPL := a35[7:0];
          FlagS := a25[7:0][7];
          FlagZ := is_zero(a25[7:0]);
          FlagA := a28[7:0][4];
          FlagP := parity(a25[7:0]);
          FlagCY := false;
          jump ((a36,a32));
        }
      }
    } else {
      advance (10)
      #159E
      #instruction: LD   HL,3EA4
      advance (10)
      #15A1
      #instruction: CALL 15C5
      let:8 a37 = SPH in
      let:8 a38 = SPL in
      let:16 a39 = (-1 + (a37,a38)) in
      M[a39] := 15;
      let:8 a40 = a39[15:8] in
      let:8 a41 = a39[7:0] in
      let:16 a42 = (-1 + (a40,a41)) in
      M[a42] := A4;
      #return-to: 15A4
      advance (17)
      #15C5
      #instruction: LD   B,17
      advance (7)
      #15C7
      #instruction: LD   A,(HL)
      let:8 a43 = M[3EA4] in
      advance (7)
      #15C8
      #instruction: AND  A
      let:8 a44 = a43 in
      let:8 a45 = a43 in
      let:8 a46 = (a44 & a45) in
      let:8 a47 = (a44 | a45) in
      advance (4)
      #15C9
      #instruction: JP   NZ,166B
      if (!is_zero(a46)) {
        advance (10)
        #166B
        #instruction: SCF
        advance (4)
        #166C
        #instruction: RET
        let:8 a48 = a42[15:8] in
        let:8 a49 = a42[7:0] in
        let:16 a50 = (1 + (a48,a49)) in
        let:8 a51 = M[(a48,a49)] in
        let:8 a52 = a50[15:8] in
        let:8 a53 = a50[7:0] in
        let:16 a54 = (1 + (a52,a53)) in
        let:8 a55 = M[(a52,a53)] in
        advance (10)
        A := a46;
        B := 17;
        H := 3E;
        L := A4;
        SPH := a54[15:8];
        SPL := a54[7:0];
        FlagS := a46[7];
        FlagZ := is_zero(a46);
        FlagA := a47[3];
        FlagP := parity(a46);
        FlagCY := true;
        jump ((a55,a51));
      } else {
        advance (10)
        #15CC
        #instruction: INC  HL
        advance (5)
        #15CD
        #instruction: DEC  B
        let:16 a56 = addWithCarry(!true,17,~00) in
        let:8 a57 = (17 & 0F) in
        let:8 a58 = (~00 & 0F) in
        let:16 a59 = addWithCarry(!true,a57,a58) in
        advance (5)
        #15CE
        #instruction: JP   NZ,15C7
        if (!is_zero(a56[7:0])) {
          advance (10)
          A := a46;
          B := a56[7:0];
          H := 3E;
          L := A5;
          SPH := a42[15:8];
          SPL := a42[7:0];
          FlagS := a56[7:0][7];
          FlagZ := is_zero(a56[7:0]);
          FlagA := a59[7:0][4];
          FlagP := parity(a56[7:0]);
          FlagCY := false;
          jump (15C7);
        } else {
          advance (10)
          #15D1
          #instruction: RET
          let:8 a60 = a42[15:8] in
          let:8 a61 = a42[7:0] in
          let:16 a62 = (1 + (a60,a61)) in
          let:8 a63 = M[(a60,a61)] in
          let:8 a64 = a62[15:8] in
          let:8 a65 = a62[7:0] in
          let:16 a66 = (1 + (a64,a65)) in
          let:8 a67 = M[(a64,a65)] in
          advance (10)
          A := a46;
          B := a56[7:0];
          H := 3E;
          L := A5;
          SPH := a66[15:8];
          SPL := a66[7:0];
          FlagS := a56[7:0][7];
          FlagZ := is_zero(a56[7:0]);
          FlagA := a59[7:0][4];
          FlagP := parity(a56[7:0]);
          FlagCY := false;
          jump ((a67,a63));
        }
      }
    }

1959:

    #1959
    #instruction: CALL 191A
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 5C;
    #return-to: 195C
    advance (17)
    #191A
    #instruction: LD   C,1C
    advance (7)
    #191C
    #instruction: LD   HL,241E
    advance (10)
    #191F
    #instruction: LD   DE,1AE4
    advance (10)
    #1922
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1A;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := E4;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 08;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 24;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 1E;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(0026,0026) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,26);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 1C;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

195C:

    #195C
    #instruction: CALL 1925
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 5F;
    #return-to: 195F
    advance (17)
    #1925
    #instruction: LD   HL,20F8
    advance (10)
    #1928
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = M[20F8] in
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a8 = M[20F9] in
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a9 = M[20FA] in
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a10 = M[20FB] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a11 = a9 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a12 = a8 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a19 = a8 in
    let:8 a20 = a7 in
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a19;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a27 = a12 in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a27;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a34 = a12 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a35 = updateBit((a34 >> 01),7,a34[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a36 = updateBit((a35 >> 01),7,a35[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a37 = updateBit((a36 >> 01),7,a36[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a38 = updateBit((a37 >> 01),7,a37[0]) in
    let:8 a39 = (0F & a38) in
    let:8 a40 = (0F | a38) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a41 = a33[15:8] in
    let:8 a42 = a33[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 09;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a47 = a39 in
    let:16 a48 = addWithCarry(false,1A,a47) in
    let:8 a49 = (1A & 0F) in
    let:8 a50 = (a47 & 0F) in
    let:16 a51 = addWithCarry(false,a49,a50) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a52 = a10 in
    let:8 a53 = a11 in
    let:8 a54 = a46[15:8] in
    let:8 a55 = a46[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := a52;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := a53;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a60 = a48[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a61 = a60 in
    let:8 a62 = a60 in
    let:17 a63 = add17((00,a61),(00,a62)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    let:8 a66 = a63[15:0][15:8] in
    let:8 a67 = a63[15:0][7:0] in
    let:17 a68 = add17((a64,a65),(a66,a67)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a69 = a68[15:0][15:8] in
    let:8 a70 = a68[15:0][7:0] in
    let:8 a71 = a68[15:0][15:8] in
    let:8 a72 = a68[15:0][7:0] in
    let:17 a73 = add17((a69,a70),(a71,a72)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a74 = a73[15:0][15:8] in
    let:8 a75 = a73[15:0][7:0] in
    let:17 a76 = add17(1E00,(a74,a75)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a77 = a76[15:0][15:8] in
    let:8 a78 = a76[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a79 = a59[15:8] in
    let:8 a80 = a59[7:0] in
    let:16 a81 = (1 + (a79,a80)) in
    let:8 a82 = M[(a79,a80)] in
    let:8 a83 = a81[15:8] in
    let:8 a84 = a81[7:0] in
    let:16 a85 = (1 + (a83,a84)) in
    let:8 a86 = M[(a83,a84)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a87 = a48[7:0] in
    unknown_output(6,a87);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a88 = C in
    let:8 a89 = a85[15:8] in
    let:8 a90 = a85[7:0] in
    let:16 a91 = (-1 + (a89,a90)) in
    M[a91] := 08;
    let:8 a92 = a91[15:8] in
    let:8 a93 = a91[7:0] in
    let:16 a94 = (-1 + (a92,a93)) in
    M[a94] := a88;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a95 = a77 in
    let:8 a96 = a78 in
    let:8 a97 = M[(a95,a96)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a98 = a97 in
    let:8 a99 = a86 in
    let:8 a100 = a82 in
    M[(a99,a100)] := a98;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a101 = a77 in
    let:8 a102 = a78 in
    let:16 a103 = (1 + (a101,a102)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a104 = a86 in
    let:8 a105 = a82 in
    let:17 a106 = add17(0020,(a104,a105)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a107 = a94[15:8] in
    let:8 a108 = a94[7:0] in
    let:16 a109 = (1 + (a107,a108)) in
    let:8 a110 = M[(a107,a108)] in
    let:8 a111 = a109[15:8] in
    let:8 a112 = a109[7:0] in
    let:16 a113 = (1 + (a111,a112)) in
    let:8 a114 = M[(a111,a112)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a115 = a114 in
    let:16 a116 = addWithCarry(!true,a115,~00) in
    let:8 a117 = (a115 & 0F) in
    let:8 a118 = (~00 & 0F) in
    let:16 a119 = addWithCarry(!true,a117,a118) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a116[7:0])) {
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a120 = a113[15:8] in
      let:8 a121 = a113[7:0] in
      let:16 a122 = (1 + (a120,a121)) in
      let:8 a123 = M[(a120,a121)] in
      let:8 a124 = a122[15:8] in
      let:8 a125 = a122[7:0] in
      let:16 a126 = (1 + (a124,a125)) in
      let:8 a127 = M[(a124,a125)] in
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a126[15:8];
      SPL := a126[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump ((a127,a123));
    }

195F:

    #195F
    #instruction: CALL 192B
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 62;
    #return-to: 1962
    advance (17)
    #192B
    #instruction: LD   HL,20FC
    advance (10)
    #192E
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = M[20FC] in
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a8 = M[20FD] in
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a9 = M[20FE] in
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a10 = M[20FF] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a11 = a9 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a12 = a8 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a19 = a8 in
    let:8 a20 = a7 in
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a19;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a27 = a12 in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a27;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a34 = a12 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a35 = updateBit((a34 >> 01),7,a34[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a36 = updateBit((a35 >> 01),7,a35[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a37 = updateBit((a36 >> 01),7,a36[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a38 = updateBit((a37 >> 01),7,a37[0]) in
    let:8 a39 = (0F & a38) in
    let:8 a40 = (0F | a38) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a41 = a33[15:8] in
    let:8 a42 = a33[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 09;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a47 = a39 in
    let:16 a48 = addWithCarry(false,1A,a47) in
    let:8 a49 = (1A & 0F) in
    let:8 a50 = (a47 & 0F) in
    let:16 a51 = addWithCarry(false,a49,a50) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a52 = a10 in
    let:8 a53 = a11 in
    let:8 a54 = a46[15:8] in
    let:8 a55 = a46[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := a52;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := a53;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a60 = a48[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a61 = a60 in
    let:8 a62 = a60 in
    let:17 a63 = add17((00,a61),(00,a62)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    let:8 a66 = a63[15:0][15:8] in
    let:8 a67 = a63[15:0][7:0] in
    let:17 a68 = add17((a64,a65),(a66,a67)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a69 = a68[15:0][15:8] in
    let:8 a70 = a68[15:0][7:0] in
    let:8 a71 = a68[15:0][15:8] in
    let:8 a72 = a68[15:0][7:0] in
    let:17 a73 = add17((a69,a70),(a71,a72)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a74 = a73[15:0][15:8] in
    let:8 a75 = a73[15:0][7:0] in
    let:17 a76 = add17(1E00,(a74,a75)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a77 = a76[15:0][15:8] in
    let:8 a78 = a76[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a79 = a59[15:8] in
    let:8 a80 = a59[7:0] in
    let:16 a81 = (1 + (a79,a80)) in
    let:8 a82 = M[(a79,a80)] in
    let:8 a83 = a81[15:8] in
    let:8 a84 = a81[7:0] in
    let:16 a85 = (1 + (a83,a84)) in
    let:8 a86 = M[(a83,a84)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a87 = a48[7:0] in
    unknown_output(6,a87);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a88 = C in
    let:8 a89 = a85[15:8] in
    let:8 a90 = a85[7:0] in
    let:16 a91 = (-1 + (a89,a90)) in
    M[a91] := 08;
    let:8 a92 = a91[15:8] in
    let:8 a93 = a91[7:0] in
    let:16 a94 = (-1 + (a92,a93)) in
    M[a94] := a88;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a95 = a77 in
    let:8 a96 = a78 in
    let:8 a97 = M[(a95,a96)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a98 = a97 in
    let:8 a99 = a86 in
    let:8 a100 = a82 in
    M[(a99,a100)] := a98;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a101 = a77 in
    let:8 a102 = a78 in
    let:16 a103 = (1 + (a101,a102)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a104 = a86 in
    let:8 a105 = a82 in
    let:17 a106 = add17(0020,(a104,a105)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a107 = a94[15:8] in
    let:8 a108 = a94[7:0] in
    let:16 a109 = (1 + (a107,a108)) in
    let:8 a110 = M[(a107,a108)] in
    let:8 a111 = a109[15:8] in
    let:8 a112 = a109[7:0] in
    let:16 a113 = (1 + (a111,a112)) in
    let:8 a114 = M[(a111,a112)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a115 = a114 in
    let:16 a116 = addWithCarry(!true,a115,~00) in
    let:8 a117 = (a115 & 0F) in
    let:8 a118 = (~00 & 0F) in
    let:16 a119 = addWithCarry(!true,a117,a118) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a116[7:0])) {
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a120 = a113[15:8] in
      let:8 a121 = a113[7:0] in
      let:16 a122 = (1 + (a120,a121)) in
      let:8 a123 = M[(a120,a121)] in
      let:8 a124 = a122[15:8] in
      let:8 a125 = a122[7:0] in
      let:16 a126 = (1 + (a124,a125)) in
      let:8 a127 = M[(a124,a125)] in
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a126[15:8];
      SPL := a126[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump ((a127,a123));
    }

1962:

    #1962
    #instruction: CALL 1950
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 65;
    #return-to: 1965
    advance (17)
    #1950
    #instruction: LD   HL,20F4
    advance (10)
    #1953
    #instruction: JP   1931
    advance (10)
    #1931
    #instruction: LD   E,(HL)
    let:8 a7 = M[20F4] in
    advance (7)
    #1932
    #instruction: INC  HL
    advance (5)
    #1933
    #instruction: LD   D,(HL)
    let:8 a8 = M[20F5] in
    advance (7)
    #1934
    #instruction: INC  HL
    advance (5)
    #1935
    #instruction: LD   A,(HL)
    let:8 a9 = M[20F6] in
    advance (7)
    #1936
    #instruction: INC  HL
    advance (5)
    #1937
    #instruction: LD   H,(HL)
    let:8 a10 = M[20F7] in
    advance (7)
    #1938
    #instruction: LD   L,A
    let:8 a11 = a9 in
    advance (5)
    #1939
    #instruction: JP   09AD
    advance (10)
    #09AD
    #instruction: LD   A,D
    let:8 a12 = a8 in
    advance (5)
    #09AE
    #instruction: CALL 09B2
    let:8 a13 = a6[15:8] in
    let:8 a14 = a6[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 09;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := B1;
    #return-to: 09B1
    advance (17)
    #09B2
    #instruction: PUSH DE
    let:8 a19 = a8 in
    let:8 a20 = a7 in
    let:8 a21 = a18[15:8] in
    let:8 a22 = a18[7:0] in
    let:16 a23 = (-1 + (a21,a22)) in
    M[a23] := a19;
    let:8 a24 = a23[15:8] in
    let:8 a25 = a23[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := a20;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a27 = a12 in
    let:8 a28 = a26[15:8] in
    let:8 a29 = a26[7:0] in
    let:16 a30 = (-1 + (a28,a29)) in
    M[a30] := a27;
    let:8 a31 = a30[15:8] in
    let:8 a32 = a30[7:0] in
    let:16 a33 = (-1 + (a31,a32)) in
    M[a33] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a34 = a12 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a35 = updateBit((a34 >> 01),7,a34[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a36 = updateBit((a35 >> 01),7,a35[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a37 = updateBit((a36 >> 01),7,a36[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a38 = updateBit((a37 >> 01),7,a37[0]) in
    let:8 a39 = (0F & a38) in
    let:8 a40 = (0F | a38) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a41 = a33[15:8] in
    let:8 a42 = a33[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 09;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a47 = a39 in
    let:16 a48 = addWithCarry(false,1A,a47) in
    let:8 a49 = (1A & 0F) in
    let:8 a50 = (a47 & 0F) in
    let:16 a51 = addWithCarry(false,a49,a50) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a52 = a10 in
    let:8 a53 = a11 in
    let:8 a54 = a46[15:8] in
    let:8 a55 = a46[7:0] in
    let:16 a56 = (-1 + (a54,a55)) in
    M[a56] := a52;
    let:8 a57 = a56[15:8] in
    let:8 a58 = a56[7:0] in
    let:16 a59 = (-1 + (a57,a58)) in
    M[a59] := a53;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a60 = a48[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a61 = a60 in
    let:8 a62 = a60 in
    let:17 a63 = add17((00,a61),(00,a62)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    let:8 a66 = a63[15:0][15:8] in
    let:8 a67 = a63[15:0][7:0] in
    let:17 a68 = add17((a64,a65),(a66,a67)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a69 = a68[15:0][15:8] in
    let:8 a70 = a68[15:0][7:0] in
    let:8 a71 = a68[15:0][15:8] in
    let:8 a72 = a68[15:0][7:0] in
    let:17 a73 = add17((a69,a70),(a71,a72)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a74 = a73[15:0][15:8] in
    let:8 a75 = a73[15:0][7:0] in
    let:17 a76 = add17(1E00,(a74,a75)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a77 = a76[15:0][15:8] in
    let:8 a78 = a76[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a79 = a59[15:8] in
    let:8 a80 = a59[7:0] in
    let:16 a81 = (1 + (a79,a80)) in
    let:8 a82 = M[(a79,a80)] in
    let:8 a83 = a81[15:8] in
    let:8 a84 = a81[7:0] in
    let:16 a85 = (1 + (a83,a84)) in
    let:8 a86 = M[(a83,a84)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a87 = a48[7:0] in
    unknown_output(6,a87);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a88 = C in
    let:8 a89 = a85[15:8] in
    let:8 a90 = a85[7:0] in
    let:16 a91 = (-1 + (a89,a90)) in
    M[a91] := 08;
    let:8 a92 = a91[15:8] in
    let:8 a93 = a91[7:0] in
    let:16 a94 = (-1 + (a92,a93)) in
    M[a94] := a88;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a95 = a77 in
    let:8 a96 = a78 in
    let:8 a97 = M[(a95,a96)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a98 = a97 in
    let:8 a99 = a86 in
    let:8 a100 = a82 in
    M[(a99,a100)] := a98;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a101 = a77 in
    let:8 a102 = a78 in
    let:16 a103 = (1 + (a101,a102)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a104 = a86 in
    let:8 a105 = a82 in
    let:17 a106 = add17(0020,(a104,a105)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a107 = a94[15:8] in
    let:8 a108 = a94[7:0] in
    let:16 a109 = (1 + (a107,a108)) in
    let:8 a110 = M[(a107,a108)] in
    let:8 a111 = a109[15:8] in
    let:8 a112 = a109[7:0] in
    let:16 a113 = (1 + (a111,a112)) in
    let:8 a114 = M[(a111,a112)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a115 = a114 in
    let:16 a116 = addWithCarry(!true,a115,~00) in
    let:8 a117 = (a115 & 0F) in
    let:8 a118 = (~00 & 0F) in
    let:16 a119 = addWithCarry(!true,a117,a118) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a116[7:0])) {
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a120 = a113[15:8] in
      let:8 a121 = a113[7:0] in
      let:16 a122 = (1 + (a120,a121)) in
      let:8 a123 = M[(a120,a121)] in
      let:8 a124 = a122[15:8] in
      let:8 a125 = a122[7:0] in
      let:16 a126 = (1 + (a124,a125)) in
      let:8 a127 = M[(a124,a125)] in
      advance (10)
      A := a97;
      B := a116[7:0];
      C := a110;
      D := a103[15:8];
      E := a103[7:0];
      H := a106[15:0][15:8];
      L := a106[15:0][7:0];
      SPH := a126[15:8];
      SPL := a126[7:0];
      FlagS := a116[7:0][7];
      FlagZ := is_zero(a116[7:0]);
      FlagA := a119[7:0][4];
      FlagP := parity(a116[7:0]);
      FlagCY := a106[16];
      jump ((a127,a123));
    }

1965:

    #1965
    #instruction: CALL 193C
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 68;
    #return-to: 1968
    advance (17)
    #193C
    #instruction: LD   C,07
    advance (7)
    #193E
    #instruction: LD   HL,3501
    advance (10)
    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    #1944
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 1F;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := A9;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 08;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a19 = a18[15:8] in
    let:8 a20 = a18[7:0] in
    let:16 a21 = (-1 + (a19,a20)) in
    M[a21] := 35;
    let:8 a22 = a21[15:8] in
    let:8 a23 = a21[7:0] in
    let:16 a24 = (-1 + (a22,a23)) in
    M[a24] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a25 = add17(0002,0002) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a26 = a25[15:0][15:8] in
    let:8 a27 = a25[15:0][7:0] in
    let:8 a28 = a25[15:0][15:8] in
    let:8 a29 = a25[15:0][7:0] in
    let:17 a30 = add17((a26,a27),(a28,a29)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a31 = a30[15:0][15:8] in
    let:8 a32 = a30[15:0][7:0] in
    let:8 a33 = a30[15:0][15:8] in
    let:8 a34 = a30[15:0][7:0] in
    let:17 a35 = add17((a31,a32),(a33,a34)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a36 = a35[15:0][15:8] in
    let:8 a37 = a35[15:0][7:0] in
    let:17 a38 = add17(1E00,(a36,a37)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a39 = a38[15:0][15:8] in
    let:8 a40 = a38[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a41 = a24[15:8] in
    let:8 a42 = a24[7:0] in
    let:16 a43 = (1 + (a41,a42)) in
    let:8 a44 = M[(a41,a42)] in
    let:8 a45 = a43[15:8] in
    let:8 a46 = a43[7:0] in
    let:16 a47 = (1 + (a45,a46)) in
    let:8 a48 = M[(a45,a46)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a49 = a47[15:8] in
    let:8 a50 = a47[7:0] in
    let:16 a51 = (-1 + (a49,a50)) in
    M[a51] := 08;
    let:8 a52 = a51[15:8] in
    let:8 a53 = a51[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 07;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a55 = a39 in
    let:8 a56 = a40 in
    let:8 a57 = M[(a55,a56)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a58 = a57 in
    let:8 a59 = a48 in
    let:8 a60 = a44 in
    M[(a59,a60)] := a58;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a61 = a39 in
    let:8 a62 = a40 in
    let:16 a63 = (1 + (a61,a62)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a64 = a48 in
    let:8 a65 = a44 in
    let:17 a66 = add17(0020,(a64,a65)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a67 = a54[15:8] in
    let:8 a68 = a54[7:0] in
    let:16 a69 = (1 + (a67,a68)) in
    let:8 a70 = M[(a67,a68)] in
    let:8 a71 = a69[15:8] in
    let:8 a72 = a69[7:0] in
    let:16 a73 = (1 + (a71,a72)) in
    let:8 a74 = M[(a71,a72)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a75 = a74 in
    let:16 a76 = addWithCarry(!true,a75,~00) in
    let:8 a77 = (a75 & 0F) in
    let:8 a78 = (~00 & 0F) in
    let:16 a79 = addWithCarry(!true,a77,a78) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a76[7:0])) {
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a73[15:8];
      SPL := a73[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a80 = a73[15:8] in
      let:8 a81 = a73[7:0] in
      let:16 a82 = (1 + (a80,a81)) in
      let:8 a83 = M[(a80,a81)] in
      let:8 a84 = a82[15:8] in
      let:8 a85 = a82[7:0] in
      let:16 a86 = (1 + (a84,a85)) in
      let:8 a87 = M[(a84,a85)] in
      advance (10)
      A := a57;
      B := a76[7:0];
      C := a70;
      D := a63[15:8];
      E := a63[7:0];
      H := a66[15:0][15:8];
      L := a66[15:0][7:0];
      SPH := a86[15:8];
      SPL := a86[7:0];
      FlagS := a76[7:0][7];
      FlagZ := is_zero(a76[7:0]);
      FlagA := a79[7:0][4];
      FlagP := parity(a76[7:0]);
      FlagCY := a66[16];
      jump ((a87,a83));
    }

1968:

    #1968
    #instruction: JP   1947
    advance (10)
    #1947
    #instruction: LD   A,(20EB)
    let:8 a1 = M[20EB] in
    advance (13)
    #194A
    #instruction: LD   HL,3C01
    advance (10)
    #194D
    #instruction: JP   09B2
    advance (10)
    #09B2
    #instruction: PUSH DE
    let:8 a2 = D in
    let:8 a3 = E in
    let:8 a4 = SPH in
    let:8 a5 = SPL in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := a2;
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := a3;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a10 = a1 in
    let:8 a11 = a9[15:8] in
    let:8 a12 = a9[7:0] in
    let:16 a13 = (-1 + (a11,a12)) in
    M[a13] := a10;
    let:8 a14 = a13[15:8] in
    let:8 a15 = a13[7:0] in
    let:16 a16 = (-1 + (a14,a15)) in
    M[a16] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a17 = a1 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a18 = updateBit((a17 >> 01),7,a17[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a19 = updateBit((a18 >> 01),7,a18[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a20 = updateBit((a19 >> 01),7,a19[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a21 = updateBit((a20 >> 01),7,a20[0]) in
    let:8 a22 = (0F & a21) in
    let:8 a23 = (0F | a21) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a24 = a16[15:8] in
    let:8 a25 = a16[7:0] in
    let:16 a26 = (-1 + (a24,a25)) in
    M[a26] := 09;
    let:8 a27 = a26[15:8] in
    let:8 a28 = a26[7:0] in
    let:16 a29 = (-1 + (a27,a28)) in
    M[a29] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a30 = a22 in
    let:16 a31 = addWithCarry(false,1A,a30) in
    let:8 a32 = (1A & 0F) in
    let:8 a33 = (a30 & 0F) in
    let:16 a34 = addWithCarry(false,a32,a33) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a35 = a29[15:8] in
    let:8 a36 = a29[7:0] in
    let:16 a37 = (-1 + (a35,a36)) in
    M[a37] := 3C;
    let:8 a38 = a37[15:8] in
    let:8 a39 = a37[7:0] in
    let:16 a40 = (-1 + (a38,a39)) in
    M[a40] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a41 = a31[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a42 = a41 in
    let:8 a43 = a41 in
    let:17 a44 = add17((00,a42),(00,a43)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a45 = a44[15:0][15:8] in
    let:8 a46 = a44[15:0][7:0] in
    let:8 a47 = a44[15:0][15:8] in
    let:8 a48 = a44[15:0][7:0] in
    let:17 a49 = add17((a45,a46),(a47,a48)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a50 = a49[15:0][15:8] in
    let:8 a51 = a49[15:0][7:0] in
    let:8 a52 = a49[15:0][15:8] in
    let:8 a53 = a49[15:0][7:0] in
    let:17 a54 = add17((a50,a51),(a52,a53)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a55 = a54[15:0][15:8] in
    let:8 a56 = a54[15:0][7:0] in
    let:17 a57 = add17(1E00,(a55,a56)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a58 = a57[15:0][15:8] in
    let:8 a59 = a57[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a60 = a40[15:8] in
    let:8 a61 = a40[7:0] in
    let:16 a62 = (1 + (a60,a61)) in
    let:8 a63 = M[(a60,a61)] in
    let:8 a64 = a62[15:8] in
    let:8 a65 = a62[7:0] in
    let:16 a66 = (1 + (a64,a65)) in
    let:8 a67 = M[(a64,a65)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a68 = a31[7:0] in
    unknown_output(6,a68);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a69 = C in
    let:8 a70 = a66[15:8] in
    let:8 a71 = a66[7:0] in
    let:16 a72 = (-1 + (a70,a71)) in
    M[a72] := 08;
    let:8 a73 = a72[15:8] in
    let:8 a74 = a72[7:0] in
    let:16 a75 = (-1 + (a73,a74)) in
    M[a75] := a69;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a76 = a58 in
    let:8 a77 = a59 in
    let:8 a78 = M[(a76,a77)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a79 = a78 in
    let:8 a80 = a67 in
    let:8 a81 = a63 in
    M[(a80,a81)] := a79;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a82 = a58 in
    let:8 a83 = a59 in
    let:16 a84 = (1 + (a82,a83)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a85 = a67 in
    let:8 a86 = a63 in
    let:17 a87 = add17(0020,(a85,a86)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a88 = a75[15:8] in
    let:8 a89 = a75[7:0] in
    let:16 a90 = (1 + (a88,a89)) in
    let:8 a91 = M[(a88,a89)] in
    let:8 a92 = a90[15:8] in
    let:8 a93 = a90[7:0] in
    let:16 a94 = (1 + (a92,a93)) in
    let:8 a95 = M[(a92,a93)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a96 = a95 in
    let:16 a97 = addWithCarry(!true,a96,~00) in
    let:8 a98 = (a96 & 0F) in
    let:8 a99 = (~00 & 0F) in
    let:16 a100 = addWithCarry(!true,a98,a99) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a97[7:0])) {
      advance (10)
      A := a78;
      B := a97[7:0];
      C := a91;
      D := a84[15:8];
      E := a84[7:0];
      H := a87[15:0][15:8];
      L := a87[15:0][7:0];
      SPH := a94[15:8];
      SPL := a94[7:0];
      FlagS := a97[7:0][7];
      FlagZ := is_zero(a97[7:0]);
      FlagA := a100[7:0][4];
      FlagP := parity(a97[7:0]);
      FlagCY := a87[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a101 = a94[15:8] in
      let:8 a102 = a94[7:0] in
      let:16 a103 = (1 + (a101,a102)) in
      let:8 a104 = M[(a101,a102)] in
      let:8 a105 = a103[15:8] in
      let:8 a106 = a103[7:0] in
      let:16 a107 = (1 + (a105,a106)) in
      let:8 a108 = M[(a105,a106)] in
      advance (10)
      A := a78;
      B := a97[7:0];
      C := a91;
      D := a84[15:8];
      E := a84[7:0];
      H := a87[15:0][15:8];
      L := a87[15:0][7:0];
      SPH := a107[15:8];
      SPL := a107[7:0];
      FlagS := a97[7:0][7];
      FlagZ := is_zero(a97[7:0]);
      FlagA := a100[7:0][4];
      FlagP := parity(a97[7:0]);
      FlagCY := a87[16];
      jump ((a108,a104));
    }

196E:

    #196E
    #instruction: JP   1671
    advance (10)
    jump (1671);

197C:

    #197C
    #instruction: CALL 1947
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 19;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := 7F;
    #return-to: 197F
    advance (17)
    #1947
    #instruction: LD   A,(20EB)
    let:8 a7 = M[20EB] in
    advance (13)
    #194A
    #instruction: LD   HL,3C01
    advance (10)
    #194D
    #instruction: JP   09B2
    advance (10)
    #09B2
    #instruction: PUSH DE
    let:8 a8 = D in
    let:8 a9 = E in
    let:8 a10 = a6[15:8] in
    let:8 a11 = a6[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := a8;
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := a9;
    advance (11)
    #09B3
    #instruction: PUSH PSW
    let:8 a16 = a7 in
    let:8 a17 = a15[15:8] in
    let:8 a18 = a15[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := a16;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,FlagS),6,FlagZ),4,FlagA),2,FlagP),0,FlagCY);
    advance (11)
    #09B4
    #instruction: RRCA
    let:8 a23 = a7 in
    advance (4)
    #09B5
    #instruction: RRCA
    let:8 a24 = updateBit((a23 >> 01),7,a23[0]) in
    advance (4)
    #09B6
    #instruction: RRCA
    let:8 a25 = updateBit((a24 >> 01),7,a24[0]) in
    advance (4)
    #09B7
    #instruction: RRCA
    let:8 a26 = updateBit((a25 >> 01),7,a25[0]) in
    advance (4)
    #09B8
    #instruction: AND  0F
    let:8 a27 = updateBit((a26 >> 01),7,a26[0]) in
    let:8 a28 = (0F & a27) in
    let:8 a29 = (0F | a27) in
    advance (7)
    #09BA
    #instruction: CALL 09C5
    let:8 a30 = a22[15:8] in
    let:8 a31 = a22[7:0] in
    let:16 a32 = (-1 + (a30,a31)) in
    M[a32] := 09;
    let:8 a33 = a32[15:8] in
    let:8 a34 = a32[7:0] in
    let:16 a35 = (-1 + (a33,a34)) in
    M[a35] := BD;
    #return-to: 09BD
    advance (17)
    #09C5
    #instruction: ADD  1A
    let:8 a36 = a28 in
    let:16 a37 = addWithCarry(false,1A,a36) in
    let:8 a38 = (1A & 0F) in
    let:8 a39 = (a36 & 0F) in
    let:16 a40 = addWithCarry(false,a38,a39) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a41 = a35[15:8] in
    let:8 a42 = a35[7:0] in
    let:16 a43 = (-1 + (a41,a42)) in
    M[a43] := 3C;
    let:8 a44 = a43[15:8] in
    let:8 a45 = a43[7:0] in
    let:16 a46 = (-1 + (a44,a45)) in
    M[a46] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a47 = a37[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a48 = a47 in
    let:8 a49 = a47 in
    let:17 a50 = add17((00,a48),(00,a49)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a51 = a50[15:0][15:8] in
    let:8 a52 = a50[15:0][7:0] in
    let:8 a53 = a50[15:0][15:8] in
    let:8 a54 = a50[15:0][7:0] in
    let:17 a55 = add17((a51,a52),(a53,a54)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a56 = a55[15:0][15:8] in
    let:8 a57 = a55[15:0][7:0] in
    let:8 a58 = a55[15:0][15:8] in
    let:8 a59 = a55[15:0][7:0] in
    let:17 a60 = add17((a56,a57),(a58,a59)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a61 = a60[15:0][15:8] in
    let:8 a62 = a60[15:0][7:0] in
    let:17 a63 = add17(1E00,(a61,a62)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a64 = a63[15:0][15:8] in
    let:8 a65 = a63[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a66 = a46[15:8] in
    let:8 a67 = a46[7:0] in
    let:16 a68 = (1 + (a66,a67)) in
    let:8 a69 = M[(a66,a67)] in
    let:8 a70 = a68[15:8] in
    let:8 a71 = a68[7:0] in
    let:16 a72 = (1 + (a70,a71)) in
    let:8 a73 = M[(a70,a71)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a74 = a37[7:0] in
    unknown_output(6,a74);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a75 = C in
    let:8 a76 = a72[15:8] in
    let:8 a77 = a72[7:0] in
    let:16 a78 = (-1 + (a76,a77)) in
    M[a78] := 08;
    let:8 a79 = a78[15:8] in
    let:8 a80 = a78[7:0] in
    let:16 a81 = (-1 + (a79,a80)) in
    M[a81] := a75;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a82 = a64 in
    let:8 a83 = a65 in
    let:8 a84 = M[(a82,a83)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a85 = a84 in
    let:8 a86 = a73 in
    let:8 a87 = a69 in
    M[(a86,a87)] := a85;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a88 = a64 in
    let:8 a89 = a65 in
    let:16 a90 = (1 + (a88,a89)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a91 = a73 in
    let:8 a92 = a69 in
    let:17 a93 = add17(0020,(a91,a92)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a94 = a81[15:8] in
    let:8 a95 = a81[7:0] in
    let:16 a96 = (1 + (a94,a95)) in
    let:8 a97 = M[(a94,a95)] in
    let:8 a98 = a96[15:8] in
    let:8 a99 = a96[7:0] in
    let:16 a100 = (1 + (a98,a99)) in
    let:8 a101 = M[(a98,a99)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a102 = a101 in
    let:16 a103 = addWithCarry(!true,a102,~00) in
    let:8 a104 = (a102 & 0F) in
    let:8 a105 = (~00 & 0F) in
    let:16 a106 = addWithCarry(!true,a104,a105) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a103[7:0])) {
      advance (10)
      A := a84;
      B := a103[7:0];
      C := a97;
      D := a90[15:8];
      E := a90[7:0];
      H := a93[15:0][15:8];
      L := a93[15:0][7:0];
      SPH := a100[15:8];
      SPL := a100[7:0];
      FlagS := a103[7:0][7];
      FlagZ := is_zero(a103[7:0]);
      FlagA := a106[7:0][4];
      FlagP := parity(a103[7:0]);
      FlagCY := a93[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a107 = a100[15:8] in
      let:8 a108 = a100[7:0] in
      let:16 a109 = (1 + (a107,a108)) in
      let:8 a110 = M[(a107,a108)] in
      let:8 a111 = a109[15:8] in
      let:8 a112 = a109[7:0] in
      let:16 a113 = (1 + (a111,a112)) in
      let:8 a114 = M[(a111,a112)] in
      advance (10)
      A := a84;
      B := a103[7:0];
      C := a97;
      D := a90[15:8];
      E := a90[7:0];
      H := a93[15:0][15:8];
      L := a93[15:0][7:0];
      SPH := a113[15:8];
      SPL := a113[7:0];
      FlagS := a103[7:0][7];
      FlagZ := is_zero(a103[7:0]);
      FlagA := a106[7:0][4];
      FlagP := parity(a103[7:0]);
      FlagCY := a93[16];
      jump ((a114,a110));
    }

197F:

    #197F
    #instruction: JP   193C
    advance (10)
    #193C
    #instruction: LD   C,07
    advance (7)
    #193E
    #instruction: LD   HL,3501
    advance (10)
    #1941
    #instruction: LD   DE,1FA9
    advance (10)
    #1944
    #instruction: JP   08F3
    advance (10)
    #08F3
    #instruction: LD   A,(DE)
    advance (7)
    #08F4
    #instruction: PUSH DE
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (-1 + (a1,a2)) in
    M[a3] := 1F;
    let:8 a4 = a3[15:8] in
    let:8 a5 = a3[7:0] in
    let:16 a6 = (-1 + (a4,a5)) in
    M[a6] := A9;
    advance (11)
    #08F5
    #instruction: CALL 08FF
    let:8 a7 = a6[15:8] in
    let:8 a8 = a6[7:0] in
    let:16 a9 = (-1 + (a7,a8)) in
    M[a9] := 08;
    let:8 a10 = a9[15:8] in
    let:8 a11 = a9[7:0] in
    let:16 a12 = (-1 + (a10,a11)) in
    M[a12] := F8;
    #return-to: 08F8
    advance (17)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a13 = a12[15:8] in
    let:8 a14 = a12[7:0] in
    let:16 a15 = (-1 + (a13,a14)) in
    M[a15] := 35;
    let:8 a16 = a15[15:8] in
    let:8 a17 = a15[7:0] in
    let:16 a18 = (-1 + (a16,a17)) in
    M[a18] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:17 a19 = add17(0002,0002) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a20 = a19[15:0][15:8] in
    let:8 a21 = a19[15:0][7:0] in
    let:8 a22 = a19[15:0][15:8] in
    let:8 a23 = a19[15:0][7:0] in
    let:17 a24 = add17((a20,a21),(a22,a23)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a25 = a24[15:0][15:8] in
    let:8 a26 = a24[15:0][7:0] in
    let:8 a27 = a24[15:0][15:8] in
    let:8 a28 = a24[15:0][7:0] in
    let:17 a29 = add17((a25,a26),(a27,a28)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a30 = a29[15:0][15:8] in
    let:8 a31 = a29[15:0][7:0] in
    let:17 a32 = add17(1E00,(a30,a31)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a33 = a32[15:0][15:8] in
    let:8 a34 = a32[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a35 = a18[15:8] in
    let:8 a36 = a18[7:0] in
    let:16 a37 = (1 + (a35,a36)) in
    let:8 a38 = M[(a35,a36)] in
    let:8 a39 = a37[15:8] in
    let:8 a40 = a37[7:0] in
    let:16 a41 = (1 + (a39,a40)) in
    let:8 a42 = M[(a39,a40)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    unknown_output(6,02);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a43 = a41[15:8] in
    let:8 a44 = a41[7:0] in
    let:16 a45 = (-1 + (a43,a44)) in
    M[a45] := 08;
    let:8 a46 = a45[15:8] in
    let:8 a47 = a45[7:0] in
    let:16 a48 = (-1 + (a46,a47)) in
    M[a48] := 07;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a49 = a33 in
    let:8 a50 = a34 in
    let:8 a51 = M[(a49,a50)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a52 = a51 in
    let:8 a53 = a42 in
    let:8 a54 = a38 in
    M[(a53,a54)] := a52;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a55 = a33 in
    let:8 a56 = a34 in
    let:16 a57 = (1 + (a55,a56)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a58 = a42 in
    let:8 a59 = a38 in
    let:17 a60 = add17(0020,(a58,a59)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a61 = a48[15:8] in
    let:8 a62 = a48[7:0] in
    let:16 a63 = (1 + (a61,a62)) in
    let:8 a64 = M[(a61,a62)] in
    let:8 a65 = a63[15:8] in
    let:8 a66 = a63[7:0] in
    let:16 a67 = (1 + (a65,a66)) in
    let:8 a68 = M[(a65,a66)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a69 = a68 in
    let:16 a70 = addWithCarry(!true,a69,~00) in
    let:8 a71 = (a69 & 0F) in
    let:8 a72 = (~00 & 0F) in
    let:16 a73 = addWithCarry(!true,a71,a72) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a70[7:0])) {
      advance (10)
      A := a51;
      B := a70[7:0];
      C := a64;
      D := a57[15:8];
      E := a57[7:0];
      H := a60[15:0][15:8];
      L := a60[15:0][7:0];
      SPH := a67[15:8];
      SPL := a67[7:0];
      FlagS := a70[7:0][7];
      FlagZ := is_zero(a70[7:0]);
      FlagA := a73[7:0][4];
      FlagP := parity(a70[7:0]);
      FlagCY := a60[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a74 = a67[15:8] in
      let:8 a75 = a67[7:0] in
      let:16 a76 = (1 + (a74,a75)) in
      let:8 a77 = M[(a74,a75)] in
      let:8 a78 = a76[15:8] in
      let:8 a79 = a76[7:0] in
      let:16 a80 = (1 + (a78,a79)) in
      let:8 a81 = M[(a78,a79)] in
      advance (10)
      A := a51;
      B := a70[7:0];
      C := a64;
      D := a57[15:8];
      E := a57[7:0];
      H := a60[15:0][15:8];
      L := a60[15:0][7:0];
      SPH := a80[15:8];
      SPL := a80[7:0];
      FlagS := a70[7:0][7];
      FlagZ := is_zero(a70[7:0]);
      FlagA := a73[7:0][4];
      FlagP := parity(a70[7:0]);
      FlagCY := a60[16];
      jump ((a81,a77));
    }

19F5:

    #19F5
    #instruction: LD   A,C
    let:8 a1 = C in
    advance (5)
    #19F6
    #instruction: DEC  A
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!true,a2,~00) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~00 & 0F) in
    let:16 a6 = addWithCarry(!true,a4,a5) in
    advance (5)
    #19F7
    #instruction: JP   NZ,19EC
    if (!is_zero(a3[7:0])) {
      advance (10)
      #19EC
      #instruction: LD   DE,1C60
      advance (10)
      #19EF
      #instruction: LD   B,10
      advance (7)
      #19F1
      #instruction: LD   C,A
      let:8 a7 = a3[7:0] in
      advance (5)
      #19F2
      #instruction: CALL 1439
      let:8 a8 = SPH in
      let:8 a9 = SPL in
      let:16 a10 = (-1 + (a8,a9)) in
      M[a10] := 19;
      let:8 a11 = a10[15:8] in
      let:8 a12 = a10[7:0] in
      let:16 a13 = (-1 + (a11,a12)) in
      M[a13] := F5;
      #return-to: 19F5
      advance (17)
      #1439
      #instruction: PUSH BC
      let:8 a14 = a7 in
      let:8 a15 = a13[15:8] in
      let:8 a16 = a13[7:0] in
      let:16 a17 = (-1 + (a15,a16)) in
      M[a17] := 10;
      let:8 a18 = a17[15:8] in
      let:8 a19 = a17[7:0] in
      let:16 a20 = (-1 + (a18,a19)) in
      M[a20] := a14;
      advance (11)
      #143A
      #instruction: LD   A,(DE)
      advance (7)
      #143B
      #instruction: LD   (HL),A
      let:8 a21 = H in
      let:8 a22 = L in
      M[(a21,a22)] := 00;
      advance (7)
      #143C
      #instruction: INC  DE
      advance (5)
      #143D
      #instruction: LD   BC,0020
      advance (10)
      #1440
      #instruction: ADD  HL,BC
      let:8 a23 = H in
      let:8 a24 = L in
      let:17 a25 = add17(0020,(a23,a24)) in
      advance (10)
      #1441
      #instruction: POP  BC
      let:8 a26 = a20[15:8] in
      let:8 a27 = a20[7:0] in
      let:16 a28 = (1 + (a26,a27)) in
      let:8 a29 = M[(a26,a27)] in
      let:8 a30 = a28[15:8] in
      let:8 a31 = a28[7:0] in
      let:16 a32 = (1 + (a30,a31)) in
      let:8 a33 = M[(a30,a31)] in
      advance (10)
      #1442
      #instruction: DEC  B
      let:8 a34 = a33 in
      let:16 a35 = addWithCarry(!true,a34,~00) in
      let:8 a36 = (a34 & 0F) in
      let:8 a37 = (~00 & 0F) in
      let:16 a38 = addWithCarry(!true,a36,a37) in
      advance (5)
      #1443
      #instruction: JP   NZ,1439
      if (!is_zero(a35[7:0])) {
        advance (10)
        A := 00;
        B := a35[7:0];
        C := a29;
        D := 1C;
        E := 61;
        H := a25[15:0][15:8];
        L := a25[15:0][7:0];
        SPH := a32[15:8];
        SPL := a32[7:0];
        FlagS := a35[7:0][7];
        FlagZ := is_zero(a35[7:0]);
        FlagA := a38[7:0][4];
        FlagP := parity(a35[7:0]);
        FlagCY := a25[16];
        jump (1439);
      } else {
        advance (10)
        #1446
        #instruction: RET
        let:8 a39 = a32[15:8] in
        let:8 a40 = a32[7:0] in
        let:16 a41 = (1 + (a39,a40)) in
        let:8 a42 = M[(a39,a40)] in
        let:8 a43 = a41[15:8] in
        let:8 a44 = a41[7:0] in
        let:16 a45 = (1 + (a43,a44)) in
        let:8 a46 = M[(a43,a44)] in
        advance (10)
        A := 00;
        B := a35[7:0];
        C := a29;
        D := 1C;
        E := 61;
        H := a25[15:0][15:8];
        L := a25[15:0][7:0];
        SPH := a45[15:8];
        SPL := a45[7:0];
        FlagS := a35[7:0][7];
        FlagZ := is_zero(a35[7:0]);
        FlagA := a38[7:0][4];
        FlagP := parity(a35[7:0]);
        FlagCY := a25[16];
        jump ((a46,a42));
      }
    } else {
      advance (10)
      #19FA
      #instruction: LD   B,10
      advance (7)
      #19FC
      #instruction: CALL 14CB
      let:8 a47 = SPH in
      let:8 a48 = SPL in
      let:16 a49 = (-1 + (a47,a48)) in
      M[a49] := 19;
      let:8 a50 = a49[15:8] in
      let:8 a51 = a49[7:0] in
      let:16 a52 = (-1 + (a50,a51)) in
      M[a52] := FF;
      #return-to: 19FF
      advance (17)
      #14CB
      #instruction: XOR  A
      let:8 a53 = a3[7:0] in
      let:8 a54 = a3[7:0] in
      let:8 a55 = (a53 ^ a54) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:8 a56 = C in
      let:8 a57 = a52[15:8] in
      let:8 a58 = a52[7:0] in
      let:16 a59 = (-1 + (a57,a58)) in
      M[a59] := 10;
      let:8 a60 = a59[15:8] in
      let:8 a61 = a59[7:0] in
      let:16 a62 = (-1 + (a60,a61)) in
      M[a62] := a56;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      let:8 a63 = a55 in
      let:8 a64 = H in
      let:8 a65 = L in
      M[(a64,a65)] := a63;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:8 a66 = H in
      let:8 a67 = L in
      let:17 a68 = add17(0020,(a66,a67)) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:8 a69 = a62[15:8] in
      let:8 a70 = a62[7:0] in
      let:16 a71 = (1 + (a69,a70)) in
      let:8 a72 = M[(a69,a70)] in
      let:8 a73 = a71[15:8] in
      let:8 a74 = a71[7:0] in
      let:16 a75 = (1 + (a73,a74)) in
      let:8 a76 = M[(a73,a74)] in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:8 a77 = a76 in
      let:16 a78 = addWithCarry(!true,a77,~00) in
      let:8 a79 = (a77 & 0F) in
      let:8 a80 = (~00 & 0F) in
      let:16 a81 = addWithCarry(!true,a79,a80) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a78[7:0])) {
        advance (10)
        A := a55;
        B := a78[7:0];
        C := a72;
        H := a68[15:0][15:8];
        L := a68[15:0][7:0];
        SPH := a75[15:8];
        SPL := a75[7:0];
        FlagS := a78[7:0][7];
        FlagZ := is_zero(a78[7:0]);
        FlagA := a81[7:0][4];
        FlagP := parity(a78[7:0]);
        FlagCY := a68[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:8 a82 = a75[15:8] in
        let:8 a83 = a75[7:0] in
        let:16 a84 = (1 + (a82,a83)) in
        let:8 a85 = M[(a82,a83)] in
        let:8 a86 = a84[15:8] in
        let:8 a87 = a84[7:0] in
        let:16 a88 = (1 + (a86,a87)) in
        let:8 a89 = M[(a86,a87)] in
        advance (10)
        A := a55;
        B := a78[7:0];
        C := a72;
        H := a68[15:0][15:8];
        L := a68[15:0][7:0];
        SPH := a88[15:8];
        SPL := a88[7:0];
        FlagS := a78[7:0][7];
        FlagZ := is_zero(a78[7:0]);
        FlagA := a81[7:0][4];
        FlagP := parity(a78[7:0]);
        FlagCY := a68[16];
        jump ((a89,a85));
      }
    }

19FF:

    #19FF
    #instruction: LD   A,H
    let:8 a1 = H in
    advance (5)
    #1A00
    #instruction: CP   35
    let:8 a2 = a1 in
    let:16 a3 = addWithCarry(!false,a2,~35) in
    let:8 a4 = (a2 & 0F) in
    let:8 a5 = (~35 & 0F) in
    let:16 a6 = addWithCarry(!false,a4,a5) in
    advance (7)
    #1A02
    #instruction: JP   NZ,19FA
    if (!is_zero(a3[7:0])) {
      advance (10)
      #19FA
      #instruction: LD   B,10
      advance (7)
      #19FC
      #instruction: CALL 14CB
      let:8 a7 = SPH in
      let:8 a8 = SPL in
      let:16 a9 = (-1 + (a7,a8)) in
      M[a9] := 19;
      let:8 a10 = a9[15:8] in
      let:8 a11 = a9[7:0] in
      let:16 a12 = (-1 + (a10,a11)) in
      M[a12] := FF;
      #return-to: 19FF
      advance (17)
      #14CB
      #instruction: XOR  A
      let:8 a13 = a1 in
      let:8 a14 = a1 in
      let:8 a15 = (a13 ^ a14) in
      advance (4)
      #14CC
      #instruction: PUSH BC
      let:8 a16 = C in
      let:8 a17 = a12[15:8] in
      let:8 a18 = a12[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := 10;
      let:8 a20 = a19[15:8] in
      let:8 a21 = a19[7:0] in
      let:16 a22 = (-1 + (a20,a21)) in
      M[a22] := a16;
      advance (11)
      #14CD
      #instruction: LD   (HL),A
      let:8 a23 = a15 in
      let:8 a24 = H in
      let:8 a25 = L in
      M[(a24,a25)] := a23;
      advance (7)
      #14CE
      #instruction: LD   BC,0020
      advance (10)
      #14D1
      #instruction: ADD  HL,BC
      let:8 a26 = H in
      let:8 a27 = L in
      let:17 a28 = add17(0020,(a26,a27)) in
      advance (10)
      #14D2
      #instruction: POP  BC
      let:8 a29 = a22[15:8] in
      let:8 a30 = a22[7:0] in
      let:16 a31 = (1 + (a29,a30)) in
      let:8 a32 = M[(a29,a30)] in
      let:8 a33 = a31[15:8] in
      let:8 a34 = a31[7:0] in
      let:16 a35 = (1 + (a33,a34)) in
      let:8 a36 = M[(a33,a34)] in
      advance (10)
      #14D3
      #instruction: DEC  B
      let:8 a37 = a36 in
      let:16 a38 = addWithCarry(!true,a37,~00) in
      let:8 a39 = (a37 & 0F) in
      let:8 a40 = (~00 & 0F) in
      let:16 a41 = addWithCarry(!true,a39,a40) in
      advance (5)
      #14D4
      #instruction: JP   NZ,14CC
      if (!is_zero(a38[7:0])) {
        advance (10)
        A := a15;
        B := a38[7:0];
        C := a32;
        H := a28[15:0][15:8];
        L := a28[15:0][7:0];
        SPH := a35[15:8];
        SPL := a35[7:0];
        FlagS := a38[7:0][7];
        FlagZ := is_zero(a38[7:0]);
        FlagA := a41[7:0][4];
        FlagP := parity(a38[7:0]);
        FlagCY := a28[16];
        jump (14CC);
      } else {
        advance (10)
        #14D7
        #instruction: RET
        let:8 a42 = a35[15:8] in
        let:8 a43 = a35[7:0] in
        let:16 a44 = (1 + (a42,a43)) in
        let:8 a45 = M[(a42,a43)] in
        let:8 a46 = a44[15:8] in
        let:8 a47 = a44[7:0] in
        let:16 a48 = (1 + (a46,a47)) in
        let:8 a49 = M[(a46,a47)] in
        advance (10)
        A := a15;
        B := a38[7:0];
        C := a32;
        H := a28[15:0][15:8];
        L := a28[15:0][7:0];
        SPH := a48[15:8];
        SPL := a48[7:0];
        FlagS := a38[7:0][7];
        FlagZ := is_zero(a38[7:0]);
        FlagA := a41[7:0][4];
        FlagP := parity(a38[7:0]);
        FlagCY := a28[16];
        jump ((a49,a45));
      }
    } else {
      advance (10)
      #1A05
      #instruction: RET
      let:8 a50 = SPH in
      let:8 a51 = SPL in
      let:16 a52 = (1 + (a50,a51)) in
      let:8 a53 = M[(a50,a51)] in
      let:8 a54 = a52[15:8] in
      let:8 a55 = a52[7:0] in
      let:16 a56 = (1 + (a54,a55)) in
      let:8 a57 = M[(a54,a55)] in
      advance (10)
      A := a1;
      SPH := a56[15:8];
      SPL := a56[7:0];
      FlagS := a3[7:0][7];
      FlagZ := is_zero(a3[7:0]);
      FlagA := a6[7:0][4];
      FlagP := parity(a3[7:0]);
      FlagCY := !a3[15:8][0];
      jump ((a57,a53));
    }

1A82:

    #1A82
    #instruction: AND  A
    let:8 a1 = A in
    let:8 a2 = A in
    let:8 a3 = (a1 & a2) in
    let:8 a4 = (a1 | a2) in
    advance (4)
    #1A83
    #instruction: RET  Z
    if (is_zero(a3)) {
      let:8 a5 = SPH in
      let:8 a6 = SPL in
      let:16 a7 = (1 + (a5,a6)) in
      let:8 a8 = M[(a5,a6)] in
      let:8 a9 = a7[15:8] in
      let:8 a10 = a7[7:0] in
      let:16 a11 = (1 + (a9,a10)) in
      let:8 a12 = M[(a9,a10)] in
      advance (11)
      A := a3;
      SPH := a11[15:8];
      SPL := a11[7:0];
      FlagS := a3[7];
      FlagZ := is_zero(a3);
      FlagA := a4[3];
      FlagP := parity(a3);
      FlagCY := false;
      jump ((a12,a8));
    } else {
      advance (5)
      #1A84
      #instruction: PUSH PSW
      let:8 a13 = a3 in
      let:8 a14 = SPH in
      let:8 a15 = SPL in
      let:16 a16 = (-1 + (a14,a15)) in
      M[a16] := a13;
      let:8 a17 = a16[15:8] in
      let:8 a18 = a16[7:0] in
      let:16 a19 = (-1 + (a17,a18)) in
      M[a19] := updateBit(updateBit(updateBit(updateBit(updateBit(02,7,a3[7]),6,is_zero(a3)),4,a4[3]),2,parity(a3)),0,false);
      advance (11)
      #1A85
      #instruction: DEC  A
      let:8 a20 = a3 in
      let:16 a21 = addWithCarry(!true,a20,~00) in
      let:8 a22 = (a20 & 0F) in
      let:8 a23 = (~00 & 0F) in
      let:16 a24 = addWithCarry(!true,a22,a23) in
      advance (5)
      #1A86
      #instruction: LD   (HL),A
      let:8 a25 = a21[7:0] in
      let:8 a26 = H in
      let:8 a27 = L in
      M[(a26,a27)] := a25;
      advance (7)
      #1A87
      #instruction: CALL 19E6
      let:8 a28 = a19[15:8] in
      let:8 a29 = a19[7:0] in
      let:16 a30 = (-1 + (a28,a29)) in
      M[a30] := 1A;
      let:8 a31 = a30[15:8] in
      let:8 a32 = a30[7:0] in
      let:16 a33 = (-1 + (a31,a32)) in
      M[a33] := 8A;
      #return-to: 1A8A
      advance (17)
      #19E6
      #instruction: LD   HL,2701
      advance (10)
      #19E9
      #instruction: JP   Z,19FA
      if (is_zero(a21[7:0])) {
        advance (10)
        #19FA
        #instruction: LD   B,10
        advance (7)
        #19FC
        #instruction: CALL 14CB
        let:8 a34 = a33[15:8] in
        let:8 a35 = a33[7:0] in
        let:16 a36 = (-1 + (a34,a35)) in
        M[a36] := 19;
        let:8 a37 = a36[15:8] in
        let:8 a38 = a36[7:0] in
        let:16 a39 = (-1 + (a37,a38)) in
        M[a39] := FF;
        #return-to: 19FF
        advance (17)
        #14CB
        #instruction: XOR  A
        let:8 a40 = a21[7:0] in
        let:8 a41 = a21[7:0] in
        let:8 a42 = (a40 ^ a41) in
        advance (4)
        #14CC
        #instruction: PUSH BC
        let:8 a43 = C in
        let:8 a44 = a39[15:8] in
        let:8 a45 = a39[7:0] in
        let:16 a46 = (-1 + (a44,a45)) in
        M[a46] := 10;
        let:8 a47 = a46[15:8] in
        let:8 a48 = a46[7:0] in
        let:16 a49 = (-1 + (a47,a48)) in
        M[a49] := a43;
        advance (11)
        #14CD
        #instruction: LD   (HL),A
        let:8 a50 = a42 in
        M[2701] := a50;
        advance (7)
        #14CE
        #instruction: LD   BC,0020
        advance (10)
        #14D1
        #instruction: ADD  HL,BC
        let:17 a51 = add17(0020,2701) in
        advance (10)
        #14D2
        #instruction: POP  BC
        let:8 a52 = a49[15:8] in
        let:8 a53 = a49[7:0] in
        let:16 a54 = (1 + (a52,a53)) in
        let:8 a55 = M[(a52,a53)] in
        let:8 a56 = a54[15:8] in
        let:8 a57 = a54[7:0] in
        let:16 a58 = (1 + (a56,a57)) in
        let:8 a59 = M[(a56,a57)] in
        advance (10)
        #14D3
        #instruction: DEC  B
        let:8 a60 = a59 in
        let:16 a61 = addWithCarry(!true,a60,~00) in
        let:8 a62 = (a60 & 0F) in
        let:8 a63 = (~00 & 0F) in
        let:16 a64 = addWithCarry(!true,a62,a63) in
        advance (5)
        #14D4
        #instruction: JP   NZ,14CC
        if (!is_zero(a61[7:0])) {
          advance (10)
          A := a42;
          B := a61[7:0];
          C := a55;
          H := a51[15:0][15:8];
          L := a51[15:0][7:0];
          SPH := a58[15:8];
          SPL := a58[7:0];
          FlagS := a61[7:0][7];
          FlagZ := is_zero(a61[7:0]);
          FlagA := a64[7:0][4];
          FlagP := parity(a61[7:0]);
          FlagCY := a51[16];
          jump (14CC);
        } else {
          advance (10)
          #14D7
          #instruction: RET
          let:8 a65 = a58[15:8] in
          let:8 a66 = a58[7:0] in
          let:16 a67 = (1 + (a65,a66)) in
          let:8 a68 = M[(a65,a66)] in
          let:8 a69 = a67[15:8] in
          let:8 a70 = a67[7:0] in
          let:16 a71 = (1 + (a69,a70)) in
          let:8 a72 = M[(a69,a70)] in
          advance (10)
          A := a42;
          B := a61[7:0];
          C := a55;
          H := a51[15:0][15:8];
          L := a51[15:0][7:0];
          SPH := a71[15:8];
          SPL := a71[7:0];
          FlagS := a61[7:0][7];
          FlagZ := is_zero(a61[7:0]);
          FlagA := a64[7:0][4];
          FlagP := parity(a61[7:0]);
          FlagCY := a51[16];
          jump ((a72,a68));
        }
      } else {
        advance (10)
        #19EC
        #instruction: LD   DE,1C60
        advance (10)
        #19EF
        #instruction: LD   B,10
        advance (7)
        #19F1
        #instruction: LD   C,A
        let:8 a73 = a21[7:0] in
        advance (5)
        #19F2
        #instruction: CALL 1439
        let:8 a74 = a33[15:8] in
        let:8 a75 = a33[7:0] in
        let:16 a76 = (-1 + (a74,a75)) in
        M[a76] := 19;
        let:8 a77 = a76[15:8] in
        let:8 a78 = a76[7:0] in
        let:16 a79 = (-1 + (a77,a78)) in
        M[a79] := F5;
        #return-to: 19F5
        advance (17)
        #1439
        #instruction: PUSH BC
        let:8 a80 = a73 in
        let:8 a81 = a79[15:8] in
        let:8 a82 = a79[7:0] in
        let:16 a83 = (-1 + (a81,a82)) in
        M[a83] := 10;
        let:8 a84 = a83[15:8] in
        let:8 a85 = a83[7:0] in
        let:16 a86 = (-1 + (a84,a85)) in
        M[a86] := a80;
        advance (11)
        #143A
        #instruction: LD   A,(DE)
        advance (7)
        #143B
        #instruction: LD   (HL),A
        M[2701] := 00;
        advance (7)
        #143C
        #instruction: INC  DE
        advance (5)
        #143D
        #instruction: LD   BC,0020
        advance (10)
        #1440
        #instruction: ADD  HL,BC
        let:17 a87 = add17(0020,2701) in
        advance (10)
        #1441
        #instruction: POP  BC
        let:8 a88 = a86[15:8] in
        let:8 a89 = a86[7:0] in
        let:16 a90 = (1 + (a88,a89)) in
        let:8 a91 = M[(a88,a89)] in
        let:8 a92 = a90[15:8] in
        let:8 a93 = a90[7:0] in
        let:16 a94 = (1 + (a92,a93)) in
        let:8 a95 = M[(a92,a93)] in
        advance (10)
        #1442
        #instruction: DEC  B
        let:8 a96 = a95 in
        let:16 a97 = addWithCarry(!true,a96,~00) in
        let:8 a98 = (a96 & 0F) in
        let:8 a99 = (~00 & 0F) in
        let:16 a100 = addWithCarry(!true,a98,a99) in
        advance (5)
        #1443
        #instruction: JP   NZ,1439
        if (!is_zero(a97[7:0])) {
          advance (10)
          A := 00;
          B := a97[7:0];
          C := a91;
          D := 1C;
          E := 61;
          H := a87[15:0][15:8];
          L := a87[15:0][7:0];
          SPH := a94[15:8];
          SPL := a94[7:0];
          FlagS := a97[7:0][7];
          FlagZ := is_zero(a97[7:0]);
          FlagA := a100[7:0][4];
          FlagP := parity(a97[7:0]);
          FlagCY := a87[16];
          jump (1439);
        } else {
          advance (10)
          #1446
          #instruction: RET
          let:8 a101 = a94[15:8] in
          let:8 a102 = a94[7:0] in
          let:16 a103 = (1 + (a101,a102)) in
          let:8 a104 = M[(a101,a102)] in
          let:8 a105 = a103[15:8] in
          let:8 a106 = a103[7:0] in
          let:16 a107 = (1 + (a105,a106)) in
          let:8 a108 = M[(a105,a106)] in
          advance (10)
          A := 00;
          B := a97[7:0];
          C := a91;
          D := 1C;
          E := 61;
          H := a87[15:0][15:8];
          L := a87[15:0][7:0];
          SPH := a107[15:8];
          SPL := a107[7:0];
          FlagS := a97[7:0][7];
          FlagZ := is_zero(a97[7:0]);
          FlagA := a100[7:0][4];
          FlagP := parity(a97[7:0]);
          FlagCY := a87[16];
          jump ((a108,a104));
        }
      }
    }

1A8A:

    #1A8A
    #instruction: POP  PSW
    let:8 a1 = SPH in
    let:8 a2 = SPL in
    let:16 a3 = (1 + (a1,a2)) in
    let:8 a4 = M[(a1,a2)] in
    let:8 a5 = a3[15:8] in
    let:8 a6 = a3[7:0] in
    let:16 a7 = (1 + (a5,a6)) in
    let:8 a8 = M[(a5,a6)] in
    advance (10)
    #1A8B
    #instruction: LD   HL,2501
    advance (10)
    #1A8E
    #instruction: AND  0F
    let:8 a9 = a8 in
    let:8 a10 = (0F & a9) in
    let:8 a11 = (0F | a9) in
    advance (7)
    #1A90
    #instruction: JP   09C5
    advance (10)
    #09C5
    #instruction: ADD  1A
    let:8 a12 = a10 in
    let:16 a13 = addWithCarry(false,1A,a12) in
    let:8 a14 = (1A & 0F) in
    let:8 a15 = (a12 & 0F) in
    let:16 a16 = addWithCarry(false,a14,a15) in
    advance (7)
    #09C7
    #instruction: JP   08FF
    advance (10)
    #08FF
    #instruction: LD   DE,1E00
    advance (10)
    #0902
    #instruction: PUSH HL
    let:8 a17 = a7[15:8] in
    let:8 a18 = a7[7:0] in
    let:16 a19 = (-1 + (a17,a18)) in
    M[a19] := 25;
    let:8 a20 = a19[15:8] in
    let:8 a21 = a19[7:0] in
    let:16 a22 = (-1 + (a20,a21)) in
    M[a22] := 01;
    advance (11)
    #0903
    #instruction: LD   H,00
    advance (7)
    #0905
    #instruction: LD   L,A
    let:8 a23 = a13[7:0] in
    advance (5)
    #0906
    #instruction: ADD  HL,HL
    let:8 a24 = a23 in
    let:8 a25 = a23 in
    let:17 a26 = add17((00,a24),(00,a25)) in
    advance (10)
    #0907
    #instruction: ADD  HL,HL
    let:8 a27 = a26[15:0][15:8] in
    let:8 a28 = a26[15:0][7:0] in
    let:8 a29 = a26[15:0][15:8] in
    let:8 a30 = a26[15:0][7:0] in
    let:17 a31 = add17((a27,a28),(a29,a30)) in
    advance (10)
    #0908
    #instruction: ADD  HL,HL
    let:8 a32 = a31[15:0][15:8] in
    let:8 a33 = a31[15:0][7:0] in
    let:8 a34 = a31[15:0][15:8] in
    let:8 a35 = a31[15:0][7:0] in
    let:17 a36 = add17((a32,a33),(a34,a35)) in
    advance (10)
    #0909
    #instruction: ADD  HL,DE
    let:8 a37 = a36[15:0][15:8] in
    let:8 a38 = a36[15:0][7:0] in
    let:17 a39 = add17(1E00,(a37,a38)) in
    advance (10)
    #090A
    #instruction: EX   DE,HL
    let:8 a40 = a39[15:0][15:8] in
    let:8 a41 = a39[15:0][7:0] in
    advance (4)
    #090B
    #instruction: POP  HL
    let:8 a42 = a22[15:8] in
    let:8 a43 = a22[7:0] in
    let:16 a44 = (1 + (a42,a43)) in
    let:8 a45 = M[(a42,a43)] in
    let:8 a46 = a44[15:8] in
    let:8 a47 = a44[7:0] in
    let:16 a48 = (1 + (a46,a47)) in
    let:8 a49 = M[(a46,a47)] in
    advance (10)
    #090C
    #instruction: LD   B,08
    advance (7)
    #090E
    #instruction: OUT  06
    let:8 a50 = a13[7:0] in
    unknown_output(6,a50);
    advance (10)
    #0910
    #instruction: JP   1439
    advance (10)
    #1439
    #instruction: PUSH BC
    let:8 a51 = C in
    let:8 a52 = a48[15:8] in
    let:8 a53 = a48[7:0] in
    let:16 a54 = (-1 + (a52,a53)) in
    M[a54] := 08;
    let:8 a55 = a54[15:8] in
    let:8 a56 = a54[7:0] in
    let:16 a57 = (-1 + (a55,a56)) in
    M[a57] := a51;
    advance (11)
    #143A
    #instruction: LD   A,(DE)
    let:8 a58 = a40 in
    let:8 a59 = a41 in
    let:8 a60 = M[(a58,a59)] in
    advance (7)
    #143B
    #instruction: LD   (HL),A
    let:8 a61 = a60 in
    let:8 a62 = a49 in
    let:8 a63 = a45 in
    M[(a62,a63)] := a61;
    advance (7)
    #143C
    #instruction: INC  DE
    let:8 a64 = a40 in
    let:8 a65 = a41 in
    let:16 a66 = (1 + (a64,a65)) in
    advance (5)
    #143D
    #instruction: LD   BC,0020
    advance (10)
    #1440
    #instruction: ADD  HL,BC
    let:8 a67 = a49 in
    let:8 a68 = a45 in
    let:17 a69 = add17(0020,(a67,a68)) in
    advance (10)
    #1441
    #instruction: POP  BC
    let:8 a70 = a57[15:8] in
    let:8 a71 = a57[7:0] in
    let:16 a72 = (1 + (a70,a71)) in
    let:8 a73 = M[(a70,a71)] in
    let:8 a74 = a72[15:8] in
    let:8 a75 = a72[7:0] in
    let:16 a76 = (1 + (a74,a75)) in
    let:8 a77 = M[(a74,a75)] in
    advance (10)
    #1442
    #instruction: DEC  B
    let:8 a78 = a77 in
    let:16 a79 = addWithCarry(!true,a78,~00) in
    let:8 a80 = (a78 & 0F) in
    let:8 a81 = (~00 & 0F) in
    let:16 a82 = addWithCarry(!true,a80,a81) in
    advance (5)
    #1443
    #instruction: JP   NZ,1439
    if (!is_zero(a79[7:0])) {
      advance (10)
      A := a60;
      B := a79[7:0];
      C := a73;
      D := a66[15:8];
      E := a66[7:0];
      H := a69[15:0][15:8];
      L := a69[15:0][7:0];
      SPH := a76[15:8];
      SPL := a76[7:0];
      FlagS := a79[7:0][7];
      FlagZ := is_zero(a79[7:0]);
      FlagA := a82[7:0][4];
      FlagP := parity(a79[7:0]);
      FlagCY := a69[16];
      jump (1439);
    } else {
      advance (10)
      #1446
      #instruction: RET
      let:8 a83 = a76[15:8] in
      let:8 a84 = a76[7:0] in
      let:16 a85 = (1 + (a83,a84)) in
      let:8 a86 = M[(a83,a84)] in
      let:8 a87 = a85[15:8] in
      let:8 a88 = a85[7:0] in
      let:16 a89 = (1 + (a87,a88)) in
      let:8 a90 = M[(a87,a88)] in
      advance (10)
      A := a60;
      B := a79[7:0];
      C := a73;
      D := a66[15:8];
      E := a66[7:0];
      H := a69[15:0][15:8];
      L := a69[15:0][7:0];
      SPH := a89[15:8];
      SPL := a89[7:0];
      FlagS := a79[7:0][7];
      FlagZ := is_zero(a79[7:0]);
      FlagA := a82[7:0][4];
      FlagP := parity(a79[7:0]);
      FlagCY := a69[16];
      jump ((a90,a86));
    }
